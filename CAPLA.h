#pragma once
#ifndef CAPLA_H
#define CAPLA_H

#define TIME_H

#include "pch.h"
#include "SHARE_TOOL.h"
#include "GEOMETRY_TOOL.h"
#include "lib/doublyLinkedList.h"
#include "lib/SmallestEnclosingCircle.hpp"
#include "CPLA.h"

//************************************
// Class:    CAPLA
// Qualifier:Mix of PLA & APCA
// date: 181111
// author:
//************************************
TEMPLATE
class CAPLA : virtual public GEOMETRY, virtual public TOOL, virtual public PLA_QUAL {
public:
	struct TOOL::INPUT_ARGUMENT input_argument;
	struct TOOL::OUTPUT_ARGUMENT output_argument;//181214
	//struct TOOL::TIME time_record[20];//181210

	struct POINT;//210509
	struct BREAK_POINT_COEFFICIENT;
	struct BREAK_POINT_MAGNITUDE;//181113
	struct AREA_COEFFICIENT;//181119

	struct AREA_COEFFICIENT_SPEED;//200305 delete redundant variable

	struct AREA_COEFFICIENT_SPEED_NO_MINMAX;//210203 no min max point

	template<typename T, typename Y>//210906
	struct AREA_COEFFICIENT_RTREE_NODE;

	struct AREA_COEFFICIENT_CONCISE;//200210 Only contain necessary property
	struct Y_AXIS_COEFFICIENT;//190726  For y axis projection, to get adaptive endpoit
	struct SEGMENT_COEFFICIENT;//190416
	struct APLA_COEFFICIENT;//181212 For PLA Coefficient
	struct APLA_COEFFICIENT1;//190612 For based PLA method
	struct PLA_COEFFICIENT_CONCISE;//200210 Only contain a&b

	struct SPLIT_COEFFICIENT;//200210 Split Coefficient, For fast finding split point

	template<typename T>
	struct OPTIMIZATION_COEFFICIENT;//200915 split & merge & optimization coefficients

	//************************************
	// Stuct:UPPER_BOUND_COEFFICIENT
	// Qualifier: upper bound > max deviation.
	// date:210113
	// author:
	//************************************
	template<typename T>
	struct UPPER_BOUND_COEFFICIENT;

	struct MagnitudeIncrease;//181113
	struct AreaIncreasing;//181120 Get min
	struct AreaDecreasing;//181219 Get max value
	struct ParallelogramHeightIncrease;//190104
	struct WidthIncreasing;//190104
	struct DensityIncrease;//200211  min desntiy to max density
	struct DensityIncrease_Pointer;//190328  min desntiy to max density pointer
	struct DeviationIncreasing;//190115
	struct Width_Divide_Radius_Increase;//190315

	struct Set_Deviation_Decrease;//190624

	struct SPLIT_ID_INCREASE;//200211

	struct COMPARE_GREATER_SEGMENT_DENSITY;//200812 compare segment density, greater is true.

	template<typename T, typename Y, typename U>
	struct OPTION_DISTANCE_STRUCT;//210907 disatnce type, triangle area or SAPLA or APCA disance

	//191111
	CAPLA() {};

	template<typename T>
	CAPLA(const T& const n, const T& const N);
	//191211
	template<typename T>
	CAPLA(const T& const n, const T& const N, const bool& const change_file);

	//200224 split_id_coefficients = 0
	template<typename T, typename Y>
	inline void initial_split_coefficients(T& const input_argument, Y& const output_argument);

	//200224 vector of split coefficients get value from out argument
	template<typename T, typename Y, typename U>
	inline void get_split_coefficients(const T& const input_argument, const U& const output_argument, const int& const split_methods_option, vector<Y>& const local_total_split_id_sum_deviation, vector<Y>& const local_total_split_id_shift, vector<Y>& const local_total_split_id_time, vector<Y>& const global_total_approximation_sum_deviation, vector<Y>& const global_total_approximation_time);

	//200227 vector of split coefficients get value from out argument
	template<typename T, typename Y, typename U>
	inline void get_split_coefficients(const T& const input_argument, const U& const output_argument, const int& const split_methods_option, vector<Y>& const local_total_split_id_sum_deviation, vector<Y>& const local_total_split_id_shift, vector<Y>& const local_total_split_id_time, vector<Y>& const global_total_approximation_sum_deviation, vector<Y>& const global_total_approximation_time, vector<Y>& const global_total_knn_prune_power);

	//200329 vector of initial N coefficients get value from out argument
	template<typename T, typename Y, typename U, typename U1>
	inline void get_initial_N_coefficients(const T& const input_argument, const U& const output_argument, const U1& const initial_N_number, vector<Y>& const total_initial_N_prune_power_vector, vector<Y>& const total_initial_N_sum_deviation_vector, vector<Y>& const total_initial_N_run_time_vector, vector<Y>& const total_initial_N_approximation_time_vector, vector<Y>& const total_initial_N_knn_time_vector);

	//200331 vector of initial N coefficients sort by N value
	template<typename T, typename Y, typename U, typename U1>
	inline void get_initial_N_sort_N_coefficients(const T& const input_argument, const U& const output_argument, const U1& const N_size, const U1& const N_id, const U1& const initial_N_number, vector<Y>& const initial_N_by_N_prune_power_vector, vector<Y>& const initial_N_by_N_sum_deviation_vector, vector<Y>& const initial_N_by_N_run_time_vector, vector<Y>& const initial_N_by_N_approximation_time_vector, vector<Y>& const initial_N_by_N_knn_time_vector);

	void initialBREAK_POINT_COEFFICIENT(const typename TOOL::INPUT_ARGUMENT& input_argument, BREAK_POINT_COEFFICIENT& const break_point);//181112

	void deleteBREAK_POINT_COEFFICIENT(BREAK_POINT_COEFFICIENT& const break_point);//181112

	void getAPLADifference(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, int*& const break_point_ID);//181112

	void copyRectangleCoefficient(vector<AREA_COEFFICIENT>& area_vector, const int vector_id, AREA_COEFFICIENT& temp_coefficient);//181205

	void initialRecArea(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector);//181211

	void initialRecArea0ForParallelogram(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector);//181211

	void initialRecArea0ForParallelogramNoPush(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector);//190416

	void initialRecArea0ForParallelogramArray(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, SEGMENT_COEFFICIENT*& area_vector);//190417

	void initialRecArea0ForParallelogramArrayVector(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector);//190429 Use vector to instead Array,

	void initialRecAreaPLAImprove(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector);//190606 initial by PLA

	void initialAPLARightEndpoint(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector);//190617 Use minmax point as right endpoint

	void initialAPLARightEndpoint3Sub(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector);//190617 16:31 Use minmax point split segment into 3 subsegment

	void initialAPLARightEndpoint3SubAdaptive(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector);//190705 11:31 Merge Use minmax point split segment into 3 subsegment, for flat stream, use few segments, for drastic change, use more segments

	void initialAPLARightEndpoint3SubAdaptiveMergeSplit(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector);//190711 16:59 Merge Use minmax point split segment into 3 subsegment, for flat stream, use few segments, for drastic change, use more segments. Splie Merge when initial

	void initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursive(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector);//190719 Recursive merge and split segment
	//190812
	void initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursiveSpeed(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector);//190812 Recursive merge and split segment
	//190820 Use Linded list to instead Vector
	void initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursiveSpeed(typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list);//190820 Recursive merge and split segment
	//190918 Linked List
	void initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursiveSpeed(typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list);//190918 Recursive merge and split segment

	//190918 Linked List
	void initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursiveSpeed1(typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list);//190918 Recursive merge and split segment

	//191002 Linked List
	void initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursiveSpeed2(typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list);//191002 Recursive merge and split segment

	 //191209 Y projection initialization
	template<typename T>
	inline void initial_threshold_and_all(typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, const int& const original_id, int& const min_max_count, const T& const segment_3, T& const temp_segment, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<T>& const all_segment_linked_list);

	//191209 Y projection initialization
	//200212 
	template<typename T, typename Y, typename U>
	inline void initial_threshold_and_all(const U& const input_argument, const vector<T>& const original_time_series_vector, const int& const original_id, int& const min_max_count, const Y& const segment_3, Y& const temp_segment, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<Y>& const all_segment_linked_list);

	//200314 Y projection initialization. delete minmax point. Concise above function. Delete redundant variable
	template<typename T, typename Y, typename U>
	inline void initial_threshold_and_all(const U& const input_argument, const T& const point_value, Y& const y_projection_argument);

	//200429 get the right endpoint of long segment_3 
	template<typename T, typename Y, typename U, typename T1>
	inline void get_segment_3_right_endpoint(const T& const segment_width_second, const Y& const remainder, const U& const pre_right_endpoint, T1& const temp_coefficient);

	//191209 get_minmax_y_projection
	template<typename T>
	void get_minmax_y_projection(typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, const int& const pre_right_endpoint, T& const segment_3, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<T>& const all_segment_linked_list);

	//191209 get_minmax_y_projection
	//200212 Add template, use vector to instead pointer for time sereis 
	template<typename T, typename Y, typename U>
	void get_minmax_y_projection(U& const input_argument, const vector<T>& const original_time_series_vector, const int& const pre_right_endpoint, Y& const segment_3, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<Y>& const all_segment_linked_list);

	//200316 Add template, use vector to instead pointer for time sereis 
	template<typename T, typename Y, typename U>
	void get_minmax_y_projection(const U& const input_argument, const vector<T>& const original_time_series_vector, const int& const segment_begin_id, const int& const segment_end_id, int& const id_min_point, int& const id_max_point, Y& const y_projection_argument);

	//200424, get minmax point in long segment, use minmax point as endpoint to get three short segment. 
	template<typename T, typename T1, typename Y, typename U, typename U1>
	void assign_three_segments_by_minmax(U& const input_argument, const vector<T>& const original_time_series_vector, const T1& const  pre_right_endpoint, int& const id_min_point, int& const id_max_point, Y& const segment_1, Y& const segment_2, Y& const segment_3, U1& const output_argument);

	//200428
	template<typename T, typename Y, typename U>
	inline void insert_segment_back_linkedlist(T& const temp_coefficient, DoublyLinkedList<Y>& const doubly_linked_list, U& const rest_segment_number);

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&   Initial part of algorithm   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	//191208 merge Y projection & MSPLA
	template<typename T>
	void initialMSPLA(int null, typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<T>& const all_segment_linked_list, DoublyLinkedList<T>& const cluster_linked_list, DoublyLinkedList<T>& const doubly_linked_list);

	//200212 merge Y projection & MSPLA
	//200212 Add template. Use vector to instead pointer for time series
	template<typename T, typename Y, typename U>
	void initialMSPLA(U& const input_argument, const vector<T>& const original_time_series_vector, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<Y>& const all_segment_linked_list, DoublyLinkedList<Y>& const cluster_linked_list, DoublyLinkedList<Y>& const doubly_linked_list);

	//200212 merge Y projection & MSPLA
	//200212 Add template. Use vector to instead pointer for time series
	template<typename T, typename Y, typename U, typename U1>
	void initialMSPLA(U& const input_argument, const vector<T>& const original_time_series_vector, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<Y>& const all_segment_linked_list, DoublyLinkedList<Y>& const cluster_linked_list, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument);

	//200731 loop to get split point at initial part.
	template<typename T, typename Y>
	void loop_to_get_split_point(const vector<T>& const original_time_series_vector, Y& const current_segment, Y& const accumulate_segment, Y& const next_two_points_segment, DoublyLinkedList<Y>& const doubly_linked_list);

	//200819 add segment in linkedlist, compute merged segment infor, split area difference.
	template<typename T, typename Y, typename U, typename U1>
	void insert_last_segment_compute_merge_split_coefficients(const vector<T>& const original_time_series_vector, Y& const current_segment, multimap<U, DoublyListNode<Y>&, greater<U>>& const merge_segment_density_map, multimap<U, DoublyListNode<Y>&, std::greater<U>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument);

	//200803 get split point in one segment by biggest accumulation area
	template<typename T, typename T1, typename Y, typename U, typename U1>
	void get_right_endpoint_by_accumulation_area(U& const input_argument, const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument);

	//210301 No split & merge operation
	template<typename T, typename T1, typename Y, typename U, typename U1>
	void get_right_endpoint_by_accumulation_area_no_split_merge(U& const input_argument, const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument);

	//210301 No split & merge operation, no threshold
	template<typename T, typename T1, typename Y, typename U, typename U1>
	void get_right_endpoint_by_accumulation_area_no_split_merge_threshold(U& const input_argument, const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument);

	//200924 compute area difference of whole linked list
	template<typename T>
	long double get_whole_area_difference(const DoublyLinkedList<T>& const doubly_linked_list);

	//201005 compute area difference of whole linked list by MAP, not by linked list
	template<typename T>
	long double get_whole_area_difference_by_map(const T& const map);

	/**********************************************************************************************************************************************/
	//201002 move the left / right endpoint of max area difference segment
	template<typename T, typename Y, typename T1>
	void optimize_segment_max_area_difference(const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map);

	//201103 Speed up. move the left / right endpoint of max area difference segment
	template<typename T, typename Y, typename T1>
	bool optimize_segment_max_area_difference_speed(const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map);

	//************************************
	// Method:copy_optimization_coefficient
	// Qualifier: left segment copy right segment. No label of optimization
	// date:201227  08:56
	// author:
	//************************************
	template<typename T>
	inline void copy_optimization_coefficient(T& const segment_main, const T& const segment_copied);

	//************************************
	// Method:initial_segment_decrease_right
	// Qualifier: initial segemnt decrease right point, a&b, area difference.
	// date:201203  23:48
	// author:
	//************************************
	template<typename T, typename Y, typename U>
	inline bool initial_segment_decrease_right(const vector<T>& const original_time_series_vector, const Y& const segment_original, Y& const segment_decrease_right, U& const output_argument);

	//************************************
	// Method:initial_segment_increase_right
	// Qualifier: initial segemnt increase right point, a&b, area difference.
	// date:201205  16:58
	// author:
	//************************************
	template<typename T, typename Y, typename U>
	inline void initial_segment_increase_right(const vector<T>& const original_time_series_vector, const Y& const segment_original, Y& const segment_increase_right, U& const output_argument);

	//************************************
	// Method:initial_segment_increase_left
	// Qualifier: initial segemnt increase left point, a&b, area difference.
	// date:201204  00:39
	// author:
	//************************************
	template<typename T, typename Y, typename U>
	inline void initial_segment_increase_left(const vector<T>& const original_time_series_vector, const Y& const segment_original, Y& const segment_increase_left, U& const output_argument);

	//************************************
	// Method:initial_segment_decrease_left
	// Qualifier: initial segemnt decrease left point, a&b, area difference.
	// date:201211  20:02
	// author:
	//************************************
	template<typename T, typename Y, typename U>
	inline bool initial_segment_decrease_left(const vector<T>& const original_time_series_vector, const Y& const segment_original, Y& const segment_decrease_left, U& const output_argument);

	//************************************
	// Method:compare_segment_right_decrease
	// Qualifier: compare if segment decrease right endpoint can decrease area difference
	// date:201204  01:11
	// author:
	//************************************
	template<typename T, typename Y, typename T1>
	inline bool compare_segment_right_decrease(multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map, T& const node_max_area_difference, Y& const segment_middle, const Y& const temp_segment_decrease_right, Y& const segment_right, const Y& const temp_segment_increase_left);

	//************************************
	// Method:compare_segment_left_decrease
	// Qualifier: Compare if segment decrease left endpoint can decrease area difference. Middle segment has max area difference
	// date:201213  09:19
	// author:
	//************************************
	template<typename T, typename Y, typename T1>
	inline bool compare_segment_left_decrease(multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map, T& const node_max_area_difference, Y& const segment_middle, const Y& const temp_segment_decrease_left, Y& const segment_left, const Y& const temp_segment_increase_right);

	//************************************
	// Method:optimize_segment_max_area_difference_speed1
	// Qualifier: Optimization of segment adjust. Speed up. move the left / right endpoint of max area difference segment
	// date:201213  09:19
	// author:
	//************************************
	template<typename T, typename Y, typename T1>
	bool optimize_segment_max_area_difference_speed1(const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map);

	//************************************
	// Method:erase_node_if_no_need_adjust
	// Qualifier:
	// date:201214  10:12
	// author:
	//************************************
	template<typename T, typename Y>
	inline bool erase_node_if_no_need_adjust(multimap<T, DoublyListNode<Y>& const, greater<T>>& const split_area_difference_map, const DoublyListNode<Y>& const node_candidate_erase);

	//************************************
	// Method:update_segment_map_by_min_area_difference
	// Qualifier:
	// date:201214  11:13
	// author:
	//************************************
	template<typename T, typename Y>
	inline void update_segment_map_by_min_area_difference(multimap<T, DoublyListNode<Y>& const, greater<T>>& const split_area_difference_map, Y& const segment_decrease, const Y& const temp_segment_decrease, Y& const segment_increase, const Y& const temp_segment_increase, DoublyListNode<Y>& const node_increase);

	//************************************
	// Method:update_segment_map_by_min_area_difference
	// Qualifier:
	// date:201223  15:41
	// author:
	//************************************
	template<typename T, typename Y>
	inline void update_segment_map_by_min_area_difference(multimap<T, DoublyListNode<Y>& const, greater<T>>& const split_area_difference_map, const Y& const temp_segment_move, DoublyListNode<Y>& const node_original);

	//************************************
	// Method:erase_if_adjacent_segments_are_zeros
	// Qualifier:
	// date:201215 16:01
	// author:
	//************************************
	template<typename T, typename Y>
	inline void erase_if_adjacent_segments_are_zeros(multimap<T, DoublyListNode<Y>& const, greater<T>>& const split_area_difference_map, DoublyListNode<Y>& const node_middle);

	//************************************
	// Method:adjust_compute_segment_right
	// Qualifier:
	// date:201215 20:31
	// author:
	//************************************
	template<typename T, typename Y, typename T1, typename U>
	bool adjust_compute_segment_right(const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map, DoublyListNode<Y>& const node_middle, U& const output_argument);

	//************************************
	// Method:assert_if_finish_move
	// Qualifier:
	// date:201226 12:14
	// author:
	//************************************
	template<typename T>
	inline bool assert_if_finish_move(const T& const segment_middle, const T& const segment_right);

	//************************************
	// Method:compute_segment_decrease_right
	// Qualifier:
	// date:201226 09:34
	// author:
	//************************************
	template<typename T, typename Y, typename T1, typename T2, typename T3, typename T4, typename U>
	void compute_segment_decrease_right(const vector<T>& const original_time_series_vector, const T3 type_move, T4& const area_difference_min_other, multimap<T1, T2>& const map_new_area_difference_adjust_type, const Y& const segment_original_middle, const Y& const segment_original_right, Y& const segment_middle_decrease_right, Y& const segment_right_increase_left, U& const output_argument);

	//************************************
	// Method:compute_segment_increase_right
	// Qualifier:
	// date:201226 11:14
	// author:
	//************************************
	template<typename T, typename Y, typename T1, typename T2, typename T3, typename T4, typename U>
	void compute_segment_increase_right(const vector<T>& const original_time_series_vector, const T3 type_move, T4& const area_difference_min_other, multimap<T1, T2>& const map_new_area_difference_adjust_type, const Y& const segment_original_middle, const Y& const segment_original_right, Y& const segment_middle_increase_right, Y& const segment_right_decrease_left, U& const output_argument);

	//210901 right move midle endpint in adjacent segments with defined width, increase right enpint of left segment and decrease left endpoitn of rightn segment
	template<typename T, typename Y, typename U, typename T1>
	void endpoint_increase_right_adjacent_segment(const vector<T>& const original_time_series_vector, const Y& const width_move, U& const segment_left, T1& const segment_right);

	//210907 Average Value. right move midle endpint in adjacent segments with defined width, increase right enpint of left segment and decrease left endpoitn of rightn segment
	template<typename T, typename Y, typename U, typename T1>
	void endpoint_increase_right_adjacent_segment_average(const vector<T>& const original_time_series_vector, const Y& const width_move, U& const segment_left, T1& const segment_right);

	//210901 right move midle endpint in adjacent segments with defined width, decrease right enpint of left segment and increase left endpoitn of rightn segment
	template<typename T, typename Y, typename U, typename T1>
	void endpoint_decrease_right_adjacent_segment(const vector<T>& const original_time_series_vector, const Y& const width_move, U& const segment_left, T1& const segment_right);

	//210916 Average Value. right move midle endpint in adjacent segments with defined width, decrease right enpint of left segment and increase left endpoitn of rightn segment
	template<typename T, typename Y, typename U, typename T1>
	void endpoint_decrease_right_adjacent_segment_average(const vector<T>& const original_time_series_vector, const Y& const width_move, U& const segment_left, T1& const segment_right);

	/*=========================================     210907 Average     ==================================================================================*/
	template<typename T>
	inline bool assert_segment_average(const T& const segment);

	template<typename T, typename Y>
	bool assert_segment_average(const vector<T>& const original_time_series_vector, const Y& const segment);

	template<typename T, typename Y>
	bool assert_endpoint_average(const vector<T>& const original_time_series_vector, const DoublyLinkedList<Y>& const list);

	template<typename T, typename Y>
	void get_average_segment(const vector<T>& const original_time_series_vector, Y& const segment);

	template<typename T, typename Y, typename U>
	inline void get_sub_average_by_long_segment(const T& const long_segment, const Y& const sub_segment_1, U& const sub_segment_2);
	/*===================================================================================================================================================*/

	//****************************************
	// Method:is_seg_out_map
	// Qualifier:short segment and flat segment outside split multimap
	// date:201228 06:51
	// author:
	//****************************************
	template<typename T>
	inline bool is_seg_out_map(const T& const segment);

	//****************************************
	// Method:label_left_node_erase_emplace_map
	// Qualifier: 1 Label left, middle node. 2 Erase, Emplace MAP
	// date:201228 15:23
	// author:
	//****************************************
	template<typename Y, typename T1>
	inline void label_left_node_erase_emplace_map(multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map, DoublyListNode<Y>& const node_middle);

	//****************************************
	// Method:label_right_node_erase_emplace_map
	// Qualifier: 1 Label middle, right node. 2 Erase, Emplace MAP
	// date:201228 15:36
	// author:
	//****************************************
	template<typename Y, typename T1>
	inline void label_right_node_erase_emplace_map(multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map, DoublyListNode<Y>& const node_middle);

	//****************************************
	// Method:update_left_node_label_map
	// Qualifier: 1 Update, Label left, middle node. 2 Update, Erase, Emplace MAP
	// date:201228 15:36
	// author:
	//****************************************
	template<typename Y, typename T1>
	inline void update_left_node_label_map(multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map, DoublyListNode<Y>& const node_middle, const Y& const segment_left_move, const Y& const segment_middle_move);

	//****************************************
	// Method:update_right_node_label_map
	// Qualifier: 1 Update, Label left, middle node. 2 Update, Erase, Emplace MAP
	// date:201228 15:36
	// author:
	//****************************************
	template<typename Y, typename T1>
	inline void update_right_node_label_map(multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map, DoublyListNode<Y>& const node_middle, const Y& const segment_middle_move, const Y& const segment_right_move);

	//****************************************
	// Method:adjust_compute_segment_2_sides
	// Qualifier:
	// date:201224 13:11
	// author:
	//****************************************
	template<typename T, typename Y, typename T1, typename U>
	bool adjust_compute_segment_2_sides(const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map, DoublyListNode<Y>& const node_middle, U& const output_argument);

	//************************************
	// Method:optimize_segment_max_area_difference_speed2
	// Qualifier: Optimization of segment adjust, for max difference segment, adjust left / right endpoint of segment, choose the min area difference one.
	// date:201213  09:19
	// author:
	//************************************
	template<typename T, typename Y, typename T1>
	bool optimize_segment_max_area_difference_speed2(const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map);

	//************************************
	// Method:optimize_segment_max_area_difference_speed3
	// Qualifier: Optimization of segment adjust, for max difference segment, adjust both left & right endpoint of segment, choose the min area difference from original one.
	// date:201224  09:19
	// author:
	//************************************
	template<typename T, typename Y, typename T1, typename U>
	bool optimize_segment_max_area_difference_speed3(const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map, U& const output_argument);

	//201002 After initialization, split&merge operation, begin to optimizaiton of endpoints of segment.
	template<typename T, typename T1, typename Y, typename U, typename U1>
	void optimization_segments_loop(U& const input_argument, const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument);

	//201103 Speed up. After initialization, split&merge operation, begin to optimizaiton of endpoints of segment.
	template<typename T, typename T1, typename Y, typename U, typename U1>
	void optimization_segments_loop_speed(U& const input_argument, const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument);

	//201030 After initial part, The fastest way. Use split&merge&optimization to get tighter approximation
	template<typename T, typename T1, typename Y, typename U, typename U1>
	void split_merge_optimization_segments_speed(U& const input_argument, const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument);

	//************************************
	// Method: update_list_map_sub_left_is_merge
	// Qualifier: When candidate merge segment is splited sub left segment.
	// date:201229  14:44
	// author:
	//************************************
	template<typename T, typename T1, typename Y, typename U>
	inline bool update_list_map_sub_left_is_merge(const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyListNode<Y>& const node_split_candidate, Y& const temp_segment_splited_sub_left, const Y& const temp_segment_splited_sub_right, const Y& const temp_segment_candidate_split_right, U& const output_argument);

	//************************************
	// Method: update_list_map_original_right_is_merge
	// Qualifier: When candidate merge segment is splited original right segment.
	// date:201229  21:19
	// author:
	//************************************
	template<typename T, typename T1, typename Y, typename U>
	inline bool update_list_map_original_right_is_merge(const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyListNode<Y>& const node_split_candidate, const Y& const temp_segment_splited_sub_left, const Y& const temp_segment_splited_sub_right, Y& const temp_segment_candidate_split_right, U& const output_argument);

	//************************************
	// Method: update_list_map_split_is_not_merge
	// Qualifier: When candidate merge segment is splited original right segment.
	// date:201231  14:30
	// author:
	//************************************
	template<typename T, typename T1, typename Y, typename U>
	inline bool update_list_map_split_is_not_merge(const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, DoublyListNode<Y>& const node_split_candidate, DoublyListNode<Y>& const node_merge_candidate, DoublyListNode<Y>& const node_sub_left_new, const Y& const temp_segment_splited_sub_right, U& const output_argument);

	//************************************
	// Method: update_list_map_merge_split_same
	// Qualifier: When candidate split segment is candiate merge segment
	// date:210301  21:25
	// author:
	//************************************
	template<typename T, typename T1, typename Y, typename U>
	inline bool update_list_map_merge_split_same(const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyListNode<Y>& const node_split_candidate, Y& const temp_segment_splited_sub_left, const Y& const temp_segment_splited_sub_right, U& const output_argument);

	//************************************
	// Method:split_merge_optimization_segments_speed0
	// Qualifier: After initial part, The fastest way. Use split&merge&optimization to get tighter approximation
	// date:201228  14:44
	// author:
	//************************************
	template<typename T, typename T1, typename Y, typename U, typename U1>
	void split_merge_optimization_segments_speed0(U& const input_argument, const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument);

	//************************************
	// Method:split_merge_optimization_segments_speed1
	// Qualifier: After initial part, The fastest way. Use split&merge&optimization to get tighter approximation
	// date:201228  14:44
	// author:
	//************************************
	template<typename T, typename T1, typename Y, typename U, typename U1>
	void split_merge_optimization_segments_speed1(U& const input_argument, const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument);

	//************************************
	// Method:split_merge_optimization_segments_speed2
	// Qualifier: After initial part, The fastest way. Use split&merge&optimization to get tighter approximation
	// date:210301  14:44
	// author:
	//************************************
	template<typename T, typename T1, typename Y, typename U, typename U1>
	void split_merge_optimization_segments_speed2(U& const input_argument, const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument);

	//************************************
	// Method:split_merge_optimization_segments_speed3
	// Qualifier: After initial part, add speeded ms part, not only sm part.
	// date:210303  09:27
	// author:
	//************************************
	template<typename T, typename T1, typename Y, typename U, typename U1>
	void split_merge_optimization_segments_speed3(U& const input_argument, const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument);

	//200915 After initial part, Use split&merge&optimization to get tighter approximation
	template<typename T, typename T1, typename Y, typename U, typename U1, typename U2>
	void split_merge_optimization_segments(U& const input_argument, const vector<T>& const original_time_series_vector, const U2& const optimization_coefficients, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument);
	/**********************************************************************************************************************************************/

	//************************************
	// Method:get_SAPLA_by_one_line_or_two_points
	// Qualifier: After initial part, add speeded ms part, not only sm part.
	// date:210307  16:03
	// author:
	//************************************
	template <typename T, typename T1, typename Y, typename U, typename U1>
	void get_SAPLA_by_one_line_or_two_points(U& const input_argument, const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument);

	//200707 new initial method
	template<typename T, typename Y, typename U, typename U1>
	void initial_SAPLA_200706(U& const input_argument, const vector<T>& const original_time_series_vector, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument);

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& Initial Y Projection &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	//191028 Initial to check Y-projection & APLA
	void initialAPLAYProjection(typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<AREA_COEFFICIENT>& const all_linked_list, DoublyLinkedList<AREA_COEFFICIENT>& const cluster_linked_list, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list);//191028 Initial to check Y-projection & APLA
	//191115 for KNN algorithm
	template<typename T>
	void initial_apla_yprojection_knn(typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<T>& const all_linked_list, DoublyLinkedList<T>& const cluster_linked_list, DoublyLinkedList<T>& const doubly_linked_list);

	void initialAPLARightEndpoint3SubNoMerge(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector);//190627 16:38 Use minmax point split segment into 3 subsegment, when minmax points at endpoint, not merge.

	void initialRecArea0ForParallelogramArrayVector0(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector);//190605 Use vector to instead Array,

	template<typename T, typename T1, typename Y, typename U>
	void initial_y_projection_all_cluster(const U& const input_argument, const vector<T>& const original_time_series_vector, T1& const y_projection_argument, DoublyLinkedList<Y>& const all_segment_linked_list, DoublyLinkedList<Y>& const cluster_linked_list);
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	 /*---------------------------------------------------------Width--------------------------------------------------------------------*/
	inline double& getRecWidth(const vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, const int& const rec_num, AREA_COEFFICIENT& const temp_coefficient);//190115

	double& getRecWidth(vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, const int& const rec_num);//190319

	inline double& getRecWidth(SEGMENT_COEFFICIENT*& area_vector, const int& const vector_id, SEGMENT_COEFFICIENT& const temp_coefficient);//190418

	inline double& getRecWidthWidth(vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient);//190605

	void getRightEndpointAndWidth(const vector<int>& const right_endpoint_vector, vector<AREA_COEFFICIENT>& const area_vector);//190624
	/*-----------------------------------------------------------------------------------------------------------------------------------*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&          Get a & b from one point or two points           &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*---------------------------------      a&b One Point Slope a & Intercept b    -----------------------------------------------------------*/
	inline long double& getAandBSlopInterceptOnePoint(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient);//190115

	//200212 Use vector of time series to instead pointer. Add template
	template<typename T, typename Y>
	inline long double& getAandBSlopInterceptOnePoint(const vector<T>& const original_time_series_vector, Y& const temp_coefficient);//200212

	//200422
	template<typename T, typename Y>
	inline Y& getAandBSlopInterceptOnePoint(const T& const point_value, Y& const temp_coefficient);//190115
	/*------------------------------------------------------------------------------------------------------------------------------------------*/

	/*-----------------------------------     a&b Two Point Slope a & Intercept b     -----------------------------------------------------------*/
	inline AREA_COEFFICIENT& getAandBSlopInterceptTwoPoint(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient);//190929

	//200212 Use vector to instead pointer for time sereis ,add template
	template<typename T, typename Y>
	inline Y& getAandBSlopInterceptTwoPoint(const vector<T>& const original_time_series_vector, Y& const temp_coefficient);//200212

	template<typename T, typename Y>
	inline void getAandBSlopInterceptTwoPoint(const Y& const left_value, const Y& const right_value, T& const temp_coefficient);//191114
	/*--------------------------------------------------------------------------------------------------------------------------------------------*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	AREA_COEFFICIENT& refreshSegmentCoefficient(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient);//190318 for AREA_COEFFICIENT

	void refreshSegmentCoefficient(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector, const int& const vector_id);//190319 for vector

	AREA_COEFFICIENT& refreshSegmentCoefficient0ForParallelogram(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient);//190404

	SEGMENT_COEFFICIENT& refreshSegmentCoefficient0ForParallelogram(DataType*& const original_time_series, SEGMENT_COEFFICIENT& const temp_coefficient);//190419

	void computeRectangleCoefficient(vector<AREA_COEFFICIENT>& area_vector, const int& const vector_id, const double& const lowest_id, const double& const lowest_value, const double& const heightest_id, const double& const heightest_value);//181205 old

	void computeRectangleCoefficient(vector<AREA_COEFFICIENT>& area_vector, const int& const vector_id, const typename GEOMETRY::POINT& const min_point, const typename GEOMETRY::POINT& const max_point);//190319 Improve input argument of function

	bool updateRectangle(vector<AREA_COEFFICIENT>& area_vector, const int& const vector_id, DataType*& const original_time_series);//181205 update adjacent rectangle after merge operation

	void mergeRectangleRange(vector<AREA_COEFFICIENT>& area_vector, int& first_id, int& last_id, DataType*& const original_time_series);//181210 Range

	//190410
	bool mergeRectangleRecursive(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector, int vector_id);

	bool isRecMonotonic(vector<AREA_COEFFICIENT>& area_vector, int& first_id, int& last_id);//181211

	bool moveRecEndpoint(vector<AREA_COEFFICIENT>& area_vector, int& vector_id, DataType*& const original_time_series);//181211 Update Left current and reight rectangle

	//190319
	bool moveRectagnleEndpoint(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector, int vector_id);

	//190327
	bool moveRectagnleSplitpoint(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector, int vector_id);

	void mergeRectangle(vector<AREA_COEFFICIENT>& area_vector, const int vector_id);//181120

	//void mergeRectangle(vector<AREA_COEFFICIENT>& area_vector, const int vector_id, const double temp_heightest_id,const double temp_lowest_id);//181127

	void mergeRectangle(vector<AREA_COEFFICIENT>& area_vector, int& vector_id, const AREA_COEFFICIENT& const temp_coefficient, DataType*& const original_time_series);//181205 rcurrent rectangle merge.  No recursive.

	void mergeRectangle0(vector<AREA_COEFFICIENT>& area_vector, int& vector_id, const AREA_COEFFICIENT& const temp_coefficient, DataType*& const original_time_series);//181210 current rectangle merge right rectangle if current heightest value< right lowest value. merge. recursive

	void mergeRectangle1(vector<AREA_COEFFICIENT>& area_vector, int& vector_id, const AREA_COEFFICIENT& const temp_coefficient, DataType*& const original_time_series);//181210 current rectangle merge right rectangle and left rectangle. merge. No recursive No recursive

	void mergeRectangle2(vector<AREA_COEFFICIENT>& area_vector, int& vector_id, const AREA_COEFFICIENT& const temp_coefficient, DataType*& const original_time_series);//181210 current rectangle merge right rectangle and left rectangle. merge. recursive recursive

	void mergeRectangle0ForParallelogram(vector<AREA_COEFFICIENT>& area_vector, int& vector_id, const AREA_COEFFICIENT& const temp_coefficient, DataType*& const original_time_series);//190404 Only for ForParallelogram

	inline void mergeRectangle0ForParallelogramNoErase(vector<AREA_COEFFICIENT>& area_vector, int& vector_id, int& const segment_number, const AREA_COEFFICIENT& const temp_coefficient, DataType*& const original_time_series);//190410 Only for ForParallelogram, No erase function

	inline void mergeRectangle0ForParallelogramNoEraseArray(SEGMENT_COEFFICIENT*& area_vector, int& vector_id, const SEGMENT_COEFFICIENT& const temp_coefficient, DataType*& const original_time_series);//190418 Only for ForParallelogram, No erase function,for array, speed up algorithm.

	void splitRectangle(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector, int vector_id);//190114


	/*===============================================    Find Split Point    ==========================================================================*/
	int binarySearchIdEquality(DataType*& const original_time_series, int& const left_id, int& const right_id);//190709 get slope a & intercept b by 2 points

	double AdaptiveSearchIdEquality(DataType*& const original_time_series, int& const left_id, int& const right_id);//190716 get slope a & intercept b by adaptive length points

	double binarySearchIdPointDistance(DataType*& const original_time_series, int& const left_id, int& const right_id);//190715

	double AdaptiveSearchIdPointDistance(DataType*& const original_time_series, int& const left_id, int& const right_id);//190716 For every binary, compute left_a & right_a

	double AdaptiveSearchIdPointDistance2(DataType*& const original_time_series, int& const left_id, int& const right_id);//191008 For every binary, only comput changed left id or right id
	//191231 vector to 
	template<typename T>
	double AdaptiveSearchIdPointDistance2(const vector<T>& const original_time_series, int& const left_id, int& const right_id);//191231 For every binary, only comput changed left id or right id

	//200219
	// compute intersection point by endpoint of one segment
	template<typename T>
	double get_intersection_point_by_segment(const vector<T>& const original_time_series, const int& const left_id, const int& const right_id);

	//191207 
	double find_split_point_by_binary_gradient(DataType*& const original_time_series, const int& const left_id, const int& const right_id); //For every binary, only comput changed left id or right id by middle gradient
	//191206 By Gradient Descent
	int find_split_point_by_gradient_descent(DataType*& const original_time_series, const int& const left_id, const int& const right_id);

	double findSplitSegmentByEndpoint2length(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient);//190709 Find split point by a&b of length 2 endpoint of segment, if no equal, pick mid point.
	//191231 vector to instead pointer
	template<typename T, typename Y>
	double findSplitSegmentByEndpoint2length(const vector<T>& const original_time_series, const Y& const temp_coefficient);//191231 Find split point by a&b of length 2 endpoint of segment, if no equal, pick mid point.

	//200219
	// regard the intersection point from  two endpoint of segment as sp;lit id
	template<typename T, typename Y>
	int find_split_point_by_direct_intersection_point(const vector<T>& const original_time_series_vector, const Y& const temp_coefficient);

	// 200221
	// regard the middle point of segment split id
	template<typename T>
	inline double find_split_point_by_middle_point(const T& const temp_coefficient);

	//200205 Use optimal method to find split point in one segment.
	//split_point_type: 0 best split point. 1 min triangle density
	template<typename T, typename Y>
	double findSplitSegmentBaseline(const vector<T>& const original_time_series, const Y& const temp_coefficient, const int split_point_type);

	//200210 get split coefficient: left & right a&b, triangle densitys
	// return trianle density
	template<typename T, typename Y>
	long double& get_split_coefficient(const vector<T>& const original_time_series_vector, Y& const temp_coefficient, SPLIT_COEFFICIENT& const split_coefficent);

	//200220 get split coefficient: left & right a&b, triangle densitys
	// return trianle density
	template<typename T, typename Y, typename U>
	long double& get_split_coefficient(const vector<T>& const original_time_series_vector, Y& const temp_coefficient, SPLIT_COEFFICIENT& const split_coefficent, const int& const split_id_left, const int& const split_id_right, vector<U>& const segments_density_vector, const int& const split_point_left_segment_id);

	//200301, Use linekd list to instead vector get split coefficient: left & right a&b, triangle densitys
	// return trianle density
	template<typename T, typename Y, typename U>
	long double& get_split_coefficient(const vector<T>& const original_time_series_vector, Y& const temp_coefficient, SPLIT_COEFFICIENT& const split_coefficent, const int& const split_id_left, const int& const split_id_right, DoublyLinkedList<U>& const segments_density_linked_list, const int& const split_point_left_segment_id);

	//200217 get split coefficient:sub left & right a&b, triangle denstiys
	// return trianle density
	//template<typename T, typename Y, typename U>
	//double& get_split_coefficient(const vector<T>& const original_time_series_vector, U& const split_coefficent, Y& const sub_segment_left, Y& const sub_segment_right, Y& const original_long_segment);

	//200214 Find min density point fast use vector. prove coefficeints for sub left segment, sub irght segment, and long smegnetnr 
	template<typename T, typename Y, typename U>
	U get_segment_min_density_local_id(const vector<T>& const original_time_series_vector, Y& const original_long_segment, vector<U>& const segments_density_vector);

	//200301 Use Linked List instead vector. Find min density point fast use vector. prove coefficeints for sub left segment, sub irght segment, and long smegnetnr 
	template<typename T, typename Y, typename U>
	U get_segment_min_density_local_id(const vector<T>& const original_time_series_vector, Y& const original_long_segment, DoublyLinkedList<U>& const segments_density_linked_list);

	//200301 Already know local mind density split id. Try to search border section. make local section as global section. Find min density point fast use vector. prove coefficeints for sub left segment, sub irght segment, and long smegnetnr 
	template<typename T, typename Y, typename U>
	U& get_segment_min_density_global_id(const vector<T>& const original_time_series_vector, Y& const long_segment, U& const min_density_segment_local, vector<U>& const segments_density_vector);

	//200302 Use linked list ot instead vector. Already know local mind density split id. Try to search border section. make local section as global section. Find min density point fast use vector. prove coefficeints for sub left segment, sub irght segment, and long smegnetnr 
	template<typename T, typename Y, typename U>
	U& get_segment_min_density_global_id(const vector<T>& const original_time_series_vector, Y& const long_segment, U& const min_density_segment_local, DoublyLinkedList<U>& const segments_density_linked_list);

	//200210 Find min density point fast use vector
	template<typename T, typename Y>
	double find_split_point_by_min_density_fast(const vector<T>& const original_time_series_vector, Y& const temp_coefficient);

	//200302 Find min density point fast use vector. prove coefficeints for sub left segment, sub irght segment, and long smegnetnr
	// return 1 split id. 2 sub left&right segment a&b
	template<typename T, typename Y, typename U>
	double find_split_point_by_min_density_fast(const vector<T>& const original_time_series_vector, Y& const sub_segment_left, Y& const sub_segment_right, U& const temp_coefficient);

	//200225 contain 5 split point methods 1 min denisty , 2 BInary 3 Intersectoin point 4 middle point 5 best split id 
	template<typename T, typename Y>
	double group_find_split_point_methods(const vector<T>& const original_time_series_vector, Y& const temp_coefficient, const int& const option_split_method);

	//200225 contain 5 split point methods 1 min denisty , 2 BInary 3 Intersectoin point 4 middle point 5 best split id 
	template<typename T, typename Y, typename U>
	double group_find_split_point_methods(const vector<T>& const original_time_series_vector, const int& const option_split_method, Y& const sub_segment_left, Y& const sub_segment_right, Y& const temp_coefficient, U& const output_argument);

	//190715 get middle point of one segment
	template<typename T>
	inline int findSegmentMiddleID(T& const temp_coefficient);//190715

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&      Area Difference      &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	//190903
	inline double& getAreaDifference(AREA_COEFFICIENT& const temp_coefficient); //Min Max area - PLA area

	//190918
	inline double& getAreaDifference(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient); // Right end point area - PLA area

	//200212 change original time series from pointer to vector. Add template
	template<typename T, typename Y>
	inline long double& getAreaDifference(const vector<T>& const original_time_series_vector, Y& const temp_coefficient); // MinMax Area - PLA Area

	//201004 10:13 without original time series
	//template<typename T>
	//inline long double& get_area_difference_segment(T& const temp_coefficient); // MinMax Area - PLA Area

	//201007 02:21 Use the endpoint height difference instead area difference
	template<typename T, typename Y>
	inline long double& get_area_difference_segment(const vector<T>& const original_time_series_vector, Y& const temp_coefficient);
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&         201029 Upper Bound         &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	//201029 13:35 Compute max_deviation from left&right min&max points
	template<typename T, typename Y>
	inline long double& get_segment_max_deviation_instead(const T& const left_endpoint_value, const T& const right_endpoint_value, Y& const temp_coefficient);

	//210112 09:10 Compute upper bound from left&right min&max points
	template<typename T, typename Y>
	long double& get_segment_max_deviation_instead1(const vector<T>& const original_time_series_vector, Y& const temp_coefficient);
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	//190722
	void SplitSegmentByRealPLAArea(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector, const int& const split_number); //190722 find which point should be splited in one segment
	//190823
	void SplitSegmentByRealPLAArea(DataType*& const original_time_series, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list, const int& const split_number); //190823 find which point should be splited in one segment

	//191006
	void splitSegmentBySplitedPoint(DataType*& const original_time_series, AREA_COEFFICIENT& const sub_left_segment, AREA_COEFFICIENT& const long_segment);

	//200212 Add template. Use pointer to instead vector for time series
	template<typename T, typename Y>
	void splitSegmentBySplitedPoint(const vector<T>& const original_time_series_vector, Y& const sub_left_segment, Y& const long_segment);

	//200226 Add split method option.  Add template. Use pointer to instead vector for time series
	template<typename T, typename Y>
	void splitSegmentBySplitedPoint(const vector<T>& const original_time_series_vector, const int& const option_split_method, Y& const sub_left_segment, Y& const long_segment);

	//200226 Add split method option.  Add template. Use pointer to instead vector for time series
	template<typename T, typename Y, typename U>
	void splitSegmentBySplitedPoint(const vector<T>& const original_time_series_vector, const int& const option_split_method, Y& const sub_left_segment, Y& const long_segment, U& const output_argument);

	//200821 find if multimap has key
	template<typename T, typename Y, typename U>
	bool find_if_in_multimap(const T& const key, const multimap<U, Y, greater<U>>& const multi_map);

	//************************************
	// Method:find_key_in_map
	// Qualifier: if key in map
	// Input: map, key
	// Output: key in map
	// date:201223
	// author:
	//************************************
	template<typename T, typename T1, typename Y>
	inline bool find_key_in_map(const multimap<Y, DoublyListNode<T>&, std::greater<Y>>& const sorted_multimap, const T1& const key);

	//************************************
	// Method:find_endpoint_key_in_map
	// Qualifier: if key, right endpoint in map
	// Input: map, key, right endpoint
	// Output: right endpoint, key in map
	// date:201228
	// author:
	//************************************
	template<typename T, typename T1, typename Y, typename U>
	bool find_endpoint_key_in_map(const multimap<Y, DoublyListNode<T>&, std::greater<Y>>& const sorted_multimap, const U& const unique_right_endpoint, const T1& const key);

	//190930
	template<typename T, typename T1, typename Y, typename U>
	void eraseMapByKey(multimap<Y, DoublyListNode<T>&, std::greater<Y>>& const sorted_multimap, const U& const unique_right_endpoint, const T1& const key);

	//190930
	template<typename T, typename T1, typename T2, typename Y, typename U>
	void updateMapByKey(multimap<Y, DoublyListNode<T>&, std::greater<Y>>& const sorted_multimap, const U& const unique_right_endpoint, const T1& const key, const T2& const new_value);

	//190830
	void splitSegmentBySlope(DataType*& const original_time_series, multimap<double, DoublyListNode<AREA_COEFFICIENT>&, std::greater<double>>& const merge_segment_density_map, multimap<double, DoublyListNode<AREA_COEFFICIENT>&, std::greater<double>>& const split_area_difference_map, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list);

	//200212 change original time series from pointer to vector. Add templatea
	template<typename T, typename Y>
	void splitSegmentBySlope(const vector<T>& const original_time_series_vector, multimap<double, DoublyListNode<Y>&, std::greater<double>>& const merge_segment_density_map, multimap<double, DoublyListNode<Y>&, std::greater<double>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list);

	//200226 Add split metyhod option change original time series from pointer to vector. Add templatea
	template<typename T, typename Y, typename U, typename T1>
	void splitSegmentBySlope(const vector<T>& const original_time_series_vector, const int& const split_method_option, multimap<T1, DoublyListNode<Y>&, std::greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, std::greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U& const output_argument);

	//191124 for burst time series that need to split segment
	template<typename T>
	void split_burst_segment(DataType*& const original_time_series, const int& const  point_dimension, DoublyLinkedList<T>& const doubly_linked_list);

	//191124 for burst time series that need to split segment
	//200212 change original time series from pointer to vector. Add template
	template<typename T, typename Y>
	void split_burst_segment(const vector<T>& const original_time_series_vector, const int& const  point_dimension, DoublyLinkedList<Y>& const doubly_linked_list);
	/*............................................................................................................................*/

	/*===========================================================            Merge Segment       =============================================================*/
	//190910
	inline void mergeSegmentByDensity(DataType*& const original_time_series, multimap<double, DoublyListNode<AREA_COEFFICIENT>&, std::greater<double>>& const merge_segment_density_map, multimap<double, DoublyListNode<AREA_COEFFICIENT>&, std::greater<double>>& const split_area_difference_map, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list);
	//200212 change original time series from pointer to vector. Add templatea
	template<typename T, typename Y, typename U, typename T1>
	inline void mergeSegmentByDensity(const vector<T>& const original_time_series_vector, multimap<U, DoublyListNode<Y>&, std::greater<U>>& const merge_segment_density_map, multimap<U, DoublyListNode<Y>&, std::greater<U>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, T1& const output_argument);
	//190712
	inline void mergeEndSegment(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector, AREA_COEFFICIENT& const temp_coefficient);//190712 18:15 new segment is same with end vector, merge them.
	/*=========================================================================================================================================================*/

	/*===============================================        Split & Merge & Optimization Segment       ========================================================*/
	//200925 Split & Merge Operation iteration 
	template<typename T, typename Y, typename U, typename T1>
	inline void split_merge_optimization(const vector<T>& const original_time_series_vector, const int& const split_method_option, multimap<T1, DoublyListNode<Y>&, std::greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, std::greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U& const output_argument);
	/*==========================================================================================================================================================*/

	bool isSymmetry(const AREA_COEFFICIENT& const temp_coefficient, DataType*& const original_time_series);//181220 Whether max point or min point in the middle

	bool isSymmetryForParallelogram(const AREA_COEFFICIENT& const temp_coefficient, DataType*& const original_time_series);//190408 Whether max point or min point in the middle

	void getMergedInfo(DataType*& const original_time_series, const vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient);//181129

	void getMergedInfor0ForParallelogram(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, int& const vector_id, int& const segment_number, AREA_COEFFICIENT& const temp_coefficient);//181129

	void getMergedInfor0ForParallelogramImprove(vector<AREA_COEFFICIENT>& const area_vector, int& const vector_id, AREA_COEFFICIENT& const temp_coefficient);//181129
	//190825 Use linked list to instead vector
	void getMergedInfor0ForParallelogramImprove(DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list, int& const vector_id, AREA_COEFFICIENT& const temp_coefficient);//190825
	//190904
	double getMergedSubSegmentInformation(DoublyListNode<AREA_COEFFICIENT>& const node);
	//190918
	double getMergedSubSegmentInformation(DataType*& const original_time_series, DoublyListNode<AREA_COEFFICIENT>& const node);

	//200212 time series from pointer to vector. Add template
	template<typename T, typename Y, typename U>
	double getMergedSubSegmentInformation(const vector<T>& const original_time_series_vector, DoublyListNode<Y>& const node, U& const output_argument);

	//201030 time series from pointer to vector. Add template
	template<typename T, typename Y, typename U>
	double getMergedSubSegmentInformation(const vector<T>& const original_time_series_vector, Y& const left_segment, Y& const right_segment, Y& const merged_segment, U& const output_argument);

	void getMergedInforQueue(vector<AREA_COEFFICIENT>& const area_vector, int& const vector_id, AREA_COEFFICIENT& const temp_coefficient);//190607

	void getMergedInfor0ForParallelogramArray(DataType*& const original_time_series, SEGMENT_COEFFICIENT*& area_vector, int& const vector_id, SEGMENT_COEFFICIENT& const temp_coefficient);//190418

	double& computeParallelogram(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient);//190102

	double& computeParallelogramNoProjection(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient);//190404 the funciton is the same with above, only improve the process, not project the deviaiton point to the left segment.

	double& computeParallelogramNoProjection(DataType*& const original_time_series, SEGMENT_COEFFICIENT& const temp_coefficient);//190419 the funciton is the same with above, only improve the process, not project the deviaiton point to the left segment.

	std::vector<typename GEOMETRY::POINT> getPointFromSeg(DataType*& const original_time_series, const AREA_COEFFICIENT& const temp_coefficient);//190306

	double& getPolygonArea(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient);//190123

	double& getConvexHullArea(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient);//190227

	double& getCircleArea(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient);//190308

	void getSegmentMinMaxRectangleAreaDensity(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector);//190701
	//190826
	void getSegmentMinMaxRectangleAreaDensity(DataType*& const original_time_series, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list);//190826

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&                Get slope a & intercept b              &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	//get a & b of segment PLA by original time series, only know width & right end point
	double& getAAndBByPLA(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient);//190107 return a;

	// 191114 add template vector. get a & b of segment PLA by original time series, only know width & right end point
	template<typename T>
	T& getAAndBByPLA(const vector<DataType>& const original_time_series, T& const temp_coefficient);//190107 return a;

	//200320 get apla coeffcient minus advisor
	template<typename T>
	inline void get_apla_coefficients_segment(T& const temp_coefficient);

	//200504 Aleady know is flat segment. get 1 a & b 2 min&max point of segment PLA by original time series, only know width & right end point
	template<typename T, typename Y>
	inline void get_ab_minmax_flat_segment(const vector<T>& const original_time_series_vector, Y& const temp_coefficient);

	//200730 compute a&b min&max of two points segment
	template<typename T, typename Y>
	inline void get_segment_two_points_ab_minmax(const T& const left_value, const T& const right_value, Y& const temp_coefficient);

	//200731 compute a&b min&max of accumulation segment from current segment.
	template<typename T, typename Y>
	inline Y& get_ab_minmax_segment_by_accumulation(const T& const accumulate_point_value, const Y& const last_segment, Y& const temp_coefficient);

	//200731 compute a&b, min&max of accumulation segment from current segment.
	template<typename T, typename Y>
	inline Y& get_ab_minmax_segment_by_accumulation(const T& const accumulate_point_value, Y& const current_segment);

	//200420 get 1 a & b 2 min&max point of segment PLA by original time series, only know width & right end point
	template<typename T, typename Y>
	Y& get_ab_minmax_segment(const vector<T>& const original_time_series_vector, Y& const temp_coefficient);

	// 200221 add template vector. get a & b of segment PLA by original time series, only know width & right end point
	template<typename T, typename Y>
	Y& get_ab_segment(const vector<T>& const original_time_series_vector, Y& const temp_coefficient);

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	/*==============================================      Accumulate Right   ==================================================================*/
	// 200228 get a&b of long segment by one point and old short segment
	template<typename T, typename Y>
	inline Y& get_ab_segment_by_accumulation(const vector<T>& const original_time_series_vector, const Y& const last_segment, Y& const temp_coefficient);

	// get a& b of long segment by right one pointand old short segment
	template<typename T, typename Y>
	inline Y& get_ab_segment_by_accumulation(const T& const accumulate_point_value, const Y& const last_segment, Y& const temp_coefficient);

	// 200731 get a&b of accumulate segment by one point and current segment
	template<typename T, typename Y>
	inline void get_ab_accumulation_segment(const T& const accumulate_point_value, Y& const current_segment);

	// 20907 get average of accumulate segment by one point and current segment
	template<typename T, typename Y>
	inline void get_ab_accumulation_segment_average(const T& const accumulate_point_value, Y& const current_segment);
	/*=========================================================================================================================================*/

	/*==============================================      Accumulate Left    ==================================================================*/
	//201021 get a& b of long segment by left one pointand old short segment
	template<typename T, typename Y>
	inline Y& get_ab_segment_by_accumulation_left(const T& const point_value_left, const Y& const sub_right_segment, Y& const temp_coefficient);

	//201901 get a& b of long segment by left one pointand old short segment
	template<typename T, typename Y>
	inline Y& get_ab_segment_by_accumulation_left(const T& const point_value_left, Y& const temp_coefficient);

	//210907 get average of long segment by left one pointand old short segment
	template<typename T, typename Y>
	inline Y& get_ab_segment_by_accumulation_left_average(const T& const point_value_left, Y& const temp_coefficient);
	/*=========================================================================================================================================*/

	/*==============================================      Decrement Right    ==================================================================*/
	// 200228 get a1&b1 of short left segment by one point and old long segment
	template<typename T, typename Y>
	inline Y& get_ab_segment_by_decrement(const vector<T>& const original_time_series_vector, const Y& const last_segment, Y& const temp_coefficient);

	// 201021 get a1&b1 of short left segment by right one point and old long segment
	template<typename T, typename Y>
	inline Y& get_ab_segment_by_decrement_right(const T& const point_value_right, const Y& const long_segment, Y& const sub_left_segment);

	// 201901 get a1&b1 of short left segment by right one point and old long segment
	template<typename T, typename Y>
	inline Y& get_ab_segment_by_decrement_right(const T& const point_value_right, Y& const temp_coefficient);

	//210907 get average of short left segment by right one point and old long segment
	template<typename T, typename Y>
	inline Y& get_ab_segment_by_decrement_right_average(const T& const point_value_right, Y& const sub_left_segment);
	/*=========================================================================================================================================*/

	/*==============================================      Decrement Left     ==================================================================*/
	// 201022 get a2&b2 of short right segment by left one point and old long segment
	template<typename T, typename Y>
	inline Y& get_ab_segment_by_decrement_left(const vector<T>& const original_time_series_vector, const Y& const long_segment, Y& const sub_right_segment);

	// 201021 get a2&b2 of short right segment by left one point and old long segment
	template<typename T, typename Y>
	inline Y& get_ab_segment_by_decrement_left(const T& const point_value_left, const Y& const long_segment, Y& const sub_right_segment);

	// 2010901 get a2&b2 of short right segment by left one point and old long segment
	template<typename T, typename Y>
	inline Y& get_ab_segment_by_decrement_left(const T& const point_value_left, Y& const long_segment);

	// 2010907 get average of short right segment by left one point and old long segment
	template<typename T, typename Y>
	inline Y& get_ab_segment_by_decrement_left_average(const T& const point_value_left, Y& const sub_right_segment);
	/*=========================================================================================================================================*/
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	double& getABSlopeInterceptOriginal(DataType*& const original_time_series, const int& const left_id, const int& const right_id, double& const slope_a, double& const intercept_b);//190716 get slope a & intercept b by original time series

	template<typename T>//191231 vector to instead pointer
	double& getABSlopeInterceptOriginal(const vector<T>& const original_time_series, const int& const left_id, const int& const right_id, double& const slope_a, double& const intercept_b);//191231 get slope a & intercept b by original time series

	double& getAAndBByPLAShortSeg(DataType*& const original_time_series, const vector<AREA_COEFFICIENT>& const area_vector, int& const vector_id, AREA_COEFFICIENT& const temp_coefficient);//190412 return a&b from short sub segment;

	void getAAndBByPLAShortSegSpeed(const vector<AREA_COEFFICIENT>& const area_vector, int& const vector_id, AREA_COEFFICIENT& const temp_coefficient);//190611 No evaluation method and sum value and a b
	//190825
	inline void getAAndBByPLAShortSegSpeed(DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list, int& const vector_id, AREA_COEFFICIENT& const temp_coefficient);//190825 No evaluation method and sum value and a b
	//190904 get merged information of left segment & right segment
	// Input: left & right segment, 1 a&b, 2 width, 3 sum value
	// Output: Merged segment,  1 a&b, 2 width, 3 sum value
	template<typename T, typename Y>
	inline void getAAndBByPLAShortSegSpeed(const T& const left_segment, const T& const right_segment, Y& const merged_segment);
	//210907 get merged average value of left segment & right segment
	template<typename T, typename Y>
	inline void getAAndBByPLAShortSegSpeed_average(const T& const left_segment, const T& const right_segment, Y& const merged_segment);
	//190920
	// Input: 1 left sub segment a&b, width, sum; 2 merged segment a&b, width, sum.
	// Output: 1 merged segment a&b, width, sum;
	//inline AREA_COEFFICIENT& getSubRightAAndBByPLA(const AREA_COEFFICIENT& const left_segment, const AREA_COEFFICIENT& const merged_segment, AREA_COEFFICIENT& const right_segment);
	//200211
	// Input: 1 left sub segment a&b, width, sum; 2 merged segment a&b, width, sum.
	// Output: 1 merged segment a&b, width, sum;
	template<typename T>
	inline T& getSubRightAAndBByPLA(const T& const left_segment, const T& const merged_segment, T& const right_segment);

	//190926
	// Input: 1 left sub segment a&b, width, sum; 2 merged segment a&b, width, sum.
	// Output: 1 merged segment a&b, width, sum;
	//inline AREA_COEFFICIENT& getSubLeftAAndBByPLA(const AREA_COEFFICIENT& const right_segment, const AREA_COEFFICIENT& const merged_segment, AREA_COEFFICIENT& const left_segment);

	//200211
	// Input: 1 left sub segment a&b, width, sum; 2 merged segment a&b, width, sum.
	// Output: 1 merged segment a&b, width, sum;
	template<typename T>
	inline T& getSubLeftAAndBByPLA(const T& const right_segment, const T& const merged_segment, T& const left_segment);

	//190926
	// Input: 1 Original time series: long segment a&b, sum, width, right endpoint; 2 left(right) sub segment: a&b, sum, width, right endopint;
	// Output: right(left) sub segment: a&b, sum, sub left right min&max point
	template<typename T>
	void getSubAAndBByPLA(DataType*& const original_time_series, T& const left_segment, T& const right_segment, const T& const merged_segment);

	//200210
	// Input: 1 Original time series vector: long segment a&b, sum, width, right endpoint; 2 left(right) sub segment: a&b, sum, width, right endopint;
	// Output: right(left) sub segment: a&b, sum, sub left right min&max point
	template<typename T, typename Y>
	void getSubAAndBByPLA(const vector<T>& const original_time_series, Y& const left_segment, Y& const right_segment, const Y& const merged_segment);

	//210907
	template<typename T, typename Y>
	void getSubAAndBByPLA_average(const vector<T>& const original_time_series, Y& const left_segment, Y& const right_segment, const Y& const merged_segment);

	//210601 : Consider one point segment
	// Input: 1 Original time series vector: long segment a&b, width, right endpoint; 2 left(right) sub segment: a&b, width, right endopint;
	// Output: right(left) sub segment: a&b.
	template<typename T, typename Y>
	void get_sub_ab_by_long_one_point(const vector<T>& const original_time_series, Y& const left_segment, Y& const right_segment, const Y& const merged_segment);

	double& getAAndBByPLAShortSegArray(DataType*& const original_time_series, SEGMENT_COEFFICIENT*& area_vector, int& const vector_id, SEGMENT_COEFFICIENT& const temp_coefficient);//190418 return a&b from short segment;

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&   Get Sum & Max Deviation   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	
	/*----------------------------------------------      get segemnt value     ------------------------------------------------------*/
	template<typename T, typename Y>
	inline long double get_sum_value(const T& const a, const T& const b, const Y& const segment_length);
	/*--------------------------------------------------------------------------------------------------------------------------------*/

	/*==================================================== get Segemnt Sum Deviation =======================================================*/
	// get segment sum deviaiton,  only know right endpoitn and widht of segment
	double& getSegmentDevByPLA(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient);//190115 return deviation

	// 200113  get segment sum deviaiton,  Know right endpoint, width, a & b of every segment
	//template<typename T, typename Y>
	//double& get_segment_sum_deviation(const vector<T>& const original_time_series, Y& const temp_coefficient);//200113

	// 210120 Only return sum value. get segment sum deviaiton,  Know right endpoint, width, a & b of every segment
	template<typename T, typename Y>
	long double get_segment_sum_deviation(const vector<T>& const original_time_series_vector, const Y& const temp_coefficient);

	// 210120 Only return sum value. get segment sum deviaiton,  Know right endpoint, width, a & b of every segment
	//template<typename T, typename Y>
	//long double get_segment_sum_deviation(const vector<T>& const original_time_series_vector, const Y& const temp_coefficient);

	//210120 evaluate triangle area lower bound sum deviation of segment
	template<typename T, typename Y>
	bool evaluate_segment_sum_deviation_vs_triangle_area(const vector<T>& const original_time_series_vector, const Y& const temp_coefficient);

	// 200220 get segment sum deviation by split point
	// 200113  get segment sum deviaiton, Know right endpoint, width, a & b of every segment
	template<typename T, typename Y, typename U>
	double get_segment_sum_deviation_by_split_id(const vector<T>& const original_time_series_vector, const Y& const temp_coefficient, const U& const split_id);//200113
	/*=====================================================================================================================================*/

	/*==================================== get Segemnt Sum Deviation & Max Deviation =======================================================*/
	// 201023 Return Sum & Max deviation. Know right endpoint, width, a & b of one segment
	template<typename T, typename Y, typename U>
	long double get_segment_sum_max_deviation(const vector<T>& const original_time_series_vector, const Y& const temp_coefficient, U& const sum_deviation, U& const max_deviation);
	/*======================================================================================================================================*/

	//210120
	template<typename T, typename Y>
	bool assert_merge_deviation(const vector<T>& const original_time_series_vector, const Y& const left_segment, const Y& const right_segment, const Y& const merged_segment);
	//210327
	/*template<typename T, typename Y, typename U, typename W, typename T1>
	long double get_sum_max_deviation(const vector<T>& const original_time_series_vector, const DoublyLinkedList<Y>& const linked_list, U& const sum_deviation, W& const max_deviation, T1& const max_deviation_multiple_width);*/
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&     get Absolute y value Difference for Each Segment          &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	// 200220 scan segment to get absolute difference
	// Input: 1 segment right endpoint, width.
	// Output: sum absolute segment y vlaue difference
	template<typename T, typename Y>
	long double& get_sum_segment_absolute_difference(const vector<T>& const original_time_series_vector, Y& const temp_coefficient);
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	//void compareAreaPercentage(vector<AREA_COEFFICIENT>& area_vector, const int vector_id);//181122 move right_endpoint

	void compareAreaPercentage0(vector<AREA_COEFFICIENT>& area_vector, const int vector_id);//181128 Only compaer percentage

	void compareAreaPercentage(vector<AREA_COEFFICIENT>& area_vector, int& vector_id, DataType*& const original_time_series);//181205

	//int chooseMergeSegmentID();//190315

	void compareAreaPercentageMinMaxDist(vector<AREA_COEFFICIENT>& area_vector, int& vector_id, DataType*& const original_time_series);//181211

	void compareAreaPercentageMinMaxDistNoMove(vector<AREA_COEFFICIENT>& area_vector, int& vector_id, DataType*& const original_time_series);//181211

	//void compareParallelogram(vector<AREA_COEFFICIENT>& area_vector, int& vector_id, DataType *& const original_time_series);//190102

	void compareMiniMaxDist(vector<AREA_COEFFICIENT>& area_vector, const int vector_id);//181126

	void compareDeviation(vector<AREA_COEFFICIENT>& area_vector, int& vector_id, DataType*& const original_time_series);//190115

	void getAPLAArea(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series);//181119

	void getAPLAArea0(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series);//181122

	void getAPLAArea1(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series);//181122

	void getAPLAAreaMinMaxDist(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series);//181123

	void getAPLAArea3(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series);//181211 try initial area and compareAreaPercentageMinMaxDist()

	void getAPLAArea4LogLoop(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series);//190326 Improve speed. Every loop, merge adjacent segment.

	void getAPLAArea5LowerBound(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series);//190327 Improve speed. Every loop, merge adjacent segment. And because pre-merged two small segment PLA is better than merged one big PLA, this is lover bound

	void getAPLAArea5LowerBoundSpeed(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series);//190404 Speed up above algorithm

	void getAPLAArea5LowerBoundSpeedNoErase(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series);//190409 Speed up above algorithm, no erase() function(it cost so much time)

	void mergeOperation0(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, AREA_COEFFICIENT& const temp_coefficient);//190609

	void mergeOperationBatch2(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, vector<AREA_COEFFICIENT>& const temp_coefficient_vector, AREA_COEFFICIENT& const temp_coefficient);//190610 Improve mergeOperation0, use batch to speed up

	void mergeOperationBatch2Set(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, vector<AREA_COEFFICIENT>& const temp_coefficient_vector, AREA_COEFFICIENT& const temp_coefficient);//190610 Use set to instead priority_queue;

	void mergeOperationBatch2SetPointer(typename TOOL::INPUT_ARGUMENT& input_argument, vector<AREA_COEFFICIENT>& const area_vector, vector<AREA_COEFFICIENT>& const temp_coefficient_vector, AREA_COEFFICIENT& const temp_coefficient, vector<int>& const count_break_point_vector);//190612 Add sub segemt to speed up,avoid repeat calculate, Use set to instead priority_queue;

	void mergeOperationBatch2SetSpeed(typename TOOL::INPUT_ARGUMENT& input_argument, vector<AREA_COEFFICIENT>& const area_vector, vector<AREA_COEFFICIENT>& const temp_coefficient_vector, AREA_COEFFICIENT& const temp_coefficient);//190611 Use set to instead priority_queue,speed;

	void mergeOperationBatch2SetSpeedPointer(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, vector<AREA_COEFFICIENT>& const temp_coefficient_vector, AREA_COEFFICIENT& const temp_coefficient);//190612 Add sub segemt to speed up,avoid repeat calculate, Use set to instead priority_queue;
	//190823
	void mergeOperationBatch2SetSpeedPointer(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const temp_coefficient_vector, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list);//190823 Add sub segemt to speed up,avoid repeat calculate, Use set to instead priority_queue;
	//190827
	void mergeSplitOperationLink(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list);

	//200212 Add template. Change time series from pointer to vector
	template<typename T, typename Y, typename U>
	void mergeSplitOperationLink(U& input_argument, const vector<T>& const original_time_series_vector, DoublyLinkedList<Y>& const doubly_linked_list);

	//200212 Add template. Change time series from pointer to vector
	template<typename T, typename Y, typename U, typename U1>
	void mergeSplitOperationLink(U& input_argument, const vector<T>& const original_time_series_vector, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument);

	/*================================================   Y Projection Algorithm    =======================================================*/
	 //190729 get adaptive right end point throgh y projection.
	void yProjectionAPLAInitial(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, const map<double, int>& const whole_difference_map, vector<AREA_COEFFICIENT>& const area_vector);
	//191028 Check if burst time series
	bool checkIfBurstDataSet(typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument);
	//191206 for threshold , max value may also be threshold
	bool check_if_burst_dataset(typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument);
	//191028 split original time series by all y projection value
	void initialYProjectionAll(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series,  const typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<AREA_COEFFICIENT>& const all_linked_list);
	//191030 split original time series by flat segment & mountain segment(unflat segment)
	void initialYProjectionCluster(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, const DoublyLinkedList<AREA_COEFFICIENT>& const all_linked_list, DoublyLinkedList<AREA_COEFFICIENT>& const cluster_linked_list);
	//191210
	template<typename T>
	void get_y_all_cluster_segment(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<T>& const all_segment_linked_list, DoublyLinkedList<T>& const cluster_linked_list);

	//191210
	template<typename T, typename Y, typename U>
	void get_y_all_cluster_segment(U& input_argument, const vector<T>& const original_time_series_vector, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<Y>& const all_segment_linked_list, DoublyLinkedList<Y>& const cluster_linked_list);

	//200213 whether is flat point
	template<typename T, typename U>
	inline bool is_flat_point(const U& const y_projection_argument, const T& const data);

	//200213 get rectangle width of current segment
	template<typename T, typename U>
	inline double& y_projection_get_segment_width(const DoublyLinkedList<U>& const all_segment_linked_list, T& const temp_coefficient);

	//200213 new Y projection method. for complicated situation, frist point is or not flat point.
	template<typename T, typename Y, typename U>
	void get_y_all_cluster_segment_200213(U& input_argument, const vector<T>& const original_time_series_vector, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<Y>& const all_segment_linked_list, DoublyLinkedList<Y>& const cluster_linked_list);

	//190730 y projection, merge initialed y projection method.
	void yProjectionAPLAMerge(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, const map<double, int>& const whole_difference_map, vector<AREA_COEFFICIENT>& const area_vector);
	//191029 Linked list. y projection, merge & split. initialed y projection method.
	void YProjectionAPLALink(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, const typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list);
	//191030 merge & split segment through all_linked_list & cluster_linked_list
	void YProjectionMerge(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, const DoublyLinkedList<AREA_COEFFICIENT>& const all_linked_list, const DoublyLinkedList<AREA_COEFFICIENT>& const cluster_linked_list, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list);

	//191209 merge & split segment by y_projection
	template<typename T>
	void y_projection_merge_split(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, const DoublyLinkedList<T>& const all_linked_list, const DoublyLinkedList<T>& const cluster_linked_list, DoublyLinkedList<T>& const doubly_linked_list);

	//200212 merge & split segment by y_projection
	template<typename T, typename Y, typename U>
	void y_projection_merge_split(U& input_argument, const vector<T>& const original_time_series_vector, const DoublyLinkedList<Y>& const all_linked_list, const DoublyLinkedList<Y>& const cluster_linked_list, DoublyLinkedList<Y>& const doubly_linked_list);

	//191116 when the time series only has one value
	template<typename T>
	void y_projection_merge_line(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, DoublyLinkedList<T>& const doubly_linked_list);

	//191116 when the time series only has one value
	template<typename T, typename Y, typename U>
	void y_projection_merge_line(U& input_argument, const vector<T>& const original_time_series_vector, DoublyLinkedList<Y>& const doubly_linked_list);
	/*====================================================================================================================================*/

	/*==============================================    Burst Time Series ================================================================*/
	//191008
	//void getAPLAForBurstData(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const burst_segment);
	/*====================================================================================================================================*/

	/*============================================================get APLA point====================================================================================*/
	void mergeOperationJump1(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, AREA_COEFFICIENT& const temp_coefficient);//190610 loop +=2

	void getAPLAAreaPLAImprove(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series);//190606, APLA based on PLA

	void getAPLAAreaPLAImproveNoPointer(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series);//190612, APLA based on PLA, minimize struct, no pointer

	void getAPLAByMinMax(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series);//190617  For every segment, use minmax point as endpoint. Then for every segment use same subsegemnt number to merge.
	//190911
	template<typename T>
	void getAPLAByMinMaxLinkedList(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<T>& const all_linked_list, DoublyLinkedList<T>& const cluster_linked_list, typename TOOL::OUTPUT_ARGUMENT& output_argument);// Use Linked List to instead vector, For every segment, use minmax point as endpoint. Then for every segment use same subsegemnt number to merge.

	//191108 no other evaluation method. directly get APLA approximation
	template<typename T>
	void get_APLA_point(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<T>& const all_linked_list, DoublyLinkedList<T>& const cluster_linked_list, DoublyLinkedList<T>& const doubly_linked_list);

	//191209 Merge y projeciton & MSPLA
	//template<typename T>
	//void get_APLA_point_new_y_projection(int nothing, typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<T>& const all_linked_list, DoublyLinkedList<T>& const cluster_linked_list, DoublyLinkedList<T>& const doubly_linked_list);

	//// 191209 Merge y projeciton & MSPLA
	////200213 Use vector to instead pointer for time series. Add template
	//template<typename T, typename Y, typename U>
	//void get_APLA_point_new_y_projection(int nothing, U& input_argument, const vector<T>& const original_time_series_vector, TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<Y>& const all_linked_list, DoublyLinkedList<Y>& const cluster_linked_list, DoublyLinkedList<Y>& const doubly_linked_list);


	// 191209 Merge y projeciton & MSPLA
	//200213 Use vector to instead pointer for time series. Add template
	template<typename T, typename Y, typename U, typename U1, typename U2>
	void get_APLA_point_new_y_projection(U& input_argument, const vector<T>& const original_time_series_vector, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<Y>& const all_linked_list, DoublyLinkedList<Y>& const cluster_linked_list, DoublyLinkedList<U2>& const doubly_linked_list, U1& output_argument);
	/*==============================================================================================================================================================*/

	/*============================================================For KNN ==================================================================================================*/
	//***************************************************************
	// Method:get_apla_projection
	// Qualifier:  project query time series to target APLA point
	// Input:
	// Output: same right endpoint, different a&b
	// notice:
	// date:191111
	// author:
	//***************************************************************
	template<typename T, typename Y>
	vector<Y>& get_apla_projection(const vector<DataType>& const query_time_series_vector, const DoublyLinkedList<T>& const doubly_linked_list, vector<Y>& const area_vector);
	
	//211228 project APCA
	template<typename T, typename Y>
	vector<Y>& get_apla_average_projection(const vector<DataType>& const query_time_series_vector, const DoublyLinkedList<T>& const doubly_linked_list, vector<Y>& const area_vector);

	//191114 compue distance LB for two segments.
	template<typename T, typename Y>
	inline long double get_segment_distance_LB(const T& const segment_1, const Y& const segment_2);

	//210721 compue distance with power for two approximations with same right endpoints.
	template<typename T, typename Y>
	long double get_sqrt_distance_sapla_same_endpoints(const DoublyLinkedList<T>& const doubly_linked_list_1, const DoublyLinkedList<Y>& const doubly_linked_list_2);

	//191114 compue distance LB for two APLA points.
	template<typename T,typename Y>
	double get_distance_LB(const DoublyLinkedList<T>& const doubly_linked_list, const vector<Y>& const area_vector);

	//191114 directly get distanceLB from query time series & original APLA point, combine(get_apla_projection, get_segment_distance_LB, get_distance_LB)
	template<typename T>
	double get_distance_LB_by_series_apla(const vector<DataType>& const query_time_series_vector, const DoublyLinkedList<T>& const doubly_linked_list);

	//191129 compue PLA distance LB for two APLA points.
	template<typename T>
	double get_distance_LB_pla(const DoublyLinkedList<T>& const query_linked_list, const DoublyLinkedList<T>& const doubly_linked_list);

	//200109 compue query time series with reconstruct time series. APCA distance AE
	template<typename T>
	long double get_distance_AE(const vector<DataType>& const query_time_series_vector, const DoublyLinkedList<T>& const doubly_linked_list);

	//191205 compue PLA distance LB for two APLA points fast.
	template<typename T>
	double get_distance_LB_pla_speed(const DoublyLinkedList<T>& const query_linked_list, const DoublyLinkedList<T>& const doubly_linked_list);

	//200110 compue PLA distance LB for two APLA points lower bound.
	template<typename T>
	double get_distance_lower_bound(const DoublyLinkedList<T>& const query_linked_list, const DoublyLinkedList<T>& const doubly_linked_list);

	//200113 compute adaptive segment endpoint distance
	template<typename T>
	double get_apla_endpoint_distance(const DoublyLinkedList<T>& const query_linked_list, const DoublyLinkedList<T>& const doubly_linked_list);

	//200107 compue distance LB for two APLA points by APCA(average value).
	template<typename T>
	double get_distance_apca_LB(const DoublyLinkedList<T>& const doubly_linked_list, const vector<T>& const area_vector);
	/*======================================================================================================================================================================*/
	
	/*==================================================     210506 Index   ====================================================================================*/

	template<typename T>//210518 Lower bound distance between SAPLA (Approximation)
	inline double get_last_segment_right_endpoint(const DoublyListNode<T>& const current_node);

	//210519 1 skipt id of current(first) short segment. 2 last short segment right endpoint < long right endpoint 
	template<typename T, typename Y, typename U, typename T1>
	void get_id_vector_short_segment(const T& const segment_long, const Y& const linked_list_short, U& const id_short_begin, T1& const id_segment_vec);

	template<typename T, typename Y, typename U, typename T1>//210519
	void get_id_vector_segments_equal_endpoint(const vector<T>& const series_long, Y& const segment_long, const DoublyLinkedList<Y>& const linked_list_short, T1& const id_segment_vec, U& const distance_SAPLA);

	//not in use
	template<typename T, typename Y, typename U, typename T1, typename T2, typename T3, typename T4, typename T5>
	void get_distance_SAPLA_segments(const T4& const type_distance, const vector<T>& const original_time_series_long, const T2 right_endpoint_long_original, Y& const segment_long, DoublyLinkedList<Y>& const doubly_linked_list_long, DoublyLinkedList<Y>& const doubly_linked_list_short, T3& const id_begin_long, T3& const id_begin_short, T1& const id_segment_vector, U& const distance_SAPLA, T5& const number_points);

	//210817 get segment distance by option
	template<typename T, typename Y, typename U>
	inline long double get_distance_SAPLA_segment_by_option(const T& const type_distance, const Y& const segment_1, const U& const segment_2);

	// 210531 In use now. get SAPLA distance between 1 long segment and several short segments.
	template<typename T, typename Y, typename U, typename T1, typename T2, typename T3, typename T4>
	void get_distance_SAPLA_segments(const T3& const type_distance, const vector<T>& const original_time_series_long, const T2 right_endpoint_long_original, const DoublyLinkedList<Y>& const doubly_linked_list_short, T1& const id_segment_vector, Y& const segment_long, Y& const segment_short_begin_current, Y& const segment_short_begin_next, U& const distance_SAPLA, T4& const number_points);

	// 210910 In use now. Not change list. get SAPLA distance between 1 long segment and several short segments.
	template<typename T, typename Y, typename U, typename T1, typename T2, typename T3, typename T4>
	void get_distance_SAPLA_segments_average(const T3& const type_distance, const vector<T>& const original_time_series_long, const T2 right_endpoint_long_original, const DoublyLinkedList<Y>& const doubly_linked_list_short, T1& const id_segment_vector, Y& const segment_long, Y& const segment_short_begin_current, Y& const segment_short_begin_next, U& const distance_SAPLA, T4& const number_points);

	//210818 1 partition linked list. 2 minimum segment limitation
	// Add long id and linekd list
	template<typename T, typename Y, typename U, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
	void get_distance_SAPLA_segments_210818(const T3& const option_struct, const vector<T>& const original_time_series_long, const T2 right_endpoint_long_original, const DoublyLinkedList<Y>& const doubly_linked_list_short, DoublyLinkedList<T6>& const doubly_linked_list_long, DoublyListNode<T5>& const node_long, T1& const id_segment_vector, Y& const segment_long, Y& const segment_short_begin_current, Y& const segment_short_begin_next, U& const distance_SAPLA, T4& const number_points);

	// 210506 Lower bound distance between SAPLA (Approximation)
	template<typename T, typename Y, typename U, typename T1, typename T2 >
	long double get_distance_SAPLA(const vector<T>& const original_time_series_vector_1, const vector<T1>& const original_time_series_vector_2, const DoublyLinkedList<Y>& const doubly_linked_list_1, const DoublyLinkedList<T2>& const doubly_linked_list_2, U& const number_points);

	// 210910 Lower bound distance between APCA (Approximation) average distance
	template<typename T, typename Y, typename U>
	long double get_distance_SAPLA_average(const vector<T>& const original_time_series_vector_1, const vector<T>& const original_time_series_vector_2, const DoublyLinkedList<Y>& const doubly_linked_list_1, const DoublyLinkedList<Y>& const doubly_linked_list_2, U& const number_points);

	//210603
	//template<typename T, typename Y, typename U, typename T1, typename T2>
	//long double get_distance_SAPLA(const vector<T>& const original_time_series_vector_1, const T1& const original_time_series_vector_id, const T2& const address, const DoublyLinkedList<Y>& const doubly_linked_list_1, const DoublyLinkedList<Y>& const doubly_linked_list_2, U& const number_points);

	//210622 get equal endpoint SAPLA approximation for 2 approximation points
	template<typename T, typename Y, typename U>
	void get_same_partition_SAPLA(const vector<T>& const original_time_series_vector_1, const vector<T>& const original_time_series_vector_2, DoublyLinkedList<Y>& const doubly_linked_list_1, DoublyLinkedList<Y>& const doubly_linked_list_2, U& const number_points);

	//210818 No minimum segment lenght limitation, and change linked list
	template<typename T, typename Y, typename U>
	long double get_same_partition_SAPLA_210818(const vector<T>& const original_time_series_vector_1, const vector<T>& const original_time_series_vector_2, DoublyLinkedList<Y>& const doubly_linked_list_1, DoublyLinkedList<Y>& const doubly_linked_list_2, U& const number_points);

	//210831 add minimum segment lenght limitation, and change linked list
	template<typename T, typename Y, typename U, typename T1, typename T2>
	long double get_same_partition_SAPLA_limit(const vector<T>& const original_time_series_vector_1, const vector<T1>& const original_time_series_vector_2, DoublyLinkedList<Y>& const doubly_linked_list_1, DoublyLinkedList<T2>& const doubly_linked_list_2, U& const number_points);

	//210901 add minimum segment with limitation, and change linked list, only move list 1 (query) when smaller than min with
	template<typename T, typename Y, typename U, typename T1, typename T2>
	long double get_same_partition_SAPLA_limit_only_move_1(const vector<T>& const original_time_series_vector_1, const vector<T1>& const original_time_series_vector_2, DoublyLinkedList<Y>& const doubly_linked_list_1, DoublyLinkedList<T2>& const doubly_linked_list_2, U& const option_struct);


	//2112228 Only change linked list 1, only move list 1 (query).
	template<typename T, typename Y, typename U, typename T1, typename T2>
	long double get_same_partition_SAPLA_limit_only_project(const vector<T>& const original_time_series_vector_1, const vector<T1>& const original_time_series_vector_2, DoublyLinkedList<Y>& const doubly_linked_list_1, DoublyLinkedList<T2>& const doubly_linked_list_2, U& const option_struct);

	//210901 Compute av. add minimum segment with limitation, and change linked list, only move list 1 when smaller than min with
	//template<typename T, typename Y, typename U, typename T1, typename T2>
	//long double get_same_partition_APCA_limit_only_move_1(const vector<T>& const original_time_series_vector_1, const vector<T1>& const original_time_series_vector_2, DoublyLinkedList<Y>& const doubly_linked_list_1, DoublyLinkedList<T2>& const doubly_linked_list_2, U& const number_points);

	//210622 Brute force to get. get equal endpoint SAPLA approximation for 2 approximation points
	template<typename T, typename Y>
	long double get_same_partition_SAPLA_debug(const vector<T>& const original_time_series_vector_1, const vector<T>& const original_time_series_vector_2, DoublyLinkedList<Y>& const doubly_linked_list_1, DoublyLinkedList<Y>& const doubly_linked_list_2);

	//210518 Lower bound distance between SAPLA (Approximation) Debug improved SAPLA distance
	template<typename T, typename Y>
	long double get_distance_SAPLA_debug(const vector<T>& const original_time_series_vector_1, const vector<T>& const original_time_series_vector_2, const DoublyLinkedList<Y>& const doubly_linked_list_1, const DoublyLinkedList<Y>& const doubly_linked_list_2);

	template<typename T, typename Y>
	long double get_distance_SAPLA_pub(const vector<T>& const original_time_series_vector_1, const vector<T>& const original_time_series_vector_2, const DoublyLinkedList<Y>& const doubly_linked_list_1, const DoublyLinkedList<Y>& const doubly_linked_list_2);
	/*=============================================================================================================================================================*/
	
	//210901 short segmnt increase right endpoints with  width_difference or merge with next segment. next segment decrease left
	template<typename T, typename Y, typename U, typename T1, typename T2, typename T3>
	void move_merge_short_segment_no_min_width(const T3& const type_representation, const vector<T>& const original_time_series_short_vector, const Y& const width_min, const U& const width_difference, const T1 id_segment_short, DoublyLinkedList<T2>& const doubly_linked_list_short);

	//210901 long segment decrease right endpoint with width_difference, next sement increase left
	template<typename T, typename Y, typename U, typename T1, typename T2, typename T3>
	void move_merge_long_segment_no_min_width(const T3& const type_representation, const vector<T>& const original_time_series_long_vector, const Y& const width_min, const U& const width_difference, const T1 id_segment_long, DoublyLinkedList<T2>& const doubly_linked_list_long);

	//210908 for APCA, elimite one point segment
	template<typename T, typename Y>
	void move_one_point_segment_mo_min_width_average(const vector<T>& const original_time_series_vector, DoublyLinkedList<Y>& const doubly_linked_list);

	//For struct Length 190623
	void getRandomEndpoint(const int& const time_series_length, const int& const endpoint_size, set<int>& const result_endpoint_set);//190623 get random end point

	void getBestEndpoint(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series);//190621 compare all situation, find best result

	/*................................................Get ALL result 190624 store all situation...............................................................*/
	void combinationUtilJumpVector(DataType*& const original_time_series, const vector<int>& const arr, int index, vector<int> data, int i, set<pair<double, vector<int>>>& const endpoint_collection);//190624 No adjacent combination /* arr[] ---> Input Array data[] ---> Temporary array to store current combination start & end ---> Staring and Ending indexes in arr[] index ---> Current index in data[] r ---> Size of a combination to be printed */

	void getAllAPLAResult(DataType*& const original_time_series, const vector<int>& const arr, const int& const r, set<pair<double, vector<int>>>& const endpoint_collection);//190624 // No adjacent combinationThe main function that prints all combinations of size r in arr[] of size n. This function mainly uses combinationUtil()
	/*........................................................................................................................................................*/

	/*------------------------------------------------Get Best APLA result 190626 no store all situation--------------------------------------------------------------------------------------------------*/
	void combinationUtilJumpVector(DataType*& const original_time_series, const vector<int>& const arr, int index, vector<int> data, int i, pair<double, vector<AREA_COEFFICIENT>>& const best_endpoint_pair);//190626 No adjacent combination /* arr[] ---> Input Array data[] ---> Temporary array to store current combination start & end ---> Staring and Ending indexes in arr[] index ---> Current index in data[] r ---> Size of a combination to be printed */

	//200811 use vector time series
	template<typename T, typename Y, typename U>
	void combinationUtilJumpVector(const vector<T>& const original_time_series_vector, const vector<U>& const arr, U index, vector<U> data, U i, pair<long double, vector<Y>>& const best_endpoint_pair);//200811 No adjacent combination /* arr[] ---> Input Array data[] ---> Temporary array to store current combination start & end ---> Staring and Ending indexes in arr[] index ---> Current index in data[] r ---> Size of a combination to be printed */

	void getBestAPLAResult(DataType*& const original_time_series, const vector<int>& const arr, const int& const r, pair<double, vector<AREA_COEFFICIENT>>& const best_endpoint_pair);//190626 // No adjacent combinationThe main function that prints all combinations of size r in arr[] of size n. This function mainly uses combinationUtil()
	
	//200811 uset vector time series
	template<typename T, typename Y, typename U>
	void getBestAPLAResult(const vector<T>& const original_time_series_vector, const vector<U>& const arr, const U& const r, pair<long double, vector<Y>>& const best_endpoint_pair);//190626 // No adjacent combinationThe main function that prints all combinations of size r in arr[] of size n. This function mainly uses combinationUtil()
    /*-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

	/*=========================================================================Failed=====================================================================================================================*/
	void getAPLAArea5LowerBoundSpeedNoErase0(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series);//190606 Failed, cannot speed up when loop from head and tail to middle.
	void getAPLAArea5LowerBoundSpeedNoEraseArray(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series);//190416
	double getLineSegmentTriangleAreaImprove(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient);//190604
	/*=====================================================================================================================================================================================================*/

   /*===================================================   get Deviation   =============================================================================================*/
	void getAPLADeviation(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series);//190115 try compare with deviation

	double getAPLASumDeviaitonNoAB(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector);//190624 get sum_deviation very fast, No a,b

	template<typename T, typename Y>
	long double getAPLASumDeviaitonNoAB(const vector<T>& const original_time_series_vector, vector<Y>& const area_vector);//200811 get sum_deviation very fast, No a,b

	double getAPLASumDeviaiton(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector);//190702 get sum_deviation very fast, already has a&b

	void getAPLASegmentDeviation(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector);//190626 Aleady has a&b, right_endpoint, width, sum_value
	//190826 Linked list
	void getAPLASegmentDeviation(DataType*& const original_time_series, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list);//190826 Aleady has a&b, right_endpoint, width, sum_value

	//200303 Add template & use vector time series. Get segment sun deviation
	template<typename T, typename Y>
	void getAPLASegmentDeviation(const vector<T>& const original_time_series_vector, DoublyLinkedList<Y>& const doubly_linked_list);//190826 Aleady has a&b, right_endpoint, width, sum_value

	//200303 get one segment  (sum difference)^2  //getSegmentSumDifferenceSquare
	template<typename T, typename Y, typename U>
	long double get_segment_difference_square(const vector<T>& const original_time_series_vector, const Y& const temp_coefficient, U& const max_deviation_seg);

	//200303 get sume deviation of apprxomation, No a&b of each segment.  Only know right endpoint and rectangle width
	template<typename T, typename Y>
	long double get_sum_deviation_no_ab(const vector<T>& const original_time_series_vector, const DoublyLinkedList<Y>& const doubly_linked_list);

	//200327 get sume deviation & max deviation of apprxomation, No a&b of each segment.  Only know right endpoint and rectangle width
	template<typename T, typename Y, typename U>
	long double get_sum_deviation_no_ab(const vector<T>& const original_time_series_vector, const DoublyLinkedList<Y>& const doubly_linked_list, U& const result_collection);

	//201005 get sume deviation of apprxomation, No a&b of each segment.  Only know right endpoint and rectangle width
	template<typename T, typename Y>
	long double get_sum_deviation_no_ab(const vector<T>& const original_time_series_vector, const vector<Y>& const approximation_vector);
	//210304
	template<typename T>
	long double get_sum_upper_bound(const DoublyLinkedList<T>& const doubly_linked_list);
	/*===================================================================================================================================================================*/

	/*===================================================   get Reconstruct Time Series  ================================================================================*/

	void getAPLAReconstructSeriesNoAB(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, vector<double>& const reconstruct_time_series);//190625 No a,b, only has endpoint and witdh get reconstruct series vector

	//20303 Use template
	template<typename T, typename Y>
	void getAPLAReconstructSeries(const vector<Y>& const area_vector, vector<T>& const reconstruct_time_series);//190625 Has endpoint, width, a,b. get reconstruct series vector

	//20303 Use template
	template<typename T, typename Y>
	void getAPLAReconstructSeries(const DoublyLinkedList<Y>& const doubly_linked_list, vector<T>& const reconstruct_time_series);//190917 Has endpoint, width, a,b. get reconstruct series vector

	//191230 get reconstruct time series for one time series, not know a&b
	template<typename T>
	void get_PLA_reconstruct_series(const vector<T>& const reconstruct_time_series);

	//200108 get reconstruct time series for one time series
	template<typename T>
	void get_PLA_reconstruct_series(const vector<T>& const original_time_series_vector, vector<T>& const reconstruct_time_series_vector);

	//200206 get econstruct time series, a, b, segment_width for one time series
	template<typename T, typename Y>
	void get_PLA_reconstruct_series(const vector<T>& const original_time_series_vector, Y& const temp_coefficient, vector<T>& const reconstruct_time_series_vector);

	//200205 get part reconstruct time series for part of time series
	template<typename T>
	void get_PLA_part_reconstruct_series(const vector<T>& const original_time_series, const int& const begin_id, const int& const end_id, vector<T>& const part_reconstruct_time_series);

	//200206 get part reconstruct time series, a&b width. for part of time series
	template<typename T, typename Y>
	void get_PLA_part_reconstruct_series(const vector<T>& const original_time_series, const int& const begin_id, const int& const end_id, Y& const temp_coefficient, vector<T>& const part_reconstruct_time_series);

	//200205 get part reconstruct time series for part of time series
	template<typename T, typename Y>
	void get_PLA_reconstruct_series_by_endpoint(const vector<T>& const original_time_series, vector<Y>& const right_endpoint, vector<T>& const reconstruct_time_series);

	//200220 get reconstruction time series for one segemnt, already know a&b and right endpoint
	template<typename T, typename Y>
	void get_PLA_reconstruct_series_by_segment(const vector<T>& const original_time_series_vector, const Y& const temp_coefficient, vector<T>& const reconstruct_time_series);
	/*===================================================================================================================================================================*/

	/*========================================================================Get a&b of one segment=====================================================================================================================*/
	////200110 get a & b of original time series
	//template<typename T>
	//void get_PLA_coefficient(const vector<T>& const original_time_series_vector, const int& const begin_id, const int& const end_id, TOOL::APLA_COEFFICIENT& const pla_coefficient);

	//200110 get a & b of original time series
	template<typename T>
	void get_PLA_coefficient(const vector<T>& const original_time_series_vector, typename TOOL::APLA_COEFFICIENT& const pla_coefficient);

	//200110 get a & b of original time series
	template<typename T>
	typename APLA::APLA_COEFFICIENT get_PLA_coefficient(const vector<T>& const original_time_series_vector);
	/*===================================================================================================================================================================*/

	void getAPLA(const typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector);//181213

	//200302 use template
	template<typename T, typename Y, typename U>
	void getAPLA(const U& const input_argument, T*& const original_time_series, DoublyLinkedList<Y>& const doubly_linked_list);//190917

	void getAPLA(const typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, list<AREA_COEFFICIENT>& const area_vector);//190408

	void getAPLAArray(const typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, SEGMENT_COEFFICIENT*& const area_vector);//190426

	/*=============================================================*/
	//get slope and intercept a&b and sum value
	void getPLAByAdaptiveSegment(const typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector);//190617

	//190821 Linked list to instead vector, get slope and intercept a&b and sum value . No minmax point
	void getPLAByAdaptiveSegment(const typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list);//190821

	//200212  Linked list to instead vector, get slope and intercept a&b and sum value . No minmax point
	//200212 Linked list to instead vector, get slope and intercept a&b and sum value . No minmax point
	template<typename T, typename Y, typename U>
	void getPLAByAdaptiveSegment(const U& const input_argument, const vector<T>& const original_time_series_vector, DoublyLinkedList<Y>& const doubly_linked_list);//200212

	//191031 Linked list to instead vector, get slope and intercept a&b and sum value & minmax point of every segment
	//template<typename T>
	void getPLAByAdaptiveSegmentAndMinMax(const typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list);//191031

	//200212 use vector to instead pointer for time series.Add template
	//191031 Linked list to instead vector, get slope and intercept a&b and sum value & minmax point of every segment
	template<typename T, typename Y, typename U>
	void getPLAByAdaptiveSegmentAndMinMax(const U& const input_argument, const vector<T>& const original_time_series_vector, DoublyLinkedList<Y>& const doubly_linked_list);//191031

	//200212 use vector to instead pointer for time series.Add template
	//200319 Linked list to instead vector, get slope and intercept a&b, triangle density, area difference
	template<typename T, typename Y>
	void get_each_segment_ab_density_difference(const vector<T>& const original_time_series_vector, DoublyLinkedList<Y>& const doubly_linked_list);

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&        Print Segment Coeffcients        &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	void printSpecialPoint(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient);//190517
	void printSpecialPoint0(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient);//190524
	void printSpecialPoint1(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient);//190602

	double computeMagnitude(AREA_COEFFICIENT& const temp_coefficient, double difference);//190521
	double computeDifferenceA(AREA_COEFFICIENT& const temp_coefficient, int level);//190524
	AREA_COEFFICIENT& getMaxMagnitude0(AREA_COEFFICIENT& const temp_coefficient);//190521
	AREA_COEFFICIENT& getMaxMagnitude(AREA_COEFFICIENT& const temp_coefficient);//190521
	bool printMaxMagnitude(const AREA_COEFFICIENT& const temp_coefficient);//190521
	double printReconstructRecursive(const AREA_COEFFICIENT& const temp_coefficient, int  level);//190522

	//200907 print right endpoint, segment width, a&b, increment area, area difference, long segment triangle density
	template<typename T>
	void print_segment_coefficients(const T& const temp_coefficient);
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&        Evaluation & Assertion        &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	void testAChange(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient);//190522
	void testAChange0(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient, int& const left_id, int& const right_id);//190522
	void testAChange1(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient);//190522 max_deviation point in minmax point, endpoint, sub_deviation point
	void draw3Line(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient);
	void testDeviationPointRecursive(AREA_COEFFICIENT& const temp_coefficient, int level, set <int>& deviation_id);//190524
	bool testDeviationPoint(AREA_COEFFICIENT& const temp_coefficient, int level, set <int>& deviation_id);//190524

	/*#################################################################################################################################################*/

	/*######################################################    Assert Linked List  ###################################################################*/
	//190822
	template<typename T>
	bool compareLinkListAndVector(DoublyLinkedList<T>& const doubly_linked_list, vector<T>& const area_vector);

	//210301
	template<typename T>
	inline bool assert_adjacent_nodes(const DoublyListNode<T>& const node);

	//210301
	template<typename T>
	inline bool assert_adjacent_nodes_endpoint(const DoublyListNode<T>& const node);

	//191101 assert segment & sub segment: non INF, right endpoint, width, minmax point,, a&b
	template<typename T, typename Y>
	bool assertLinkedListAndSubLinkedList(const vector<T>& const original_time_series_vector, const DoublyLinkedList<Y>& const doubly_linked_list);
	// 191101 assert segment: non INF, right endpoint, width, minmax point,, a&b
	template<typename T>
	bool assertLinkedList(const DoublyLinkedList<T>& const doubly_linked_list);

	// 201004 assert segment: non INF, right endpoint, width, minmax point, a&b, sub right endpoint
	template<typename T, typename Y>
	bool assertLinkedList(const vector<T>& const original_time_series_vector, const DoublyLinkedList<Y>& const doubly_linked_list);

	// 191101 assert segment right endpoint, width
	template<typename T>
	bool assertRightEndpoint_Width(const DoublyLinkedList<T>& const doubly_linked_list) const;
	/*######################################################       Assert a&b          ################################################################*/
	template<typename T, typename Y>//210831
	bool assert_endpoint_a_b(const vector<T>& const original_time_series_vector, const DoublyLinkedList<Y>& const doubly_linked_list);

	template<typename T>
	inline bool assert_segment_apla_coefficient(const T& const temp_coefficient);

	// 200214 assert a & b of  one  segment
	template<typename T>
	inline bool assert_segment_a_b(const T& const temp_coefficient) const;

	//200512 assert a&b of one segment with time series
	template<typename T, typename Y>
	inline bool assert_segment_a_b(const vector<T>& const original_time_series_vector, const Y& const temp_coefficient);

	// 191108 assert a & b of every segment
	template<typename T, typename Y>
	bool assert_a_b(const vector<T>& const original_time_series_vector, const DoublyLinkedList<Y>& const doubly_linked_list);

	//210901 two segments have same left endpoint
	template<typename T, typename Y>
	inline bool assert_segment_same_left_endpoint(const T& const segment_1, const Y& const segment_2);

	// 210901 assert each rectangle width >= min width
	template<typename T, typename Y>
	bool assert_list_min_width(const T& const segment_1, const DoublyLinkedList<Y>& const doubly_linked_list);

	// 200320 assert compare a & b of two segments
	template<typename T>
	inline bool assert_two_segments_a_b(const T& const segment1, const T& const segment2) const;

	// 200713 assert a & b of two segments is equal
	template<typename T>
	inline bool assert_equal_a_b(const T& const segment1, const T& const segment2) const;
	/*#################################################################################################################################################*/

	// 200712 whether a&b of two segments are same
	template<typename T>
	inline bool if_equal_ab(const T& const segment1, const T& const segment2) const;
	
	// 200721 a1-a2<MIN_D && b1-b2<MIN_D
	template<typename T>
	inline const bool if_similar_ab_two_segments(const T& const segment1, const T& const segment2) const;

	/*############################################          Assert Split coefficients       ###########################################################*/
	// test loop linked list
	template<typename T>
	void evaluate_linkedlist_for_loop(const DoublyLinkedList<T>& const doubly_linked_list);

	//191211 evaluate linked list right endpoint, width, right height difference
	template<typename T>
	void assert_linkedlist_rightEndpoint_Width_rightHeightDifference(const typename TOOL::INPUT_ARGUMENT& const input_argument, const DoublyLinkedList<T>& const doubly_linked_list);

	//191211 evaluate linked list right endpoint, width, right height difference
	template<typename T>
	void assert_split_coefficients(const T& const temp_coefficient);

	//200311 evaluate structure split coefficients, sub left & right, segment density. magnitude
	template<typename T>
	void assert_structure_split_coefficients(const T& const split_coeffcients);
	/*#################################################################################################################################################*/
	/*#############################################          Assert Min&Max Point        ##############################################################*/
	// 191108 assert min max point of one segment
	template<typename T>
	bool assert_segment_minmax(const T& const segment) const;

	// 200512 assert min max point of one segment
	template<typename T, typename Y>
	inline bool assert_segment_minmax(const vector<T>& const original_time_series_vector, const Y& const temp_coefficient) const;

	//200313 assert min&max value
	template<typename T, typename Y>
	void assert_minmax_value(const vector<T>& const original_time_series_vector, const DoublyLinkedList<Y>& const doubly_linked_list);
	/*#################################################################################################################################################*/

	/*############################################    Assert a&b, min&max point of segment   ##########################################################*/
	// 200527 assert min&max, a&b of one segment
	template<typename T, typename Y>
	inline void assert_segment_a_b_minmax(const vector<T>& const original_time_series_vector, const Y& const temp_coefficient);
	/*#################################################################################################################################################*/

	/*########################################    Segment Density & Area Difference of Segment  #######################################################*/
	// 200825 assert loop about density & area difference in each segment
	template<typename T, typename Y, typename U>
	bool assert_loop_segment_density_area_difference(const DoublyLinkedList<T>& const doubly_linked_list, const multimap<U, Y, std::greater<U>>& const multi_map_1, const multimap<U, Y, std::greater<U>>& const multi_map_2);
	/*#################################################################################################################################################*/

	/*########################################             Evaluate Split Segment MAP           #######################################################*/
	// 201102 Assert Split MAP
	template<typename T>
	bool assert_split_map_area_difference(const T& const split_map);

	// 201227 Assert Split MAP
	template<typename T>
	bool assert_split_map_optimization(const T& const split_map);
	/*#################################################################################################################################################*/

	/*########################################            Evaluate Merge Segment MAP            ##############################################*/
	// 210123 Assert Merge MAP
	template<typename T>
	bool assert_merge_map_triangle_density(const T& const merge_map);
	/*########################################################################################################################################*/

	/*#########################################            Assert partition 210618            ################################################*/
	template<typename T, typename Y>//210830 two segment has same value
	inline bool assert_segment_equal(const T& const segment_1, const Y& const segment_2);

	//210622 2 SAPLA has same right endpoints
	template<typename T>
	bool assert_has_same_endpoints(const DoublyLinkedList<T>& const doubly_linked_list_1, const DoublyLinkedList<T>& const doubly_linked_list_2);
	/*########################################################################################################################################*/

	//***************************************************************
	// Method:evaluate_accuracy_time_split_point
	// Qualifier:  Evaluate split point comparison: min density, binary, direct intersection and best split method
	// Input:
	// Output: accuracy & time of 4 split point finding methods
	// notice:
	// date:200219
	// author:
	//***************************************************************
	template<typename T, typename Y>
	void evaluate_accuracy_time_split_point(const vector<T>& const original_time_series_vector, const Y& const temp_coefficient, const double& const split_id_min_density, const double& const split_time_min_density);
	
	//201028 evaluate 1 upper & lower bound: max devation * l > sum deviation > lower bound deviation, 2 The probablity of left&right, min&max point is max deviation poiont
	template<typename T, typename Y, typename U>
	bool evaluate_segment_upper_lower_bound(U& const input_argument, const vector<T>& const original_time_series_vector, const Y& const temp_coefficient);

	//201023 evaluate 1 upper & lower bound: max devation * l > sum deviation > lower bound deviation, 2 The probablity of left&right, min&max point is max deviation poiont
	template<typename T, typename Y, typename U>
	bool evaluate_upper_lower_bound(U& const input_argument, const vector<T>& const original_time_series_vector, const DoublyLinkedList<Y>& const doubly_linked_list);
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	//void computeDft(const vector<double> &inreal, const vector<double> &inimag, vector<double> &outreal, vector<double> &outimag);
	//void computeDft(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType original_time_series[], DataType*& dft_time_series);

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&                   Compute intersection point of                         &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	inline typename GEOMETRY::POINT& getIntersectionPoint(const AREA_COEFFICIENT& const temp_coefficient1, const AREA_COEFFICIENT& const temp_coefficient2, typename GEOMETRY::POINT& const intersection_point);//190527
	inline typename GEOMETRY::POINT& getIntersectionPoint(const APLA_COEFFICIENT& const apla1, const APLA_COEFFICIENT& const apla2, typename GEOMETRY::POINT& const intersection_point);//190528
	inline typename GEOMETRY::POINT& getIntersectionPoint(const double& const a1, const double& const b1, const double& const a2, const double& const b2, typename GEOMETRY::POINT& const intersection_point);//190528
	inline typename GEOMETRY::POINT& segmentsIntr(typename  GEOMETRY::POINT& const point1, typename GEOMETRY::POINT& const point2, typename  GEOMETRY::POINT& const point3, typename GEOMETRY::POINT& const point4, typename GEOMETRY::POINT& const intersection_point);//190528
	inline typename GEOMETRY::POINT& segmentsIntrArea(typename  GEOMETRY::POINT& const point1, typename GEOMETRY::POINT& const point2, typename  GEOMETRY::POINT& const point3, typename GEOMETRY::POINT& const point4, typename GEOMETRY::POINT& const intersection_point);//190528 //
	
    //210509
	template<typename T>
	inline void segmentsIntrArea_pub(const T& const point1, const T& const point2, const T& const point3, const T& const point4, T& const intersection_point);

	inline typename GEOMETRY::POINT& getLineSegmentIntersectionPoint(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient, typename GEOMETRY::POINT& const intersection_point1, typename GEOMETRY::POINT& const intersection_point2);//190528
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&   Triangle reconstruction Area &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	
	//210509
	template<typename T>
	inline long double get_abs_area_triangle(const T& const point1, const T& const point2, const T& const point3);
	
	double getLineSegmentTriangleArea(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient);//190528
	//double getLineSegmentLeftArea(typename  GEOMETRY::POINT& const up_point, typename  GEOMETRY::POINT& const down_point, typename  GEOMETRY::POINT& const intersection_point);//190604
	//double getLineSegmentRightArea(typename  GEOMETRY::POINT& const intersection_point, typename  GEOMETRY::POINT& const up_point, typename  GEOMETRY::POINT& const down_point);//190604

	inline double getLineSegmentTriangleDensity(AREA_COEFFICIENT& const temp_coefficient);//190602

	double getLineSegmentTriangleAreaDensity(vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient);//190611
	//190826 Use linkned list to instead vector
	double getLineSegmentTriangleAreaDensity(DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient);//190826

	//190905 Use linkned list to instead vector
	inline double& getLineSegmentTriangleAreaDensity(int nothing, const AREA_COEFFICIENT& const left_segment, const AREA_COEFFICIENT& const right_segment, AREA_COEFFICIENT& const merged_segment);//190905

	//200206 get density of triangle area
	template<typename T, typename Y>
	inline double getLineSegmentTriangleAreaDensity(const T& const left_segment, const  T& const right_segment, Y& const merged_segment);

	//211007 get segment triangle area. If area > 0, segment 0 is top, segment 1 is down, else converse
	template<typename T, typename Y>
	inline long double get_segment_top_down_area_difference(const T& const segment_0, const Y& const segment_1);

	//211007 get list triangle area. If area > 0, list 0 is top, list 1 is down, else converse
	template<typename T, typename Y>
	long double get_top_down_area_difference(const DoublyLinkedList<T>& const doubly_linked_list_0, const DoublyLinkedList<Y>& const doubly_linked_list_1);

	//211012 get list triangle area. If area > 0, list 0 is top, list 1 is down, else converse
	template<typename T, typename Y>
	void get_convex_top(const T& const segment_candidate, DoublyLinkedList<Y>& const doubly_linked_list);

	//200728 get density of triangle area from current segment & accumulates segment
	template<typename T>
	inline long double get_triangle_density_by_accumulate_segment(T& const current_segment, const T& const accumulate_segment);

	//210509 get triangle area by line A1A2 and B1B2, they have same length
	template<typename T>
	inline long double get_triangle_area(const T& const segment_1, const T& const segment_2);

	//210509 get triangle area by line A1A2 and B1B2, they have same length
	template<typename T>
	inline long double get_triangle_area_pub(const T& const segment_1, const T& const segment_2);

	//201007 get triangle area by line A1A2 and B1B2
	template<typename T, typename Y>
	inline long double get_triangle_area_by_points(T& const current_segment, const Y& const B1_y, const Y& const B2_y);

	//210509 get triangle area by line A1A2 and B1B2
	template<typename T, typename Y>
	inline long double get_triangle_area_by_points_pub(T& const current_segment, const Y& const B1_y, const Y& const B2_y);
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!       210113 compute upper bound      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	//200206 get endpoint of long segment and two short segments, and comput height difference between them
	template<typename T>
	inline long double get_line_segment_height_diference(const T& const left_segment, const  T& const right_segment, const T& const merged_segment);

	/*+++++++++++++++++++++++++++++++++++++++         upper bound         ++++++++++++++++++++++++++++++++++++++++++++*/
	//210111 get endpoint of accumulate segment and current segment, and comput height difference between them.(whether bigger than max deviation, search upper bound)
	template<typename T, typename Y, typename U>
	inline long double get_line_segment_height_diference_from_accumulate(const vector<Y>& const original_time_series_vector, T& const current_segment, T& const accumulate_segment, U& const output_argument);

	//210113 get upper bound of sub left & right segment after splitting
	template<typename T, typename Y, typename U>
	inline void get_upper_bound_sub_segment_left_right(const vector<Y>& const original_time_series_vector, T& const left_segment, T& const right_segment, const T& const merged_segment, U& const output_argument);

	//200206 get endpoint of long segment and two short segments, compute height difference with original time series
	template<typename T, typename Y, typename U>
	inline long double get_line_segment_height_diference_with_original(const vector<Y>& const original_time_series_vector, const T& const left_segment, const  T& const right_segment, T& const merged_segment, U& const output_argument);
	
	//210114 After optimization. get upper bound when increase/decrease, left/right endpoint
	template<typename T, typename Y, typename U>
	inline long double get_upper_bound_move_endpoint(const vector<Y>& const original_time_series_vector, const T& const segment_original, T& const segment_move, U& const output_argument);
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	
	/*----------------------------   Cound Upper Bound  ----------------------------------------*/
	//210121
	template<typename T, typename Y>
	inline void count_upper_bound_type(const T upper_bound_type, Y& const map_upper_bound);

	//210122
	template<typename T, typename Y>
	void merge_map_with_same_key(const T& const map_target, Y& const map_result);

	//210121
	template<typename T, typename Y>
	inline void count_upper_bound_whole(const T& const output_argument, Y& const evaluation_bound_whole);

	//210122
	template<typename T>
	void print_count_of_upper_bound(const T& const evaluation_bound);
	/*-----------------------------------------------------------------------------------------*/

	/*--------------------   210126  get point id of upper bound    ---------------------------*/
	//210126
	template<typename T, typename Y>
	inline void get_current_max_id(const T& const map_result, Y& const temp_coefficient);
	/*-----------------------------------------------------------------------------------------*/

	/*------------------------   210115 Assert upper bound   ----------------------------------*/
	//210115 Not INF
	template<typename T>
	inline bool assert_segment_bound(const T& const temp_coefficient);
	//210115
	template<typename T, typename Y>
	inline bool assert_segment_bound(const vector<Y>& const original_time_series_vector, const T& const temp_coefficient);

	//210115
	template<typename T, typename Y>
	inline bool assert_bound(const vector<Y>& const original_time_series_vector, const DoublyLinkedList<T>& const doubly_linked_list);

	/*-----------------------------------------------------------------------------------------*/
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&                Area Difference                &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	// 190724
	// Input a&b, min max point, widht, right endpoint
	// Output PLA, minmax width area difference
	inline double& getPLAMinMaxAreaDifference(vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient);//190724

	// 190826
	// Input a&b, min max point, widht, right endpoint
	// Output PLA, minmax width area difference
	double& getPLAMinMaxAreaDifference(DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient);//190826

	// 190905
	// Input a&b, min max point, widht, right endpoint
	// Output PLA, minmax width area difference
	double& getPLAMinMaxAreaDifference(const AREA_COEFFICIENT& const left_segment, const AREA_COEFFICIENT& const right_segment, AREA_COEFFICIENT& const merged_segment);//190905
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/


	double get3SubSegment2PointsABArea(vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient);//190628 get a b of sub segment in 2 endpoints and middle.

	template<typename T>
	void getPLALineRectangleAreaDensity(vector<T>& const area_vector);//190627 Already know a&b right_endpoint and width

	template<typename T>
	void getPLALineRectangleAreaDensity(DoublyLinkedList<T>& const doubly_linked_list);//190826 Already know a&b right_endpoint and width

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&      get Min&Max Value Height           &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	//200419 scan segment to get min & max value height
	template<typename T, typename Y>
	long double get_segment_minmax_height(const vector<T>& const original_time_series_vector, Y& const temp_coefficient);
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&          get Min&Max point           &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	//200519 initialize min&max point of segmnet = INF
	template<typename T>
	inline void initialize_segment_minmax(T& const temp_coefficient);

	//200422 get min&max point of one point segment
	template<typename T, typename Y>
	inline void get_segment_one_point_minmax(const T& const point_value, Y& const temp_coefficient);

	//200422 get min&max point of two points segment
	template<typename T, typename Y>
	inline void get_segment_two_point_minmax(const vector<T>& const original_time_series_vector, Y& const temp_coefficient);

	//200714 get min&max point of two points segment
	template<typename T, typename Y>
	inline void get_segment_two_point_minmax(const T& const left_value, const T& const right_value, Y& const temp_coefficient);

	//200422 get and verify min&max point of long segment
	template<typename T, typename Y, typename U>
	inline void get_segment_minmax_point(const T& const point_id, const Y& const point_value, U& const temp_coefficient);

	//scan to get minmax point of segment
	void getSegmentMinMaxPoint(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient);//190701

	//200212 scan segment. time series from pointer to vector, Addd template
	template<typename T, typename Y>
	void getSegmentMinMaxPoint(const vector<T>& const original_time_series_vector, Y& const temp_coefficient);

	//200714 get accumulated segment minmaxpoint by last short segment minmax point
	template<typename T, typename Y>
	inline void get_minmax_segment_by_accumulation(const T& const end_point_value,const Y& const short_segment, Y& const temp_coefficient);

	//200731 get accumulated segment minmaxpoint by accumulate endpoint value
	template<typename T, typename Y>
	inline void get_minmax_segment_by_accumulation(const T& const end_point_value, Y& const accumulate_segment);

	//200506 Get min&max point of long segment from left & right short segments
	template<typename T>
	inline void get_long_segment_minmax_by_sub_segments(const T& const sub_left_segment, const T& const sub_right_segment, T& const long_segment);

	//191031
	//Input: oritinal time series. sub left right: 1 right enpoint, 2 width. Long segment: 1 right endpoint, 2 width, 3 min&max point
	//Output: sub left right: min&max point 
	void getSubMinMaxPoint(DataType*& const original_time_series, AREA_COEFFICIENT& const left_segment, AREA_COEFFICIENT& const right_segment, const AREA_COEFFICIENT& const merged_segment);

	//200213 use vector to instead pointer for time series
	//Input: oritinal time series vector. sub left right: 1 right enpoint, 2 width. Long segment: 1 right endpoint, 2 width, 3 min&max point
	//Output: sub left right: min&max point 
	template<typename T, typename Y>
	void getSubMinMaxPoint(const vector<T>& const original_time_series_vector, Y& const left_segment, Y& const right_segment, const Y& const merged_segment);
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	void getSegmentADifference(vector<AREA_COEFFICIENT>& const area_vector);//190627 Get difference of left and right endpoint a, already know a&b

	/*-------------------------------------------------------------------------------------------*/
	void countBreakPoint(vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, vector<int>& const count_break_point_vector);//190613
	/*-------------------------------------------------------------------------------------------*/

	/*====================================================200128 Write Result===================================================================================================*/
	//***************************************************************
	// Method:write_reconstruct_time_series
	// Qualifier:  
	// Input: File name, segment coefficenst
	// Output: write reconstruct time series to file
	// date:200128
	// author:
	//***************************************************************
	template<typename T>
	void write_reconstruct_time_series(const string& const file_name, const DoublyLinkedList<T>& const doubly_linked_list);
	//***************************************************************
	// Method:write_segment_point
	// Qualifier:  
	// Input:File name, segment coefficenst
	// Output: write segment points to file
	// date:200128
	// author:
	//***************************************************************
	template<typename T>
	void write_segment_point(const string& const file_name, const DoublyLinkedList<T>& const doubly_linked_list);
	/*==========================================================================================================================================================================*/
};

//#include "CAPLA.cpp"
///////********APLA*********///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//************************************
// Stuct:POINT
// Qualifier:
// date:181112
// author:
//************************************
TEMPLATE
struct APLA::POINT {
	long double id = INF;
	long double value = INF;
	//GEOMETRY::POINT* center;

	POINT(long double x, long double y) : id(x), value(y) {}
	POINT() : id(INF), value(INF) {}

	~POINT() {
		id = INF;
		value = INF;
	}
};

//************************************
// Stuct:BREAK_POINT_COEFFICIENT
// Qualifier:
// date:181112
// author:
//************************************
TEMPLATE
struct APLA::BREAK_POINT_COEFFICIENT {
	int array_length = NULL;//

	double* point_width = nullptr; //The breadth of wave;
	double* point_height = nullptr; //The breadth of wave;
	//double* point_coefficient = nullptr;

	~BREAK_POINT_COEFFICIENT() {
		array_length = NULL;

		if (point_width != nullptr) {
			delete[] point_width;
			point_width = nullptr;
		}

		if (point_height != nullptr) {
			delete[] point_height;
			point_height = nullptr;
		}
	}
};

//************************************
// Stuct:BREAK_POINT_MAGNITUDE
// Qualifier:
// date:181112
// author:
//************************************
TEMPLATE
struct APLA::BREAK_POINT_MAGNITUDE {
	double break_point_id = NULL; //The breadth of wave;
	double break_point_magnitude = NULL; //The breadth of wave;
	//double* point_coefficient = nullptr;

	~BREAK_POINT_MAGNITUDE() {
		break_point_id = NULL; //The breadth of wave;
		break_point_magnitude = NULL; //The breadth of wave;
	}
};

//************************************
// Stuct:AREA_COEFFICIENT
// Qualifier:
// date:181119
// author:
//************************************
TEMPLATE
struct APLA::AREA_COEFFICIENT {
public:
	double right_endpoint = INF; //The right end point of segment;

	//double heightest_id = INF; //id of heightest point
	//double lowest_id = INF;   // id of lowest point
	//double heightest_value = INF; //The heightest value of point;
	//double lowest_value = INF; //The lowest value of point;


	double rectangle_height = INF; // difference between heightest value and lowest value.

	double rectangle_width = INF; //width of rectangle
	double minmax_distance = INF; //x axis distance between minimum and maximum points

	/*======================Area====================*/
	double rectangle_area = INF; //area of rectangle
	double real_area = INF; //181217 true rectangle area / total rectangle area
	double minmax_width_area = INF; //190701 minmax_height * segment_width
	double minmax_distance_area = INF; //190701 minmax_height * minmax_distance
	/*=============================================*/

	//200302 speed
	//double merged_percentage = INF; // current rectangle area / new rectangle area

	int merge_count = INF;//181218 count how many times this rectangle merged
	double segment_density = INF;//181218 real_area/rectangle_area;
	double rectangle_density = INF;//190627
	double rec_deviation = INF;//181218 For every reconstructed APLA segment, get deviation
	double sum_difference = INF;//190523 point difference between original point and PLA line

	double parallelogram_height = INF;//190114
	double circle_radius = INF;//90315

	double sum_value = INF;//190412

	double increment_area = INF;//190602 when left sub segment & right sub segment merge to long segment, the area between long segment PLA and left & right sub segment.

	/*=================Area difference======================*/
	long double area_difference = INF;//190724 min max point width area - PLA area
	double area_difference_density = INF;//190724 Difference / width
	/*======================================================*/

	GEOMETRY::POINT max_point;
	GEOMETRY::POINT min_point;
	//200302 speed
	GEOMETRY::POINT deviation_point;//190118

	/*====================Y projection================================*/
	GEOMETRY::POINT segment_left_point;//190728 y-projection method
	GEOMETRY::POINT segment_right_point;
	bool is_flat = false;
	double segment_right_height_difference = INF;//191209
	Y_AXIS_COEFFICIENT y_projection_coefficient;//190729
	/*================================================================*/

	inline double getSegmentDensity();//190312
	inline double getSegmentDensitySpeed();//190405

	bool compareSegmentCoefficient(const AREA_COEFFICIENT& const compared_segment);//190318

	APLA_COEFFICIENT apla;

	/*====================Test==========================*/
	//200302 speed
	//AREA_COEFFICIENT* left_subsegment = nullptr;

	AREA_COEFFICIENT* right_subsegment = nullptr;

	bool already_compute = false;
	/*...............................................*/
	double segment_magnitude = 0;//190520 +=a-sub_a
	/*...............................................*/

	UPPER_BOUND_COEFFICIENT<long double> bound;//210113 upper bound
	/*=================================================*/

	/*!!!!200413 Instead Area Difference, Absolute sum of y value difference !!!!*/
	long double sum_difference_absolute = INF;//200413
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	AREA_COEFFICIENT() {
		right_endpoint = INF; //The right end point of segment;

		//heightest_id = INF; //id of heightest point
		//lowest_id = INF;   // id of lowest point
		//heightest_value = INF; //The heightest value of point;
		//lowest_value = INF; //The lowest value of point;

		rectangle_height = INF; // difference between heightest value and lowest value.
		rectangle_width = INF; //width of rectangle
		minmax_distance = INF; //x axis distance between minimum and maximum points
		rectangle_area = INF; //area of rectangle
		real_area = INF;
		minmax_width_area = INF;
		minmax_distance_area = INF;

		/*max_point.~POINT();
		min_point.~POINT();
		deviation_point.~POINT();
		apla.~APLA_COEFFICIENT();*/
		//segment_left_point.POINT();//190728 Y axis projection
		//segment_right_point.POINT();
		//y_projection_coefficient.Y_AXIS_COEFFICIENT();

		merge_count = INF;
		segment_density = INF;
		rectangle_density = INF;//190627
		rec_deviation = INF;
		sum_difference = INF;

		parallelogram_height = INF;
		circle_radius = INF;//190315

		sum_value = INF;//190412
		increment_area = INF;//190602

		/*==========Area difference======================*/
		area_difference = INF;//190724 min max point width area - PLA area
		area_difference_density = INF;//190724 Difference / width
		/*....................................*/

		/*==================Test==========================*/
		//left_subsegment = nullptr;

		right_subsegment = nullptr;
		already_compute = false;
		/*===============================================*/

		/*!!!!200413 Instead Area Difference, Absolute sum of y value difference !!!!*/
		sum_difference_absolute = INF;//200413
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	}
	//
	~AREA_COEFFICIENT() {
		right_endpoint = INF; //The right end point of segment;

		//heightest_id = INF; //id of heightest point
		//lowest_id = INF;   // id of lowest point
		//heightest_value = INF; //The heightest value of point;
		//lowest_value = INF; //The lowest value of point;

		rectangle_height = INF; // difference between heightest value and lowest value.
		rectangle_width = INF; //width of rectangle
		minmax_distance = INF; //x axis distance between minimum and maximum points
		rectangle_area = INF; //area of rectangle
		real_area = INF;
		minmax_width_area = INF;
		minmax_distance_area = INF;

		max_point.~POINT();
		min_point.~POINT();
		deviation_point.~POINT();

		apla.~APLA_COEFFICIENT();

		/*====================Y projection================================*/
		segment_left_point.~POINT();//190728 Y axis projection
		segment_right_point.~POINT();
		//y_projection_coefficient.~Y_AXIS_COEFFICIENT();//190729
		is_flat = false;
		segment_right_height_difference = INF;//191209
		/*=================================================================*/

		merge_count = INF;
		segment_density = INF;
		rectangle_density = INF;//190627
		rec_deviation = INF;
		sum_difference = INF;

		parallelogram_height = INF;
		circle_radius = INF;//190315

		sum_value = INF;//190412
		increment_area = INF;//190602

		/*==========Area difference======================*/
		area_difference = INF;//190724 min max point width area - PLA area
		area_difference_density = INF;//190724 Difference / width
		/*....................................*/

		/*==================Test==========================*/
	/*	if (left_subsegment!=nullptr) {
			delete left_subsegment;
			left_subsegment = nullptr;
		}
		if (right_subsegment != nullptr) {
			delete right_subsegment;
			right_subsegment = nullptr;
		}*/
		already_compute = false;
		/*===============================================*/

		/*!!!!200413 Instead Area Difference, Absolute sum of y value difference !!!!*/
		sum_difference_absolute = INF;//200413
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	}
};

//************************************
// Stuct:AREA_COEFFICIENT_SPEED
// Qualifier: Only contain necessary coefficients, delete redundant variable
// date:200305
// author:
//************************************
TEMPLATE
struct APLA::AREA_COEFFICIENT_SPEED {
public:
	double right_endpoint = INF; //The right end point of segment;
	double rectangle_width = INF; //width of rectangle
	//double sum_value = INF;
	long double segment_density = INF;//181218 real_area/rectangle_area;
	APLA_COEFFICIENT apla;//a & b

	/*!!!!    210203 min&max point y value: standard of which segment to split    !!!!*/
	GEOMETRY::POINT max_point;
	GEOMETRY::POINT min_point;
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	long double area_difference = INF;//190724 min max point width area - PLA area

	/*!!!!!!!!!!!         Y projection     !!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	bool is_flat = false;
	long double segment_right_height_difference = -INF;//191209
	//Y_AXIS_COEFFICIENT y_projection_coefficient;//190729
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	AREA_COEFFICIENT_SPEED* right_subsegment = nullptr;

	/*!!!!!!  200413 Instead Area Difference, Absolute sum of y value difference !!!!!*/
	//long double sum_difference_absolute = INF;//200413
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*--------------------------------------------------------------------------------*/
	OPTIMIZATION_COEFFICIENT<long double> optimization_coefficient;//200915 optimization coefficients
	/*--------------------------------------------------------------------------------*/

	UPPER_BOUND_COEFFICIENT<long double> bound;//210113 upper bound

	bool is_split = false;
	bool is_merge = false;

	AREA_COEFFICIENT_SPEED() {
		right_endpoint = INF; //The right end point of segment;
		rectangle_width = INF; //width of rectangle
		//sum_value = INF;
		segment_density = INF;
		area_difference = INF;//190724 min max point width area - PLA area

		right_subsegment = nullptr;

		is_split = false;
		is_merge = false;

		/*!!!!200413 Instead Area Difference, Absolute sum of y value difference !!!!*/
		//sum_difference_absolute = INF;//200413
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	}
	~AREA_COEFFICIENT_SPEED() {
		right_endpoint = INF; //The right end point of segment;
		rectangle_width = INF; //width of rectangle
		//sum_value = INF;
		segment_density = INF;
		apla.~APLA_COEFFICIENT();

		/*!!!!    200419 min&max point y value: standard of which segment to split    !!!!*/
		max_point.~POINT();
		min_point.~POINT();
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

		/*!!!!!!!!!!!!!!!!!!!!Y projection!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		//y_projection_coefficient.~Y_AXIS_COEFFICIENT();//190729
		is_flat = false;
		segment_right_height_difference = INF;//191209
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

		/*!!!!200413 Instead Area Difference, Absolute sum of y value difference !!!!*/
		//sum_difference_absolute = INF;//200413
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

		/*--------------------------------------------------------------------------------*/
		optimization_coefficient.~OPTIMIZATION_COEFFICIENT();
		/*--------------------------------------------------------------------------------*/

		bound.~UPPER_BOUND_COEFFICIENT();

		is_split = false;
		is_merge = false;
	}
};

//************************************
// Stuct:AREA_COEFFICIENT_SPEED_NO_MINMAX
// Qualifier: No min max point
// date:210203
// author:
//************************************
TEMPLATE
struct APLA::AREA_COEFFICIENT_SPEED_NO_MINMAX {
public:
	double right_endpoint = INF; //The right end point of segment;
	double rectangle_width = INF; //width of rectangle
	//double sum_value = INF;
	long double segment_density = INF;//181218 real_area/rectangle_area;
	APLA_COEFFICIENT apla;//a & b

	/*!!!!    210203 min&max point y value: standard of which segment to split    !!!!*/
	//GEOMETRY::POINT max_point;
	//GEOMETRY::POINT min_point;
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	long double area_difference = INF;//190724 min max point width area - PLA area

	/*!!!!!!!!!!!         Y projection     !!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	bool is_flat = false;
	long double segment_right_height_difference = -INF;//191209
	//Y_AXIS_COEFFICIENT y_projection_coefficient;//190729
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	AREA_COEFFICIENT_SPEED_NO_MINMAX* right_subsegment = nullptr;

	/*!!!!!!  200413 Instead Area Difference, Absolute sum of y value difference !!!!!*/
	//long double sum_difference_absolute = INF;//200413
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*--------------------------------------------------------------------------------*/
	OPTIMIZATION_COEFFICIENT<long double> optimization_coefficient;//200915 optimization coefficients
	/*--------------------------------------------------------------------------------*/

	UPPER_BOUND_COEFFICIENT<long double> bound;//210113 upper bound

	bool is_merge = false;
	bool is_split = false;

	AREA_COEFFICIENT_SPEED_NO_MINMAX() {
		right_endpoint = INF; //The right end point of segment;
		rectangle_width = INF; //width of rectangle
		//sum_value = INF;
		segment_density = INF;
		area_difference = INF;//190724 min max point width area - PLA area

		right_subsegment = nullptr;

		is_merge = false;
		is_split = false;

		/*!!!!200413 Instead Area Difference, Absolute sum of y value difference !!!!*/
		//sum_difference_absolute = INF;//200413
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	}
	~AREA_COEFFICIENT_SPEED_NO_MINMAX() {
		right_endpoint = INF; //The right end point of segment;
		rectangle_width = INF; //width of rectangle
		//sum_value = INF;
		segment_density = INF;
		apla.~APLA_COEFFICIENT();

		/*!!!!    200419 min&max point y value: standard of which segment to split    !!!!*/
		//max_point.~POINT();
		//min_point.~POINT();
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

		/*!!!!!!!!!!!!!!!!!!!!Y projection!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		//y_projection_coefficient.~Y_AXIS_COEFFICIENT();//190729
		is_flat = false;
		segment_right_height_difference = INF;//191209
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

		is_merge = false;
		is_split = false;

		/*!!!!200413 Instead Area Difference, Absolute sum of y value difference !!!!*/
		//sum_difference_absolute = INF;//200413
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

		/*--------------------------------------------------------------------------------*/
		optimization_coefficient.~OPTIMIZATION_COEFFICIENT();
		/*--------------------------------------------------------------------------------*/

		bound.~UPPER_BOUND_COEFFICIENT();
	}
};

//210618 Rtree cover convex hull
TEMPLATE
template<typename T, typename Y>
struct APLA::AREA_COEFFICIENT_RTREE_NODE {
public:

	T right_endpoint = INF; //The right end point of segment;
	Y rectangle_width = INF; //width of rectangle

	APLA::APLA_COEFFICIENT apla;//a & b

	AREA_COEFFICIENT_RTREE_NODE() {
		right_endpoint = INF;
		rectangle_width = INF;
	}
	~AREA_COEFFICIENT_RTREE_NODE() {
		//right_endpoint = INF; //The right end point of segment;
		//apla.~APLA_COEFFICIENT();
	}
};

//************************************
// Stuct:AREA_COEFFICIENT_CONCISE
// Qualifier: Only contain necessary coefficients
// date:200210
// author:
//************************************
TEMPLATE
struct APLA::AREA_COEFFICIENT_CONCISE {
public:
	int right_endpoint = INF; //The right end point of segment;
	double rectangle_width = INF; //width of rectangle
	//double sum_value = INF;
	long double segment_density = INF;//181218 real_area/rectangle_area;

	APLA_COEFFICIENT apla;//a & b

	AREA_COEFFICIENT_CONCISE() {
		right_endpoint = INF; //The right end point of segment;
		rectangle_width = INF; //width of rectangle
		//sum_value = INF;
		segment_density = INF;
	}
	~AREA_COEFFICIENT_CONCISE() {
		right_endpoint = INF; //The right end point of segment;
		rectangle_width = INF; //width of rectangle
		//sum_value = INF;
		segment_density = INF;
		apla.~APLA_COEFFICIENT();
	}
};

/*----------- Members of struct Point ------------*/

//************************************
// Stuct function: getSegmentDensity
// Qualifier: Get density of segment. the number of points in area.
// date:190312
// author:
//************************************
TEMPLATE
inline double APLA::AREA_COEFFICIENT::getSegmentDensity() {//190312
#ifdef _DEBUG
	assert(rectangle_area >= 0);
	assert(rectangle_width != INF);
	if (rectangle_height < parallelogram_height && parallelogram_height != INF) {
		assert(rectangle_area == rectangle_width * parallelogram_height);
	}
	else if (parallelogram_height == INF && rectangle_height != INF) {
		//cout << rectangle_area << endl;
		//assert(rectangle_area != INF);
	}
	else {
		//assert(rectangle_area != INF);
	}
#endif

	//return parallelogram_height;

	return segment_density = rectangle_area == 0 ? rectangle_width : rectangle_width / rectangle_area;
}

//************************************
// Stuct function: getSegmentDensity
// Qualifier: Get density of segment. the number of points in area.
// date:190312
// author:
//************************************
TEMPLATE
inline double APLA::AREA_COEFFICIENT::getSegmentDensitySpeed() {//190405
#ifdef _DEBUG
	assert(rectangle_area >= 0);
	assert(rectangle_width != INF);
	if (rectangle_height < parallelogram_height && parallelogram_height != INF) {
		assert(rectangle_area == rectangle_width * parallelogram_height);
	}
	else if (parallelogram_height == INF && rectangle_height != INF) {
		//cout << rectangle_area << endl;
		//assert(rectangle_area != INF);
	}
	else {
		//assert(rectangle_area != INF);
	}
#endif

	//return parallelogram_height;
	if (parallelogram_height == 0)
		return segment_density = INF;

	return segment_density = 1.0 / parallelogram_height;
}

//************************************
// Stuct function: compareSegmentCoefficient
// Qualifier: .
// date:190318
// author:
//************************************
TEMPLATE
bool APLA::AREA_COEFFICIENT::compareSegmentCoefficient(const AREA_COEFFICIENT& const compared_segment) {//190318
	assert(rectangle_height == compared_segment.rectangle_height);
	assert(rectangle_width == compared_segment.rectangle_width);
	assert(minmax_distance == compared_segment.minmax_distance);
	assert(min_point.id == compared_segment.min_point.id);
	assert(min_point.value == compared_segment.min_point.value);
	assert(max_point.id == compared_segment.max_point.id);
	assert(max_point.value == compared_segment.max_point.value);
	assert(rectangle_area == compared_segment.rectangle_area);
	//assert(real_area == compared_segment.real_area);
	//assert(merged_percentage == compared_segment.merged_percentage);
	//assert(merge_count == compared_segment.merge_count);
	assert(segment_density == compared_segment.segment_density);
	//assert(parallelogram_height == compared_segment.parallelogram_height);
	//assert(deviation_point.id == compared_segment.deviation_point.id);
	//assert(deviation_point.value == compared_segment.deviation_point.value);
	assert(circle_radius == compared_segment.circle_radius);
	assert(rec_deviation == compared_segment.rec_deviation);
	assert(apla.a == compared_segment.apla.a);
	assert(apla.b == compared_segment.apla.b);
	return true;
}

//************************************
// Stuct:Y_AXIS_COEFFICIENT
// Qualifier:For y axis projection, to get adaptive endpoit
// date:190726
// author:
//************************************
TEMPLATE
struct APLA::Y_AXIS_COEFFICIENT {//190726  For y axis projection, to get adaptive endpoint
public:
	//int min_adjacent_points_height_difference = INF;
	//int max_adjacent_points_height_difference = INF;

	double segment_left_height_difference = INF;
	double segment_right_height_difference = INF;

	map<double, int> internal_difference_map;
	bool is_flat = false;

	vector<AREA_COEFFICIENT> sub_segment_vector;

	Y_AXIS_COEFFICIENT() {
		segment_left_height_difference = INF;
		segment_right_height_difference = INF;

		//min_adjacent_points_height_difference = INF;
		//max_adjacent_points_height_difference = INF;
		is_flat = false;
		sub_segment_vector.clear();
		sub_segment_vector.shrink_to_fit();
	}
	~Y_AXIS_COEFFICIENT() {
		//min_adjacent_points_height_difference = INF;
		//max_adjacent_points_height_difference = INF;
		segment_left_height_difference = INF;
		segment_right_height_difference = INF;
		is_flat = false;
		sub_segment_vector.clear();
		sub_segment_vector.shrink_to_fit();
	}
};

//************************************
// Stuct:SEGMENT_COEFFICIENT
// Qualifier:
// date:190416
// author:
//************************************
TEMPLATE
struct APLA::SEGMENT_COEFFICIENT {//190416
public:
	double right_endpoint = INF; //The right end point of segment;

	//double heightest_id = INF; //id of heightest point
	//double lowest_id = INF;   // id of lowest point
	//double heightest_value = INF; //The heightest value of point;
	//double lowest_value = INF; //The lowest value of point;

	double rectangle_height = INF; // difference between heightest value and lowest value.
	double rectangle_width = INF; //width of rectangle
	//double minmax_distance = INF; //x axis distance between minimum and maximum points
	double rectangle_area = INF; //area of rectangle
	//double real_area = INF; //181217 true rectangle area / total rectangle area

	//double merged_percentage = INF; // current rectangle area / new rectangle area

	//int merge_count = INF;//181218 count how many times this rectangle merged
	double segment_density = INF;//181218 real_area/rectangle_area;
	double rec_deviation = INF;//181218 For every reconstructed APLA segment, get deviation

	double parallelogram_height = INF;//190114
	//double circle_radius = INF;//90315

	double sum_value = INF;//190412

	GEOMETRY::POINT max_point;
	//GEOMETRY::POINT min_point;
	GEOMETRY::POINT deviation_point;//190118

	//inline double getSegmentDensity();//190312
	inline double getSegmentDensitySpeed();//190405

	//bool compareSegmentCoefficient(const AREA_COEFFICIENT& const compared_segment);//190318

	APLA_COEFFICIENT apla;

	SEGMENT_COEFFICIENT() {
		right_endpoint = INF; //The right end point of segment;

		//heightest_id = INF; //id of heightest point
		//lowest_id = INF;   // id of lowest point
		//heightest_value = INF; //The heightest value of point;
		//lowest_value = INF; //The lowest value of point;

		rectangle_height = INF; // difference between heightest value and lowest value.
		rectangle_width = INF; //width of rectangle
		//minmax_distance = INF; //x axis distance between minimum and maximum points
		rectangle_area = INF; //area of rectangle
		//real_area = INF;

		/*max_point.~POINT();
		min_point.~POINT();
		deviation_point.~POINT();

		apla.~APLA_COEFFICIENT();*/

		//merge_count = INF;
		segment_density = INF;
		rec_deviation = INF;

		parallelogram_height = INF;
		//circle_radius = INF;//190315

		sum_value = INF;//190412
	}
	//
	~SEGMENT_COEFFICIENT() {
		right_endpoint = INF; //The right end point of segment;

		//heightest_id = INF; //id of heightest point
		//lowest_id = INF;   // id of lowest point
		//heightest_value = INF; //The heightest value of point;
		//lowest_value = INF; //The lowest value of point;

		rectangle_height = INF; // difference between heightest value and lowest value.
		rectangle_width = INF; //width of rectangle
		//minmax_distance = INF; //x axis distance between minimum and maximum points
		rectangle_area = INF; //area of rectangle
		//real_area = INF;

		max_point.~POINT();
		//min_point.~POINT();
		deviation_point.~POINT();

		apla.~APLA_COEFFICIENT();

		//merge_count = INF;
		segment_density = INF;
		rec_deviation = INF;

		parallelogram_height = INF;
		//circle_radius = INF;//190315

		sum_value = INF;//190412
	}
};

//************************************
// Stuct function: getSegmentDensitySpeed
// Qualifier: Get density of segment. the number of points in area.
// date:190418
// author:
//************************************
TEMPLATE
inline double APLA::SEGMENT_COEFFICIENT::getSegmentDensitySpeed() {//190418

	/*............................................................................*/
#ifdef _DEBUG
	assert(rectangle_area >= 0);
	assert(rectangle_width != INF);
	if (rectangle_height < parallelogram_height && parallelogram_height != INF) {
		assert(rectangle_area == rectangle_width * parallelogram_height);
	}
	else if (parallelogram_height == INF && rectangle_height != INF) {
		//cout << rectangle_area << endl;
		//assert(rectangle_area != INF);
	}
	else {
		//assert(rectangle_area != INF);
	}
#endif
	/*............................................................................*/

	//return parallelogram_height;

	return segment_density = 1.0 / parallelogram_height;
}

//************************************
// Stuct:APLA_COEFFICIENT
// Qualifier:
// date:181212
// author:
//************************************
TEMPLATE
struct APLA::APLA_COEFFICIENT {//181212 For PLA Coefficient
	long double a = INF;//ax+b
	long double b = INF;//ax+b
	//double right_endpoint = INF;
	//int segmentNum = INF; //the dimension of the index(eg. MBR, imput parameter)

	long double a_minuend = INF;//(l-1)/2
	long double a_divisor = INF;//l(l-1)(l+1)
	long double b_minuend = INF;//2l-1
	long double b_divisor = INF;//l(l+1)

	APLA_COEFFICIENT() {
		a = INF;//ax+b
		b = INF;//ax+b
		//right_endpoint = INF;
		//segmentNum = INF; //the dimension of the index(eg. MBR, imput parameter)
		//because initial segment length is 2, l=2
		a_minuend = 0.5;//(l-1)/2
		a_divisor = 6;//l(l-1)(l+1)
		b_minuend = 3;//2l-1
		b_divisor = 6;//l(l+1)
	}

	~APLA_COEFFICIENT() {
		//segmentNum = INF;
		a = INF;
		b = INF;
		//right_endpoint = INF;

		a_minuend = INF;//(l-1)/2
		a_divisor = INF;//l(l-1)(l+1)
		b_minuend = INF;//2l-1
		b_divisor = INF;//l(l+1)
	}
};

//************************************
// Stuct:APLA_COEFFICIENT
// Qualifier:
// date:181212
// author:
//************************************
TEMPLATE
struct APLA::APLA_COEFFICIENT1 {//190612 For based PLA method
};

//************************************
// Stuct:PLA_COEFFICIENT_CONCISE
// Qualifier:Only contain a&b
// date:200210
// author:
//************************************
TEMPLATE
struct APLA::PLA_COEFFICIENT_CONCISE {//200210 Only contain a&b
	double a = INF;
	double b = INF;

	PLA_COEFFICIENT_CONCISE() {
		a = INF;
		b = INF;
	}

	~PLA_COEFFICIENT_CONCISE() {
		a = INF;
		b = INF;
	}
};

//************************************
// Stuct:SPLIT_COEFFICIENT
// Qualifier:200210 Split Coefficient, For fast finding split point
// date:200210
// Properties: 
// author:
//************************************
TEMPLATE
struct APLA::SPLIT_COEFFICIENT {//
	//int split_id = INF;// pint id
	//PLA_COEFFICIENT_CONCISE pla_left;// left segment a & b
	//PLA_COEFFICIENT_CONCISE pla_right;// right segment a & b
	//int rectangle_width_left = INF;
	//int rectangle_width_right = INF;
	int split_magnitude = INF;
	//double segment_density = INF;

	AREA_COEFFICIENT_CONCISE segment_left;
	AREA_COEFFICIENT_CONCISE segment_right;
	//AREA_COEFFICIENT segment_left;
	//AREA_COEFFICIENT segment_right;

	SPLIT_COEFFICIENT() {
		//split_id = INF;// pint id
		//left_pla.~APLA_COEFFICIENT();
		//right_pla.~APLA_COEFFICIENT();
		//rectangle_width_left = INF;
		//rectangle_width_right = INF;
		split_magnitude = INF;
		//segment_density = INF;
	}

	~SPLIT_COEFFICIENT() {
		//split_id = INF;// pint id
		//pla_left.~PLA_COEFFICIENT_CONCISE();
		//pla_right.~PLA_COEFFICIENT_CONCISE();
		//rectangle_width_left = INF;
		//rectangle_width_right = INF;
		split_magnitude = INF;
		//segment_density = INF;
		segment_left.~AREA_COEFFICIENT_CONCISE();
		segment_right.~AREA_COEFFICIENT_CONCISE();
		//segment_left.~AREA_COEFFICIENT();
		//segment_right.~AREA_COEFFICIENT();
	}
};

//************************************
// Stuct:OPTIMIZATION_COEFFICIENT
// Qualifier:split & merge & optimization coefficients
// date:200915
// Properties: 
// author:
//************************************
TEMPLATE
template<typename T>
struct APLA::OPTIMIZATION_COEFFICIENT {

	//T right_endpoint_last_merged_segment = INF;

	//bool finish_left = false;
	bool finish_right = false;

	//201204
	bool finish_decrease_right = false;
	bool finish_decrease_left = false;

	OPTIMIZATION_COEFFICIENT() {
		//right_endpoint_last_merged_segment = INF;
		//finish_left = false;
		finish_right = false;
		//201204
		finish_decrease_right = false;
		finish_decrease_left = false;
	}

	~OPTIMIZATION_COEFFICIENT() {
		//right_endpoint_last_merged_segment = INF;
		//finish_left = false;
		finish_right = false;
		//201204
		finish_decrease_right = false;
		finish_decrease_left = false;
	}
};

//************************************
// Stuct:UPPER_BOUND_COEFFICIENT
// Qualifier: upper bound > max deviation.
// date:210113
// author:
//************************************
TEMPLATE
template<typename T>
struct APLA::UPPER_BOUND_COEFFICIENT {

	T upper_bound_area = -INF;
	T upper_bound_diff = -INF;

	/*----------------------------*/
	/*size_t id_upper_bound_diff = NULL;
	T upper_bound_sum = -INF;

	size_t id_point_max_deviation = NULL;
	T value_point_max_deviation = INF;

	T sum_deviation_real = INF;*/
	/*----------------------------*/

	UPPER_BOUND_COEFFICIENT() {
		upper_bound_area = -INF;
		upper_bound_diff = -INF;

		/*----------------------------*/
		/*id_upper_bound_diff = NULL;
		upper_bound_sum = -INF;

		id_point_max_deviation = NULL;
		value_point_max_deviation = INF;

		sum_deviation_real = INF;*/
		/*----------------------------*/
	}

	~UPPER_BOUND_COEFFICIENT() {
		upper_bound_area = -INF;
		upper_bound_diff = -INF;

		/*----------------------------*/
		/*id_upper_bound_diff = NULL;
		upper_bound_sum = -INF;

		id_point_max_deviation = NULL;
		value_point_max_deviation = INF;

		sum_deviation_real = INF;*/
		/*----------------------------*/
	}

};

//************************************
// Stuct:MagnitudeDecreasing
// Qualifier:
// date:181113
// author:
//************************************
TEMPLATE
struct APLA::MagnitudeIncrease {
	bool operator () (const BREAK_POINT_MAGNITUDE& a, const BREAK_POINT_MAGNITUDE& b) {//minimum to maximum
		return a.break_point_magnitude < b.break_point_magnitude;             // Get minimum value
	}
};

//************************************
// Stuct:AreaIncreasing
// Qualifier:
// date:181120
// author:
//************************************
TEMPLATE
struct APLA::AreaIncreasing {//181120
	bool operator () (const AREA_COEFFICIENT& const a, const AREA_COEFFICIENT& const b) {
		return a.rectangle_area < b.rectangle_area;             // Get minimum value
		//return a.parallelogram_height < b.parallelogram_height;
	}
};

//************************************
// Stuct:HeightIncreasing
// Qualifier:
// date:190312
// author:
//************************************
TEMPLATE
struct APLA::ParallelogramHeightIncrease {//190312
	bool operator () (const AREA_COEFFICIENT& const a, const AREA_COEFFICIENT& const b) {
		// Get minimum value
		return a.parallelogram_height < b.parallelogram_height; // Get minimum value
		//return a.getSegmentDensity() > b.getSegmentDensity();
	}
};

//************************************
// Stuct:DensityIncrease
// Qualifier:Get minimum value, segment density from minimum to maximum
//            segment_density = segment_width / segment_area
// date:190313
// author:
//************************************
//TEMPLATE
//struct APLA::DensityIncrease {
//	bool operator () (AREA_COEFFICIENT& const a, AREA_COEFFICIENT& const b) {
//		// Get minimum value
//		//return a.parallelogram_height < b.parallelogram_height; // Get minimum value
//#if _DEBUG
//		assert(a.segment_density != NULL && b.segment_density != NULL);
//#endif
//		return a.segment_density < b.segment_density;
//	}
//};

//************************************
// Stuct:DensityIncrease
// Qualifier:Get minimum value, segment density from minimum to maximum
//            segment_density = segment_width / segment_area
// 200211  min desntiy to max density
// date:200211
// author:
//************************************
TEMPLATE
struct APLA::DensityIncrease {
	template<typename T>
	bool operator () (T& const a, T& const b) {
		// Get minimum value
		//return a.parallelogram_height < b.parallelogram_height; // Get minimum value
#if _DEBUG
		//assert(a.segment_density != INF && b.segment_density != INF);
#endif
		return a.segment_right.segment_density < b.segment_right.segment_density;
	}
};

//************************************
// Stuct:DensityIncrease_Pointer
// Qualifier:Get minimum value, segment density from minimum to maximum
//            segment_density = segment_width / segment_area
// date:190328
// author:
//************************************
TEMPLATE
struct APLA::DensityIncrease_Pointer {
	bool operator () (AREA_COEFFICIENT* const a, AREA_COEFFICIENT* const b) {
		// Get minimum value
		//return a.parallelogram_height < b.parallelogram_height; // Get minimum value
		return a->getSegmentDensity() < b->getSegmentDensity();
	}
};

//************************************
// Stuct:WidthIncreasing
// Qualifier:
// date:190104
// author:
//************************************
TEMPLATE
struct APLA::WidthIncreasing {//190104
	bool operator () (const AREA_COEFFICIENT& a, const AREA_COEFFICIENT& b) {
		// Get minimum value
		return a.rectangle_width < b.rectangle_width;
	}
};

//************************************
// Stuct:DeviationIncreasing
// Qualifier:
// date:190115
// author:
//************************************
TEMPLATE
struct APLA::DeviationIncreasing {//190115
	bool operator () (const AREA_COEFFICIENT& a, const AREA_COEFFICIENT& b) {
		// Get minimum value
		return a.rec_deviation < b.rec_deviation;
	}
};

//************************************
// Stuct:MiniMaxDistIncreasing
// Qualifier:
// date:181219
// author:
//************************************
TEMPLATE
struct APLA::AreaDecreasing {//181219
	bool operator () (const AREA_COEFFICIENT& a, const AREA_COEFFICIENT& b) {
		return a.rectangle_area > b.rectangle_area;             // Get maximum value
	}
};

//************************************
// Stuct: Width_To_Radius_Increase
// Qualifier: segment_width / radius
// date:180315
// author:
//************************************
TEMPLATE
struct APLA::Width_Divide_Radius_Increase {//190315
	bool operator () (const AREA_COEFFICIENT& a, const AREA_COEFFICIENT& b) {//minimum to maximum
		assert(a.circle_radius != INF && b.circle_radius != INF);
		return (a.rectangle_width / a.circle_radius) < (b.rectangle_width / b.circle_radius);             // Get minimum value
	}
};

//************************************
// Stuct: Set_Deviation_Decrease
// Qualifier: segment_width / radius
// date:190624
// author:
//************************************
TEMPLATE
struct APLA::Set_Deviation_Decrease {//190624
	//template <class T1, class T2>
	bool operator () (const pair<vector<int>, double>& lhs, const pair<vector<int>, double>& rhs) {
		return lhs.second < rhs.second;             // Get minimum value
	}
};

//************************************
// Stuct: SPLIT_ID_INCREASE
// Qualifier: get min to max by split id
// date:200211
// author:
//************************************
TEMPLATE
struct APLA::SPLIT_ID_INCREASE {//200211
	template<typename T>
	bool operator () (T& const a, T& const b) {
		// Get minimum value
		//return a.parallelogram_height < b.parallelogram_height; // Get minimum value
#if _DEBUG
		assert(a.segment_left.right_endpoint != INF && b.segment_left.right_endpoint != INF);
#endif
		return a.segment_left.right_endpoint < b.segment_left.right_endpoint;
	}
};

//************************************
// Stuct: COMPARE_INCREASE_SEGMENT_DENSITY
// Qualifier: get smallest segment density, small to big
// date:200812
// author:
//************************************
TEMPLATE
struct APLA::COMPARE_GREATER_SEGMENT_DENSITY {

	template<typename T>
	bool operator () (const T& const segment_a, const T& const segment_b) const {
		// Get minimum value
#if _DEBUG
		assert(segment_a.segment_density != INF && segment_b.segment_density != INF);
#endif
		return segment_a.segment_density > segment_b.segment_density;
	}
};

//************************************
// Stuct: OPTION_DISTANCE_STRUCT
// Qualifier: disatnce type, triangle area or SAPLA or APCA disance
// date:210907
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
struct APLA::OPTION_DISTANCE_STRUCT {
	T type_distance = -1;// 0 SAPLA Eucliden, 1 triangle area
	Y type_representation = -1;// 0 SAPLA/APLA/PLA/PAA/PAALM/SAX/CHEBY, 3 APCA(average)
	U number_point = INF;// point number to scan in original time series.

	OPTION_DISTANCE_STRUCT() {
		type_distance = -1;
		type_representation = -1;
		number_point = INF;
	}

	OPTION_DISTANCE_STRUCT(const T& const type_distance, const Y& const type_representation, const U& const number_point): type_distance(type_distance), type_representation(type_representation), number_point(number_point){}

	~OPTION_DISTANCE_STRUCT() {
		type_distance = -1;
		type_representation = -1;
		number_point = INF;
	}
};

//************************************
// Method:CAPLA
// Qualifier:
// date:181111
// author:
//************************************
TEMPLATE
template<typename T>
APLA::CAPLA(const T& n, const T& N) {
	input_argument.time_series_length = n;
	input_argument.point_dimension = N;
	input_argument.change_file = true;
	//For PLA Representation 181212    191107 May be delete, is it usesless
	//****************PLA*********************************************************
	input_argument.remainder = int(n) % int(N);//For PLA
	input_argument.segment_length_second = (n - input_argument.remainder) / N;
	input_argument.segment_length_first = input_argument.segment_length_second + 1;
#ifdef _DEBUG
	assert(input_argument.segment_length_second > 1);//l(l-1)(l+1), so l != 1
#endif
	//*******************************************************************************
}

//************************************
// Method:CAPLA
// Qualifier: add change file
// date:191211
// author:
//************************************
TEMPLATE
template<typename T>
APLA::CAPLA(const T& const n, const T& const N, const bool& const change_file) {
	input_argument.time_series_length = n;
	input_argument.point_dimension = N;
	input_argument.change_file = change_file;
	//For PLA Representation 181212    191107 May be delete, is it usesless
	//****************PLA*********************************************************
	input_argument.remainder = int(n) % int(N);//For PLA
	input_argument.segment_length_second = (n - input_argument.remainder) / N;
	input_argument.segment_length_first = input_argument.segment_length_second + 1;
#ifdef _DEBUG
	assert(input_argument.segment_length_second > 1);//l(l-1)(l+1), so l != 1
#endif
	//*******************************************************************************
}

//200224 split_id_coefficients = 0
//************************************
// Method:initialBREAK_POINT
// Qualifier:
// date:181112
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline void APLA::initial_split_coefficients(T& const input_argument, Y& const output_argument) {

	input_argument.pruning_power = 0;
	input_argument.whole_run_time = 0;

	output_argument.sum_deviation = 0;
	output_argument.run_time = INF;

	output_argument.coefficents_split_id.local_split_sum_deviation = 0;
	output_argument.coefficents_split_id.split_sum_deviation_min_density = 0;
	output_argument.coefficents_split_id.split_sum_deviation_binary = 0;
	output_argument.coefficents_split_id.split_sum_deviation_direct_intersection = 0;
	output_argument.coefficents_split_id.split_sum_deviation_middle = 0;
	output_argument.coefficents_split_id.split_sum_deviation_best = 0;

	output_argument.coefficents_split_id.local_split_shift_abs = 0;
	output_argument.coefficents_split_id.split_accuracy_min_density = 0;
	output_argument.coefficents_split_id.split_accuracy_binary = 0;
	output_argument.coefficents_split_id.split_accuracy_direct_intersection = 0;
	output_argument.coefficents_split_id.split_accuracy_middle = 0;
	output_argument.coefficents_split_id.split_id_best = 0;

	output_argument.coefficents_split_id.local_split_time = 0;
	output_argument.coefficents_split_id.split_time_min_density = 0;
	output_argument.coefficents_split_id.split_time_binary = 0;
	output_argument.coefficents_split_id.split_time_direct_intersection = 0;
	output_argument.coefficents_split_id.split_time_middle = 0;
	output_argument.coefficents_split_id.split_time_best = 0;
}
//200224 vector of split coefficients get value from out argument
//************************************
// Method:get_split_coefficients
// Qualifier: vector of split coefficients get value from out argument
// date:200224
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
inline void APLA::get_split_coefficients(const T& const input_argument, const U& const output_argument, const int& const split_methods_option, vector<Y>& const local_total_split_id_sum_deviation, vector<Y>& const local_total_split_id_shift, vector<Y>& const local_total_split_id_time, vector<Y>& const global_total_approximation_sum_deviation, vector<Y>& const global_total_approximation_time) {
	assert(local_total_split_id_sum_deviation.size() == local_total_split_id_shift.size() && local_total_split_id_shift.size() == local_total_split_id_time.size() && local_total_split_id_time.size() == global_total_approximation_sum_deviation.size() && global_total_approximation_sum_deviation.size() == global_total_approximation_time.size() && split_methods_option != INF && split_methods_option >= 0 && split_methods_option < global_total_approximation_time.size());
	assert(output_argument.sum_deviation != INF && output_argument.run_time != INF && input_argument.whole_run_time != INF);
	//assert(output_argument.coefficents_split_id.split_sum_deviation_min_density != INF && output_argument.coefficents_split_id.split_sum_deviation_binary != INF && output_argument.coefficents_split_id.split_sum_deviation_direct_intersection != INF && output_argument.coefficents_split_id.split_sum_deviation_middle != INF && output_argument.coefficents_split_id.split_sum_deviation_best != INF);
	//assert(output_argument.coefficents_split_id.split_accuracy_min_density != INF && output_argument.coefficents_split_id.split_accuracy_binary != INF && output_argument.coefficents_split_id.split_accuracy_direct_intersection != INF && output_argument.coefficents_split_id.split_accuracy_middle != INF && output_argument.coefficents_split_id.split_id_best != INF);
	//assert(output_argument.coefficents_split_id.split_time_min_density != INF && output_argument.coefficents_split_id.split_time_binary != INF&& output_argument.coefficents_split_id.split_time_direct_intersection != INF&& output_argument.coefficents_split_id.split_time_middle != INF&& output_argument.coefficents_split_id.split_time_best != INF);
	assert(output_argument.run_time == input_argument.whole_run_time);
	/*------------------------------get local sum & shift & time by method optiopn-------*/
	local_total_split_id_sum_deviation[split_methods_option] += output_argument.coefficents_split_id.local_split_sum_deviation;

	local_total_split_id_shift[split_methods_option] += output_argument.coefficents_split_id.local_split_shift_abs;

	local_total_split_id_time[split_methods_option] += output_argument.coefficents_split_id.local_split_time;
	/*-----------------------------------------------------------------------------------*/

	/*------------------------------get global sum & shift & time by method optiopn-------*/
	global_total_approximation_sum_deviation[split_methods_option] += output_argument.sum_deviation;

	global_total_approximation_time[split_methods_option] += input_argument.whole_run_time;
	/*-----------------------------------------------------------------------------------*/

	/*-------------------------200219 split id evaluation-----------------------*/
	// 1 min density,2 binary search,3  direct intersection and 4 best split point method.
	//split_id_deviation_sum
	/*split_id_deviation_sum[0] += output_argument.coefficents_split_id.split_sum_deviation_min_density;
	split_id_deviation_sum[1] += output_argument.coefficents_split_id.split_sum_deviation_binary;
	split_id_deviation_sum[2] += output_argument.coefficents_split_id.split_sum_deviation_direct_intersection;
	split_id_deviation_sum[3] += output_argument.coefficents_split_id.split_sum_deviation_middle;
	split_id_deviation_sum[4] += output_argument.coefficents_split_id.split_sum_deviation_best;

	split_id_accuracy_sum[0] += output_argument.coefficents_split_id.split_accuracy_min_density;
	split_id_accuracy_sum[1] += output_argument.coefficents_split_id.split_accuracy_binary;
	split_id_accuracy_sum[2] += output_argument.coefficents_split_id.split_accuracy_direct_intersection;
	split_id_accuracy_sum[3] += output_argument.coefficents_split_id.split_accuracy_middle;
	split_id_accuracy_sum[4] += output_argument.coefficents_split_id.split_id_best;

	split_id_time_sum[0] += output_argument.coefficents_split_id.split_time_min_density;
	split_id_time_sum[1] += output_argument.coefficents_split_id.split_time_binary;
	split_id_time_sum[2] += output_argument.coefficents_split_id.split_time_direct_intersection;
	split_id_time_sum[3] += output_argument.coefficents_split_id.split_time_middle;
	split_id_time_sum[4] += output_argument.coefficents_split_id.split_time_best;*/
	/*----------------------------------------------------------------------------*/

	for (int spit_segment_id = 0; spit_segment_id < local_total_split_id_sum_deviation.size(); spit_segment_id++) {
		assert(local_total_split_id_sum_deviation[spit_segment_id] != INF && local_total_split_id_shift[spit_segment_id] != INF && local_total_split_id_time[spit_segment_id] != INF && global_total_approximation_sum_deviation[spit_segment_id] != INF && global_total_approximation_time[spit_segment_id] != INF);
	}
}

//200227 vector of split coefficients get value from out arugemt
//************************************
// Method:get_split_coefficients
// Qualifier: vector of split coefficients get value from out argument
// date:200224
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
inline void APLA::get_split_coefficients(const T& const input_argument, const U& const output_argument, const int& const split_methods_option, vector<Y>& const local_total_split_id_sum_deviation, vector<Y>& const local_total_split_id_shift, vector<Y>& const local_total_split_id_time, vector<Y>& const global_total_approximation_sum_deviation, vector<Y>& const global_total_approximation_time, vector<Y>& const global_total_knn_prune_power) {
	assert(local_total_split_id_sum_deviation.size() == local_total_split_id_shift.size() && local_total_split_id_shift.size() == local_total_split_id_time.size() && local_total_split_id_time.size() == global_total_approximation_sum_deviation.size() && global_total_approximation_sum_deviation.size() == global_total_approximation_time.size() && split_methods_option != INF && split_methods_option >= 0 && split_methods_option < global_total_approximation_time.size());
	assert(output_argument.sum_deviation != INF && output_argument.run_time != INF && input_argument.whole_run_time != INF && input_argument.pruning_power != INF);
	//assert(output_argument.coefficents_split_id.split_sum_deviation_min_density != INF && output_argument.coefficents_split_id.split_sum_deviation_binary != INF && output_argument.coefficents_split_id.split_sum_deviation_direct_intersection != INF && output_argument.coefficents_split_id.split_sum_deviation_middle != INF && output_argument.coefficents_split_id.split_sum_deviation_best != INF);
	//assert(output_argument.coefficents_split_id.split_accuracy_min_density != INF && output_argument.coefficents_split_id.split_accuracy_binary != INF && output_argument.coefficents_split_id.split_accuracy_direct_intersection != INF && output_argument.coefficents_split_id.split_accuracy_middle != INF && output_argument.coefficents_split_id.split_id_best != INF);
	//assert(output_argument.coefficents_split_id.split_time_min_density != INF && output_argument.coefficents_split_id.split_time_binary != INF&& output_argument.coefficents_split_id.split_time_direct_intersection != INF&& output_argument.coefficents_split_id.split_time_middle != INF&& output_argument.coefficents_split_id.split_time_best != INF);
	assert(output_argument.run_time == input_argument.whole_run_time);
	/*------------------------------get local sum & shift & time by method optiopn-------*/
	local_total_split_id_sum_deviation[split_methods_option] += output_argument.coefficents_split_id.local_split_sum_deviation;

	local_total_split_id_shift[split_methods_option] += output_argument.coefficents_split_id.local_split_shift_abs;

	local_total_split_id_time[split_methods_option] += output_argument.coefficents_split_id.local_split_time;
	/*-----------------------------------------------------------------------------------*/

	/*------------------------------get global sum & shift & time by method optiopn-------*/
	global_total_knn_prune_power[split_methods_option] += input_argument.pruning_power;

	global_total_approximation_sum_deviation[split_methods_option] += output_argument.sum_deviation;

	global_total_approximation_time[split_methods_option] += input_argument.whole_run_time;
	/*-----------------------------------------------------------------------------------*/

	for (int spit_segment_id = 0; spit_segment_id < local_total_split_id_sum_deviation.size(); spit_segment_id++) {
		assert(local_total_split_id_sum_deviation[spit_segment_id] != INF && local_total_split_id_shift[spit_segment_id] != INF && local_total_split_id_time[spit_segment_id] != INF && global_total_approximation_sum_deviation[spit_segment_id] != INF && global_total_approximation_time[spit_segment_id] != INF && global_total_knn_prune_power[spit_segment_id] != INF);
	}
}

//200329 vector of initial N coefficients get value from out argument
//*******************************************
// Method:get_initial_N_coefficients
// Qualifier:
// date:200329
// author:
//*******************************************
TEMPLATE
template<typename T, typename Y, typename U, typename U1>
inline void APLA::get_initial_N_coefficients(const T& const input_argument, const U& const output_argument, const U1& const initial_N_number, vector<Y>& const total_initial_N_prune_power_vector, vector<Y>& const total_initial_N_sum_deviation_vector, vector<Y>& const total_initial_N_run_time_vector, vector<Y>& const total_initial_N_approximation_time_vector, vector<Y>& const total_initial_N_knn_time_vector) {
	assert(total_initial_N_prune_power_vector.size() == total_initial_N_sum_deviation_vector.size() && total_initial_N_sum_deviation_vector.size() == total_initial_N_run_time_vector.size() && total_initial_N_run_time_vector.size() == total_initial_N_approximation_time_vector.size() && total_initial_N_approximation_time_vector.size() == total_initial_N_knn_time_vector.size() && initial_N_number != INF && initial_N_number >= 0 && initial_N_number < total_initial_N_knn_time_vector.size());
	assert(output_argument.sum_deviation != INF && output_argument.run_time != INF && input_argument.whole_run_time != INF && input_argument.pruning_power != INF);
	assert(output_argument.run_time == input_argument.whole_run_time && initial_N_number != INF);

	/*------------------------------get prune power & sum deviation by initial_N_number------------------------------*/
	total_initial_N_prune_power_vector[initial_N_number] += input_argument.pruning_power;
	total_initial_N_sum_deviation_vector[initial_N_number] += output_argument.sum_deviation;
	/*----------------------------------------------------------------------------------------------------------------*/

	/*-------------------------------get prune power & sum deviation by initial_N_number------------------------------*/
	total_initial_N_run_time_vector[initial_N_number] += input_argument.whole_run_time;
	total_initial_N_approximation_time_vector[initial_N_number] += input_argument.representation_time;;
	total_initial_N_knn_time_vector[initial_N_number] += input_argument.knn_total_time;
	/*----------------------------------------------------------------------------------------------------------------*/

	for (int coefficient_id = 0; coefficient_id < total_initial_N_prune_power_vector.size(); coefficient_id++) {
		assert(total_initial_N_prune_power_vector[initial_N_number] != INF && total_initial_N_sum_deviation_vector[initial_N_number] != INF && total_initial_N_run_time_vector[initial_N_number] != INF && total_initial_N_approximation_time_vector[initial_N_number] != INF && total_initial_N_knn_time_vector[initial_N_number] != INF);
	}
}

//200331 vector of initial N coefficients sort by N value
//*******************************************
// Method:get_initial_N_sort_N_coefficients
// Qualifier:
// date:200331
// author:
//*******************************************
TEMPLATE
template<typename T, typename Y, typename U, typename U1>
inline void APLA::get_initial_N_sort_N_coefficients(const T& const input_argument, const U& const output_argument, const U1& const N_size, const U1& const N_id, const U1& const initial_N_number, vector<Y>& const initial_N_by_N_prune_power_vector, vector<Y>& const initial_N_by_N_sum_deviation_vector, vector<Y>& const initial_N_by_N_run_time_vector, vector<Y>& const initial_N_by_N_approximation_time_vector, vector<Y>& const initial_N_by_N_knn_time_vector) {
	assert(initial_N_by_N_prune_power_vector.size() == initial_N_by_N_sum_deviation_vector.size() && initial_N_by_N_sum_deviation_vector.size() == initial_N_by_N_run_time_vector.size() && initial_N_by_N_run_time_vector.size() == initial_N_by_N_approximation_time_vector.size() && initial_N_by_N_approximation_time_vector.size() == initial_N_by_N_knn_time_vector.size() && initial_N_number != INF && initial_N_number >= 0 && initial_N_number < initial_N_by_N_approximation_time_vector.size());
	assert(output_argument.sum_deviation != INF && output_argument.run_time != INF && input_argument.whole_run_time != INF && input_argument.pruning_power != INF);
	assert(output_argument.run_time == input_argument.whole_run_time && N_id != INF && initial_N_number != INF);

	/*------------------------------get prune power & sum deviation by initial_N_number------------------------------*/
	initial_N_by_N_prune_power_vector[N_size * N_id + initial_N_number] += input_argument.pruning_power;
	initial_N_by_N_sum_deviation_vector[N_size * N_id + initial_N_number] += output_argument.sum_deviation;
	/*----------------------------------------------------------------------------------------------------------------*/

	/*-------------------------------get prune power & sum deviation by initial_N_number------------------------------*/
	initial_N_by_N_run_time_vector[N_size * N_id + initial_N_number] += input_argument.whole_run_time;
	initial_N_by_N_approximation_time_vector[N_size * N_id + initial_N_number] += input_argument.representation_time;;
	initial_N_by_N_knn_time_vector[N_size * N_id + initial_N_number] += input_argument.knn_total_time;
	/*----------------------------------------------------------------------------------------------------------------*/

	for (int coefficient_id = 0; coefficient_id < initial_N_by_N_prune_power_vector.size(); coefficient_id++) {
		assert(initial_N_by_N_prune_power_vector[initial_N_number] != INF && initial_N_by_N_sum_deviation_vector[initial_N_number] != INF && initial_N_by_N_run_time_vector[initial_N_number] != INF && initial_N_by_N_approximation_time_vector[initial_N_number] != INF && initial_N_by_N_knn_time_vector[initial_N_number] != INF);
	}
}

//************************************
// Method:initialBREAK_POINT
// Qualifier:
// date:181112
// author:
//************************************
TEMPLATE
void APLA::initialBREAK_POINT_COEFFICIENT(const typename TOOL::INPUT_ARGUMENT& input_argument, BREAK_POINT_COEFFICIENT& const break_point) {
	assert(input_argument.time_series_length % 2 == 0);//n is even
	break_point.array_length = input_argument.time_series_length / 2;
	TOOL::newArray(break_point.point_width, break_point.array_length);
	TOOL::newArray(break_point.point_height, break_point.array_length);
}

//************************************
// Method:initialBREAK_POINT
// Qualifier:
// date:181112
// author:
//************************************
TEMPLATE
void APLA::deleteBREAK_POINT_COEFFICIENT(BREAK_POINT_COEFFICIENT& const break_point) {//181112
	TOOL::deleteArray(break_point.point_width);
	TOOL::deleteArray(break_point.point_height);
}

//************************************
// Method:getAPLADifference
// Qualifier:
// date:181112
// author:
//************************************
TEMPLATE
void APLA::getAPLADifference(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, int*& const break_point_ID) {
	assert(input_argument.time_series_length % 2 == 0);//n is even

	int even_ID_array_length = input_argument.time_series_length / 2;
	int odd_ID_array_length = even_ID_array_length - 1;

	double* even_ID_array = new double[even_ID_array_length];// decide break point
	double* odd_ID_array = new double[odd_ID_array_length];// compute magnitude of break point

	double* point_coefficient;
	TOOL::newArray(point_coefficient, even_ID_array_length);

	int even_id = 0;
	int odd_id = 0;

	BREAK_POINT_MAGNITUDE break_point_magnitude;
	BREAK_POINT_COEFFICIENT break_point_coefficient;
	priority_queue<BREAK_POINT_MAGNITUDE, vector<BREAK_POINT_MAGNITUDE>, MagnitudeIncrease > queue;

	initialBREAK_POINT_COEFFICIENT(input_argument, break_point_coefficient);

	for (int array_id = 0; array_id < input_argument.time_series_length - 1; array_id++) {
		if (array_id & 1) {//odd
			odd_ID_array[odd_id] = original_time_series[array_id + 1] - original_time_series[array_id];
			odd_id++;
		}
		else {//even
			even_ID_array[even_id] = original_time_series[array_id + 1] - original_time_series[array_id];
			even_id++;
		}
	}

	assert(odd_id == odd_ID_array_length);
	assert(even_id == even_ID_array_length);

	TOOL::printArray(even_ID_array, even_ID_array_length);
	TOOL::printArray(odd_ID_array, odd_ID_array_length);

	break_point_coefficient.point_width[0] = 1;
	break_point_coefficient.point_height[0] = 0;
	TOOL::getMeanValue(break_point_coefficient.point_width[0], break_point_coefficient.point_height[0], point_coefficient[0]);

	for (int array_id = 1; array_id < even_ID_array_length; array_id++) {
		//if (even_ID_array[array_id] * odd_ID_array[array_id - 1] > 0 && even_ID_array[array_id] * even_ID_array[array_id - 1] > 0) {
		if (even_ID_array[array_id] * even_ID_array[array_id - 1] > 0) {
			break_point_coefficient.point_width[array_id] = break_point_coefficient.point_width[array_id - 1] + 1;
			break_point_coefficient.point_height[array_id] = odd_ID_array[array_id - 1] + break_point_coefficient.point_height[array_id - 1];

			if (odd_ID_array[array_id - 1] * even_ID_array[array_id] > 0) {
				break_point_coefficient.point_height[array_id - 1] = 0;
				break_point_coefficient.point_width[array_id - 1] = 0;
				TOOL::getMeanValue(fabs(break_point_coefficient.point_width[array_id - 1]), fabs(break_point_coefficient.point_height[array_id - 1]), point_coefficient[array_id - 1]);
			}
		}
		else {
			break_point_coefficient.point_width[array_id] = 1;
			break_point_coefficient.point_height[array_id] = odd_ID_array[array_id - 1];
		}
		TOOL::getMeanValue(fabs(break_point_coefficient.point_width[array_id]), fabs(break_point_coefficient.point_height[array_id]), point_coefficient[array_id]);
	}

	for (int array_id = 0; array_id < even_ID_array_length; array_id++) {
		break_point_magnitude.break_point_magnitude = point_coefficient[array_id];
		break_point_magnitude.break_point_id = array_id;
		queue.push(break_point_magnitude);
	}

	TOOL::printArray(break_point_coefficient.point_width, even_ID_array_length);
	TOOL::printArray(break_point_coefficient.point_height, even_ID_array_length);

	TOOL::printArray(point_coefficient, even_ID_array_length);

	deleteBREAK_POINT_COEFFICIENT(break_point_coefficient);
	TOOL::deleteArray(even_ID_array);
	TOOL::deleteArray(odd_ID_array);

	while (!queue.empty()) {
		cout << "id: " << queue.top().break_point_id << " magnitude: " << queue.top().break_point_magnitude << endl;
		queue.pop();
	}

	delete[] point_coefficient;
	point_coefficient = nullptr;
}

//************************************
// Method:copyRectangleCoefficient
// Qualifier:
// date:181205
// author:
//************************************
TEMPLATE
void APLA::copyRectangleCoefficient(vector<AREA_COEFFICIENT>& area_vector, const int vector_id, AREA_COEFFICIENT& temp_coefficient) {
	area_vector.at(vector_id) = temp_coefficient;

	(area_vector.begin() + vector_id)->lowest_id = temp_coefficient.lowest_id;
	(area_vector.begin() + vector_id)->lowest_value = temp_coefficient.lowest_value;
	(area_vector.begin() + vector_id)->heightest_id = temp_coefficient.heightest_id;
	(area_vector.begin() + vector_id)->heightest_value = temp_coefficient.heightest_value;
}

//************************************
// Method:computeRectangleCoefficient
// Qualifier: update adjacent rectangle after merge operation
// date:181211
// author:
//************************************
TEMPLATE
void APLA::initialRecArea(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector) {//181211
#ifdef _DEBUG
	assert(input_argument.time_series_length % 2 == 0);//n is even
#endif

	int initial_rectangle_num = input_argument.time_series_length / 2;//!!!!!!!!!!!!!!!!! what if time_series_length is  odd???
	AREA_COEFFICIENT area_coefficient, temp_coefficient;
	//AreaIncreasing areaIncreasing;

	for (int array_id = 0; array_id < initial_rectangle_num; array_id++) {
		// end point
		area_coefficient.right_endpoint = array_id * 2 + 1;
		//width
		area_coefficient.rectangle_width = 2.0;
		//minmax value
		area_coefficient.min_point.value = min(original_time_series[array_id * 2], original_time_series[array_id * 2 + 1]);
		area_coefficient.max_point.value = max(original_time_series[array_id * 2], original_time_series[array_id * 2 + 1]);
		//minmax height
		area_coefficient.rectangle_height = area_coefficient.max_point.value - area_coefficient.min_point.value;
		//minmax id
		if (original_time_series[array_id * 2 + 1] >= original_time_series[array_id * 2]) {
			area_coefficient.max_point.id = array_id * 2 + 1;
			area_coefficient.min_point.id = array_id * 2;
		}
		else {
			area_coefficient.max_point.id = array_id * 2;
			area_coefficient.min_point.id = array_id * 2 + 1;
		}

		//minmax distance
		area_coefficient.minmax_distance = area_coefficient.rectangle_height == 0 ? 0 : fabs(area_coefficient.max_point.id - area_coefficient.min_point.id);
		//assert(area_coefficient.minmax_distance > 1);

		//segment area
		area_coefficient.rectangle_area = area_coefficient.rectangle_height * area_coefficient.rectangle_width;
		//assert(area_coefficient.rectangle_area > 0);
		area_coefficient.real_area = area_coefficient.rectangle_height * area_coefficient.minmax_distance;
		area_coefficient.merge_count = 0;
		//density
		area_coefficient.segment_density = area_coefficient.getSegmentDensity();
		//deviation
		area_coefficient.rec_deviation = 0;

		/*=========================Special Coefficient===================*/
		//parallelogram height
		getAAndBByPLA(original_time_series, area_coefficient);
		area_coefficient.parallelogram_height = INF;
		//area_coefficient.deviation_point.id = area_coefficient.max_point.id;
		//circle radius
		area_coefficient.circle_radius = hypotl(area_coefficient.rectangle_height, area_coefficient.rectangle_width) / 2.0;
		//assert(area_coefficient.circle_radius != NULL);
		/*..............................................................*/

		/*==============Evaluate refreshSegmentCoefficient()================*/
#ifdef _DEBUG
		temp_coefficient.right_endpoint = area_coefficient.right_endpoint;
		temp_coefficient.rectangle_width = area_coefficient.rectangle_width;

		refreshSegmentCoefficient(original_time_series, temp_coefficient);

		temp_coefficient.rectangle_area = temp_coefficient.rectangle_height * temp_coefficient.rectangle_width;
		//temp_coefficient.getSegmentDensity();
		temp_coefficient.parallelogram_height = INF;
		area_coefficient.rec_deviation = temp_coefficient.rec_deviation;
		temp_coefficient.circle_radius = hypotl(temp_coefficient.rectangle_height, temp_coefficient.rectangle_width) / 2.0;
		area_coefficient.deviation_point = temp_coefficient.deviation_point;
		//cout << "area_coefficient: " << area_coefficient.segment_density << ",   temp_coefficient" << temp_coefficient.segment_density << endl;
		temp_coefficient.compareSegmentCoefficient(area_coefficient);
#endif
		/*----------------------------------------------------------------*/
		refreshSegmentCoefficient(original_time_series, area_coefficient);
		area_vector.push_back(area_coefficient);
	}

	/*for (auto&& i : area_vector) {
		cout << i.right_endpoint << " ";
	}
	cout << endl << "Min: ";
	for (auto&& i : area_vector) {
		cout << i.lowest_id << " ";
	}
	cout << endl << "Max: ";
	for (auto&& i : area_vector) {
		cout << i.heightest_id << " ";
	}
	cout << endl;*/
}

//************************************
// Method:initialRecArea0ForParallelogram
// Qualifier: intial segment for the parallelogram
// date:190404
// author:
//************************************
TEMPLATE
void APLA::initialRecArea0ForParallelogram(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector) {//190404
#ifdef _DEBUG
	assert(input_argument.time_series_length % 2 == 0);//n is even
#endif

	int initial_rectangle_num = input_argument.time_series_length / 2;//!!!!!!!!!!!!!!!!! what if time_series_length is  odd???
	AREA_COEFFICIENT area_coefficient;
	//AreaIncreasing areaIncreasing;
	output_argument.min_density_segment.value = INF;
	output_argument.min_density_segment.id = INF;

	for (int array_id = 0; array_id < initial_rectangle_num; array_id++) {
		// end point
		area_coefficient.right_endpoint = array_id * 2 + 1;
		//width
		area_coefficient.rectangle_width = 2.0;
		//sum value 190412
		area_coefficient.sum_value = original_time_series[int(area_coefficient.right_endpoint) - 1] + original_time_series[int(area_coefficient.right_endpoint)];

		getAAndBByPLA(original_time_series, area_coefficient);//Get a & b of PLA
		//refreshSegmentCoefficient(original_time_series, area_coefficient);
		refreshSegmentCoefficient0ForParallelogram(original_time_series, area_coefficient);
		//output_argument.density_min_value = min(area_coefficient.segment_density, ooutput_argument.min_density_segment.value);

		if (area_coefficient.segment_density < output_argument.min_density_segment.value) {
			output_argument.min_density_segment.value = area_coefficient.segment_density;
			output_argument.min_density_segment.id = array_id;
		}

		area_vector.push_back(area_coefficient);
	}

	/*AREA_COEFFICIENT temp_coefficient;
	area_vector*/

	/*for (auto&& i : area_vector) {
		cout << i.right_endpoint << " ";
	}
	cout << endl << "Min: ";
	for (auto&& i : area_vector) {
		cout << i.lowest_id << " ";
	}
	cout << endl << "Max: ";
	for (auto&& i : area_vector) {
		cout << i.heightest_id << " ";
	}
	cout << endl;*/
}

//************************************
// Method:initialRecArea0ForParallelogramNoPush
// Qualifier: intial segment for the parallelogramnot use vector push function, to save time
// date:190416
// author:
//************************************
TEMPLATE
void APLA::initialRecArea0ForParallelogramNoPush(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector) {//190416
#ifdef _DEBUG
	assert(input_argument.time_series_length % 2 == 0);//n is even
#endif

	int initial_rectangle_num = input_argument.time_series_length / 2;//!!!!!!!!!!!!!!!!! what if time_series_length is  odd???
	area_vector.resize(initial_rectangle_num, AREA_COEFFICIENT());

	//AREA_COEFFICIENT area_coefficient;
	//AreaIncreasing areaIncreasing;
	output_argument.min_density_segment.value = INF;
	output_argument.min_density_segment.id = INF;

	for (int array_id = 0; array_id < initial_rectangle_num; array_id++) {
		// end point
		area_vector[array_id].right_endpoint = array_id * 2 + 1;
		//width
		area_vector[array_id].rectangle_width = 2.0;
		//sum value 190412
		area_vector[array_id].sum_value = original_time_series[int(area_vector[array_id].right_endpoint) - 1] + original_time_series[int(area_vector[array_id].right_endpoint)];

		getAAndBByPLA(original_time_series, area_vector[array_id]);//Get a & b of PLA
		//refreshSegmentCoefficient(original_time_series, area_coefficient);
		refreshSegmentCoefficient0ForParallelogram(original_time_series, area_vector[array_id]);
		//output_argument.density_min_value = min(area_coefficient.segment_density, ooutput_argument.min_density_segment.value);

		if (area_vector[array_id].segment_density < output_argument.min_density_segment.value) {
			output_argument.min_density_segment.value = area_vector[array_id].segment_density;
			output_argument.min_density_segment.id = array_id;
		}

		//area_vector.push_back(area_vector);
	}
}

//************************************
// Method:initialRecArea0ForParallelogramArray
// Qualifier: intial segment for the parallelogramuse array, not vector, to save time
// date:190417
// author:
//************************************
TEMPLATE
void APLA::initialRecArea0ForParallelogramArray(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, SEGMENT_COEFFICIENT*& area_vector) {//190417
#ifdef _DEBUG
	assert(input_argument.time_series_length % 2 == 0);//n is even
#endif
	int initial_rectangle_num = input_argument.time_series_length / 2;//!!!!!!!!!!!!!!!!! what if time_series_length is  odd???
	area_vector = new SEGMENT_COEFFICIENT[initial_rectangle_num];

	//AREA_COEFFICIENT area_coefficient;
	//AreaIncreasing areaIncreasing;
	output_argument.min_density_segment.value = INF;
	output_argument.min_density_segment.id = INF;

	for (int array_id = 0; array_id < initial_rectangle_num; array_id++) {
		// end point
		area_vector[array_id].right_endpoint = array_id * 2 + 1;
		//width
		area_vector[array_id].rectangle_width = 2.0;
		//sum value 190412
		area_vector[array_id].sum_value = original_time_series[int(area_vector[array_id].right_endpoint) - 1] + original_time_series[int(area_vector[array_id].right_endpoint)];

		//================get a&b=========================
		area_vector[array_id].apla.a = (original_time_series[int(area_vector[array_id].right_endpoint)] - original_time_series[int(area_vector[array_id].right_endpoint) - 1]);
		area_vector[array_id].apla.b = original_time_series[int(area_vector[array_id].right_endpoint) - 1];
		//refreshSegmentCoefficient(original_time_series, area_coefficient);
		//================get deviation==================
		area_vector[array_id].parallelogram_height = fabs(original_time_series[int(area_vector[array_id].right_endpoint)] - original_time_series[int(area_vector[array_id].right_endpoint) - 1]);
		area_vector[array_id].rec_deviation = 0;
		//area_vector[array_id].deviation_point.id = area_vector[array_id].max_point.id;
		//output_argument.density_min_value = min(area_coefficient.segment_density, ooutput_argument.min_density_segment.value);
		/*================get Density=======================*/
		area_vector[array_id].getSegmentDensitySpeed();
		/*================get Threshhold====================*/
		if (area_vector[array_id].segment_density < output_argument.min_density_segment.value) {
			output_argument.min_density_segment.value = area_vector[array_id].segment_density;
			output_argument.min_density_segment.id = array_id;
		}
	}
}

//************************************
// Method:initialRecArea0ForParallelogramArrayVector
// Qualifier: intial segment for the parallelogramuse vectorand no sub-function to speed up
// date:190430
// author:
//************************************
TEMPLATE
void APLA::initialRecArea0ForParallelogramArrayVector(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector) {//190430 Use vector to instead Array,
#ifdef _DEBUG
	assert(input_argument.time_series_length % 2 == 0);//n is even
#endif

	int initial_rectangle_num = input_argument.time_series_length / 2;//!!!!!!!!!!!!!!!!! what if time_series_length is  odd???
	//area_vector.resize(initial_rectangle_num, AREA_COEFFICIENT());

	//AREA_COEFFICIENT area_coefficient;
	//AreaIncreasing areaIncreasing;
	//output_argument.min_density_segment.value = INF;
	//output_argument.min_density_segment.id = INF;

	/*--------------------------------------Test-----------------------------------------------*/
	priority_queue<typename GEOMETRY::POINT> min_density_queue;//190604

	typename GEOMETRY::POINT min_density_point;
	/*.........................................................................................*/

	for (int array_id = 0, segment_id = 1; array_id < initial_rectangle_num; array_id++, segment_id++) {
		// end point
		int left_id = array_id * 2;
		int right_id = area_vector[array_id].right_endpoint = left_id + 1;
		//width
		area_vector[array_id].rectangle_width = 2.0;
		//sum value 190412
		area_vector[array_id].sum_value = original_time_series[left_id] + original_time_series[right_id];
		//================get a&b=========================
		area_vector[array_id].apla.a = (original_time_series[right_id] - original_time_series[left_id]);
		area_vector[array_id].apla.b = original_time_series[left_id];
		//refreshSegmentCoefficient(original_time_series, area_coefficient);
		//================get deviation==================
		area_vector[array_id].increment_area = fabs(area_vector[array_id].apla.a);
		area_vector[array_id].parallelogram_height = area_vector[array_id].increment_area;
		//area_vector[array_id].rectangle_height = area_vector[array_id].increment_area;
		area_vector[array_id].rec_deviation = 0;
		//output_argument.density_min_value = min(area_coefficient.segment_density, ooutput_argument.min_density_segment.value);
		/*================get Density=======================*/
		area_vector[array_id].getSegmentDensitySpeed();
		/*================get Threshhold====================*/
		if (area_vector[array_id].segment_density < output_argument.min_density_segment.value) {
			output_argument.min_density_segment.value = area_vector[array_id].segment_density;
			//output_argument.min_density_segment.id = array_id;
		}

		/*------------------------------Test------------------------------------------------*/
		/*if (min_density_queue.size()<=5) {
			min_density_point.id = array_id;
			min_density_point.value = area_vector[array_id].segment_density;
			min_density_queue.push(min_density_point);
		}
		else {
		}*/
		/*..................................................................................*/

		/*================190516 Test Min&Max Section====================*/
//		int segment_left_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
//		auto[mmin, mmax] = minmax_element(original_time_series + segment_left_id, original_time_series + int(temp_coefficient.right_endpoint + 1));
//		temp_coefficient.min_point.value = *mmin;
//		temp_coefficient.max_point.value = *mmax;
//		temp_coefficient.rectangle_height = temp_coefficient.max_point.value - temp_coefficient.min_point.value;
//
//#ifdef _DEBUG
//		assert(*mmax >= *mmin);
//		assert(temp_coefficient.right_endpoint >= mmin - original_time_series && temp_coefficient.right_endpoint >= mmax - original_time_series);
//		assert(temp_coefficient.rectangle_height >= 0);
//#endif
//		//minimax id
//		temp_coefficient.min_point.id = mmin - original_time_series;
//		temp_coefficient.max_point.id = mmax - original_time_series;
//
		/*---------------------------------------------------MinMax Point------------------------------------------------------------------------------------*/
		//if (original_time_series[int(area_vector[array_id].right_endpoint - 1)] <= original_time_series[int(area_vector[array_id].right_endpoint)]) {
		//	//minmax id
		//	area_vector[array_id].min_point.id = area_vector[array_id].right_endpoint - 1;
		//	area_vector[array_id].max_point.id = area_vector[array_id].right_endpoint;
		//}
		//else {
		//	//minmax id
		//	area_vector[array_id].min_point.id = area_vector[array_id].right_endpoint;
		//	area_vector[array_id].max_point.id = area_vector[array_id].right_endpoint - 1;
		//}
		////minmax value
		//area_vector[array_id].min_point.value = original_time_series[int(area_vector[array_id].min_point.id)];
		//area_vector[array_id].max_point.value = original_time_series[int(area_vector[array_id].max_point.id)];
		/*..........................................................................................................................................*/
		//area_vector[array_id].deviation_point.id = area_vector[array_id].min_point.id;
		/*...............................................................*/
	}
}

//************************************
// Method:initialRecAreaPLAImprove
// Qualifier: initial by PLA get sum value, a, b, pla_coefficient, width, right_endpoint
// date:190606
// author:
//************************************
TEMPLATE
void APLA::initialRecAreaPLAImprove(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector) {//190606 initial by PLA
	//int segment_number = input_argument.point_dimension * 2;
	//input_argument.remainder = int(input_argument.time_series_length) % int(segment_number);//For PLA
	//double integerDividend = input_argument.time_series_length - input_argument.remainder;
	//input_argument.segment_length_second = integerDividend / segment_number;
	//input_argument.segment_length_first = input_argument.segment_length_second + 1;

#ifdef _DEBUG
	assert(input_argument.segment_length_first == input_argument.segment_length_second + 1);
#endif

	//a
	double a_first_divisor = input_argument.segment_length_second * input_argument.segment_length_first * (input_argument.segment_length_first + 1.0); //n(n-1)(n+1)
	double a_second_divisor = input_argument.segment_length_second * (input_argument.segment_length_second - 1.0) * input_argument.segment_length_first;  //n(n-1)(n+1)
	double a_first_minuend = input_argument.segment_length_second / 2.0;//(n-1)/2
	double a_second_minuend = (input_argument.segment_length_second - 1.0) / 2.0;//(n-1)/2
	  //b
	double b_first_divisor = input_argument.segment_length_first * (1.0 + input_argument.segment_length_first); //n(1+n)
	double b_second_divisor = input_argument.segment_length_second * input_argument.segment_length_first; //n(1+n)
	double b_first_minuend = 2.0 * input_argument.segment_length_first - 1.0;//2n-1
	double b_second_minuend = 2.0 * input_argument.segment_length_second - 1.0;//2n-1

	int j = 0;
	int k = 0;

	/*int account[1280];
	int* pointer = account;
	int index = 0;*/

	double a_sum = NULL;
	double b_sum = NULL;
	double t = NULL;

	//a_minuend = 0.5;//(l-1)/2
	//a_divisor = 6;//l(l-1)(l+1)
	//b_minuend = 3;//2l-1
	//b_divisor = 6;//l(l+1)

	for (int i = 1; i <= input_argument.point_dimension; i++) {
		//cout<<"i: "<<i << endl;
		a_sum = 0;
		b_sum = 0;
		t = 0;

		/*--------------------Segemnt coefficient ---------------------------------*/
		area_vector[i - 1].sum_value = 0;
		area_vector[i - 1].right_subsegment = new AREA_COEFFICIENT;
		/*........................................................................*/
		if (i <= input_argument.remainder) {//first part
			/*--------------------Segemnt coefficient ---------------------------------*/
			area_vector[i - 1].right_endpoint = i * input_argument.segment_length_first - 1;
			area_vector[i - 1].rectangle_width = input_argument.segment_length_first;
			area_vector[i - 1].apla.b_minuend = b_first_minuend;//2l-1
			area_vector[i - 1].apla.b_divisor = b_first_divisor;//l(l+1)
			//area_vector[i - 1].apla.a_minuend = (input_argument.segment_length_first - 1) / 2.0;//(l-1)/2
			area_vector[i - 1].apla.a_minuend = a_first_minuend; //(l-1)/2
			//area_vector[i - 1].apla.a_divisor = (input_argument.segment_length_first - 1) / 2.0;//l(l-1)(l+1)
			area_vector[i - 1].apla.a_divisor = a_first_divisor;//l(l-1)(l+1)
			/*.........................................................................*/
			for (j = int((i - 1) * input_argument.segment_length_first); j <= area_vector[i - 1].right_endpoint; j++) {
				//cout << "    j: "<<j << endl;
				a_sum += (t - a_first_minuend) * original_time_series[j];
				b_sum += (b_first_minuend - t * 3.0) * original_time_series[j];
				/*account[index] = j;
				index++;*/
				t++;
				//cout << "x[" << j << "] = " << x[j] << " ";
				/*--------------------Segemnt coefficient ---------------------------------*/
				area_vector[i - 1].sum_value += original_time_series[j];
				/*.........................................................................*/
			}
			//y[i - 1] = sum / input_argument.segment_length_first;
			//cout << endl << "y[" << i - 1 << "] = " << y[i - 1] << endl;
			//pla.a[i - 1] = 12.0 * a_sum / a_first_divisor;
			//pla.b[i - 1] = 2.0 * b_sum / b_first_divisor;
			area_vector[i - 1].apla.a = 12.0 * a_sum / a_first_divisor;
			area_vector[i - 1].apla.b = 2.0 * b_sum / b_first_divisor;
			//cout << endl << "v[" << i - 1 << "] = " << italicC->v[i - 1] << ", r[" << i - 1 << "] = " << italicC->r[i - 1] << endl;
			//indexOfLongSegment = input_argument.remainder;
		}
		else {//second part
			/*--------------------Segemnt coefficient ---------------------------------*/
			area_vector[i - 1].right_endpoint = input_argument.remainder + i * input_argument.segment_length_second - 1;
			area_vector[i - 1].rectangle_width = input_argument.segment_length_second;

			area_vector[i - 1].apla.b_minuend = b_second_minuend;//2l-1
			area_vector[i - 1].apla.b_divisor = b_second_divisor;//l(l+1)
			//area_vector[i - 1].apla.a_minuend = (input_argument.segment_length_first - 1) / 2.0;//(l-1)/2
			area_vector[i - 1].apla.a_minuend = a_second_minuend; //(l-1)/2
			//area_vector[i - 1].apla.a_divisor = (input_argument.segment_length_first - 1) / 2.0;//l(l-1)(l+1)
			area_vector[i - 1].apla.a_divisor = a_second_divisor;//l(l-1)(l+1)
			/*.........................................................................*/

			for (k = i - 1, j = int(input_argument.remainder + k * input_argument.segment_length_second); j <= area_vector[i - 1].right_endpoint; j++) {
				//assert(j >= 0);
				//cout << "    j: " << j << endl;
				a_sum += (t - a_second_minuend) * original_time_series[j];
				b_sum += (b_second_minuend - t * 3.0) * original_time_series[j];

				//account[index] = j;
				////cout << account[index] << endl;
				//if (index!=0) assert(account[index]-account[index-1]==1);
				//index++;
				t++;
				//cout << "x[" << j << "] = " << x[j] << " ";
				/*--------------------Segemnt coefficient ---------------------------------*/
				area_vector[i - 1].sum_value += original_time_series[j];
				/*.........................................................................*/
			}
			//cout << endl << "y[" << i - 1 << "] = " << y[i - 1] << endl;
			//pla.a[i - 1] = 12.0 * a_sum / a_second_divisor;
			//pla.b[i - 1] = 2.0 * b_sum / b_second_divisor;
			area_vector[i - 1].apla.a = 12.0 * a_sum / a_second_divisor;
			area_vector[i - 1].apla.b = 2.0 * b_sum / b_second_divisor;
			//cout << endl << "v[" << i - 1 << "] = " << italicC->v[i - 1] << ", r[" << i - 1 << "] = " << italicC->r[i - 1] << endl;
		}
	}

	/*for (auto&&i : pla) {190501
		cout << *i.a<<" "<< *i.b << endl;
	}*/

	//for (int i = 1; i < 1280; i++) {
	//	//cout << test_array[i] << ", ";
	//	assert(account[i] - account[i - 1] == 1);
	//	//assert(test_array[i+1]- test_array[i]==1);

	//}
	//cout << endl;
	/*APCA_KNN_QUAL::printArray(pointer,1280);*/
}

//************************************
// Method:initialAPLARightEndpoint
// Qualifier: a,b,width,right_endpoint,apla_coefficient, sum_value
// date:190617
// author:
//************************************
TEMPLATE
void APLA::initialAPLARightEndpoint(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector) {//190617 Use minmax point as right endpoint
	//int segment_number = input_argument.point_dimension * 2;
	//input_argument.remainder = int(input_argument.time_series_length) % int(segment_number);//For PLA
	//double integerDividend = input_argument.time_series_length - input_argument.remainder;
	//input_argument.segment_length_second = integerDividend / segment_number;
	//input_argument.segment_length_first = input_argument.segment_length_second + 1;

#ifdef _DEBUG
	assert(input_argument.segment_length_first == input_argument.segment_length_second + 1);
#endif

	int j = 0;//original id
	int k = 0;
	int original_id = 0;//190617
	int zero_id = NULL;//190617 [0,segment_len-1]

	for (int i = 1; i <= input_argument.point_dimension; i++) {//get right endpoint and width
		zero_id = 0;
		area_vector[i - 1].min_point.id = INF;
		area_vector[i - 1].min_point.value = INF;
		area_vector[i - 1].max_point.id = -INF;
		area_vector[i - 1].max_point.value = -INF;
		area_vector[i - 1].right_subsegment = new AREA_COEFFICIENT;
		area_vector[i - 1].sum_value = 0;
		double min_sum_value = 0;
		double max_sum_value = 0;
		if (i <= input_argument.remainder) {//first part
			/*--------------------Segemnt coefficient ---------------------------------*/
			area_vector[i - 1].right_endpoint = i * input_argument.segment_length_first - 1;
			/*.........................................................................*/
			for (original_id = int((i - 1) * input_argument.segment_length_first); original_id <= area_vector[i - 1].right_endpoint; original_id++) {
				//cout << "    original_id: "<<original_id << endl;
				/*---------------------------------Get minmax point of every segment----------------------------------------------*/
				if (area_vector[i - 1].min_point.value > original_time_series[original_id]) {
					area_vector[i - 1].min_point.value = original_time_series[original_id];
					area_vector[i - 1].min_point.id = original_id;
				}
				if (area_vector[i - 1].max_point.value < original_time_series[original_id]) {
					area_vector[i - 1].max_point.value = original_time_series[original_id];
					area_vector[i - 1].max_point.id = original_id;
				}
				/*................................................................................................................*/
			}
			/*-----------------------------Segment Coefficient--------------------------------------------------------*/
#ifdef _DEBUG
			assert(area_vector[i - 1].min_point.id <= area_vector[i - 1].right_endpoint && area_vector[i - 1].max_point.id <= area_vector[i - 1].right_endpoint);
			if (i > 1) {
				assert(area_vector[i - 1].min_point.id > area_vector[i - 2].right_endpoint && area_vector[i - 1].max_point.id > area_vector[i - 2].right_endpoint);
			}
#endif
			if (i < input_argument.remainder) {
				area_vector[i - 1].right_endpoint = max(area_vector[i - 1].min_point.id, area_vector[i - 1].max_point.id);
			}

			if (i > 1) {
				area_vector[i - 1].rectangle_width = area_vector[i - 1].right_endpoint - area_vector[i - 2].right_endpoint;
			}
			else {
				area_vector[i - 1].rectangle_width = area_vector[i - 1].right_endpoint + 1;
			}

#ifdef _DEBUG
			assert(original_id == i * input_argument.segment_length_first);
#endif
			/*.......................................................................................................*/
		}
		else {
			/*--------------------Segemnt coefficient ---------------------------------*/
			area_vector[i - 1].right_endpoint = input_argument.remainder + i * input_argument.segment_length_second - 1;
			/*.........................................................................*/
			for (k = i - 1, original_id = int(input_argument.remainder + k * input_argument.segment_length_second); original_id <= area_vector[i - 1].right_endpoint; original_id++) {
				//assert(original_id >= 0);
				//cout << "    original_id: " << original_id << endl;
				/*---------------------------------Get minmax point of every segment----------------------------------------------*/
				if (area_vector[i - 1].min_point.value > original_time_series[original_id]) {
					area_vector[i - 1].min_point.value = original_time_series[original_id];
					area_vector[i - 1].min_point.id = original_id;
				}
				if (area_vector[i - 1].max_point.value < original_time_series[original_id]) {
					area_vector[i - 1].max_point.value = original_time_series[original_id];
					area_vector[i - 1].max_point.id = original_id;
				}
				/*................................................................................................................*/
				//account[index] = original_id;
				////cout << account[index] << endl;
				//if (index!=0) assert(account[index]-account[index-1]==1);
				//index++;
				//cout << "x[" << original_id << "] = " << x[original_id] << " ";
				/*--------------------Segemnt coefficient ---------------------------------*/
				//area_vector[i - 1].sum_value += original_time_series[original_id];
				/*.........................................................................*/
			}
			/*-----------------------------Segment Coefficient--------------------------------------------------------*/
#ifdef _DEBUG
			assert(area_vector[i - 1].min_point.id <= area_vector[i - 1].right_endpoint && area_vector[i - 1].max_point.id <= area_vector[i - 1].right_endpoint);
			if (i > 1) {
				assert(area_vector[i - 1].min_point.id > area_vector[i - 2].right_endpoint && area_vector[i - 1].max_point.id > area_vector[i - 2].right_endpoint);
			}
#endif
			if (i < input_argument.remainder) {
				area_vector[i - 1].right_endpoint = max(area_vector[i - 1].min_point.id, area_vector[i - 1].max_point.id);
			}
			if (i > 1) {
				area_vector[i - 1].rectangle_width = area_vector[i - 1].right_endpoint - area_vector[i - 2].right_endpoint;
			}
			else {
				area_vector[i - 1].rectangle_width = area_vector[i - 1].right_endpoint + 1;
			}
#ifdef _DEBUG
			assert(original_id == i * input_argument.segment_length_second);
#endif
			/*.......................................................................................................*/
		}
#ifdef _DEBUG
		assert(area_vector[i - 1].max_point.id != area_vector[i - 1].min_point.id && area_vector[i - 1].max_point.value != area_vector[i - 1].min_point.value);
#endif
	}

	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	getPLAByAdaptiveSegment(input_argument, original_time_series, area_vector);//190617 sum_value, a, b, apla_coefficient
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	////a
	//double a_first_divisor = input_argument.segment_length_second * input_argument.segment_length_first*(input_argument.segment_length_first + 1.0); //n(n-1)(n+1)
	//double a_second_divisor = input_argument.segment_length_second * (input_argument.segment_length_second - 1.0)*input_argument.segment_length_first;  //n(n-1)(n+1)
	//double a_first_minuend = input_argument.segment_length_second / 2.0;//(n-1)/2
	//double a_second_minuend = (input_argument.segment_length_second - 1.0) / 2.0;//(n-1)/2
	//  //b
	//double b_first_divisor = input_argument.segment_length_first * (1.0 + input_argument.segment_length_first); //n(1+n)
	//double b_second_divisor = input_argument.segment_length_second * input_argument.segment_length_first; //n(1+n)
	//double b_first_minuend = 2.0*input_argument.segment_length_first - 1.0;//2n-1
	//double b_second_minuend = 2.0*input_argument.segment_length_second - 1.0;//2n-1

	//

	///*int account[1280];
	//int* pointer = account;
	//int index = 0;*/

	//double a_sum = NULL;
	//double b_sum = NULL;
	//double t = NULL;

	////a_minuend = 0.5;//(l-1)/2
	////a_divisor = 6;//l(l-1)(l+1)
	////b_minuend = 3;//2l-1
	////b_divisor = 6;//l(l+1)

	//for (int i = 1; i <= input_argument.point_dimension; i++) {
	//	//cout<<"i: "<<i << endl;
	//	a_sum = 0;
	//	b_sum = 0;
	//	t = 0;

	//	/*--------------------Segemnt coefficient ---------------------------------*/
	//	area_vector[i - 1].sum_value = 0;
	//	area_vector[i - 1].right_subsegment = new AREA_COEFFICIENT;
	//	/*........................................................................*/
	//	if (i <= input_argument.remainder) {//first part
	//		/*--------------------Segemnt coefficient ---------------------------------*/
	//		area_vector[i - 1].right_endpoint = i * input_argument.segment_length_first - 1;
	//		area_vector[i - 1].rectangle_width = input_argument.segment_length_first;
	//		area_vector[i - 1].apla.b_minuend = b_first_minuend;//2l-1
	//		area_vector[i - 1].apla.b_divisor = b_first_divisor;//l(l+1)
	//		//area_vector[i - 1].apla.a_minuend = (input_argument.segment_length_first - 1) / 2.0;//(l-1)/2
	//		area_vector[i - 1].apla.a_minuend = a_first_minuend; //(l-1)/2
	//		//area_vector[i - 1].apla.a_divisor = (input_argument.segment_length_first - 1) / 2.0;//l(l-1)(l+1)
	//		area_vector[i - 1].apla.a_divisor = a_first_divisor;//l(l-1)(l+1)
	//		/*.........................................................................*/
	//		for (j = int((i - 1) * input_argument.segment_length_first); j <= area_vector[i - 1].right_endpoint; j++) {
	//			//cout << "    j: "<<j << endl;
	//			a_sum += (t - a_first_minuend)*original_time_series[j];
	//			b_sum += (b_first_minuend - t * 3.0)*original_time_series[j];
	//			/*account[index] = j;
	//			index++;*/
	//			t++;
	//			//cout << "x[" << j << "] = " << x[j] << " ";
	//			/*--------------------Segemnt coefficient ---------------------------------*/
	//			area_vector[i - 1].sum_value += original_time_series[j];
	//			/*.........................................................................*/
	//		}
	//		//y[i - 1] = sum / input_argument.segment_length_first;
	//		//cout << endl << "y[" << i - 1 << "] = " << y[i - 1] << endl;
	//		//pla.a[i - 1] = 12.0 * a_sum / a_first_divisor;
	//		//pla.b[i - 1] = 2.0 * b_sum / b_first_divisor;
	//		area_vector[i - 1].apla.a = 12.0 * a_sum / a_first_divisor;
	//		area_vector[i - 1].apla.b = 2.0 * b_sum / b_first_divisor;
	//		//cout << endl << "v[" << i - 1 << "] = " << italicC->v[i - 1] << ", r[" << i - 1 << "] = " << italicC->r[i - 1] << endl;
	//		//indexOfLongSegment = input_argument.remainder;

	//	}
	//	else {//second part
	//		/*--------------------Segemnt coefficient ---------------------------------*/
	//		area_vector[i - 1].right_endpoint = input_argument.remainder + i * input_argument.segment_length_second - 1;
	//		area_vector[i - 1].rectangle_width = input_argument.segment_length_second;

	//		area_vector[i - 1].apla.b_minuend = b_second_minuend;//2l-1
	//		area_vector[i - 1].apla.b_divisor = b_second_divisor;//l(l+1)
	//		//area_vector[i - 1].apla.a_minuend = (input_argument.segment_length_first - 1) / 2.0;//(l-1)/2
	//		area_vector[i - 1].apla.a_minuend = a_second_minuend; //(l-1)/2
	//		//area_vector[i - 1].apla.a_divisor = (input_argument.segment_length_first - 1) / 2.0;//l(l-1)(l+1)
	//		area_vector[i - 1].apla.a_divisor = a_second_divisor;//l(l-1)(l+1)
	//		/*.........................................................................*/

	//		for (k = i - 1, j = int(input_argument.remainder + k * input_argument.segment_length_second); j <= area_vector[i - 1].right_endpoint; j++) {
	//			//assert(j >= 0);
	//			//cout << "    j: " << j << endl;
	//			a_sum += (t - a_second_minuend) * original_time_series[j];
	//			b_sum += (b_second_minuend - t * 3.0)*original_time_series[j];

	//			//account[index] = j;
	//			////cout << account[index] << endl;
	//			//if (index!=0) assert(account[index]-account[index-1]==1);
	//			//index++;
	//			t++;
	//			//cout << "x[" << j << "] = " << x[j] << " ";
	//			/*--------------------Segemnt coefficient ---------------------------------*/
	//			area_vector[i - 1].sum_value += original_time_series[j];
	//			/*.........................................................................*/
	//		}
	//		//cout << endl << "y[" << i - 1 << "] = " << y[i - 1] << endl;
	//		//pla.a[i - 1] = 12.0 * a_sum / a_second_divisor;
	//		//pla.b[i - 1] = 2.0 * b_sum / b_second_divisor;
	//		area_vector[i - 1].apla.a = 12.0 * a_sum / a_second_divisor;
	//		area_vector[i - 1].apla.b = 2.0 * b_sum / b_second_divisor;
	//		//cout << endl << "v[" << i - 1 << "] = " << italicC->v[i - 1] << ", r[" << i - 1 << "] = " << italicC->r[i - 1] << endl;
	//	}
	//}

	/*for (auto&&i : pla) {190501
		cout << *i.a<<" "<< *i.b << endl;
	}*/

	//for (int i = 1; i < 1280; i++) {
	//	//cout << test_array[i] << ", ";
	//	assert(account[i] - account[i - 1] == 1);
	//	//assert(test_array[i+1]- test_array[i]==1);

	//}
	//cout << endl;
	/*APCA_KNN_QUAL::printArray(pointer,1280);*/
}

//************************************
// Method:initialAPLARightEndpoint3Sub
// Qualifier: a,b,width,right_endpoint,apla_coefficient, sum_value. Split segment into 3 sub-segment by minmax point
// date:190617 16:45
// author:
//************************************
TEMPLATE
void APLA::initialAPLARightEndpoint3Sub(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector) {//190617 16:31 Use minmax point split segment into 3 subsegment
	//int segment_number = input_argument.point_dimension * 2;
	//input_argument.remainder = int(input_argument.time_series_length) % int(segment_number);//For PLA
	//double integerDividend = input_argument.time_series_length - input_argument.remainder;
	//input_argument.segment_length_second = integerDividend / segment_number;
	//input_argument.segment_length_first = input_argument.segment_length_second + 1;

#ifdef _DEBUG
	assert(input_argument.segment_length_first == input_argument.segment_length_second + 1);
	assert(input_argument.segment_length_first > 2);
#endif

	int j = 0;//original id
	int k = 0;
	int original_id = 0;//190617
	int zero_id = NULL;//190617 [0,segment_len-1]

	for (int i = 1; i <= input_argument.point_dimension; i++) {//get right endpoint and width
		zero_id = 0;

		int sub_id1 = i * 3 - 3;
		int sub_id2 = i * 3 - 2;
		int sub_id3 = i * 3 - 1;
		int segment_id = i * 3 - 1;
		area_vector[segment_id].min_point.id = INF;
		area_vector[segment_id].min_point.value = INF;
		area_vector[segment_id].max_point.id = -INF;
		area_vector[segment_id].max_point.value = -INF;
		area_vector[segment_id].right_subsegment = new AREA_COEFFICIENT;
		area_vector[sub_id2].right_subsegment = new AREA_COEFFICIENT;
		area_vector[sub_id1].right_subsegment = new AREA_COEFFICIENT;
		area_vector[segment_id].sum_value = 0;
		//double min_sum_value = 0;
		//double max_sum_value = 0;

		if (i <= input_argument.remainder) {//first part
			/*------------------------Right endpoint ---------------------------------*/
			area_vector[segment_id].right_endpoint = i * input_argument.segment_length_first - 1;
			/*.........................................................................*/

			for (original_id = int((i - 1) * input_argument.segment_length_first); original_id <= area_vector[segment_id].right_endpoint; original_id++) {
				//cout<<original_id<<": "<< original_time_series[original_id]<<", ";
				/*---------------------------------Get minmax point of every segment----------------------------------------------*/
				if (area_vector[segment_id].min_point.value >= original_time_series[original_id]) {
					area_vector[segment_id].min_point.value = original_time_series[original_id];
					area_vector[segment_id].min_point.id = original_id;
				}
				if (area_vector[segment_id].max_point.value <= original_time_series[original_id]) {
					area_vector[segment_id].max_point.value = original_time_series[original_id];
					area_vector[segment_id].max_point.id = original_id;
				}
				/*................................................................................................................*/
			}
			//cout << endl;
			/*-----------------------------Segment Coefficient--------------------------------------------------------*/
#ifdef _DEBUG
			assert(original_id == i * input_argument.segment_length_first);//original_id final is equal to right_endpoint
#endif
			/*.......................................................................................................*/
		}
		else {
			/*------------------------Right endpoint ---------------------------------*/
			area_vector[segment_id].right_endpoint = input_argument.remainder + i * input_argument.segment_length_second - 1;
			/*.........................................................................*/

			for (k = i - 1, original_id = int(input_argument.remainder + k * input_argument.segment_length_second); original_id <= area_vector[segment_id].right_endpoint; original_id++) {
				//assert(original_id >= 0);
				//cout<<original_id<<": "<< original_time_series[original_id]<<", ";
				/*---------------------------------Get minmax point of every segment----------------------------------------------*/
				if (area_vector[segment_id].min_point.value >= original_time_series[original_id]) {
					area_vector[segment_id].min_point.value = original_time_series[original_id];
					area_vector[segment_id].min_point.id = original_id;
				}
				if (area_vector[segment_id].max_point.value <= original_time_series[original_id]) {
					area_vector[segment_id].max_point.value = original_time_series[original_id];
					area_vector[segment_id].max_point.id = original_id;
				}
				/*................................................................................................................*/
			}
			//cout << endl;
			/*-----------------------------Segment Coefficient--------------------------------------------------------*/
#ifdef _DEBUG
			assert(original_id == input_argument.remainder + i * input_argument.segment_length_second);//original_id final is equal to right_endpoint
#endif
			/*.......................................................................................................*/
		}
		/*-----------------------------------------------------------------------------------------------------------------------------------------------------*/
		/*=========================================================================================================================================================*/
		if (area_vector[segment_id].max_point.id != area_vector[segment_id].min_point.id && area_vector[segment_id].max_point.value != area_vector[segment_id].min_point.value) {
			area_vector[sub_id1].right_endpoint = min(area_vector[segment_id].min_point.id, area_vector[segment_id].max_point.id);
			area_vector[sub_id2].right_endpoint = max(area_vector[segment_id].min_point.id, area_vector[segment_id].max_point.id);

			area_vector[segment_id].rectangle_width = area_vector[segment_id].right_endpoint - area_vector[sub_id2].right_endpoint;
			area_vector[sub_id2].rectangle_width = area_vector[sub_id2].right_endpoint - area_vector[sub_id1].right_endpoint;

			if (i > 1) {
				area_vector[sub_id1].rectangle_width = area_vector[sub_id1].right_endpoint - area_vector[sub_id1 - 1].right_endpoint;
			}
			else {
				area_vector[sub_id1].rectangle_width = area_vector[sub_id1].right_endpoint + 1;
			}

			//cout << "first right_endpoint: " << area_vector[sub_id1].right_endpoint << " " << area_vector[sub_id2].right_endpoint << " " << area_vector[segment_id].right_endpoint << endl;
			//cout << "width:     " << area_vector[sub_id1].rectangle_width << " " << area_vector[sub_id2].rectangle_width << " " << area_vector[segment_id].rectangle_width << endl;
			if (area_vector[segment_id].rectangle_width == 0) {
				//area_vector[segment_id] = area_vector[sub_id2];
				area_vector[segment_id].right_endpoint = area_vector[sub_id2].right_endpoint;// .at(0);
				area_vector[segment_id].rectangle_width = area_vector[sub_id2].rectangle_width;// .at(0);
				area_vector[sub_id2].right_endpoint = INF;// .at(0);
				area_vector[sub_id2].rectangle_width = INF;// .at(0);
			}

			if (area_vector[segment_id].rectangle_width == 1) {
				if (area_vector[sub_id2].rectangle_width != INF && area_vector[sub_id2].right_endpoint != INF) {
					area_vector[segment_id].rectangle_width = area_vector[sub_id2].rectangle_width + 1;// .at(0);
					//area_vector.erase(area_vector.begin() + sub_id2);
					area_vector[sub_id2].right_endpoint = INF;// .at(0);
					area_vector[sub_id2].rectangle_width = INF;// .at(0);
				}
				else {
					area_vector[segment_id].rectangle_width = area_vector[sub_id1].rectangle_width + 1;// .at(0);
					area_vector[sub_id1].right_endpoint = INF;// .at(0);
					area_vector[sub_id1].rectangle_width = INF;// .at(0);
				}
			}

#ifdef _DEBUG
			assert(area_vector[segment_id].rectangle_width > 1);
#endif
			if (area_vector[sub_id2].rectangle_width == 0) {
				assert(0);
				area_vector[sub_id2].right_endpoint = INF;// .at(0);
				area_vector[sub_id2].rectangle_width = INF;// .at(0);
			}
			if (area_vector[sub_id2].rectangle_width == 1) {
				area_vector[segment_id].rectangle_width++;
				//area_vector.erase(area_vector.begin() + sub_id2);
				area_vector[sub_id2].right_endpoint = INF;// .at(0);
				area_vector[sub_id2].rectangle_width = INF;// .at(0);
			}

#ifdef _DEBUG
			assert(area_vector[sub_id2].rectangle_width > 1);
#endif
			if (area_vector[sub_id1].rectangle_width == 1) {
				if (area_vector[sub_id2].rectangle_width != INF && area_vector[sub_id2].right_endpoint != INF) {
					area_vector[sub_id2].rectangle_width++;
				}
				else {
					area_vector[segment_id].rectangle_width++;
				}

				//area_vector.erase(area_vector.begin() + sub_id1);
				area_vector[sub_id1].right_endpoint = INF;// .at(0);
				area_vector[sub_id1].rectangle_width = INF;// .at(0);
			}

			if (area_vector[sub_id1].rectangle_width == 0) {
				assert(0);
				area_vector[sub_id2] = area_vector[sub_id2];
				area_vector[sub_id2].right_endpoint = INF;// .at(0);
				area_vector[sub_id2].rectangle_width = INF;// .at(0);
			}
		}
		else {
			if (i > 1) {
				area_vector[segment_id].rectangle_width = area_vector[segment_id].right_endpoint - area_vector[segment_id - 3].right_endpoint;
			}
			else {
				area_vector[segment_id].rectangle_width = area_vector[segment_id].right_endpoint + 1;
			}

			area_vector[sub_id2].right_endpoint = INF;// .at(0);
			area_vector[sub_id2].rectangle_width = INF;// .at(0);
			area_vector[sub_id1].right_endpoint = INF;// .at(0);
			area_vector[sub_id1].rectangle_width = INF;// .at(0);
		}
		/*.......................................................................................................................................................................*/
#ifdef _DEBUG
		assert(area_vector[sub_id1].rectangle_width > 0 && area_vector[sub_id2].rectangle_width > 0 && area_vector[segment_id].rectangle_width > 0);
		assert(area_vector[segment_id].min_point.id <= area_vector[segment_id].right_endpoint && area_vector[segment_id].max_point.id <= area_vector[segment_id].right_endpoint);
		/*if (i > 1) {
			assert(area_vector[segment_id].min_point.id >= area_vector[segment_id - 1].right_endpoint || area_vector[segment_id].max_point.id >= area_vector[segment_id - 1].right_endpoint);
		}*/
#endif
#ifdef _DEBUG
		//assert(area_vector[segment_id].max_point.id != area_vector[segment_id].min_point.id && area_vector[segment_id].max_point.value != area_vector[segment_id].min_point.value);
		assert(area_vector[sub_id1].rectangle_width > 1 && area_vector[sub_id2].rectangle_width > 1 && area_vector[segment_id].rectangle_width > 1);
#endif

		area_vector[segment_id].min_point.id = INF;
		area_vector[segment_id].min_point.value = INF;
		area_vector[segment_id].max_point.id = -INF;
		area_vector[segment_id].max_point.value = -INF;
	}

	area_vector.erase(std::remove_if(area_vector.begin(), area_vector.end(), [](AREA_COEFFICIENT& i) { return i.right_endpoint == INF && i.rectangle_width == INF; }), area_vector.end());
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	getPLAByAdaptiveSegment(input_argument, original_time_series, area_vector);//190617 sum_value, a, b, apla_coefficient
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	////a
	//double a_first_divisor = input_argument.segment_length_second * input_argument.segment_length_first*(input_argument.segment_length_first + 1.0); //n(n-1)(n+1)
	//double a_second_divisor = input_argument.segment_length_second * (input_argument.segment_length_second - 1.0)*input_argument.segment_length_first;  //n(n-1)(n+1)
	//double a_first_minuend = input_argument.segment_length_second / 2.0;//(n-1)/2
	//double a_second_minuend = (input_argument.segment_length_second - 1.0) / 2.0;//(n-1)/2
	//  //b
	//double b_first_divisor = input_argument.segment_length_first * (1.0 + input_argument.segment_length_first); //n(1+n)
	//double b_second_divisor = input_argument.segment_length_second * input_argument.segment_length_first; //n(1+n)
	//double b_first_minuend = 2.0*input_argument.segment_length_first - 1.0;//2n-1
	//double b_second_minuend = 2.0*input_argument.segment_length_second - 1.0;//2n-1

	//

	///*int account[1280];
	//int* pointer = account;
	//int index = 0;*/

	//double a_sum = NULL;
	//double b_sum = NULL;
	//double t = NULL;

	////a_minuend = 0.5;//(l-1)/2
	////a_divisor = 6;//l(l-1)(l+1)
	////b_minuend = 3;//2l-1
	////b_divisor = 6;//l(l+1)

	//for (int i = 1; i <= input_argument.point_dimension; i++) {
	//	//cout<<"i: "<<i << endl;
	//	a_sum = 0;
	//	b_sum = 0;
	//	t = 0;

	//	/*--------------------Segemnt coefficient ---------------------------------*/
	//	area_vector[i - 1].sum_value = 0;
	//	area_vector[i - 1].right_subsegment = new AREA_COEFFICIENT;
	//	/*........................................................................*/
	//	if (i <= input_argument.remainder) {//first part
	//		/*--------------------Segemnt coefficient ---------------------------------*/
	//		area_vector[i - 1].right_endpoint = i * input_argument.segment_length_first - 1;
	//		area_vector[i - 1].rectangle_width = input_argument.segment_length_first;
	//		area_vector[i - 1].apla.b_minuend = b_first_minuend;//2l-1
	//		area_vector[i - 1].apla.b_divisor = b_first_divisor;//l(l+1)
	//		//area_vector[i - 1].apla.a_minuend = (input_argument.segment_length_first - 1) / 2.0;//(l-1)/2
	//		area_vector[i - 1].apla.a_minuend = a_first_minuend; //(l-1)/2
	//		//area_vector[i - 1].apla.a_divisor = (input_argument.segment_length_first - 1) / 2.0;//l(l-1)(l+1)
	//		area_vector[i - 1].apla.a_divisor = a_first_divisor;//l(l-1)(l+1)
	//		/*.........................................................................*/
	//		for (j = int((i - 1) * input_argument.segment_length_first); j <= area_vector[i - 1].right_endpoint; j++) {
	//			//cout << "    j: "<<j << endl;
	//			a_sum += (t - a_first_minuend)*original_time_series[j];
	//			b_sum += (b_first_minuend - t * 3.0)*original_time_series[j];
	//			/*account[index] = j;
	//			index++;*/
	//			t++;
	//			//cout << "x[" << j << "] = " << x[j] << " ";
	//			/*--------------------Segemnt coefficient ---------------------------------*/
	//			area_vector[i - 1].sum_value += original_time_series[j];
	//			/*.........................................................................*/
	//		}
	//		//y[i - 1] = sum / input_argument.segment_length_first;
	//		//cout << endl << "y[" << i - 1 << "] = " << y[i - 1] << endl;
	//		//pla.a[i - 1] = 12.0 * a_sum / a_first_divisor;
	//		//pla.b[i - 1] = 2.0 * b_sum / b_first_divisor;
	//		area_vector[i - 1].apla.a = 12.0 * a_sum / a_first_divisor;
	//		area_vector[i - 1].apla.b = 2.0 * b_sum / b_first_divisor;
	//		//cout << endl << "v[" << i - 1 << "] = " << italicC->v[i - 1] << ", r[" << i - 1 << "] = " << italicC->r[i - 1] << endl;
	//		//indexOfLongSegment = input_argument.remainder;

	//	}
	//	else {//second part
	//		/*--------------------Segemnt coefficient ---------------------------------*/
	//		area_vector[i - 1].right_endpoint = input_argument.remainder + i * input_argument.segment_length_second - 1;
	//		area_vector[i - 1].rectangle_width = input_argument.segment_length_second;

	//		area_vector[i - 1].apla.b_minuend = b_second_minuend;//2l-1
	//		area_vector[i - 1].apla.b_divisor = b_second_divisor;//l(l+1)
	//		//area_vector[i - 1].apla.a_minuend = (input_argument.segment_length_first - 1) / 2.0;//(l-1)/2
	//		area_vector[i - 1].apla.a_minuend = a_second_minuend; //(l-1)/2
	//		//area_vector[i - 1].apla.a_divisor = (input_argument.segment_length_first - 1) / 2.0;//l(l-1)(l+1)
	//		area_vector[i - 1].apla.a_divisor = a_second_divisor;//l(l-1)(l+1)
	//		/*.........................................................................*/

	//		for (k = i - 1, j = int(input_argument.remainder + k * input_argument.segment_length_second); j <= area_vector[i - 1].right_endpoint; j++) {
	//			//assert(j >= 0);
	//			//cout << "    j: " << j << endl;
	//			a_sum += (t - a_second_minuend) * original_time_series[j];
	//			b_sum += (b_second_minuend - t * 3.0)*original_time_series[j];

	//			//account[index] = j;
	//			////cout << account[index] << endl;
	//			//if (index!=0) assert(account[index]-account[index-1]==1);
	//			//index++;
	//			t++;
	//			//cout << "x[" << j << "] = " << x[j] << " ";
	//			/*--------------------Segemnt coefficient ---------------------------------*/
	//			area_vector[i - 1].sum_value += original_time_series[j];
	//			/*.........................................................................*/
	//		}
	//		//cout << endl << "y[" << i - 1 << "] = " << y[i - 1] << endl;
	//		//pla.a[i - 1] = 12.0 * a_sum / a_second_divisor;
	//		//pla.b[i - 1] = 2.0 * b_sum / b_second_divisor;
	//		area_vector[i - 1].apla.a = 12.0 * a_sum / a_second_divisor;
	//		area_vector[i - 1].apla.b = 2.0 * b_sum / b_second_divisor;
	//		//cout << endl << "v[" << i - 1 << "] = " << italicC->v[i - 1] << ", r[" << i - 1 << "] = " << italicC->r[i - 1] << endl;
	//	}
	//}

	/*for (auto&&i : pla) {190501
		cout << *i.a<<" "<< *i.b << endl;
	}*/

	//for (int i = 1; i < 1280; i++) {
	//	//cout << test_array[i] << ", ";
	//	assert(account[i] - account[i - 1] == 1);
	//	//assert(test_array[i+1]- test_array[i]==1);

	//}
	//cout << endl;
	/*APCA_KNN_QUAL::printArray(pointer,1280);*/
}

//************************************
// Method:initialAPLARightEndpoint3SubAdaptive
// Qualifier: a,b,width,right_endpoint,apla_coefficient, sum_value. Split segment into 3 sub-segment by minmax point
//190627 16:38 Use minmax point split segment into 3 subsegment, when minmax points at endpoint, not merge.
// date:190705 11:38
// author:
//************************************
TEMPLATE
void APLA::initialAPLARightEndpoint3SubAdaptive(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector) {//190705 11:31 Use minmax point split segment into 3 subsegment, for flat stream, use few segments, for drastic change, use more segments
	//int segment_number = input_argument.point_dimension * 2;
	//input_argument.remainder = int(input_argument.time_series_length) % int(segment_number);//For PLA
	//double integerDividend = input_argument.time_series_length - input_argument.remainder;
	//input_argument.segment_length_second = integerDividend / segment_number;
	//input_argument.segment_length_first = input_argument.segment_length_second + 1;

#ifdef _DEBUG
	assert(input_argument.segment_length_first == input_argument.segment_length_second + 1);
	assert(input_argument.segment_length_first > 2);
#endif

	int j = 0;//original id
	int k = 0;
	int original_id = 0;//190617
	int zero_id = NULL;//190617 [0,segment_len-1]

	vector<AREA_COEFFICIENT> result_area_vector;

	AREA_COEFFICIENT segment_1;
	AREA_COEFFICIENT segment_2;
	AREA_COEFFICIENT segment_3;

	int segment_left_id = 0;
	int pre_segment_number = 0;
	int pre_right_endpoint = -1;

	int segment_size = area_vector.size();
	//int sub_segment_1;
	//int sub_segment_2;
	//int sub_segment_3;

	int rest_time_series_length = input_argument.time_series_length;

	while (pre_right_endpoint < input_argument.time_series_length - 1 && segment_size > 0) {
#ifdef _DEBUG
		assert(pre_right_endpoint < input_argument.time_series_length);
#endif
		rest_time_series_length = input_argument.time_series_length - (pre_right_endpoint + 1);
		int max_size = floor(rest_time_series_length / 2);
		if (segment_size > max_size) segment_size = max_size;
		auto remainder = rest_time_series_length % segment_size;//For PLA
		auto segment_width_second = (rest_time_series_length - remainder) / segment_size;
		auto segment_width_first = segment_width_second + 1;
		/*-----------------------if max size or segment size == 1 or 2-----------------------------*/
		if (max_size == 1) {
			segment_size -= 1;
			segment_1.right_endpoint = input_argument.time_series_length - 1;
#ifdef _DEBUG
			assert(pre_right_endpoint + 2 == input_argument.time_series_length - 1);
#endif
			segment_1.rectangle_width = 2;
			result_area_vector.emplace_back(segment_1);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
			pre_right_endpoint = result_area_vector.back().right_endpoint;
#ifdef _DEBUG
			assert(pre_right_endpoint == input_argument.time_series_length - 1);
#endif
			continue;
		}

		if (max_size == 2) {
			segment_size -= 2;
			segment_1.right_endpoint = pre_right_endpoint + 2;
			segment_2.right_endpoint = input_argument.time_series_length - 1;
			segment_1.rectangle_width = 2;
			segment_2.rectangle_width = segment_2.right_endpoint - segment_1.right_endpoint;

			result_area_vector.emplace_back(segment_1);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
			result_area_vector.emplace_back(segment_2);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
			pre_right_endpoint = result_area_vector.back().right_endpoint;
#ifdef _DEBUG
			assert(pre_right_endpoint < input_argument.time_series_length);
#endif
			continue;
		}

		if (segment_size == 1) {
			segment_size -= 1;
			segment_1.right_endpoint = input_argument.time_series_length - 1;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;

			result_area_vector.emplace_back(segment_1);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
			pre_right_endpoint = result_area_vector.back().right_endpoint;
#ifdef _DEBUG
			assert(pre_right_endpoint < input_argument.time_series_length);
			assert(segment_1.rectangle_width > 1);
#endif
			continue;
		}

		if (segment_size == 2) {
			segment_size -= 2;
			segment_2.right_endpoint = input_argument.time_series_length - 1;
			segment_2.rectangle_width = max_size;
			segment_1.right_endpoint = segment_2.right_endpoint - segment_2.rectangle_width;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;
#ifdef _DEBUG
			assert(segment_1.rectangle_width == rest_time_series_length - max_size);
			assert(segment_1.right_endpoint == segment_1.rectangle_width + pre_right_endpoint);
#endif
			result_area_vector.emplace_back(segment_1);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
			result_area_vector.emplace_back(segment_2);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
			pre_right_endpoint = result_area_vector.back().right_endpoint;
#ifdef _DEBUG
			assert(segment_1.rectangle_width > 1);
			assert(pre_right_endpoint < input_argument.time_series_length);
			assert(segment_1.rectangle_width > 1);
#endif
			continue;
		}
		/*......................................................................................................*/

		segment_size -= 3;

#ifdef _DEBUG
		assert(segment_width_second > 1 && segment_size > -1);
#endif

		//segment_1.right_subsegment = new AREA_COEFFICIENT;
		//segment_2.right_subsegment = new AREA_COEFFICIENT;
		//segment_3.right_subsegment = new AREA_COEFFICIENT;
		segment_3.min_point.id = INF;
		segment_3.min_point.value = INF;
		segment_3.max_point.id = -INF;
		segment_3.max_point.value = -INF;
		segment_3.sum_value = 0;

		segment_3.right_endpoint = segment_width_second * 3;
		segment_3.rectangle_width = segment_width_second * 3;
		switch (remainder) {
		case 0:
			break;
		case 1:
			segment_3.right_endpoint++;
			segment_3.rectangle_width++;
			break;
		case 2:
			segment_3.right_endpoint += 2;
			segment_3.rectangle_width += 2;
			break;
		case 3:
			segment_3.right_endpoint += 3;
			segment_3.rectangle_width += 3;
			break;
		default:
			segment_3.right_endpoint += 3;
			segment_3.rectangle_width += 3;;
		}
		segment_3.right_endpoint += pre_right_endpoint;

#ifdef _DEBUG
		assert(segment_3.rectangle_width > 5 && segment_3.right_endpoint < input_argument.time_series_length);
#endif

		for (original_id = pre_right_endpoint + 1; original_id <= segment_3.right_endpoint; original_id++) {
			//assert(original_id >= 0);
			//cout<<original_id<<": "<< original_time_series[original_id]<<", ";
			/*---------------------------------Get minmax point of every segment----------------------------------------------*/
			if (segment_3.min_point.value >= original_time_series[original_id]) {
				segment_3.min_point.value = original_time_series[original_id];
				segment_3.min_point.id = original_id;
			}
			if (segment_3.max_point.value <= original_time_series[original_id]) {
				segment_3.max_point.value = original_time_series[original_id];
				segment_3.max_point.id = original_id;
			}
			/*................................................................................................................*/
		}
		//cout << endl;

		if (segment_3.max_point.id != segment_3.min_point.id && segment_3.max_point.value != segment_3.min_point.value) {
			segment_1.right_endpoint = min(segment_3.min_point.id, segment_3.max_point.id);
			segment_2.right_endpoint = max(segment_3.min_point.id, segment_3.max_point.id);

			segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
			segment_2.rectangle_width = segment_2.right_endpoint - segment_1.right_endpoint;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;
#ifdef _DEBUG
			assert(segment_1.rectangle_width > 0);
#endif
			//cout << "first right_endpoint: " << area_vector[sub_id1].right_endpoint << " " << area_vector[sub_id2].right_endpoint << " " << segment_3.right_endpoint << endl;
			//cout << "width:     " << area_vector[sub_id1].rectangle_width << " " << area_vector[sub_id2].rectangle_width << " " << segment_3.rectangle_width << endl;
			if (segment_3.rectangle_width == 0) {
				//segment_3 = area_vector[sub_id2];
				++segment_size;
				segment_3.right_endpoint = segment_2.right_endpoint;// .at(0);
				segment_3.rectangle_width = segment_2.rectangle_width;// .at(0);
				segment_2.right_endpoint = INF;// .at(0);
				segment_2.rectangle_width = INF;// .at(0);
			}

			if (segment_3.rectangle_width == 1) {
				if (segment_2.rectangle_width != INF && segment_2.right_endpoint != INF) {
					segment_3.rectangle_width = segment_2.rectangle_width + 1;// .at(0);
					//area_vector.erase(area_vector.begin() + sub_id2);
					segment_2.right_endpoint = INF;// .at(0);
					segment_2.rectangle_width = INF;// .at(0);
					++segment_size;
				}
				else {
					++segment_size;
					segment_3.rectangle_width = segment_1.rectangle_width + 1;// .at(0);
					segment_1.right_endpoint = INF;// .at(0);
					segment_1.rectangle_width = INF;// .at(0);
				}
			}

#ifdef _DEBUG
			assert(segment_3.rectangle_width > 1);
#endif
			if (segment_2.rectangle_width == 0) {
				assert(0);
				++segment_size;
				segment_2.right_endpoint = INF;// .at(0);
				segment_2.rectangle_width = INF;// .at(0);
			}
			if (segment_2.rectangle_width == 1) {
				segment_2.rectangle_width++;
				//++segment_size;
				//area_vector.erase(area_vector.begin() + sub_id2);
				segment_1.right_endpoint -= 1;// .at(0);
				segment_1.rectangle_width -= 1;// .at(0);
			}

#ifdef _DEBUG
			assert(segment_2.rectangle_width > 1 && segment_1.right_endpoint <= segment_2.right_endpoint);
#endif
			if (segment_1.rectangle_width == 1) {
				if (segment_2.rectangle_width != INF && segment_2.right_endpoint != INF) {
					segment_2.rectangle_width++;
					++segment_size;
				}
				else {
					segment_3.rectangle_width++;
					++segment_size;
				}

				//area_vector.erase(area_vector.begin() + sub_id1);
				segment_1.right_endpoint = INF;// .at(0);
				segment_1.rectangle_width = INF;// .at(0);
			}

			if (segment_1.rectangle_width == 0) {
				++segment_size;
				//segment_2 = segment_2;
				segment_1.right_endpoint = INF;// .at(0);
				segment_1.rectangle_width = INF;// .at(0);
			}
#ifdef _DEBUG
			assert(pre_right_endpoint < segment_1.right_endpoint);
#endif
		}
		else {
			/*	if (i > 1) {
					segment_3.rectangle_width = segment_3.right_endpoint - area_vector[sub_segment_id_3 - 3].right_endpoint;
				}
				else {
					segment_3.rectangle_width = segment_3.right_endpoint + 1;
				}*/
				//segment_2.right_endpoint = INF;// .at(0);
				//segment_2.rectangle_width = INF;// .at(0);
			segment_1.right_endpoint = INF;// .at(0);
			segment_1.rectangle_width = INF;// .at(0);
			++segment_size;
			/*--------------------------------------------------Test SPlit monotony segment-------------------------------------------------------------*/
#ifdef _DEBUG
			assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
			segment_2.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, segment_3);
#ifdef _DEBUG
			assert(segment_2.right_endpoint > 0);
#endif
			if (segment_2.right_endpoint != INF) {
				segment_2.rectangle_width = segment_3.rectangle_width;
				segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
				segment_2.rectangle_width -= segment_3.rectangle_width;

#ifdef _DEBUG
				assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1 && segment_2.right_endpoint < segment_3.right_endpoint);
#endif
				/*.............................................................................................................*/
			}
			else {
				segment_2.rectangle_width = INF;
				++segment_size;
			}

#ifdef _DEBUG
			assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
		}
		/*---------------------Test--------------------------------------*/
		int old_id = result_area_vector.size() - 1;
		/*...........................................................*/
		if (segment_1.right_endpoint != INF) {
			result_area_vector.emplace_back(segment_1);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
		}
		if (segment_2.right_endpoint != INF) {
			result_area_vector.emplace_back(segment_2);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
		}
		if (segment_3.right_endpoint != INF) {
			result_area_vector.emplace_back(segment_3);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
		}
		pre_right_endpoint = result_area_vector.back().right_endpoint;

		/*----------------------------------------- Test Merge same a&b segment--------------------------------------------------------------------*/
		if (old_id > -1) {
			int left_segment_id1 = result_area_vector[old_id].right_endpoint - result_area_vector[old_id].rectangle_width + 1;
			int left_segment_id2 = left_segment_id1 + 1;
			int right_segment_id1 = result_area_vector[old_id + 1].right_endpoint - 1;
			int right_segment_id2 = result_area_vector[old_id + 1].right_endpoint;
			double left_a = original_time_series[left_segment_id2] - original_time_series[left_segment_id1];
			double right_a = original_time_series[right_segment_id2] - original_time_series[right_segment_id1];

			double endpoint_value = (result_area_vector[old_id].rectangle_width + result_area_vector[old_id + 1].rectangle_width - 1) * left_a + original_time_series[left_segment_id1];

			if (float(left_a) == float(right_a) && float(endpoint_value) == float(original_time_series[right_segment_id2])) {
				++segment_size;
				result_area_vector[old_id].right_endpoint = result_area_vector[old_id + 1].right_endpoint;
				result_area_vector[old_id].rectangle_width += result_area_vector[old_id + 1].rectangle_width;
				result_area_vector.erase(result_area_vector.begin() + old_id + 1);
				result_area_vector[old_id].deviation_point.value = -1;
			}
		}
		/*................................................................................................................*/

		/*.......................................................................................................................................................................*/
#ifdef _DEBUG
		assert(segment_1.rectangle_width > 0 && segment_2.rectangle_width > 0 && segment_3.rectangle_width > 0);
		assert(segment_3.min_point.id <= segment_3.right_endpoint && segment_3.max_point.id <= segment_3.right_endpoint);
		/*if (i > 1) {
			assert(segment_3.min_point.id >= area_vector[sub_segment_id_3 - 1].right_endpoint || segment_3.max_point.id >= area_vector[sub_segment_id_3 - 1].right_endpoint);
		}*/
#endif
#ifdef _DEBUG
		//assert(segment_3.max_point.id != segment_3.min_point.id && segment_3.max_point.value != segment_3.min_point.value);
		assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
		segment_3.min_point.id = INF;
		segment_3.min_point.value = INF;
		segment_3.max_point.id = -INF;
		segment_3.max_point.value = -INF;
	}
#ifdef _DEBUG
	assert(result_area_vector.back().right_endpoint == input_argument.time_series_length - 1);
	for (int segment_id = 1; segment_id < result_area_vector.size(); segment_id++) {
		assert(result_area_vector[segment_id].rectangle_width == result_area_vector[segment_id].right_endpoint - result_area_vector[segment_id - 1].right_endpoint);
	}
	//cout << "Initial APLA Right endpoint: ";
	//for (auto&&au : result_area_vector) {
	//	cout << au.right_endpoint << ", ";
	//}
	//cout << endl;
	//cout << "Initial APLA Rectangle width: ";
	//for (auto&&au : result_area_vector) {
	//	cout << au.rectangle_width << ", ";
	//}
	//cout << endl;
#endif
	/*---------------------------------------------------- Test----------------------------------------------------------------------------------------*/
	if (result_area_vector.size() < input_argument.point_dimension) {
		int count = 5;
		int old_segment_size = result_area_vector.size();
		for (int segment_id = 0; result_area_vector.size() < input_argument.point_dimension && count > 0; segment_id++) {
			if (segment_id >= result_area_vector.size()) {
				/*if (old_segment_size < result_area_vector.size()) {
					old_segment_size = result_area_vector.size();
				}
				else {
					break;
				}*/

				segment_id = 0;
				count--;
			}

			if (result_area_vector[segment_id].deviation_point.value != -1 && result_area_vector[segment_id].rectangle_width > 3) {
				AREA_COEFFICIENT sub_segment;
				sub_segment.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, result_area_vector[segment_id]);
#ifdef _DEBUG
				assert(sub_segment.right_endpoint > 0);
#endif
				if (sub_segment.right_endpoint != INF) {
					sub_segment.rectangle_width = result_area_vector[segment_id].rectangle_width;
					result_area_vector[segment_id].rectangle_width = result_area_vector[segment_id].right_endpoint - sub_segment.right_endpoint;
					sub_segment.rectangle_width -= result_area_vector[segment_id].rectangle_width;
#ifdef _DEBUG
					assert(sub_segment.rectangle_width > 1 && result_area_vector[segment_id].rectangle_width > 1 && sub_segment.right_endpoint < result_area_vector[segment_id].right_endpoint);
					assert(sub_segment.rectangle_width + result_area_vector[segment_id].rectangle_width == result_area_vector[segment_id].right_endpoint - result_area_vector[segment_id - 1].right_endpoint);
#endif
					result_area_vector.insert(result_area_vector.begin() + segment_id, sub_segment);
					segment_id++;
				}
				else {
					continue;
				}
			}
		}
	}
	/*......................................................................................................................................*/

#ifdef _DEBUG
	for (int segment_id = 1; segment_id < result_area_vector.size(); segment_id++) {
		assert(result_area_vector[segment_id].rectangle_width == result_area_vector[segment_id].right_endpoint - result_area_vector[segment_id - 1].right_endpoint && result_area_vector[segment_id].rectangle_width > 1);
	}
#endif
	area_vector.swap(result_area_vector);
	//area_vector.erase(std::remove_if(area_vector.begin(), area_vector.end(), [](AREA_COEFFICIENT& i) { return i.right_endpoint == INF && i.rectangle_width == INF; }), area_vector.end());
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	getPLAByAdaptiveSegment(input_argument, original_time_series, area_vector);//190617 sum_value, a, b, apla_coefficient
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
}

//************************************
// Method:initialAPLARightEndpoint3SubAdaptiveMergeSplit
// Qualifier: Add split merge process. a,b,width,right_endpoint,apla_coefficient, sum_value. Split segment into 3 sub-segment by minmax point
//190711 16:59 Use minmax point split segment into 3 subsegment, when minmax points at endpoint, not merge.
// date:190627 16:45
// author:
//************************************
TEMPLATE
void APLA::initialAPLARightEndpoint3SubAdaptiveMergeSplit(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector) {//190711 16:59 Merge Use minmax point split segment into 3 subsegment, for flat stream, use few segments, for drastic change, use more segments. Splie Merge when initial
	//int segment_number = input_argument.point_dimension * 2;
	//input_argument.remainder = int(input_argument.time_series_length) % int(segment_number);//For PLA
	//double integerDividend = input_argument.time_series_length - input_argument.remainder;
	//input_argument.segment_length_second = integerDividend / segment_number;
	//input_argument.segment_length_first = input_argument.segment_length_second + 1;

#ifdef _DEBUG
	assert(input_argument.segment_length_first == input_argument.segment_length_second + 1);
	assert(input_argument.segment_length_first > 2);
#endif

	int j = 0;//original id
	int k = 0;
	int original_id = 0;//190617
	int zero_id = NULL;//190617 [0,segment_len-1]

	vector<AREA_COEFFICIENT> result_area_vector;

	AREA_COEFFICIENT segment_1;
	AREA_COEFFICIENT segment_2;
	AREA_COEFFICIENT segment_3;

	int vector_end_id = 0;
	int segment_left_id = 0;
	int pre_segment_number = 0;
	int pre_right_endpoint = -1;

	int rest_segment_number = area_vector.size();
	//int rest_segment_number = rest_segment_size;
	//int sub_segment_1;
	//int sub_segment_2;
	//int sub_segment_3;
	bool can_merge_end = true;

	int rest_time_series_length = input_argument.time_series_length;
	/*====================================While Loop==========================================================================*/
	while (pre_right_endpoint < input_argument.time_series_length - 1 && rest_segment_number > 0) {
#ifdef _DEBUG
		assert(pre_right_endpoint < input_argument.time_series_length);
		assert(result_area_vector.size() <= area_vector.size());
#endif

		segment_3.min_point.id = INF;
		segment_3.min_point.value = INF;
		segment_3.max_point.id = -INF;
		segment_3.max_point.value = -INF;
		segment_3.sum_value = 0;

		rest_time_series_length = input_argument.time_series_length - (pre_right_endpoint + 1);
		int max_size = ceil(rest_time_series_length / 2);
		if (rest_segment_number >= max_size) {
			//rest_segment_size = max_size;
			rest_segment_number = max_size;
			can_merge_end = false;
		}
		auto remainder = rest_time_series_length % rest_segment_number;//For PLA
		auto segment_width_second = (rest_time_series_length - remainder) / rest_segment_number;
		auto segment_width_first = segment_width_second + 1;

		/*-----------------------if max size or segment size == 1 or 2-----------------------------*/

		if (rest_segment_number == 1) {
			segment_1.right_endpoint = input_argument.time_series_length - 1;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;
			rest_segment_number--;
			result_area_vector.emplace_back(segment_1);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
			pre_right_endpoint = result_area_vector.back().right_endpoint;
#ifdef _DEBUG
			assert(pre_right_endpoint < input_argument.time_series_length&& segment_1.rectangle_width > 1);
#endif
			continue;
		}

		if (rest_segment_number == 2) {
			segment_2.right_endpoint = input_argument.time_series_length - 1;
			segment_2.rectangle_width = max_size;
			segment_1.right_endpoint = segment_2.right_endpoint - segment_2.rectangle_width;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;

#ifdef _DEBUG
			assert(segment_1.rectangle_width == rest_time_series_length - max_size && segment_1.right_endpoint == segment_1.rectangle_width + pre_right_endpoint);
#endif
			rest_segment_number -= 2;
			result_area_vector.emplace_back(segment_1);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
			result_area_vector.emplace_back(segment_2);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
			pre_right_endpoint = result_area_vector.back().right_endpoint;
#ifdef _DEBUG
			assert(pre_right_endpoint < input_argument.time_series_length&& segment_1.rectangle_width > 1);
#endif
			continue;
		}

		if (max_size == 1) {
			rest_segment_number--;
			segment_1.right_endpoint = input_argument.time_series_length - 1;
#ifdef _DEBUG
			assert(pre_right_endpoint + 2 == input_argument.time_series_length - 1);
#endif
			segment_1.rectangle_width = 2;
			result_area_vector.emplace_back(segment_1);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
			pre_right_endpoint = result_area_vector.back().right_endpoint;

#ifdef _DEBUG
			assert(pre_right_endpoint == input_argument.time_series_length - 1);
#endif
			continue;
		}

		if (max_size == 2) {
			segment_1.right_endpoint = pre_right_endpoint + 2;
			segment_2.right_endpoint = input_argument.time_series_length - 1;
			segment_1.rectangle_width = 2;
			segment_2.rectangle_width = segment_2.right_endpoint - segment_1.right_endpoint;

			rest_segment_number -= 2;
			result_area_vector.emplace_back(segment_1);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
			result_area_vector.emplace_back(segment_2);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
			pre_right_endpoint = result_area_vector.back().right_endpoint;
#ifdef _DEBUG
			assert(pre_right_endpoint < input_argument.time_series_length);
#endif
			continue;
		}

		/*......................................................................................................*/

#ifdef _DEBUG
		assert(segment_width_second > 1 && rest_segment_number > -1);
#endif
		/*---------------------------------Get segment_3 right endpoint & rectangle width---------------------------------------------------*/
		segment_3.right_endpoint = segment_width_second * 3;
		segment_3.rectangle_width = segment_width_second * 3;

		switch (remainder) {
		case 0:
			break;
		case 1:
			segment_3.right_endpoint++;
			segment_3.rectangle_width++;
			break;
		case 2:
			segment_3.right_endpoint += 2;
			segment_3.rectangle_width += 2;
			break;
		default:
			segment_3.right_endpoint += 3;
			segment_3.rectangle_width += 3;
		}

		segment_3.right_endpoint += pre_right_endpoint;

#ifdef _DEBUG
		assert(segment_3.rectangle_width > 5 && segment_3.right_endpoint < input_argument.time_series_length&& segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
		/*..............................................................................................*/
		//int first_min_id = INF;
		int final_min_id = INF;
		//int first_max_id = INF;
		int final_max_id = INF;

		/*------------------------------Get min max point of segment-----------------------------------------------------------------*/
		for (original_id = pre_right_endpoint + 1; original_id <= segment_3.right_endpoint; original_id++) {
			//assert(original_id >= 0);
			//cout<<original_id<<": "<< original_time_series[original_id]<<", ";
			if (segment_3.min_point.value > original_time_series[original_id]) {
				segment_3.min_point.value = original_time_series[original_id];
				segment_3.min_point.id = original_id;
				//first_min_id = original_id;
			}
			else if (segment_3.min_point.value == original_time_series[original_id]) {
				final_min_id = original_id;
			}

			if (segment_3.max_point.value < original_time_series[original_id]) {
				segment_3.max_point.value = original_time_series[original_id];
				segment_3.max_point.id = original_id;
				//first_max_id = original_id;
			}
			else if (segment_3.max_point.value == original_time_series[original_id]) {
				final_max_id = original_id;
			}
		}
		//cout << endl;

		/*=================================get minimal distance of min max points==============================================================*/
		if (segment_3.min_point.id != segment_3.max_point.id) {
			set<pair<int, pair<int, int>>> min_minmax_distance;
			final_min_id = max(segment_3.min_point.id, final_min_id);
			final_max_id = max(segment_3.max_point.id, final_max_id);
#ifdef _DEBUG
			if (final_min_id == final_max_id)
				assert(original_time_series[int(segment_3.min_point.id)] == original_time_series[final_min_id] && original_time_series[int(segment_3.max_point.id)] == original_time_series[final_max_id]);
#endif
			min_minmax_distance.emplace(make_pair(abs(segment_3.min_point.id - segment_3.max_point.id), make_pair(segment_3.min_point.id, segment_3.max_point.id)));
			min_minmax_distance.emplace(make_pair(abs(segment_3.min_point.id - final_max_id), make_pair(segment_3.min_point.id, final_max_id)));
			min_minmax_distance.emplace(make_pair(abs(final_min_id - segment_3.max_point.id), make_pair(final_min_id, segment_3.max_point.id)));
			min_minmax_distance.emplace(make_pair(abs(final_min_id - final_max_id), make_pair(final_min_id, final_max_id)));

			segment_3.min_point.id = (*min_minmax_distance.begin()).second.first;
			segment_3.max_point.id = (*min_minmax_distance.begin()).second.second;
		}
		/*.........................................................................................................................*/
		/*..........................................................................................................................*/

		/*=======================================Not Flat==================================================================================*/
		if (segment_3.max_point.id != segment_3.min_point.id && segment_3.max_point.value != segment_3.min_point.value) {
			segment_1.right_endpoint = min(segment_3.min_point.id, segment_3.max_point.id);
			segment_2.right_endpoint = max(segment_3.min_point.id, segment_3.max_point.id);

			segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
			segment_2.rectangle_width = segment_2.right_endpoint - segment_1.right_endpoint;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;

			/*--------------------------seg1=1,seg3=1 or 0-----------------------------------------------*/
			if (segment_1.rectangle_width == 1 && segment_3.rectangle_width < 2) {//segment_left_id == segment1 right endpoint
#ifdef _DEBUG
				assert(segment_2.rectangle_width > 1);
#endif
				if (segment_3.rectangle_width == 1) {
#ifdef _DEBUG
					assert(segment_2.rectangle_width == segment_3.right_endpoint - pre_right_endpoint - 2);
#endif
					segment_3.right_endpoint--;
				}
				segment_3.rectangle_width = segment_2.rectangle_width + 1;
				segment_2.right_endpoint = INF;
				segment_2.rectangle_width = INF;
				segment_1.right_endpoint = INF;
				segment_1.rectangle_width = INF;
				//rest_segment_size+=2;
#ifdef _DEBUG
				assert(segment_3.rectangle_width > 1 && segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
				/*-------------------------------------------------- SPlit monotony segment-------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				segment_2.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, segment_3);
#ifdef _DEBUG
				assert(segment_3.right_endpoint > 0 && segment_3.right_endpoint - segment_2.right_endpoint > 1);
#endif
				if (segment_2.right_endpoint != INF) {
					//rest_segment_size--;
					segment_2.rectangle_width = segment_3.rectangle_width;
					segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
					segment_2.rectangle_width -= segment_3.rectangle_width;
#ifdef _DEBUG
					assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1 && segment_2.right_endpoint < segment_3.right_endpoint);
#endif
				}
				else {
					assert(0);
					segment_2.rectangle_width = INF;
				}
				/*.............................................................................................................*/
			}
			/*................................................................................................................................................*/
			/*--------------------------seg1 width > 1, seg3=1 or 0-----------------------------------------------*/
			else if (segment_1.rectangle_width > 1 && segment_3.rectangle_width < 2) {
				if (segment_3.rectangle_width == 1) {
#ifdef _DEBUG
					assert(segment_2.rectangle_width == segment_3.right_endpoint - segment_1.right_endpoint - 1);
#endif
					segment_3.right_endpoint--;
				}
				segment_3.rectangle_width = segment_2.rectangle_width;
				segment_2.right_endpoint = INF;
				segment_2.rectangle_width = INF;
				//rest_segment_size++;
#ifdef _DEBUG
				assert(segment_1.rectangle_width + segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
				/*-------------------------------------------------- SPlit monotony segment-------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				segment_2.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, segment_3);

				if (segment_2.right_endpoint != INF) {
					//rest_segment_size--;
					segment_2.rectangle_width = segment_3.rectangle_width;
					segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
					segment_2.rectangle_width -= segment_3.rectangle_width;
#ifdef _DEBUG
					assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1 && segment_2.right_endpoint < segment_3.right_endpoint);
#endif
				}
				else {
					segment_2.rectangle_width = INF;
				}
				/*.............................................................................................................*/
				if (segment_3.rectangle_width == 1) {
					segment_1.rectangle_width--;
					segment_3.rectangle_width++;
					segment_1.right_endpoint--;
#ifdef _DEBUG
					assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
				}
			}
			/*................................................................................................................................................*/
			/*--------------------------seg1 width == 1, seg3>1-----------------------------------------------*/
			else if (segment_1.rectangle_width == 1 && segment_3.rectangle_width > 1) {
				segment_2.rectangle_width++;
				segment_1.right_endpoint = INF;
				segment_1.rectangle_width = INF;
				//rest_segment_size++;
#ifdef _DEBUG
				assert(segment_2.rectangle_width + segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
				/*-------------------------------------------------- SPlit monotony segment-------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				segment_1.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, segment_2);

				if (segment_1.right_endpoint != INF) {
					//rest_segment_size--;
					segment_1.rectangle_width = segment_2.rectangle_width;
					segment_2.rectangle_width = segment_2.right_endpoint - segment_1.right_endpoint;
					segment_1.rectangle_width -= segment_2.rectangle_width;
#ifdef _DEBUG
					assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_1.right_endpoint < segment_2.right_endpoint);
#endif
				}
				else {
					segment_1.rectangle_width = INF;
				}
				/*.............................................................................................................*/
			}
			else {
				if (segment_2.rectangle_width == 0) {
					assert(0);
					//++segment_size;
					//segment_2.right_endpoint = INF;// .at(0);
					//segment_2.rectangle_width = INF;// .at(0);
				}
				if (segment_2.rectangle_width == 1) {
					segment_3.rectangle_width++;
					//++rest_segment_size;
					segment_2.right_endpoint = INF;// .at(0);
					segment_2.rectangle_width = INF;// .at(0);
				}

#ifdef _DEBUG
				assert(segment_1.rectangle_width != INF && segment_3.rectangle_width != INF);
				assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
				//assert(0);
			}
			/*................................................................................................................................................*/

#ifdef _DEBUG
			assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
		}/*=========================================Flat=========================================================*/
		else {
			/*	if (i > 1) {
					segment_3.rectangle_width = segment_3.right_endpoint - area_vector[sub_segment_id_3 - 3].right_endpoint;
				}
				else {
					segment_3.rectangle_width = segment_3.right_endpoint + 1;
				}*/
			segment_2.right_endpoint = INF;// .at(0);
			segment_2.rectangle_width = INF;// .at(0);
			segment_1.right_endpoint = INF;// .at(0);
			segment_1.rectangle_width = INF;// .at(0);
			//rest_segment_size += 2;

			/*--------------------------------------------------Test SPlit monotony segment-------------------------------------------------------------*/
#ifdef _DEBUG
			assert(segment_1.right_endpoint == INF && segment_1.rectangle_width == INF && segment_2.right_endpoint == INF && segment_2.rectangle_width == INF);
			assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
			//segment_2.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, segment_3);
#ifdef _DEBUG
			//assert(segment_2.right_endpoint == INF);
#endif
		/*	if (segment_2.right_endpoint != INF) {
				segment_2.rectangle_width = segment_3.rectangle_width;
				segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
				segment_2.rectangle_width -= segment_3.rectangle_width;

#ifdef _DEBUG
				assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1 && segment_2.right_endpoint < segment_3.right_endpoint);
#endif
			}
			else {*/

			//}
			/*.............................................................................................................*/

#ifdef _DEBUG
			assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
		}

		/*----------------------------------------- Merge previous segments--------------------------------------------------------------------*/

		if (segment_1.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_1);
		}
		else if (segment_2.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_2);
		}
		else if (segment_3.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_3);
		}

		/*.....................................................................................................................................*/
		//int old_id = result_area_vector.size() - 1;
		/*---------------------------Push back Vector ------------------------------------------------*/
		if (segment_1.right_endpoint != INF) {
			rest_segment_number--;
			result_area_vector.emplace_back(segment_1);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
		}
		if (segment_2.right_endpoint != INF) {
			rest_segment_number--;
			result_area_vector.emplace_back(segment_2);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
		}
		if (segment_3.right_endpoint != INF) {
			rest_segment_number--;
			result_area_vector.emplace_back(segment_3);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
		}
		/*................................................................................................*/

		if (result_area_vector.back().right_endpoint == input_argument.time_series_length - 2) {
			result_area_vector.back().right_endpoint++;
			result_area_vector.back().rectangle_width++;
		}
		pre_right_endpoint = result_area_vector.back().right_endpoint;

		/*----------------------------------------- Merge same a&b segments--------------------------------------------------------------------*/
		/*if (old_id > -1) {
			int left_segment_id1 = result_area_vector[old_id].right_endpoint - result_area_vector[old_id].rectangle_width + 1;
			double left_a = original_time_series[left_segment_id1 + 1] - original_time_series[left_segment_id1];
			double right_a = original_time_series[int(result_area_vector[old_id + 1].right_endpoint)] - original_time_series[int(result_area_vector[old_id + 1].right_endpoint) - 1];

			double endpoint_value = (result_area_vector[old_id].rectangle_width + result_area_vector[old_id + 1].rectangle_width - 1) * left_a + original_time_series[left_segment_id1];

			if (float(left_a) == float(right_a) && float(endpoint_value) == float(original_time_series[int(result_area_vector[old_id + 1].right_endpoint)])) {
				result_area_vector[old_id].right_endpoint = result_area_vector[old_id + 1].right_endpoint;
				result_area_vector[old_id].rectangle_width += result_area_vector[old_id + 1].rectangle_width;
				rest_segment_number++;
				result_area_vector.erase(result_area_vector.begin() + old_id + 1);
				result_area_vector[old_id].deviation_point.value = -1;
			}
		}*/
		/*................................................................................................................*/

		/*.......................................................................................................................................................................*/
#ifdef _DEBUG
		assert(segment_3.min_point.id <= segment_3.right_endpoint && segment_3.max_point.id <= segment_3.right_endpoint);
		assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
	}

	/*......................................................................................................*/

#ifdef _DEBUG
	assert(result_area_vector.size() <= area_vector.size());
	assert(result_area_vector.back().right_endpoint == input_argument.time_series_length - 1);

	int test_candidate_length = 0;
	for (int segment_id = 1; segment_id < result_area_vector.size(); segment_id++) {
		assert(result_area_vector[segment_id].rectangle_width == result_area_vector[segment_id].right_endpoint - result_area_vector[segment_id - 1].right_endpoint);
	}

	for (auto&& au : result_area_vector) {
		if (au.deviation_point.value != -1) {
			test_candidate_length += au.rectangle_width;
		}
	}

	//cout << "Initial APLA Right endpoint: ";
	//for (auto&&au : result_area_vector) {
	//	cout << au.right_endpoint << ", ";
	//}
	//cout << endl;
	//cout << "Initial APLA Rectangle width: ";
	//for (auto&&au : result_area_vector) {
	//	cout << au.rectangle_width << ", ";
	//}
	//cout << endl;
#endif

	/*---------------------------------------------------- Split Segment increase vector----------------------------------------------------------------------------------------*/

	if (result_area_vector.size() < input_argument.point_dimension) {
		int count = 1;
		int old_segment_size = result_area_vector.size();
		for (int segment_id = 0; result_area_vector.size() < input_argument.point_dimension && count > 0; segment_id++) {
			//if (segment_id >= result_area_vector.size()) {
				//segment_id = 0;
				//count--;

			//}

			/*if (result_area_vector[segment_id].right_endpoint==280) {
				cout << result_area_vector[segment_id].deviation_point.value << endl;
				assert(0);
			}*/

			if (result_area_vector[segment_id].deviation_point.value != -1 && result_area_vector[segment_id].rectangle_width > 3) {
				AREA_COEFFICIENT sub_segment;
				sub_segment.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, result_area_vector[segment_id]);
				//sub_segment.right_endpoint=findSegmentMiddleID(result_area_vector[segment_id]);
#ifdef _DEBUG
				assert(sub_segment.right_endpoint > 0);
#endif
				if (sub_segment.right_endpoint != INF) {
					sub_segment.rectangle_width = result_area_vector[segment_id].rectangle_width;
					result_area_vector[segment_id].rectangle_width = result_area_vector[segment_id].right_endpoint - sub_segment.right_endpoint;
					sub_segment.rectangle_width -= result_area_vector[segment_id].rectangle_width;
#ifdef _DEBUG
					assert(sub_segment.rectangle_width > 1 && result_area_vector[segment_id].rectangle_width > 1 && sub_segment.right_endpoint < result_area_vector[segment_id].right_endpoint);
					assert(sub_segment.rectangle_width + result_area_vector[segment_id].rectangle_width == result_area_vector[segment_id].right_endpoint - result_area_vector[segment_id - 1].right_endpoint);
#endif
					result_area_vector.insert(result_area_vector.begin() + segment_id, sub_segment);
					segment_id++;
				}
				else {
					continue;
				}
			}
		}
	}
	/*......................................................................................................................................................................*/
#ifdef _DEBUG
	assert(result_area_vector.size() >= input_argument.point_dimension);
	for (int segment_id = 1; segment_id < result_area_vector.size(); segment_id++) {
		assert(result_area_vector[segment_id].rectangle_width == result_area_vector[segment_id].right_endpoint - result_area_vector[segment_id - 1].right_endpoint && result_area_vector[segment_id].rectangle_width > 1);
	}
#endif
	//assert(result_area_vector.size() <= area_vector.size());
	area_vector.swap(result_area_vector);
	//area_vector.erase(std::remove_if(area_vector.begin(), area_vector.end(), [](AREA_COEFFICIENT& i) { return i.right_endpoint == INF && i.rectangle_width == INF; }), area_vector.end());
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	getPLAByAdaptiveSegment(input_argument, original_time_series, area_vector);//190617 sum_value, a, b, apla_coefficient
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
}

//************************************
// Method:initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursive
// Qualifier: Recursive split and merge segment. Add split merge process. a,b,width,right_endpoint,apla_coefficient, sum_value. Split segment into 3 sub-segment by minmax point
// Output: new *right_subsegment
// date:190719 1558
// author:
//************************************
TEMPLATE
void APLA::initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursive(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector) {//190719 Recursive merge and split segment
	//int segment_number = input_argument.point_dimension * 2;
	//input_argument.remainder = int(input_argument.time_series_length) % int(segment_number);//For PLA
	//double integerDividend = input_argument.time_series_length - input_argument.remainder;
	//input_argument.segment_length_second = integerDividend / segment_number;
	//input_argument.segment_length_first = input_argument.segment_length_second + 1;

#ifdef _DEBUG
	assert(input_argument.segment_length_first == input_argument.segment_length_second + 1);
	assert(input_argument.segment_length_first > 2);
#endif

	/*===========================Y Projection Method============================================*/
	map<double, int> whole_difference_map;
	/*..........................................................................................*/

	int j = 0;//original id
	int k = 0;
	int original_id = 0;//190617
	int zero_id = NULL;//190617 [0,segment_len-1]

	vector<AREA_COEFFICIENT> result_area_vector;

	AREA_COEFFICIENT segment_1;
	AREA_COEFFICIENT segment_2;
	AREA_COEFFICIENT segment_3;

	int vector_end_id = 0;
	int segment_left_id = 0;
	int pre_segment_number = 0;
	int pre_right_endpoint = -1;

	int rest_segment_number = area_vector.size();
	//int rest_segment_number = rest_segment_size;
	//int sub_segment_1;
	//int sub_segment_2;
	//int sub_segment_3;
	bool can_merge_end = true;

	int rest_time_series_length = input_argument.time_series_length;
	/*====================================While Loop==========================================================================*/
	while (pre_right_endpoint < input_argument.time_series_length - 1 && rest_segment_number > 0) {
		//while (result_area_vector.size() < area_vector.size()) {
#ifdef _DEBUG
		assert(pre_right_endpoint < input_argument.time_series_length);
		assert(result_area_vector.size() <= area_vector.size());
#endif
		segment_3.min_point.id = INF;
		segment_3.min_point.value = INF;
		segment_3.max_point.id = -INF;
		segment_3.max_point.value = -INF;

		rest_time_series_length = input_argument.time_series_length - (pre_right_endpoint + 1);
		int max_size = ceil(rest_time_series_length / 2);
		if (rest_segment_number >= max_size) {
			//rest_segment_size = max_size;
			rest_segment_number = max_size;
			can_merge_end = false;
		}
		auto remainder = rest_time_series_length % rest_segment_number;//For PLA
		auto segment_width_second = (rest_time_series_length - remainder) / rest_segment_number;
		auto segment_width_first = segment_width_second + 1;
		/*-----------------------if max size or segment size == 1 or 2-----------------------------*/

		/*=========================Rest Segment Number 1 & 2===========================*/
		if (rest_segment_number == 1) {
			segment_1.right_endpoint = input_argument.time_series_length - 1;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;

			mergeEndSegment(original_time_series, result_area_vector, segment_1);
			if (segment_1.rectangle_width != INF && segment_1.right_endpoint != INF) {
				rest_segment_number--;
				result_area_vector.emplace_back(segment_1);
				result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
			}
			pre_right_endpoint = result_area_vector.back().right_endpoint;
#ifdef _DEBUG
			assert(pre_right_endpoint < input_argument.time_series_length&& segment_1.rectangle_width > 1);
#endif
			continue;
		}

		if (rest_segment_number == 2) {
			segment_2.right_endpoint = input_argument.time_series_length - 1;
			segment_2.rectangle_width = max_size;
			segment_1.right_endpoint = segment_2.right_endpoint - segment_2.rectangle_width;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;

#ifdef _DEBUG
			assert(segment_1.rectangle_width == rest_time_series_length - max_size && segment_1.right_endpoint == segment_1.rectangle_width + pre_right_endpoint);
#endif

			mergeEndSegment(original_time_series, result_area_vector, segment_1);
			if (segment_1.rectangle_width != INF && segment_1.right_endpoint != INF) {
				--rest_segment_number;
				result_area_vector.emplace_back(segment_1);
				result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
			}
			mergeEndSegment(original_time_series, result_area_vector, segment_2);
			if (segment_2.rectangle_width != INF && segment_2.right_endpoint != INF) {
				--rest_segment_number;
				result_area_vector.emplace_back(segment_2);
				result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
			}
			pre_right_endpoint = result_area_vector.back().right_endpoint;
#ifdef _DEBUG
			assert(pre_right_endpoint == input_argument.time_series_length - 1 && segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1);
#endif
			continue;
		}
		/*..........................................................................*/
		/*=========================Max Segment Number 1 & 2===========================*/
		if (max_size == 1) {
			assert(0);
			rest_segment_number--;
			segment_1.right_endpoint = input_argument.time_series_length - 1;
#ifdef _DEBUG
			assert(pre_right_endpoint + 2 == input_argument.time_series_length - 1);
#endif
			segment_1.rectangle_width = 2;
			result_area_vector.emplace_back(segment_1);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
			pre_right_endpoint = result_area_vector.back().right_endpoint;

#ifdef _DEBUG
			assert(pre_right_endpoint == input_argument.time_series_length - 1);
#endif
			continue;
		}

		if (max_size == 2) {
			assert(0);
			segment_1.right_endpoint = pre_right_endpoint + 2;
			segment_2.right_endpoint = input_argument.time_series_length - 1;
			segment_1.rectangle_width = 2;
			segment_2.rectangle_width = segment_2.right_endpoint - segment_1.right_endpoint;

			rest_segment_number -= 2;
			result_area_vector.emplace_back(segment_1);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
			result_area_vector.emplace_back(segment_2);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
			pre_right_endpoint = result_area_vector.back().right_endpoint;
#ifdef _DEBUG
			assert(pre_right_endpoint < input_argument.time_series_length);
#endif
			continue;
		}
		/*........................................................*/

		/*......................................................................................................*/
#ifdef _DEBUG
		assert(segment_width_second > 1 && rest_segment_number > -1);
#endif
		/*---------------------------------Get segment_3 right endpoint & rectangle width---------------------------------------------------*/
		segment_3.right_endpoint = segment_width_second * 3;
		segment_3.rectangle_width = segment_width_second * 3;

		switch (remainder) {
		case 0:
			break;
		case 1:
			segment_3.right_endpoint++;
			segment_3.rectangle_width++;
			break;
		case 2:
			segment_3.right_endpoint += 2;
			segment_3.rectangle_width += 2;
			break;
		default:
			segment_3.right_endpoint += 3;
			segment_3.rectangle_width += 3;
		}

		segment_3.right_endpoint += pre_right_endpoint;

#ifdef _DEBUG
		assert(segment_3.rectangle_width > 5 && segment_3.right_endpoint < input_argument.time_series_length&& segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
		/*..............................................................................................*/

		/*===========================Y Projection Method============================================*/
		segment_3.segment_right_point.id = segment_3.right_endpoint;
		segment_3.segment_right_point.value = original_time_series[int(segment_3.right_endpoint)];
		/*..........................................................................................*/

		//int first_min_id = INF;
		int final_min_id = 0;
		//int first_max_id = INF;
		int final_max_id = 0;

		/*------------------------------Get min max point of segment-----------------------------------------------------------------*/
		for (original_id = pre_right_endpoint + 1; original_id <= segment_3.right_endpoint; original_id++) {
			//assert(original_id >= 0);
			//cout<<original_id<<": "<< original_time_series[original_id]<<", ";
			if (segment_3.min_point.value > original_time_series[original_id]) {
				segment_3.min_point.value = original_time_series[original_id];
				segment_3.min_point.id = original_id;
				//first_min_id = original_id;
			}
			else if (segment_3.min_point.value == original_time_series[original_id]) {
				final_min_id = original_id;
			}

			if (segment_3.max_point.value < original_time_series[original_id]) {
				segment_3.max_point.value = original_time_series[original_id];
				segment_3.max_point.id = original_id;
				//first_max_id = original_id;
			}
			else if (segment_3.max_point.value == original_time_series[original_id]) {
				final_max_id = original_id;
			}

			/*===========================Y Projection Method============================================*/
		/*	auto segment_find_difference = segment_3.y_projection_coefficient.internal_difference_map.find(original_time_series[original_id]);
			if (segment_find_difference != segment_3.y_projection_coefficient.internal_difference_map.end()) {
				segment_find_difference->second++;
			}
			else {
				 segment_3.y_projection_coefficient.internal_difference_map.emplace_hint(segment_3.y_projection_coefficient.internal_difference_map.end(), original_time_series[original_id],1);
			}*/

			auto whole_find_difference = whole_difference_map.find(original_time_series[original_id]);
			if (whole_find_difference != whole_difference_map.end()) {
				whole_find_difference->second++;
			}
			else {
				whole_difference_map.emplace_hint(whole_difference_map.end(), original_time_series[original_id], 1);
			}

			/*..........................................................................................*/
		}
		//cout << endl;

		/*=================================get minimal distance of min max points==============================================================*/
		int total_distance = final_min_id + final_max_id;
		if (segment_3.min_point.id != segment_3.max_point.id && total_distance != 0) {
			set<pair<int, pair<int, int>>> min_minmax_distance;
			final_min_id = max(segment_3.min_point.id, final_min_id);
			final_max_id = max(segment_3.max_point.id, final_max_id);
#ifdef _DEBUG
			assert(final_min_id > 0 && final_max_id > 0);
			if (final_min_id == final_max_id)
				assert(original_time_series[int(segment_3.min_point.id)] == original_time_series[final_min_id] && original_time_series[int(segment_3.max_point.id)] == original_time_series[final_max_id]);
#endif
			min_minmax_distance.emplace(make_pair(abs(segment_3.min_point.id - segment_3.max_point.id), make_pair(segment_3.min_point.id, segment_3.max_point.id)));
			min_minmax_distance.emplace(make_pair(abs(segment_3.min_point.id - final_max_id), make_pair(segment_3.min_point.id, final_max_id)));
			min_minmax_distance.emplace(make_pair(abs(final_min_id - segment_3.max_point.id), make_pair(final_min_id, segment_3.max_point.id)));
			min_minmax_distance.emplace(make_pair(abs(final_min_id - final_max_id), make_pair(final_min_id, final_max_id)));

			segment_3.min_point.id = (*min_minmax_distance.begin()).second.first;
			segment_3.max_point.id = (*min_minmax_distance.begin()).second.second;
		}
		/*.........................................................................................................................*/
		/*..........................................................................................................................*/

		/*=======================================Not Flat==================================================================================*/
		if (segment_3.max_point.id != segment_3.min_point.id && segment_3.max_point.value != segment_3.min_point.value) {
			segment_1.right_endpoint = min(segment_3.min_point.id, segment_3.max_point.id);
			segment_2.right_endpoint = max(segment_3.min_point.id, segment_3.max_point.id);

			segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
			segment_2.rectangle_width = segment_2.right_endpoint - segment_1.right_endpoint;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;

			/*--------------------------seg1=1,seg3=1 or 0-----------------------------------------------*/
			if (segment_1.rectangle_width == 1 && segment_3.rectangle_width < 2) {//segment_left_id == segment1 right endpoint
#ifdef _DEBUG
				assert(segment_2.rectangle_width > 1);
#endif
				if (segment_3.rectangle_width == 1) {
#ifdef _DEBUG
					assert(segment_2.rectangle_width == segment_3.right_endpoint - pre_right_endpoint - 2);
#endif
					segment_3.right_endpoint--;
				}
				segment_3.rectangle_width = segment_2.rectangle_width + 1;
				segment_2.right_endpoint = INF;
				segment_2.rectangle_width = INF;
				segment_1.right_endpoint = INF;
				segment_1.rectangle_width = INF;
				//rest_segment_size+=2;
#ifdef _DEBUG
				assert(segment_3.rectangle_width > 1 && segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
				/*-------------------------------------------------- SPlit monotony segment-------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				segment_2.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, segment_3);
#ifdef _DEBUG
				assert(segment_3.right_endpoint > 0 && segment_3.right_endpoint - segment_2.right_endpoint > 1);
#endif
				if (segment_2.right_endpoint != INF) {
					//rest_segment_size--;
					segment_2.rectangle_width = segment_3.rectangle_width;
					segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
					segment_2.rectangle_width -= segment_3.rectangle_width;
#ifdef _DEBUG
					assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1 && segment_2.right_endpoint < segment_3.right_endpoint);
#endif
				}
				else {
					assert(0);
					segment_2.rectangle_width = INF;
				}
				/*.............................................................................................................*/
			}
			/*................................................................................................................................................*/
			/*--------------------------seg1 width > 1, seg3=1 or 0-----------------------------------------------*/
			else if (segment_1.rectangle_width > 1 && segment_3.rectangle_width < 2) {
				if (segment_3.rectangle_width == 1) {
#ifdef _DEBUG
					assert(segment_2.rectangle_width == segment_3.right_endpoint - segment_1.right_endpoint - 1);
#endif
					segment_3.right_endpoint--;
				}
				segment_3.rectangle_width = segment_2.rectangle_width;
				segment_2.right_endpoint = INF;
				segment_2.rectangle_width = INF;
				//rest_segment_size++;
#ifdef _DEBUG
				assert(segment_1.rectangle_width + segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
				/*-------------------------------------------------- SPlit monotony segment-------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				segment_2.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, segment_3);

				if (segment_2.right_endpoint != INF) {
					//rest_segment_size--;
					segment_2.rectangle_width = segment_3.rectangle_width;
					segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
					segment_2.rectangle_width -= segment_3.rectangle_width;
#ifdef _DEBUG
					assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1 && segment_2.right_endpoint < segment_3.right_endpoint);
#endif
				}
				else {
					segment_2.rectangle_width = INF;
				}
				/*.............................................................................................................*/
				if (segment_3.rectangle_width == 1) {
					segment_1.rectangle_width--;
					segment_3.rectangle_width++;
					segment_1.right_endpoint--;
#ifdef _DEBUG
					assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
				}
			}
			/*................................................................................................................................................*/
			/*--------------------------seg1 width == 1, seg3>1-----------------------------------------------*/
			else if (segment_1.rectangle_width == 1 && segment_3.rectangle_width > 1) {
				segment_2.rectangle_width++;
				segment_1.right_endpoint = INF;
				segment_1.rectangle_width = INF;
				//rest_segment_size++;
#ifdef _DEBUG
				assert(segment_2.rectangle_width + segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
				/*-------------------------------------------------- SPlit monotony segment-------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				segment_1.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, segment_2);

				if (segment_1.right_endpoint != INF) {
					//rest_segment_size--;
					segment_1.rectangle_width = segment_2.rectangle_width;
					segment_2.rectangle_width = segment_2.right_endpoint - segment_1.right_endpoint;
					segment_1.rectangle_width -= segment_2.rectangle_width;
#ifdef _DEBUG
					assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_1.right_endpoint < segment_2.right_endpoint);
#endif
				}
				else {
					segment_1.rectangle_width = INF;
				}
				/*.............................................................................................................*/
			}
			else {
				if (segment_2.rectangle_width == 0) {
					assert(0);
					//++segment_size;
					//segment_2.right_endpoint = INF;// .at(0);
					//segment_2.rectangle_width = INF;// .at(0);
				}
				if (segment_2.rectangle_width == 1) {
					segment_3.rectangle_width++;
					//++rest_segment_size;
					segment_2.right_endpoint = INF;// .at(0);
					segment_2.rectangle_width = INF;// .at(0);
				}

#ifdef _DEBUG
				assert(segment_1.rectangle_width != INF && segment_3.rectangle_width != INF);
				assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
				//assert(0);
			}
			/*................................................................................................................................................*/

#ifdef _DEBUG
			assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
		}/*=========================================Flat=========================================================*/
		else {
			segment_2.right_endpoint = INF;
			segment_2.rectangle_width = INF;
			segment_1.right_endpoint = INF;
			segment_1.rectangle_width = INF;
#ifdef _DEBUG
			assert(segment_1.right_endpoint == INF && segment_1.rectangle_width == INF && segment_2.right_endpoint == INF && segment_2.rectangle_width == INF);
			assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
			assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
		}

		/*----------------------------------------- Merge previous segments--------------------------------------------------------------------*/

		if (segment_1.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_1);
		}
		else if (segment_2.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_2);
		}
		else if (segment_3.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_3);
		}

		/*.....................................................................................................................................*/
		//int old_id = result_area_vector.size() - 1;
		/*---------------------------Push back Vector ------------------------------------------------*/
		if (segment_1.right_endpoint != INF) {
			rest_segment_number--;
			result_area_vector.emplace_back(segment_1);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
		}
		if (segment_2.right_endpoint != INF) {
			rest_segment_number--;
			result_area_vector.emplace_back(segment_2);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
		}
		if (segment_3.right_endpoint != INF) {
			rest_segment_number--;
			result_area_vector.emplace_back(segment_3);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
		}
		/*................................................................................................*/

		if (result_area_vector.back().right_endpoint == input_argument.time_series_length - 2) {
			result_area_vector.back().right_endpoint++;
			result_area_vector.back().rectangle_width++;
		}
		pre_right_endpoint = result_area_vector.back().right_endpoint;

		/*.......................................................................................................................................................................*/
#ifdef _DEBUG
		assert(segment_3.min_point.id <= segment_3.right_endpoint && segment_3.max_point.id <= segment_3.right_endpoint);
		assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
	}
	/*......................................................................................................*/

#ifdef _DEBUG
	assert(result_area_vector.size() <= area_vector.size());
	assert(result_area_vector.back().right_endpoint == input_argument.time_series_length - 1);

	//test segment width
	result_area_vector[0].rectangle_width = result_area_vector[0].right_endpoint + 1;
	for (int segment_id = 1; segment_id < result_area_vector.size(); segment_id++) {
		assert(result_area_vector[segment_id].rectangle_width == result_area_vector[segment_id].right_endpoint - result_area_vector[segment_id - 1].right_endpoint);
	}

	int test_candidate_length = 0;
	for (auto&& au : result_area_vector) {
		if (au.deviation_point.value != -1) {
			test_candidate_length += au.rectangle_width;
		}
	}

	//cout << "Initial APLA Right endpoint: ";
	//for (auto&&au : result_area_vector) {
	//	cout << au.right_endpoint << ", ";
	//}
	//cout << endl;
	//cout << "Initial APLA Rectangle width: ";
	//for (auto&&au : result_area_vector) {
	//	cout << au.rectangle_width << ", ";
	//}
	//cout << endl;
#endif

	/*=============================================Y Porjection Method==================================================================================*/
	if (whole_difference_map.size() < 21) {
		//Use Y projection method
		input_argument.is_y_projection = true;
		yProjectionAPLAInitial(input_argument, original_time_series, whole_difference_map, area_vector);//190730
		cout << "#$#$@%%#$%$^((_))+_)_+)+)+)+_)_+  Whole points difference is: " << whole_difference_map.size() << endl;
		yProjectionAPLAMerge(input_argument, original_time_series, whole_difference_map, area_vector);//190731
		//++++input: width right endpoint
		//++++Output: a&b apla coefficient, sum value
		getPLAByAdaptiveSegment(input_argument, original_time_series, area_vector);//190617 sum_value, a, b, apla_coefficient
		return;
		/*for (auto&& au : whole_difference_map) {
			cout << au.first << " " << au.second<<endl;
		}
		cout << endl;*/
	}
	/*.................................................................................................................................................*/
	/*---------------------------------------------------- Split Segment increase vector----------------------------------------------------------------------------------------*/

	if (result_area_vector.size() < input_argument.point_dimension) {
		//int count = 1;
		int old_segment_size = result_area_vector.size();
		for (int segment_id = 0; result_area_vector.size() < input_argument.point_dimension; segment_id++) {
			//if (segment_id >= result_area_vector.size()) {
				//segment_id = 0;
				//count--;

			//}

			/*if (result_area_vector[segment_id].right_endpoint==280) {
				cout << result_area_vector[segment_id].deviation_point.value << endl;
				assert(0);
			}*/

			if (result_area_vector[segment_id].deviation_point.value != -1 && result_area_vector[segment_id].rectangle_width > 3) {
				AREA_COEFFICIENT sub_segment;
				sub_segment.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, result_area_vector[segment_id]);
				//sub_segment.right_endpoint=findSegmentMiddleID(result_area_vector[segment_id]);
#ifdef _DEBUG
				assert(sub_segment.right_endpoint > 0);
#endif
				if (sub_segment.right_endpoint != INF) {
					sub_segment.rectangle_width = result_area_vector[segment_id].rectangle_width;
					result_area_vector[segment_id].rectangle_width = result_area_vector[segment_id].right_endpoint - sub_segment.right_endpoint;
					sub_segment.rectangle_width -= result_area_vector[segment_id].rectangle_width;
#ifdef _DEBUG
					assert(sub_segment.rectangle_width > 1 && result_area_vector[segment_id].rectangle_width > 1 && sub_segment.right_endpoint < result_area_vector[segment_id].right_endpoint);
					assert(sub_segment.rectangle_width + result_area_vector[segment_id].rectangle_width == result_area_vector[segment_id].right_endpoint - result_area_vector[segment_id - 1].right_endpoint);
#endif
					result_area_vector.insert(result_area_vector.begin() + segment_id, sub_segment);
					segment_id++;
				}
				else {
					continue;
				}
			}
		}
	}
	/*......................................................................................................................................................................*/
#ifdef _DEBUG
	assert(result_area_vector.size() >= input_argument.point_dimension);
	for (int segment_id = 1; segment_id < result_area_vector.size(); segment_id++) {
		assert(result_area_vector[segment_id].rectangle_width == result_area_vector[segment_id].right_endpoint - result_area_vector[segment_id - 1].right_endpoint && result_area_vector[segment_id].rectangle_width > 1);
	}
#endif
	//assert(result_area_vector.size() <= area_vector.size());
	area_vector.swap(result_area_vector);
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	//input: width right endpoint
	//Output: a&b apla coefficient, sum value
	getPLAByAdaptiveSegment(input_argument, original_time_series, area_vector);//190617 sum_value, a, b, apla_coefficient
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
}

//************************************
// Method:initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursiveSpeed
// Qualifier: Recursive split and merge segment. Add split merge process. a,b,width,right_endpoint,apla_coefficient, sum_value. Split segment into 3 sub-segment by minmax point
// Output: new *right_subsegment
// date:190812 1039
// author:
//************************************
TEMPLATE
void APLA::initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursiveSpeed(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector) {//190812
	//int segment_number = input_argument.point_dimension * 2;
	//input_argument.remainder = int(input_argument.time_series_length) % int(segment_number);//For PLA
	//double integerDividend = input_argument.time_series_length - input_argument.remainder;
	//input_argument.segment_length_second = integerDividend / segment_number;
	//input_argument.segment_length_first = input_argument.segment_length_second + 1;

#ifdef _DEBUG
	assert(input_argument.segment_length_first == input_argument.segment_length_second + 1);
	assert(input_argument.segment_length_first > 2);
#endif

	/*====================       Initial variable      ========================*/
	map<double, int> whole_difference_map;
	int original_id = 0;//190617
	int initial_vector_size = input_argument.point_dimension;// = input_argument.point_dimension < 3 ? 3 : input_argument.point_dimension;//190812

	while (initial_vector_size % 3 != 0) {
		++initial_vector_size;
	}

	vector<AREA_COEFFICIENT> result_area_vector;
	AREA_COEFFICIENT segment_1;
	AREA_COEFFICIENT segment_2;
	AREA_COEFFICIENT segment_3;
	int pre_right_endpoint = -1;
	int rest_segment_number = initial_vector_size;
	bool can_merge_end = true;
	int rest_time_series_length = INF;
	/*........................................................................*/

	/*====================================While Loop==========================================================================*/
	while (pre_right_endpoint < input_argument.time_series_length - 1 && rest_segment_number > 0) {
		//while (result_area_vector.size() < area_vector.size()) {
#ifdef _DEBUG
		assert(pre_right_endpoint < input_argument.time_series_length);
		assert(result_area_vector.size() <= initial_vector_size);
#endif
		segment_3.min_point.id = INF;
		segment_3.min_point.value = INF;
		segment_3.max_point.id = -INF;
		segment_3.max_point.value = -INF;

		rest_time_series_length = input_argument.time_series_length - (pre_right_endpoint + 1);
		int max_size = ceil(rest_time_series_length / 2);
		if (rest_segment_number >= max_size) {
			rest_segment_number = max_size;
			can_merge_end = false;
		}
		auto remainder = rest_time_series_length % rest_segment_number;//For PLA
		auto segment_width_second = (rest_time_series_length - remainder) / rest_segment_number;
		//auto segment_width_first = segment_width_second + 1;
		/*-----------------------if max size or segment size == 1 or 2-----------------------------*/

		/*=========================Rest Segment Number 1 & 2===========================*/
		if (rest_segment_number == 1) {
			segment_1.right_endpoint = input_argument.time_series_length - 1;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;

			mergeEndSegment(original_time_series, result_area_vector, segment_1);
			if (segment_1.rectangle_width != INF && segment_1.right_endpoint != INF) {
				rest_segment_number--;
				result_area_vector.emplace_back(segment_1);
				result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
			}
			pre_right_endpoint = result_area_vector.back().right_endpoint;
#ifdef _DEBUG
			assert(pre_right_endpoint < input_argument.time_series_length&& segment_1.rectangle_width > 1);
#endif
			continue;
		}

		if (rest_segment_number == 2) {
			segment_2.right_endpoint = input_argument.time_series_length - 1;
			segment_2.rectangle_width = max_size;
			segment_1.right_endpoint = segment_2.right_endpoint - segment_2.rectangle_width;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;

#ifdef _DEBUG
			assert(segment_1.rectangle_width == rest_time_series_length - max_size && segment_1.right_endpoint == segment_1.rectangle_width + pre_right_endpoint);
#endif

			mergeEndSegment(original_time_series, result_area_vector, segment_1);
			if (segment_1.rectangle_width != INF && segment_1.right_endpoint != INF) {
				--rest_segment_number;
				result_area_vector.emplace_back(segment_1);
				result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
			}
			mergeEndSegment(original_time_series, result_area_vector, segment_2);
			if (segment_2.rectangle_width != INF && segment_2.right_endpoint != INF) {
				--rest_segment_number;
				result_area_vector.emplace_back(segment_2);
				result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
			}
			pre_right_endpoint = result_area_vector.back().right_endpoint;
#ifdef _DEBUG
			assert(pre_right_endpoint == input_argument.time_series_length - 1 && segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1);
#endif
			continue;
		}
		/*..........................................................................*/
		/*=========================Max Segment Number 1 & 2===========================*/
		/*if (max_size == 1) {
			assert(0);
			rest_segment_number--;
			segment_1.right_endpoint = input_argument.time_series_length - 1;
#ifdef _DEBUG
			assert(pre_right_endpoint + 2 == input_argument.time_series_length - 1);
#endif
			segment_1.rectangle_width = 2;
			result_area_vector.emplace_back(segment_1);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
			pre_right_endpoint = result_area_vector.back().right_endpoint;

#ifdef _DEBUG
			assert(pre_right_endpoint == input_argument.time_series_length - 1);
#endif
			continue;
		}

		if (max_size == 2) {
			assert(0);
			segment_1.right_endpoint = pre_right_endpoint + 2;
			segment_2.right_endpoint = input_argument.time_series_length - 1;
			segment_1.rectangle_width = 2;
			segment_2.rectangle_width = segment_2.right_endpoint - segment_1.right_endpoint;

			rest_segment_number -= 2;
			result_area_vector.emplace_back(segment_1);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
			result_area_vector.emplace_back(segment_2);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
			pre_right_endpoint = result_area_vector.back().right_endpoint;
#ifdef _DEBUG
			assert(pre_right_endpoint < input_argument.time_series_length);
#endif
			continue;
		}*/
		/*........................................................*/

		/*......................................................................................................*/
#ifdef _DEBUG
		assert(segment_width_second > 1 && rest_segment_number > -1);
#endif
		/*-- Get segment_3 right endpoint & rectangle width --*/
		segment_3.right_endpoint = segment_width_second * 3;
		segment_3.rectangle_width = segment_3.right_endpoint;
		switch (remainder) {
		case 0:
			break;
		case 1:
			segment_3.right_endpoint++;
			segment_3.rectangle_width++;
			break;
		case 2:
			segment_3.right_endpoint += 2;
			segment_3.rectangle_width += 2;
			break;
		default:
			segment_3.right_endpoint += 3;
			segment_3.rectangle_width += 3;
		}
		segment_3.right_endpoint += pre_right_endpoint;
		/*.................................................*/

#ifdef _DEBUG
		assert(segment_3.rectangle_width > 5 && segment_3.right_endpoint < input_argument.time_series_length&& segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif

		/*===========================Y Projection Method============================================*/
		segment_3.segment_right_point.id = segment_3.right_endpoint;
		segment_3.segment_right_point.value = original_time_series[int(segment_3.right_endpoint)];
		/*..........................................................................................*/

		int final_min_id = 0;
		int final_max_id = 0;
		/*------------------------------Get min max point of segment-----------------------------------------------------------------*/
		for (original_id = pre_right_endpoint + 1; original_id <= segment_3.right_endpoint; original_id++) {
			//assert(original_id >= 0);
			//cout<<original_id<<": "<< original_time_series[original_id]<<", ";
			if (segment_3.min_point.value > original_time_series[original_id]) {
				segment_3.min_point.value = original_time_series[original_id];
				segment_3.min_point.id = original_id;
				//first_min_id = original_id;
			}
			else if (segment_3.min_point.value == original_time_series[original_id]) {
				final_min_id = original_id;
			}

			if (segment_3.max_point.value < original_time_series[original_id]) {
				segment_3.max_point.value = original_time_series[original_id];
				segment_3.max_point.id = original_id;
				//first_max_id = original_id;
			}
			else if (segment_3.max_point.value == original_time_series[original_id]) {
				final_max_id = original_id;
			}

			/*===========================Y Projection Method============================================*/
			//+ Distinguish if time series is burst time series or not
			auto whole_find_difference = whole_difference_map.find(original_time_series[original_id]);
			if (whole_find_difference != whole_difference_map.end())
				whole_find_difference->second++;
			else
				whole_difference_map.emplace_hint(whole_difference_map.end(), original_time_series[original_id], 1);

			/*..........................................................................................*/
		}
		//cout << endl;

		/*=================================get minimal distance of min max points==============================================================*/
		int total_distance = final_min_id + final_max_id;
		if (segment_3.min_point.id != segment_3.max_point.id && total_distance != 0) {
			set<pair<int, pair<int, int>>> min_minmax_distance;
			final_min_id = max(segment_3.min_point.id, final_min_id);
			final_max_id = max(segment_3.max_point.id, final_max_id);
#ifdef _DEBUG
			assert(final_min_id >= 0 && final_max_id >= 0);
			if (final_min_id == final_max_id)
				assert(original_time_series[int(segment_3.min_point.id)] == original_time_series[final_min_id] && original_time_series[int(segment_3.max_point.id)] == original_time_series[final_max_id]);
#endif
			min_minmax_distance.emplace(make_pair(abs(segment_3.min_point.id - segment_3.max_point.id), make_pair(segment_3.min_point.id, segment_3.max_point.id)));
			min_minmax_distance.emplace(make_pair(abs(segment_3.min_point.id - final_max_id), make_pair(segment_3.min_point.id, final_max_id)));
			min_minmax_distance.emplace(make_pair(abs(final_min_id - segment_3.max_point.id), make_pair(final_min_id, segment_3.max_point.id)));
			min_minmax_distance.emplace(make_pair(abs(final_min_id - final_max_id), make_pair(final_min_id, final_max_id)));

			segment_3.min_point.id = (*min_minmax_distance.begin()).second.first;
			segment_3.max_point.id = (*min_minmax_distance.begin()).second.second;
		}
		/*......................................................................................................................................*/

		/*=======================================Not Flat==================================================================================*/
		if (segment_3.max_point.id != segment_3.min_point.id && segment_3.max_point.value != segment_3.min_point.value) {
			segment_1.right_endpoint = min(segment_3.min_point.id, segment_3.max_point.id);
			segment_2.right_endpoint = max(segment_3.min_point.id, segment_3.max_point.id);

			segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
			segment_2.rectangle_width = segment_2.right_endpoint - segment_1.right_endpoint;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;

			/*--------------------------seg1=1,seg3=1 or 0-----------------------------------------------*/
			if (segment_1.rectangle_width == 1 && segment_3.rectangle_width < 2) {//segment_left_id == segment1 right endpoint
#ifdef _DEBUG
				assert(segment_2.rectangle_width > 1);
#endif
				if (segment_3.rectangle_width == 1) {
#ifdef _DEBUG
					assert(segment_2.rectangle_width == segment_3.right_endpoint - pre_right_endpoint - 2);
#endif
					segment_3.right_endpoint--;
				}
				segment_3.rectangle_width = segment_2.rectangle_width + 1;
				segment_2.right_endpoint = INF;
				segment_2.rectangle_width = INF;
				segment_1.right_endpoint = INF;
				segment_1.rectangle_width = INF;
				//rest_segment_size+=2;
#ifdef _DEBUG
				assert(segment_3.rectangle_width > 1 && segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
				/*-------------------------------------------------- SPlit monotony segment-------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				segment_2.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, segment_3);
#ifdef _DEBUG
				assert(segment_3.right_endpoint > 0 && segment_3.right_endpoint - segment_2.right_endpoint > 1);
#endif
				if (segment_2.right_endpoint != INF) {
					//rest_segment_size--;
					segment_2.rectangle_width = segment_3.rectangle_width;
					segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
					segment_2.rectangle_width -= segment_3.rectangle_width;
#ifdef _DEBUG
					assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1 && segment_2.right_endpoint < segment_3.right_endpoint);
#endif
				}
				else {
					assert(0);
					segment_2.rectangle_width = INF;
				}
				/*.............................................................................................................*/
			}
			/*................................................................................................................................................*/
			/*--------------------------seg1 width > 1, seg3=1 or 0-----------------------------------------------*/
			else if (segment_1.rectangle_width > 1 && segment_3.rectangle_width < 2) {
				if (segment_3.rectangle_width == 1) {
#ifdef _DEBUG
					assert(segment_2.rectangle_width == segment_3.right_endpoint - segment_1.right_endpoint - 1);
#endif
					segment_3.right_endpoint--;
				}
				segment_3.rectangle_width = segment_2.rectangle_width;
				segment_2.right_endpoint = INF;
				segment_2.rectangle_width = INF;
				//rest_segment_size++;
#ifdef _DEBUG
				assert(segment_1.rectangle_width + segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
				/*-------------------------------------------------- SPlit monotony segment-------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				segment_2.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, segment_3);

				if (segment_2.right_endpoint != INF) {
					//rest_segment_size--;
					segment_2.rectangle_width = segment_3.rectangle_width;
					segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
					segment_2.rectangle_width -= segment_3.rectangle_width;
#ifdef _DEBUG
					assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1 && segment_2.right_endpoint < segment_3.right_endpoint);
#endif
				}
				else {
					segment_2.rectangle_width = INF;
				}
				/*.............................................................................................................*/
				if (segment_3.rectangle_width == 1) {
					segment_1.rectangle_width--;
					segment_3.rectangle_width++;
					segment_1.right_endpoint--;
#ifdef _DEBUG
					assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
				}
			}
			/*................................................................................................................................................*/
			/*--------------------------seg1 width == 1, seg3>1-----------------------------------------------*/
			else if (segment_1.rectangle_width == 1 && segment_3.rectangle_width > 1) {
				segment_2.rectangle_width++;
				segment_1.right_endpoint = INF;
				segment_1.rectangle_width = INF;
				//rest_segment_size++;
#ifdef _DEBUG
				assert(segment_2.rectangle_width + segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
				/*-------------------------------------------------- SPlit monotony segment-------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				segment_1.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, segment_2);

				if (segment_1.right_endpoint != INF) {
					//rest_segment_size--;
					segment_1.rectangle_width = segment_2.rectangle_width;
					segment_2.rectangle_width = segment_2.right_endpoint - segment_1.right_endpoint;
					segment_1.rectangle_width -= segment_2.rectangle_width;
#ifdef _DEBUG
					assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_1.right_endpoint < segment_2.right_endpoint);
#endif
				}
				else {
					segment_1.rectangle_width = INF;
				}
				/*.............................................................................................................*/
			}
			else {
				if (segment_2.rectangle_width == 0) {
					assert(0);
					//++segment_size;
					//segment_2.right_endpoint = INF;// .at(0);
					//segment_2.rectangle_width = INF;// .at(0);
				}
				if (segment_2.rectangle_width == 1) {
					segment_3.rectangle_width++;
					//++rest_segment_size;
					segment_2.right_endpoint = INF;// .at(0);
					segment_2.rectangle_width = INF;// .at(0);
				}

#ifdef _DEBUG
				assert(segment_1.rectangle_width != INF && segment_3.rectangle_width != INF);
				assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
				//assert(0);
			}
			/*................................................................................................................................................*/

#ifdef _DEBUG
			assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
		}/*=========================================Flat=========================================================*/
		else {
			segment_2.right_endpoint = INF;
			segment_2.rectangle_width = INF;
			segment_1.right_endpoint = INF;
			segment_1.rectangle_width = INF;
#ifdef _DEBUG
			assert(segment_1.right_endpoint == INF && segment_1.rectangle_width == INF && segment_2.right_endpoint == INF && segment_2.rectangle_width == INF);
			assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
			assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
		}

		/*----------------------------------------- Merge previous segments--------------------------------------------------------------------*/

		if (segment_1.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_1);
		}
		else if (segment_2.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_2);
		}
		else if (segment_3.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_3);
		}

		/*.....................................................................................................................................*/
		//int old_id = result_area_vector.size() - 1;
		/*---------------------------Push back Vector ------------------------------------------------*/
		if (segment_1.right_endpoint != INF) {
			rest_segment_number--;
			result_area_vector.emplace_back(segment_1);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
		}
		if (segment_2.right_endpoint != INF) {
			rest_segment_number--;
			result_area_vector.emplace_back(segment_2);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
		}
		if (segment_3.right_endpoint != INF) {
			rest_segment_number--;
			result_area_vector.emplace_back(segment_3);
			result_area_vector.back().right_subsegment = new AREA_COEFFICIENT;
		}
		/*................................................................................................*/

		if (result_area_vector.back().right_endpoint == input_argument.time_series_length - 2) {
			result_area_vector.back().right_endpoint++;
			result_area_vector.back().rectangle_width++;
		}
		pre_right_endpoint = result_area_vector.back().right_endpoint;

		/*.......................................................................................................................................................................*/
#ifdef _DEBUG
		assert(segment_3.min_point.id <= segment_3.right_endpoint && segment_3.max_point.id <= segment_3.right_endpoint);
		assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
	}
	/*......................................................................................................*/

#ifdef _DEBUG
	assert(result_area_vector.size() <= initial_vector_size);
	assert(result_area_vector.back().right_endpoint == input_argument.time_series_length - 1);

	//test segment width
	result_area_vector[0].rectangle_width = result_area_vector[0].right_endpoint + 1;
	for (int segment_id = 1; segment_id < result_area_vector.size(); segment_id++) {
		assert(result_area_vector[segment_id].rectangle_width == result_area_vector[segment_id].right_endpoint - result_area_vector[segment_id - 1].right_endpoint);
	}

	int test_candidate_length = 0;
	for (auto&& au : result_area_vector) {
		if (au.deviation_point.value != -1) {
			test_candidate_length += au.rectangle_width;
		}
	}

#endif

	/*=============================================Y Porjection Method==================================================================================*/
	if (whole_difference_map.size() < 21) {
		//Use Y projection method
		input_argument.is_y_projection = true;
		yProjectionAPLAInitial(input_argument, original_time_series, whole_difference_map, area_vector);//190730
		//cout << "#$#$@%%#$%$^((_))+_)_+)+)+)+_)_+  Whole points difference is: " << whole_difference_map.size() << endl;
		yProjectionAPLAMerge(input_argument, original_time_series, whole_difference_map, area_vector);//190731
		//++++input: width right endpoint
		//++++Output: a&b apla coefficient, sum value
		getPLAByAdaptiveSegment(input_argument, original_time_series, area_vector);//190617 sum_value, a, b, apla_coefficient
		return;
		/*for (auto&& au : whole_difference_map) {
			cout << au.first << " " << au.second<<endl;
		}
		cout << endl;*/
	}
	/*.................................................................................................................................................*/
	/*---------------------------------------------------- Split Segment increase vector----------------------------------------------------------------------------------------*/

	if (result_area_vector.size() < input_argument.point_dimension) {
		//int count = 1;
		int old_segment_size = result_area_vector.size();
		for (int segment_id = 0; result_area_vector.size() < input_argument.point_dimension; segment_id++) {
			//if (segment_id >= result_area_vector.size()) {
				//segment_id = 0;
				//count--;

			//}

			/*if (result_area_vector[segment_id].right_endpoint==280) {
				cout << result_area_vector[segment_id].deviation_point.value << endl;
				assert(0);
			}*/

			if (result_area_vector[segment_id].deviation_point.value != -1 && result_area_vector[segment_id].rectangle_width > 3) {
				AREA_COEFFICIENT sub_segment;
				sub_segment.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, result_area_vector[segment_id]);
				//sub_segment.right_endpoint=findSegmentMiddleID(result_area_vector[segment_id]);
#ifdef _DEBUG
				assert(sub_segment.right_endpoint > 0);
#endif
				if (sub_segment.right_endpoint != INF) {
					sub_segment.rectangle_width = result_area_vector[segment_id].rectangle_width;
					result_area_vector[segment_id].rectangle_width = result_area_vector[segment_id].right_endpoint - sub_segment.right_endpoint;
					sub_segment.rectangle_width -= result_area_vector[segment_id].rectangle_width;
#ifdef _DEBUG
					assert(sub_segment.rectangle_width > 1 && result_area_vector[segment_id].rectangle_width > 1 && sub_segment.right_endpoint < result_area_vector[segment_id].right_endpoint);
					if (segment_id > 0)
						assert(sub_segment.rectangle_width + result_area_vector[segment_id].rectangle_width == result_area_vector[segment_id].right_endpoint - result_area_vector[segment_id - 1].right_endpoint);
#endif
					result_area_vector.insert(result_area_vector.begin() + segment_id, sub_segment);
					segment_id++;
				}
				else {
					continue;
				}
			}
		}
	}
	/*......................................................................................................................................................................*/
#ifdef _DEBUG
	assert(result_area_vector.size() >= input_argument.point_dimension);
	for (int segment_id = 1; segment_id < result_area_vector.size(); segment_id++) {
		assert(result_area_vector[segment_id].rectangle_width == result_area_vector[segment_id].right_endpoint - result_area_vector[segment_id - 1].right_endpoint && result_area_vector[segment_id].rectangle_width > 1);
	}
#endif
	//assert(result_area_vector.size() <= area_vector.size());
	area_vector.swap(result_area_vector);
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// Output: Min Max Point 210203
	/*for (auto&& au : area_vector) {
		getSegmentMinMaxPoint(original_time_series, au);
	}*/
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// input: width right endpoint
	// Output: a&b apla coefficient, sum value
	getPLAByAdaptiveSegment(input_argument, original_time_series, area_vector);//190617 sum_value, a, b, apla_coefficient
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
}

//************************************
// Method:initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursiveSpeed
// Qualifier: Recursive split and merge segment. Add split merge process. a,b,width,right_endpoint,apla_coefficient, sum_value. Split segment into 3 sub-segment by minmax point
// 190820 Use Linded list to instead Vector
// date:190820 15:17
// author:
//************************************
TEMPLATE
void APLA::initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursiveSpeed(typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list) {//190918 Recursive merge and split segment
			//int segment_number = input_argument.point_dimension * 2;
	//input_argument.remainder = int(input_argument.time_series_length) % int(segment_number);//For PLA
	//double integerDividend = input_argument.time_series_length - input_argument.remainder;
	//input_argument.segment_length_second = integerDividend / segment_number;
	//input_argument.segment_length_first = input_argument.segment_length_second + 1;

#ifdef _DEBUG
	assert(input_argument.segment_length_first == input_argument.segment_length_second + 1);
	assert(input_argument.segment_length_first > 2);
#endif

	/*====================       Initial variable      ========================*/
	map<double, int> whole_difference_map;
	int original_id = 0;//190617
	int initial_vector_size = input_argument.point_dimension;// = input_argument.point_dimension < 3 ? 3 : input_argument.point_dimension;//190812

	while (initial_vector_size % 3 != 0) {
		++initial_vector_size;
	}
	vector<AREA_COEFFICIENT> result_area_vector;
	AREA_COEFFICIENT segment_1;
	AREA_COEFFICIENT segment_2;
	AREA_COEFFICIENT segment_3;
	int pre_right_endpoint = -1;
	int rest_segment_number = initial_vector_size;
	bool can_merge_end = true;
	int rest_time_series_length = INF;
	/*........................................................................*/

	/*====================================While Loop==========================================================================*/
	while (pre_right_endpoint < input_argument.time_series_length - 1 && rest_segment_number > 0) {
		//while (result_area_vector.size() < area_vector.size()) {
#ifdef _DEBUG
		assert(pre_right_endpoint < input_argument.time_series_length);
		assert(result_area_vector.size() <= initial_vector_size);
		assert(doubly_linked_list.size() <= initial_vector_size);
#endif
		segment_3.min_point.id = INF;
		segment_3.min_point.value = INF;
		segment_3.max_point.id = -INF;
		segment_3.max_point.value = -INF;

		rest_time_series_length = input_argument.time_series_length - (pre_right_endpoint + 1);
		int max_size = ceil(rest_time_series_length / 2);
		if (rest_segment_number >= max_size) {
			rest_segment_number = max_size;
			can_merge_end = false;
		}
		auto remainder = rest_time_series_length % rest_segment_number;//For PLA
		auto segment_width_second = (rest_time_series_length - remainder) / rest_segment_number;
		//auto segment_width_first = segment_width_second + 1;
		/*-----------------------if max size or segment size == 1 or 2-----------------------------*/

		/*=========================Rest Segment Number 1 & 2===========================*/
		if (rest_segment_number == 1) {
			segment_1.right_endpoint = input_argument.time_series_length - 1;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;

			//mergeEndSegment(original_time_series, result_area_vector, segment_1);
			//if (segment_1.rectangle_width != INF && segment_1.right_endpoint != INF) {
			rest_segment_number--;
			segment_1.right_subsegment = new AREA_COEFFICIENT;
			result_area_vector.emplace_back(segment_1);
			doubly_linked_list.add(segment_1);
			//}
			pre_right_endpoint = segment_1.right_endpoint;
#ifdef _DEBUG
			assert(pre_right_endpoint < input_argument.time_series_length&& segment_1.rectangle_width > 1);
#endif
			continue;
		}

		if (rest_segment_number == 2) {
			segment_2.right_endpoint = input_argument.time_series_length - 1;
			segment_2.rectangle_width = max_size;
			segment_1.right_endpoint = segment_2.right_endpoint - segment_2.rectangle_width;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;

#ifdef _DEBUG
			assert(segment_1.rectangle_width == rest_time_series_length - max_size && segment_1.right_endpoint == segment_1.rectangle_width + pre_right_endpoint);
#endif

			//mergeEndSegment(original_time_series, result_area_vector, segment_1);
			//if (segment_1.rectangle_width != INF && segment_1.right_endpoint != INF) {
			--rest_segment_number;
			segment_1.right_subsegment = new AREA_COEFFICIENT;
			result_area_vector.emplace_back(segment_1);
			doubly_linked_list.add(segment_1);
			//}
			//mergeEndSegment(original_time_series, result_area_vector, segment_2);
			//if (segment_2.rectangle_width != INF && segment_2.right_endpoint != INF) {
			--rest_segment_number;
			segment_2.right_subsegment = new AREA_COEFFICIENT;
			result_area_vector.emplace_back(segment_2);
			doubly_linked_list.add(segment_2);
			//}
			pre_right_endpoint = segment_2.right_endpoint;
#ifdef _DEBUG
			assert(pre_right_endpoint == input_argument.time_series_length - 1 && segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1);
#endif
			continue;
		}
		/*..........................................................................*/

		/*......................................................................................................*/
#ifdef _DEBUG
		assert(segment_width_second > 1 && rest_segment_number > -1);
#endif
		/*-- Get segment_3 right endpoint & rectangle width --*/
		segment_3.right_endpoint = segment_width_second * 3;
		segment_3.rectangle_width = segment_3.right_endpoint;
		switch (remainder) {
		case 0:
			break;
		case 1:
			segment_3.right_endpoint++;
			segment_3.rectangle_width++;
			break;
		case 2:
			segment_3.right_endpoint += 2;
			segment_3.rectangle_width += 2;
			break;
		default:
			segment_3.right_endpoint += 3;
			segment_3.rectangle_width += 3;
		}
		segment_3.right_endpoint += pre_right_endpoint;
		/*.................................................*/

#ifdef _DEBUG
		assert(segment_3.rectangle_width > 5 && segment_3.right_endpoint < input_argument.time_series_length&& segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif

		/*===========================Y Projection Method============================================*/
		segment_3.segment_right_point.id = segment_3.right_endpoint;
		segment_3.segment_right_point.value = original_time_series[int(segment_3.right_endpoint)];
		/*..........................................................................................*/

		int final_min_id = 0;
		int final_max_id = 0;
		/*------------------------------Get min max point of segment-----------------------------------------------------------------*/
		for (original_id = pre_right_endpoint + 1; original_id <= segment_3.right_endpoint; original_id++) {
			//assert(original_id >= 0);
			//cout<<original_id<<": "<< original_time_series[original_id]<<", ";
			if (segment_3.min_point.value > original_time_series[original_id]) {
				segment_3.min_point.value = original_time_series[original_id];
				segment_3.min_point.id = original_id;
				//first_min_id = original_id;
			}
			else if (segment_3.min_point.value == original_time_series[original_id]) {
				final_min_id = original_id;
			}

			if (segment_3.max_point.value < original_time_series[original_id]) {
				segment_3.max_point.value = original_time_series[original_id];
				segment_3.max_point.id = original_id;
				//first_max_id = original_id;
			}
			else if (segment_3.max_point.value == original_time_series[original_id]) {
				final_max_id = original_id;
			}

			/*===========================Y Projection Method============================================*/
			//+ Distinguish if time series is burst time series or not
			auto whole_find_difference = whole_difference_map.find(original_time_series[original_id]);
			if (whole_find_difference != whole_difference_map.end())
				whole_find_difference->second++;
			else
				whole_difference_map.emplace_hint(whole_difference_map.end(), original_time_series[original_id], 1);

			/*..........................................................................................*/
		}
		//cout << endl;

		/*=================================get minimal distance of min max points==============================================================*/
		int total_distance = final_min_id + final_max_id;
		if (segment_3.min_point.id != segment_3.max_point.id && total_distance != 0) {
			set<pair<int, pair<int, int>>> min_minmax_distance;
			final_min_id = max(segment_3.min_point.id, final_min_id);
			final_max_id = max(segment_3.max_point.id, final_max_id);
#ifdef _DEBUG
			assert(final_min_id >= 0 && final_max_id >= 0);
			if (final_min_id == final_max_id)
				assert(original_time_series[int(segment_3.min_point.id)] == original_time_series[final_min_id] && original_time_series[int(segment_3.max_point.id)] == original_time_series[final_max_id]);
#endif
			min_minmax_distance.emplace(make_pair(abs(segment_3.min_point.id - segment_3.max_point.id), make_pair(segment_3.min_point.id, segment_3.max_point.id)));
			min_minmax_distance.emplace(make_pair(abs(segment_3.min_point.id - final_max_id), make_pair(segment_3.min_point.id, final_max_id)));
			min_minmax_distance.emplace(make_pair(abs(final_min_id - segment_3.max_point.id), make_pair(final_min_id, segment_3.max_point.id)));
			min_minmax_distance.emplace(make_pair(abs(final_min_id - final_max_id), make_pair(final_min_id, final_max_id)));

			segment_3.min_point.id = (*min_minmax_distance.begin()).second.first;
			segment_3.max_point.id = (*min_minmax_distance.begin()).second.second;
		}
		/*......................................................................................................................................*/

		/*=======================================Not Flat==================================================================================*/
		if (segment_3.max_point.id != segment_3.min_point.id && segment_3.max_point.value != segment_3.min_point.value) {
			segment_1.right_endpoint = min(segment_3.min_point.id, segment_3.max_point.id);
			segment_2.right_endpoint = max(segment_3.min_point.id, segment_3.max_point.id);

			segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
			segment_2.rectangle_width = segment_2.right_endpoint - segment_1.right_endpoint;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;

			/*--------------------------seg1=1,seg3=1 or 0-----------------------------------------------*/
			if (segment_1.rectangle_width == 1 && segment_3.rectangle_width < 2) {//segment_left_id == segment1 right endpoint
#ifdef _DEBUG
				assert(segment_2.rectangle_width > 1);
#endif
				if (segment_3.rectangle_width == 1) {
#ifdef _DEBUG
					assert(segment_2.rectangle_width == segment_3.right_endpoint - pre_right_endpoint - 2);
#endif
					segment_3.right_endpoint--;
				}
				segment_3.rectangle_width = segment_2.rectangle_width + 1;
				segment_2.right_endpoint = INF;
				segment_2.rectangle_width = INF;
				segment_1.right_endpoint = INF;
				segment_1.rectangle_width = INF;
				//rest_segment_size+=2;
#ifdef _DEBUG
				assert(segment_3.rectangle_width > 1 && segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
				/*-------------------------------------------------- SPlit monotony segment-------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				segment_2.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, segment_3);
#ifdef _DEBUG
				assert(segment_3.right_endpoint > 0 && segment_3.right_endpoint - segment_2.right_endpoint > 1);
#endif
				if (segment_2.right_endpoint != INF) {
					//rest_segment_size--;
					segment_2.rectangle_width = segment_3.rectangle_width;
					segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
					segment_2.rectangle_width -= segment_3.rectangle_width;
#ifdef _DEBUG
					assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1 && segment_2.right_endpoint < segment_3.right_endpoint);
#endif
				}
				else {
					assert(0);
					segment_2.rectangle_width = INF;
				}
				/*.............................................................................................................*/
			}
			/*................................................................................................................................................*/
			/*--------------------------seg1 width > 1, seg3=1 or 0-----------------------------------------------*/
			else if (segment_1.rectangle_width > 1 && segment_3.rectangle_width < 2) {
				if (segment_3.rectangle_width == 1) {
#ifdef _DEBUG
					assert(segment_2.rectangle_width == segment_3.right_endpoint - segment_1.right_endpoint - 1);
#endif
					segment_3.right_endpoint--;
				}
				segment_3.rectangle_width = segment_2.rectangle_width;
				segment_2.right_endpoint = INF;
				segment_2.rectangle_width = INF;
				//rest_segment_size++;
#ifdef _DEBUG
				assert(segment_1.rectangle_width + segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
				/*-------------------------------------------------- SPlit monotony segment-------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				segment_2.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, segment_3);

				if (segment_2.right_endpoint != INF) {
					//rest_segment_size--;
					segment_2.rectangle_width = segment_3.rectangle_width;
					segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
					segment_2.rectangle_width -= segment_3.rectangle_width;
#ifdef _DEBUG
					assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1 && segment_2.right_endpoint < segment_3.right_endpoint);
#endif
				}
				else {
					segment_2.rectangle_width = INF;
				}
				/*.............................................................................................................*/
				if (segment_3.rectangle_width == 1) {
					segment_1.rectangle_width--;
					segment_3.rectangle_width++;
					segment_1.right_endpoint--;
#ifdef _DEBUG
					assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
				}
			}
			/*................................................................................................................................................*/
			/*--------------------------seg1 width == 1, seg3>1-----------------------------------------------*/
			else if (segment_1.rectangle_width == 1 && segment_3.rectangle_width > 1) {
				segment_2.rectangle_width++;
				segment_1.right_endpoint = INF;
				segment_1.rectangle_width = INF;
				//rest_segment_size++;
#ifdef _DEBUG
				assert(segment_2.rectangle_width + segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
				/*-------------------------------------------------- SPlit monotony segment-------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				segment_1.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, segment_2);

				if (segment_1.right_endpoint != INF) {
					//rest_segment_size--;
					segment_1.rectangle_width = segment_2.rectangle_width;
					segment_2.rectangle_width = segment_2.right_endpoint - segment_1.right_endpoint;
					segment_1.rectangle_width -= segment_2.rectangle_width;
#ifdef _DEBUG
					assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_1.right_endpoint < segment_2.right_endpoint);
#endif
				}
				else {
					segment_1.rectangle_width = INF;
				}
				/*.............................................................................................................*/
			}
			else {
				if (segment_2.rectangle_width == 0) {
					assert(0);
					//++segment_size;
					//segment_2.right_endpoint = INF;// .at(0);
					//segment_2.rectangle_width = INF;// .at(0);
				}
				if (segment_2.rectangle_width == 1) {
					segment_3.rectangle_width++;
					//++rest_segment_size;
					segment_2.right_endpoint = INF;// .at(0);
					segment_2.rectangle_width = INF;// .at(0);
				}

#ifdef _DEBUG
				assert(segment_1.rectangle_width != INF && segment_3.rectangle_width != INF);
				assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
				//assert(0);
			}
			/*................................................................................................................................................*/

#ifdef _DEBUG
			assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
		}/*=========================================Flat=========================================================*/
		else {
			segment_2.right_endpoint = INF;
			segment_2.rectangle_width = INF;
			segment_1.right_endpoint = INF;
			segment_1.rectangle_width = INF;
#ifdef _DEBUG
			assert(segment_1.right_endpoint == INF && segment_1.rectangle_width == INF && segment_2.right_endpoint == INF && segment_2.rectangle_width == INF);
			assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
			assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
		}

		/*----------------------------------------- Merge previous segments--------------------------------------------------------------------*/

		/*if (segment_1.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_1);
		}
		else if (segment_2.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_2);
		}
		else if (segment_3.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_3);
		}*/

		/*.....................................................................................................................................*/
		//int old_id = result_area_vector.size() - 1;
		/*---------------------------Push back Vector ------------------------------------------------*/
		if (segment_1.right_endpoint != INF) {
			rest_segment_number--;
			segment_1.right_subsegment = new AREA_COEFFICIENT;
			result_area_vector.emplace_back(segment_1);
			doubly_linked_list.add(segment_1);
		}
		if (segment_2.right_endpoint != INF) {
			rest_segment_number--;
			segment_2.right_subsegment = new AREA_COEFFICIENT;
			result_area_vector.emplace_back(segment_2);
			doubly_linked_list.add(segment_2);
		}
		if (segment_3.right_endpoint != INF) {
			rest_segment_number--;
			segment_3.right_subsegment = new AREA_COEFFICIENT;
			result_area_vector.emplace_back(segment_3);
			doubly_linked_list.add(segment_3);
		}
		/*................................................................................................*/

		if (result_area_vector.back().right_endpoint == input_argument.time_series_length - 2) {
			result_area_vector.back().right_endpoint++;
			result_area_vector.back().rectangle_width++;
		}

		if (doubly_linked_list.back().right_endpoint == input_argument.time_series_length - 2) {
			doubly_linked_list.back().right_endpoint++;
			doubly_linked_list.back().rectangle_width++;
		}

		pre_right_endpoint = result_area_vector.back().right_endpoint;
		assert(result_area_vector.back().right_endpoint == doubly_linked_list.back().right_endpoint);
		pre_right_endpoint = doubly_linked_list.back().right_endpoint;

		/*.......................................................................................................................................................................*/
#ifdef _DEBUG
		assert(segment_3.min_point.id <= segment_3.right_endpoint && segment_3.max_point.id <= segment_3.right_endpoint);
		assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
	}
	/*......................................................................................................*/

#ifdef _DEBUG
	assert(result_area_vector.size() <= initial_vector_size);
	assert(doubly_linked_list.size() <= initial_vector_size);
	assert(result_area_vector.back().right_endpoint == input_argument.time_series_length - 1);
	assert(doubly_linked_list.back().right_endpoint == input_argument.time_series_length - 1);

	//test segment width
	assert(result_area_vector[0].rectangle_width == result_area_vector[0].right_endpoint + 1);
	for (int segment_id = 1; segment_id < result_area_vector.size(); segment_id++) {
		assert(result_area_vector[segment_id].rectangle_width == result_area_vector[segment_id].right_endpoint - result_area_vector[segment_id - 1].right_endpoint);
	}

	assert(doubly_linked_list.front().rectangle_width == doubly_linked_list.front().right_endpoint + 1);
	for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
		assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint);
	}

#endif

	/*=============================================Y Porjection Method==================================================================================*/
	//if (whole_difference_map.size() < 21) {
	//	//Use Y projection method
	//	input_argument.is_y_projection = true;
	//	yProjectionAPLAInitial(input_argument, original_time_series, whole_difference_map, area_vector);//190730
	//	//cout << "#$#$@%%#$%$^((_))+_)_+)+)+)+_)_+  Whole points difference is: " << whole_difference_map.size() << endl;
	//	yProjectionAPLAMerge(input_argument, original_time_series, whole_difference_map, area_vector);//190731
	//	//++++input: width right endpoint
	//	//++++Output: a&b apla coefficient, sum value
	//	getPLAByAdaptiveSegment(input_argument, original_time_series, area_vector);//190617 sum_value, a, b, apla_coefficient
	//	return;
	//	/*for (auto&& au : whole_difference_map) {
	//		cout << au.first << " " << au.second<<endl;
	//	}
	//	cout << endl;*/
	//}
	/*.................................................................................................................................................*/
	/*---------------------------------------------------- Split Segment increase vector----------------------------------------------------------------------------------------*/

	if (result_area_vector.size() < input_argument.point_dimension) {
		//int count = 1;
		int old_segment_size = result_area_vector.size();
		for (int segment_id = 0; result_area_vector.size() < input_argument.point_dimension; segment_id++) {
			//if (segment_id >= result_area_vector.size()) {
				//segment_id = 0;
				//count--;

			//}

			/*if (result_area_vector[segment_id].right_endpoint==280) {
				cout << result_area_vector[segment_id].deviation_point.value << endl;
				assert(0);
			}*/

			if (result_area_vector[segment_id].deviation_point.value != -1 && result_area_vector[segment_id].rectangle_width > 3) {
				AREA_COEFFICIENT sub_segment;
				sub_segment.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, result_area_vector[segment_id]);
				//sub_segment.right_endpoint=findSegmentMiddleID(result_area_vector[segment_id]);
#ifdef _DEBUG
				assert(sub_segment.right_endpoint > 0);
#endif
				if (sub_segment.right_endpoint != INF) {
					sub_segment.rectangle_width = result_area_vector[segment_id].rectangle_width;
					result_area_vector[segment_id].rectangle_width = result_area_vector[segment_id].right_endpoint - sub_segment.right_endpoint;
					sub_segment.rectangle_width -= result_area_vector[segment_id].rectangle_width;
#ifdef _DEBUG
					assert(sub_segment.rectangle_width > 1 && result_area_vector[segment_id].rectangle_width > 1 && sub_segment.right_endpoint < result_area_vector[segment_id].right_endpoint);
					if (segment_id > 0)
						assert(sub_segment.rectangle_width + result_area_vector[segment_id].rectangle_width == result_area_vector[segment_id].right_endpoint - result_area_vector[segment_id - 1].right_endpoint);
#endif
					result_area_vector.insert(result_area_vector.begin() + segment_id, sub_segment);
					segment_id++;
				}
				else {
					continue;
				}
			}
		}
	}

	if (doubly_linked_list.size() < input_argument.point_dimension) {
		//int count = 1;
		int old_segment_size = doubly_linked_list.size();
		for (int segment_id = 0; doubly_linked_list.size() < input_argument.point_dimension; segment_id++) {
			//if (segment_id >= doubly_linked_list.size()) {
				//segment_id = 0;
				//count--;

			//}

			/*if (doubly_linked_list[segment_id].right_endpoint==280) {
				cout << doubly_linked_list[segment_id].deviation_point.value << endl;
				assert(0);
			}*/

			if (doubly_linked_list[segment_id].deviation_point.value != -1 && doubly_linked_list[segment_id].rectangle_width > 3) {
				AREA_COEFFICIENT sub_segment;
				sub_segment.right_subsegment = new AREA_COEFFICIENT;
				sub_segment.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, doubly_linked_list[segment_id]);
				//sub_segment.right_endpoint=findSegmentMiddleID(result_area_vector[segment_id]);
#ifdef _DEBUG
				assert(sub_segment.right_endpoint > 0);
#endif
				if (sub_segment.right_endpoint != INF) {
					sub_segment.rectangle_width = doubly_linked_list[segment_id].rectangle_width;
					doubly_linked_list[segment_id].rectangle_width = doubly_linked_list[segment_id].right_endpoint - sub_segment.right_endpoint;
					sub_segment.rectangle_width -= doubly_linked_list[segment_id].rectangle_width;
#ifdef _DEBUG
					assert(sub_segment.rectangle_width > 1 && doubly_linked_list[segment_id].rectangle_width > 1 && sub_segment.right_endpoint < doubly_linked_list[segment_id].right_endpoint);
					if (segment_id > 0)
						assert(sub_segment.rectangle_width + doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint);
#endif
					doubly_linked_list.add(segment_id, sub_segment);
					segment_id++;
				}
				else {
					continue;
				}
			}
		}
	}

	/*......................................................................................................................................................................*/
#ifdef _DEBUG
	assert(result_area_vector.size() >= input_argument.point_dimension);
	assert(doubly_linked_list.size() >= input_argument.point_dimension);
	for (int segment_id = 1; segment_id < result_area_vector.size(); segment_id++) {
		assert(result_area_vector[segment_id].rectangle_width == result_area_vector[segment_id].right_endpoint - result_area_vector[segment_id - 1].right_endpoint && result_area_vector[segment_id].rectangle_width > 1);
	}

	for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
		assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint && doubly_linked_list[segment_id].rectangle_width > 1);
	}
#endif
	//assert(result_area_vector.size() <= area_vector.size());
	area_vector.swap(result_area_vector);
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// Output: Min Max Point 210203
	for (auto&& au : area_vector) {
		getSegmentMinMaxPoint(original_time_series, au);
	}

	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		getSegmentMinMaxPoint(original_time_series, doubly_linked_list[segment_id]);
	}
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// input: width right endpoint
	// Output: a&b apla coefficient, sum value
	getPLAByAdaptiveSegment(input_argument, original_time_series, area_vector);//190617 sum_value, a, b, apla_coefficient
	getPLAByAdaptiveSegment(input_argument, original_time_series, doubly_linked_list);//190822 sum_value, a, b, apla_coefficient
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	compareLinkListAndVector(doubly_linked_list, area_vector);
}

//190918 Linked List
//************************************
// Method:initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursiveSpeed
// Qualifier: Recursive split and merge segment. Add split merge process. a,b,width,right_endpoint,apla_coefficient, sum_value. Split segment into 3 sub-segment by minmax point
// 190918 Use Linded list
// date:190918 10:33
// author:
//************************************
TEMPLATE
void APLA::initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursiveSpeed(typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list) {//190820 Recursive merge and split segment
		//int segment_number = input_argument.point_dimension * 2;
	//input_argument.remainder = int(input_argument.time_series_length) % int(segment_number);//For PLA
	//double integerDividend = input_argument.time_series_length - input_argument.remainder;
	//input_argument.segment_length_second = integerDividend / segment_number;
	//input_argument.segment_length_first = input_argument.segment_length_second + 1;

#ifdef _DEBUG
	assert(input_argument.segment_length_first == input_argument.segment_length_second + 1);
	assert(input_argument.segment_length_first > 2);
#endif

	/*====================       Initial variable      ========================*/
	map<double, int> whole_difference_map;
	int original_id = 0;//190617
	int initial_vector_size = input_argument.point_dimension;// = input_argument.point_dimension < 3 ? 3 : input_argument.point_dimension;//190812

	while (initial_vector_size % 3 != 0) {
		++initial_vector_size;
	}
	//vector<AREA_COEFFICIENT> result_area_vector;
	AREA_COEFFICIENT segment_1;
	AREA_COEFFICIENT segment_2;
	AREA_COEFFICIENT segment_3;
	int pre_right_endpoint = -1;
	int rest_segment_number = initial_vector_size;
	bool can_merge_end = true;
	int rest_time_series_length = INF;
	/*........................................................................*/

	/*====================================While Loop==========================================================================*/
	while (pre_right_endpoint < input_argument.time_series_length - 1 && rest_segment_number > 0) {
		//while (result_area_vector.size() < area_vector.size()) {
#ifdef _DEBUG
		assert(pre_right_endpoint < input_argument.time_series_length);
		assert(doubly_linked_list.size() <= initial_vector_size);
#endif
		segment_3.min_point.id = INF;
		segment_3.min_point.value = INF;
		segment_3.max_point.id = -INF;
		segment_3.max_point.value = -INF;

		rest_time_series_length = input_argument.time_series_length - (pre_right_endpoint + 1);
		int max_size = ceil(rest_time_series_length / 2);
		if (rest_segment_number >= max_size) {
			rest_segment_number = max_size;
			can_merge_end = false;
		}
		auto remainder = rest_time_series_length % rest_segment_number;//For PLA
		auto segment_width_second = (rest_time_series_length - remainder) / rest_segment_number;
		//auto segment_width_first = segment_width_second + 1;
		/*-----------------------if max size or segment size == 1 or 2-----------------------------*/

		/*=========================Rest Segment Number 1 & 2===========================*/
		if (rest_segment_number == 1) {
			segment_1.right_endpoint = input_argument.time_series_length - 1;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;

			//mergeEndSegment(original_time_series, result_area_vector, segment_1);
			//if (segment_1.rectangle_width != INF && segment_1.right_endpoint != INF) {
			rest_segment_number--;
			segment_1.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_1);
			//}
			pre_right_endpoint = segment_1.right_endpoint;
#ifdef _DEBUG
			assert(pre_right_endpoint < input_argument.time_series_length&& segment_1.rectangle_width > 1);
#endif
			continue;
		}

		if (rest_segment_number == 2) {
			segment_2.right_endpoint = input_argument.time_series_length - 1;
			segment_2.rectangle_width = max_size;
			segment_1.right_endpoint = segment_2.right_endpoint - segment_2.rectangle_width;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;

#ifdef _DEBUG
			assert(segment_1.rectangle_width == rest_time_series_length - max_size && segment_1.right_endpoint == segment_1.rectangle_width + pre_right_endpoint);
#endif

			//mergeEndSegment(original_time_series, result_area_vector, segment_1);
			//if (segment_1.rectangle_width != INF && segment_1.right_endpoint != INF) {
			--rest_segment_number;
			segment_1.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_1);
			//}
			//mergeEndSegment(original_time_series, result_area_vector, segment_2);
			//if (segment_2.rectangle_width != INF && segment_2.right_endpoint != INF) {
			--rest_segment_number;
			segment_2.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_2);
			//}
			pre_right_endpoint = segment_2.right_endpoint;
#ifdef _DEBUG
			assert(pre_right_endpoint == input_argument.time_series_length - 1 && segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1);
#endif
			continue;
		}
		/*..........................................................................*/

		/*......................................................................................................*/
#ifdef _DEBUG
		assert(segment_width_second > 1 && rest_segment_number > -1);
#endif
		/*-- Get segment_3 right endpoint & rectangle width --*/
		segment_3.right_endpoint = segment_width_second * 3;
		segment_3.rectangle_width = segment_3.right_endpoint;
		switch (remainder) {
		case 0:
			break;
		case 1:
			segment_3.right_endpoint++;
			segment_3.rectangle_width++;
			break;
		case 2:
			segment_3.right_endpoint += 2;
			segment_3.rectangle_width += 2;
			break;
		default:
			segment_3.right_endpoint += 3;
			segment_3.rectangle_width += 3;
		}
		segment_3.right_endpoint += pre_right_endpoint;
		/*.................................................*/

#ifdef _DEBUG
		assert(segment_3.rectangle_width > 5 && segment_3.right_endpoint < input_argument.time_series_length&& segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif

		/*===========================Y Projection Method============================================*/
		segment_3.segment_right_point.id = segment_3.right_endpoint;
		segment_3.segment_right_point.value = original_time_series[int(segment_3.right_endpoint)];
		/*..........................................................................................*/

		int final_min_id = 0;
		int final_max_id = 0;
		/*------------------------------Get min max point of segment-----------------------------------------------------------------*/
		for (original_id = pre_right_endpoint + 1; original_id <= segment_3.right_endpoint; original_id++) {
			//assert(original_id >= 0);
			//cout<<original_id<<": "<< original_time_series[original_id]<<", ";
			if (segment_3.min_point.value > original_time_series[original_id]) {
				segment_3.min_point.value = original_time_series[original_id];
				segment_3.min_point.id = original_id;
				//first_min_id = original_id;
			}
			else if (segment_3.min_point.value == original_time_series[original_id]) {
				final_min_id = original_id;
			}

			if (segment_3.max_point.value < original_time_series[original_id]) {
				segment_3.max_point.value = original_time_series[original_id];
				segment_3.max_point.id = original_id;
				//first_max_id = original_id;
			}
			else if (segment_3.max_point.value == original_time_series[original_id]) {
				final_max_id = original_id;
			}

			/*===========================Y Projection Method============================================*/
			//+ Distinguish if time series is burst time series or not
			auto whole_find_difference = whole_difference_map.find(original_time_series[original_id]);
			if (whole_find_difference != whole_difference_map.end())
				whole_find_difference->second++;
			else
				whole_difference_map.emplace_hint(whole_difference_map.end(), original_time_series[original_id], 1);

			/*..........................................................................................*/
		}
		//cout << endl;

		/*=================================get minimal distance of min max points==============================================================*/
		int total_distance = final_min_id + final_max_id;
		if (segment_3.min_point.id != segment_3.max_point.id && total_distance != 0) {
			set<pair<int, pair<int, int>>> min_minmax_distance;
			final_min_id = max(segment_3.min_point.id, final_min_id);
			final_max_id = max(segment_3.max_point.id, final_max_id);
#ifdef _DEBUG
			assert(final_min_id >= 0 && final_max_id >= 0);
			if (final_min_id == final_max_id)
				assert(original_time_series[int(segment_3.min_point.id)] == original_time_series[final_min_id] && original_time_series[int(segment_3.max_point.id)] == original_time_series[final_max_id]);
#endif
			min_minmax_distance.emplace(make_pair(abs(segment_3.min_point.id - segment_3.max_point.id), make_pair(segment_3.min_point.id, segment_3.max_point.id)));
			min_minmax_distance.emplace(make_pair(abs(segment_3.min_point.id - final_max_id), make_pair(segment_3.min_point.id, final_max_id)));
			min_minmax_distance.emplace(make_pair(abs(final_min_id - segment_3.max_point.id), make_pair(final_min_id, segment_3.max_point.id)));
			min_minmax_distance.emplace(make_pair(abs(final_min_id - final_max_id), make_pair(final_min_id, final_max_id)));

			segment_3.min_point.id = (*min_minmax_distance.begin()).second.first;
			segment_3.max_point.id = (*min_minmax_distance.begin()).second.second;
		}
		/*......................................................................................................................................*/

		/*=======================================Not Flat==================================================================================*/
		if (segment_3.max_point.id != segment_3.min_point.id && segment_3.max_point.value != segment_3.min_point.value) {
			segment_1.right_endpoint = min(segment_3.min_point.id, segment_3.max_point.id);
			segment_2.right_endpoint = max(segment_3.min_point.id, segment_3.max_point.id);

			segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
			segment_2.rectangle_width = segment_2.right_endpoint - segment_1.right_endpoint;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;

			/*--------------------------seg1=1,seg3=1 or 0-----------------------------------------------*/
			if (segment_1.rectangle_width == 1 && segment_3.rectangle_width < 2) {//segment_left_id == segment1 right endpoint
#ifdef _DEBUG
				assert(segment_2.rectangle_width > 1);
#endif
				if (segment_3.rectangle_width == 1) {
#ifdef _DEBUG
					assert(segment_2.rectangle_width == segment_3.right_endpoint - pre_right_endpoint - 2);
#endif
					segment_3.right_endpoint--;
				}
				segment_3.rectangle_width = segment_2.rectangle_width + 1;
				segment_2.right_endpoint = INF;
				segment_2.rectangle_width = INF;
				segment_1.right_endpoint = INF;
				segment_1.rectangle_width = INF;
				//rest_segment_size+=2;
#ifdef _DEBUG
				assert(segment_3.rectangle_width > 1 && segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
				/*-------------------------------------------------- SPlit monotony segment-------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				segment_2.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, segment_3);
#ifdef _DEBUG
				assert(segment_3.right_endpoint > 0 && segment_3.right_endpoint - segment_2.right_endpoint > 1);
#endif
				if (segment_2.right_endpoint != INF) {
					//rest_segment_size--;
					segment_2.rectangle_width = segment_3.rectangle_width;
					segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
					segment_2.rectangle_width -= segment_3.rectangle_width;
#ifdef _DEBUG
					assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1 && segment_2.right_endpoint < segment_3.right_endpoint);
#endif
				}
				else {
					assert(0);
					segment_2.rectangle_width = INF;
				}
				/*.............................................................................................................*/
			}
			/*................................................................................................................................................*/
			/*--------------------------seg1 width > 1, seg3=1 or 0-----------------------------------------------*/
			else if (segment_1.rectangle_width > 1 && segment_3.rectangle_width < 2) {
				if (segment_3.rectangle_width == 1) {
#ifdef _DEBUG
					assert(segment_2.rectangle_width == segment_3.right_endpoint - segment_1.right_endpoint - 1);
#endif
					segment_3.right_endpoint--;
				}
				segment_3.rectangle_width = segment_2.rectangle_width;
				segment_2.right_endpoint = INF;
				segment_2.rectangle_width = INF;
				//rest_segment_size++;
#ifdef _DEBUG
				assert(segment_1.rectangle_width + segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
				/*-------------------------------------------------- SPlit monotony segment-------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				segment_2.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, segment_3);

				if (segment_2.right_endpoint != INF) {
					//rest_segment_size--;
					segment_2.rectangle_width = segment_3.rectangle_width;
					segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
					segment_2.rectangle_width -= segment_3.rectangle_width;
#ifdef _DEBUG
					assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1 && segment_2.right_endpoint < segment_3.right_endpoint);
#endif
				}
				else {
					segment_2.rectangle_width = INF;
				}
				/*.............................................................................................................*/
				if (segment_3.rectangle_width == 1) {
					segment_1.rectangle_width--;
					segment_3.rectangle_width++;
					segment_1.right_endpoint--;
#ifdef _DEBUG
					assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
				}
			}
			/*................................................................................................................................................*/
			/*--------------------------seg1 width == 1, seg3>1-----------------------------------------------*/
			else if (segment_1.rectangle_width == 1 && segment_3.rectangle_width > 1) {
				segment_2.rectangle_width++;
				segment_1.right_endpoint = INF;
				segment_1.rectangle_width = INF;
				//rest_segment_size++;
#ifdef _DEBUG
				assert(segment_2.rectangle_width + segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
				/*-------------------------------------------------- SPlit monotony segment-------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				segment_1.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, segment_2);

				if (segment_1.right_endpoint != INF) {
					//rest_segment_size--;
					segment_1.rectangle_width = segment_2.rectangle_width;
					segment_2.rectangle_width = segment_2.right_endpoint - segment_1.right_endpoint;
					segment_1.rectangle_width -= segment_2.rectangle_width;
#ifdef _DEBUG
					assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_1.right_endpoint < segment_2.right_endpoint);
#endif
				}
				else {
					segment_1.rectangle_width = INF;
				}
				/*.............................................................................................................*/
			}
			else {
				if (segment_2.rectangle_width == 0) {
					assert(0);
					//++segment_size;
					//segment_2.right_endpoint = INF;// .at(0);
					//segment_2.rectangle_width = INF;// .at(0);
				}
				if (segment_2.rectangle_width == 1) {
					segment_3.rectangle_width++;
					//++rest_segment_size;
					segment_2.right_endpoint = INF;// .at(0);
					segment_2.rectangle_width = INF;// .at(0);
				}

#ifdef _DEBUG
				assert(segment_1.rectangle_width != INF && segment_3.rectangle_width != INF);
				assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
				//assert(0);
			}
			/*................................................................................................................................................*/

#ifdef _DEBUG
			assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
		}/*=========================================Flat=========================================================*/
		else {
			segment_2.right_endpoint = INF;
			segment_2.rectangle_width = INF;
			segment_1.right_endpoint = INF;
			segment_1.rectangle_width = INF;
#ifdef _DEBUG
			assert(segment_1.right_endpoint == INF && segment_1.rectangle_width == INF && segment_2.right_endpoint == INF && segment_2.rectangle_width == INF);
			assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
			assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
		}

		/*----------------------------------------- Merge previous segments--------------------------------------------------------------------*/

		/*if (segment_1.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_1);
		}
		else if (segment_2.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_2);
		}
		else if (segment_3.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_3);
		}*/

		/*.....................................................................................................................................*/
		//int old_id = result_area_vector.size() - 1;
		/*---------------------------Push back Vector ------------------------------------------------*/
		if (segment_1.right_endpoint != INF) {
			rest_segment_number--;
			segment_1.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_1);
		}
		if (segment_2.right_endpoint != INF) {
			rest_segment_number--;
			segment_2.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_2);
		}
		if (segment_3.right_endpoint != INF) {
			rest_segment_number--;
			segment_3.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_3);
		}
		/*................................................................................................*/

		if (doubly_linked_list.back().right_endpoint == input_argument.time_series_length - 2) {
			doubly_linked_list.back().right_endpoint++;
			doubly_linked_list.back().rectangle_width++;
		}
		pre_right_endpoint = doubly_linked_list.back().right_endpoint;

		/*.......................................................................................................................................................................*/
#ifdef _DEBUG
		assert(segment_3.min_point.id <= segment_3.right_endpoint && segment_3.max_point.id <= segment_3.right_endpoint);
		assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
	}
	/*......................................................................................................*/

#ifdef _DEBUG
	assert(doubly_linked_list.size() <= initial_vector_size);
	assert(doubly_linked_list.back().right_endpoint == input_argument.time_series_length - 1);

	//test segment width
	assert(doubly_linked_list.front().rectangle_width == doubly_linked_list.front().right_endpoint + 1);
	for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
		assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint);
	}

#endif

	/*=============================================Y Porjection Method==================================================================================*/
	//if (whole_difference_map.size() < 21) {
	//	//Use Y projection method
	//	input_argument.is_y_projection = true;
	//	yProjectionAPLAInitial(input_argument, original_time_series, whole_difference_map, area_vector);//190730
	//	//cout << "#$#$@%%#$%$^((_))+_)_+)+)+)+_)_+  Whole points difference is: " << whole_difference_map.size() << endl;
	//	yProjectionAPLAMerge(input_argument, original_time_series, whole_difference_map, area_vector);//190731
	//	//++++input: width right endpoint
	//	//++++Output: a&b apla coefficient, sum value
	//	getPLAByAdaptiveSegment(input_argument, original_time_series, area_vector);//190617 sum_value, a, b, apla_coefficient
	//	return;
	//	/*for (auto&& au : whole_difference_map) {
	//		cout << au.first << " " << au.second<<endl;
	//	}
	//	cout << endl;*/
	//}
	/*.................................................................................................................................................*/
	/*---------------------------------------------------- Split Segment increase vector----------------------------------------------------------------------------------------*/

	if (doubly_linked_list.size() < input_argument.point_dimension) {
		//int count = 1;
		int old_segment_size = doubly_linked_list.size();
		for (int segment_id = 0; doubly_linked_list.size() < input_argument.point_dimension; segment_id++) {
			//if (segment_id >= doubly_linked_list.size()) {
				//segment_id = 0;
				//count--;

			//}

			/*if (doubly_linked_list[segment_id].right_endpoint==280) {
				cout << doubly_linked_list[segment_id].deviation_point.value << endl;
				assert(0);
			}*/

			if (doubly_linked_list[segment_id].deviation_point.value != -1 && doubly_linked_list[segment_id].rectangle_width > 3) {
				AREA_COEFFICIENT sub_segment;
				sub_segment.right_subsegment = new AREA_COEFFICIENT;
				sub_segment.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, doubly_linked_list[segment_id]);
				//sub_segment.right_endpoint=findSegmentMiddleID(result_area_vector[segment_id]);
#ifdef _DEBUG
				assert(sub_segment.right_endpoint > 0);
#endif
				if (sub_segment.right_endpoint != INF) {
					sub_segment.rectangle_width = doubly_linked_list[segment_id].rectangle_width;
					doubly_linked_list[segment_id].rectangle_width = doubly_linked_list[segment_id].right_endpoint - sub_segment.right_endpoint;
					sub_segment.rectangle_width -= doubly_linked_list[segment_id].rectangle_width;
#ifdef _DEBUG
					assert(sub_segment.rectangle_width > 1 && doubly_linked_list[segment_id].rectangle_width > 1 && sub_segment.right_endpoint < doubly_linked_list[segment_id].right_endpoint);
					if (segment_id > 0)
						assert(sub_segment.rectangle_width + doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint);
#endif
					doubly_linked_list.add(segment_id, sub_segment);
					segment_id++;
				}
				else {
					continue;
				}
			}
		}
	}

	/*......................................................................................................................................................................*/
#ifdef _DEBUG
	assert(doubly_linked_list.size() >= input_argument.point_dimension);
	for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
		assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint && doubly_linked_list[segment_id].rectangle_width > 1);
	}
#endif
	//assert(result_area_vector.size() <= area_vector.size());
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// Output: Min Max Point

	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		getSegmentMinMaxPoint(original_time_series, doubly_linked_list[segment_id]);
	}
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// input: width right endpoint
	// Output: a&b apla coefficient, sum value
	getPLAByAdaptiveSegment(input_argument, original_time_series, doubly_linked_list);//190822 sum_value, a, b, apla_coefficient
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
}

//190918 Linked List
//************************************
// Method:initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursiveSpeed
// Qualifier: Recursive split and merge segment. Add split merge process. a,b,width,right_endpoint,apla_coefficient, sum_value. Split segment into 3 sub-segment by minmax point
// 190918 Use Linded list
// date:190918 10:33
// author:
//************************************
TEMPLATE
void APLA::initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursiveSpeed1(typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list) {//190918 Recursive merge and split segment
#ifdef _DEBUG
	assert(input_argument.segment_length_first == input_argument.segment_length_second + 1);
	assert(input_argument.segment_length_first > 2);
#endif

	/*====================       Initial variable      ========================*/
	//map<double, int> whole_difference_map;
	int original_id = 0;//190617
	int initial_vector_size = input_argument.point_dimension;// = input_argument.point_dimension < 3 ? 3 : input_argument.point_dimension;//190812

	while (initial_vector_size % 3 != 0) {
		++initial_vector_size;
	}
	//vector<AREA_COEFFICIENT> result_area_vector;
	AREA_COEFFICIENT segment_1;
	AREA_COEFFICIENT segment_2;
	AREA_COEFFICIENT segment_3;
	int pre_right_endpoint = -1;
	int rest_segment_number = initial_vector_size;
	bool can_merge_end = true;
	int rest_time_series_length = INF;
	/*........................................................................*/

	/*====================================While Loop==========================================================================*/
	while (pre_right_endpoint < input_argument.time_series_length - 1 && rest_segment_number > 0) {
		//while (result_area_vector.size() < area_vector.size()) {
#ifdef _DEBUG
		assert(pre_right_endpoint < input_argument.time_series_length);
		assert(doubly_linked_list.size() <= initial_vector_size);
#endif
		segment_3.min_point.id = INF;
		segment_3.min_point.value = INF;
		segment_3.max_point.id = -INF;
		segment_3.max_point.value = -INF;

		rest_time_series_length = input_argument.time_series_length - (pre_right_endpoint + 1);
		int max_size = ceil(rest_time_series_length / 2);
		if (rest_segment_number >= max_size) {
			rest_segment_number = max_size;
			can_merge_end = false;
		}
		auto remainder = rest_time_series_length % rest_segment_number;//For PLA
		auto segment_width_second = (rest_time_series_length - remainder) / rest_segment_number;
		//auto segment_width_first = segment_width_second + 1;
		/*-----------------------if max size or segment size == 1 or 2-----------------------------*/

		/*=========================Rest Segment Number 1 & 2===========================*/
		if (rest_segment_number == 1) {
			segment_1.right_endpoint = input_argument.time_series_length - 1;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;

			//mergeEndSegment(original_time_series, result_area_vector, segment_1);
			//if (segment_1.rectangle_width != INF && segment_1.right_endpoint != INF) {
			rest_segment_number--;
			segment_1.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_1);
			//}
			pre_right_endpoint = segment_1.right_endpoint;
#ifdef _DEBUG
			assert(pre_right_endpoint < input_argument.time_series_length&& segment_1.rectangle_width > 1);
#endif
			continue;
		}

		if (rest_segment_number == 2) {
			segment_2.right_endpoint = input_argument.time_series_length - 1;
			segment_2.rectangle_width = max_size;
			segment_1.right_endpoint = segment_2.right_endpoint - segment_2.rectangle_width;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;

#ifdef _DEBUG
			assert(segment_1.rectangle_width == rest_time_series_length - max_size && segment_1.right_endpoint == segment_1.rectangle_width + pre_right_endpoint);
#endif

			//mergeEndSegment(original_time_series, result_area_vector, segment_1);
			//if (segment_1.rectangle_width != INF && segment_1.right_endpoint != INF) {
			--rest_segment_number;
			segment_1.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_1);
			//}
			//mergeEndSegment(original_time_series, result_area_vector, segment_2);
			//if (segment_2.rectangle_width != INF && segment_2.right_endpoint != INF) {
			--rest_segment_number;
			segment_2.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_2);
			//}
			pre_right_endpoint = segment_2.right_endpoint;
#ifdef _DEBUG
			assert(pre_right_endpoint == input_argument.time_series_length - 1 && segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1);
#endif
			continue;
		}
		/*..........................................................................*/

		/*......................................................................................................*/
#ifdef _DEBUG
		assert(segment_width_second > 1 && rest_segment_number > -1);
#endif
		/*-- Get segment_3 right endpoint & rectangle width --*/
		segment_3.right_endpoint = segment_width_second * 3;
		segment_3.rectangle_width = segment_3.right_endpoint;
		switch (remainder) {
		case 0:
			break;
		case 1:
			segment_3.right_endpoint++;
			segment_3.rectangle_width++;
			break;
		case 2:
			segment_3.right_endpoint += 2;
			segment_3.rectangle_width += 2;
			break;
		default:
			segment_3.right_endpoint += 3;
			segment_3.rectangle_width += 3;
		}
		segment_3.right_endpoint += pre_right_endpoint;
		/*.................................................*/

#ifdef _DEBUG
		assert(segment_3.rectangle_width > 5 && segment_3.right_endpoint < input_argument.time_series_length&& segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif

		/*===========================Y Projection Method============================================*/
		//segment_3.segment_right_point.id = segment_3.right_endpoint;
		//segment_3.segment_right_point.value = original_time_series[int(segment_3.right_endpoint)];
		/*..........................................................................................*/

		int final_min_id = 0;
		int final_max_id = 0;
		/*------------------------------Get min max point of segment-----------------------------------------------------------------*/
		for (original_id = pre_right_endpoint + 1; original_id <= segment_3.right_endpoint; original_id++) {
			//assert(original_id >= 0);
			//cout<<original_id<<": "<< original_time_series[original_id]<<", ";
			if (segment_3.min_point.value > original_time_series[original_id]) {
				segment_3.min_point.value = original_time_series[original_id];
				segment_3.min_point.id = original_id;
				//first_min_id = original_id;
			}
			else if (segment_3.min_point.value == original_time_series[original_id]) {
				final_min_id = original_id;
			}

			if (segment_3.max_point.value < original_time_series[original_id]) {
				segment_3.max_point.value = original_time_series[original_id];
				segment_3.max_point.id = original_id;
				//first_max_id = original_id;
			}
			else if (segment_3.max_point.value == original_time_series[original_id]) {
				final_max_id = original_id;
			}

			/*===========================Y Projection Method============================================*/
			//+ Distinguish if time series is burst time series or not
			/*auto whole_find_difference = whole_difference_map.find(original_time_series[original_id]);
			if (whole_find_difference != whole_difference_map.end())
				whole_find_difference->second++;
			else
				whole_difference_map.emplace_hint(whole_difference_map.end(), original_time_series[original_id], 1);
*/
/*..........................................................................................*/
		}
		//cout << endl;

		/*=================================get minimal distance of min max points==============================================================*/
		/*int total_distance = final_min_id + final_max_id;
		if (segment_3.min_point.id != segment_3.max_point.id && total_distance != 0) {
			set<pair<int, pair<int, int>>> min_minmax_distance;
			final_min_id = max(segment_3.min_point.id, final_min_id);
			final_max_id = max(segment_3.max_point.id, final_max_id);
#ifdef _DEBUG
			assert(final_min_id >= 0 && final_max_id >= 0);
			if (final_min_id == final_max_id)
				assert(original_time_series[int(segment_3.min_point.id)] == original_time_series[final_min_id] && original_time_series[int(segment_3.max_point.id)] == original_time_series[final_max_id]);
#endif
			min_minmax_distance.emplace(make_pair(abs(segment_3.min_point.id - segment_3.max_point.id), make_pair(segment_3.min_point.id, segment_3.max_point.id)));
			min_minmax_distance.emplace(make_pair(abs(segment_3.min_point.id - final_max_id), make_pair(segment_3.min_point.id, final_max_id)));
			min_minmax_distance.emplace(make_pair(abs(final_min_id - segment_3.max_point.id), make_pair(final_min_id, segment_3.max_point.id)));
			min_minmax_distance.emplace(make_pair(abs(final_min_id - final_max_id), make_pair(final_min_id, final_max_id)));

			segment_3.min_point.id = (*min_minmax_distance.begin()).second.first;
			segment_3.max_point.id = (*min_minmax_distance.begin()).second.second;
		}*/
		/*......................................................................................................................................*/

		/*=======================================Not Flat==================================================================================*/
		if (segment_3.max_point.id != segment_3.min_point.id && segment_3.max_point.value != segment_3.min_point.value) {
			segment_1.right_endpoint = min(segment_3.min_point.id, segment_3.max_point.id);
			segment_2.right_endpoint = max(segment_3.min_point.id, segment_3.max_point.id);

			segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
			segment_2.rectangle_width = segment_2.right_endpoint - segment_1.right_endpoint;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;

			/*--------------------------seg1=1,seg3=1 or 0-----------------------------------------------*/
			if (segment_1.rectangle_width == 1 && segment_3.rectangle_width < 2) {//segment_left_id == segment1 right endpoint
#ifdef _DEBUG
				assert(segment_2.rectangle_width > 1);
#endif
				if (segment_3.rectangle_width == 1) {
#ifdef _DEBUG
					assert(segment_2.rectangle_width == segment_3.right_endpoint - pre_right_endpoint - 2);
#endif
					segment_3.right_endpoint--;
				}
				segment_3.rectangle_width = segment_2.rectangle_width + 1;
				segment_2.right_endpoint = INF;
				segment_2.rectangle_width = INF;
				segment_1.right_endpoint = INF;
				segment_1.rectangle_width = INF;
				//rest_segment_size+=2;
#ifdef _DEBUG
				assert(segment_3.rectangle_width > 1 && segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
				/*-------------------------------------------------- SPlit monotony segment-------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				segment_2.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, segment_3);
#ifdef _DEBUG
				assert(segment_3.right_endpoint > 0 && segment_3.right_endpoint - segment_2.right_endpoint > 1);
#endif
				if (segment_2.right_endpoint != INF) {
					//rest_segment_size--;
					segment_2.rectangle_width = segment_3.rectangle_width;
					segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
					segment_2.rectangle_width -= segment_3.rectangle_width;
#ifdef _DEBUG
					assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1 && segment_2.right_endpoint < segment_3.right_endpoint);
#endif
				}
				else {
					assert(0);
					segment_2.rectangle_width = INF;
				}
				/*.............................................................................................................*/
			}
			/*................................................................................................................................................*/
			/*--------------------------seg1 width > 1, seg3=1 or 0-----------------------------------------------*/
			else if (segment_1.rectangle_width > 1 && segment_3.rectangle_width < 2) {
				if (segment_3.rectangle_width == 1) {
#ifdef _DEBUG
					assert(segment_2.rectangle_width == segment_3.right_endpoint - segment_1.right_endpoint - 1);
#endif
					segment_3.right_endpoint--;
				}
				segment_3.rectangle_width = segment_2.rectangle_width;
				segment_2.right_endpoint = INF;
				segment_2.rectangle_width = INF;
				//rest_segment_size++;
#ifdef _DEBUG
				assert(segment_1.rectangle_width + segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
				/*-------------------------------------------------- SPlit monotony segment-------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				segment_2.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, segment_3);

				if (segment_2.right_endpoint != INF) {
					//rest_segment_size--;
					segment_2.rectangle_width = segment_3.rectangle_width;
					segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
					segment_2.rectangle_width -= segment_3.rectangle_width;
#ifdef _DEBUG
					assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1 && segment_2.right_endpoint < segment_3.right_endpoint);
#endif
				}
				else {
					segment_2.rectangle_width = INF;
				}
				/*.............................................................................................................*/
				if (segment_3.rectangle_width == 1) {
					segment_1.rectangle_width--;
					segment_3.rectangle_width++;
					segment_1.right_endpoint--;
#ifdef _DEBUG
					assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
				}
			}
			/*................................................................................................................................................*/
			/*--------------------------seg1 width == 1, seg3>1-----------------------------------------------*/
			else if (segment_1.rectangle_width == 1 && segment_3.rectangle_width > 1) {
				segment_2.rectangle_width++;
				segment_1.right_endpoint = INF;
				segment_1.rectangle_width = INF;
				//rest_segment_size++;
#ifdef _DEBUG
				assert(segment_2.rectangle_width + segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
				/*-------------------------------------------------- SPlit monotony segment-------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				segment_1.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, segment_2);

				if (segment_1.right_endpoint != INF) {
					//rest_segment_size--;
					segment_1.rectangle_width = segment_2.rectangle_width;
					segment_2.rectangle_width = segment_2.right_endpoint - segment_1.right_endpoint;
					segment_1.rectangle_width -= segment_2.rectangle_width;
#ifdef _DEBUG
					assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_1.right_endpoint < segment_2.right_endpoint);
#endif
				}
				else {
					segment_1.rectangle_width = INF;
				}
				/*.............................................................................................................*/
			}
			else {
				if (segment_2.rectangle_width == 0) {
					assert(0);
					//++segment_size;
					//segment_2.right_endpoint = INF;// .at(0);
					//segment_2.rectangle_width = INF;// .at(0);
				}
				if (segment_2.rectangle_width == 1) {
					segment_3.rectangle_width++;
					//++rest_segment_size;
					segment_2.right_endpoint = INF;// .at(0);
					segment_2.rectangle_width = INF;// .at(0);
				}

#ifdef _DEBUG
				assert(segment_1.rectangle_width != INF && segment_3.rectangle_width != INF);
				assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
				//assert(0);
			}
			/*................................................................................................................................................*/

#ifdef _DEBUG
			assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
		}/*=========================================Flat=========================================================*/
		else {
			segment_2.right_endpoint = INF;
			segment_2.rectangle_width = INF;
			segment_1.right_endpoint = INF;
			segment_1.rectangle_width = INF;
#ifdef _DEBUG
			assert(segment_1.right_endpoint == INF && segment_1.rectangle_width == INF && segment_2.right_endpoint == INF && segment_2.rectangle_width == INF);
			assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
			assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
		}

		/*----------------------------------------- Merge previous segments--------------------------------------------------------------------*/

		/*if (segment_1.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_1);
		}
		else if (segment_2.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_2);
		}
		else if (segment_3.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_3);
		}*/

		/*.....................................................................................................................................*/
		//int old_id = result_area_vector.size() - 1;
		/*---------------------------Push back Vector ------------------------------------------------*/
		if (segment_1.right_endpoint != INF) {
			rest_segment_number--;
			segment_1.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_1);
		}
		if (segment_2.right_endpoint != INF) {
			rest_segment_number--;
			segment_2.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_2);
		}
		if (segment_3.right_endpoint != INF) {
			rest_segment_number--;
			segment_3.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_3);
		}
		/*................................................................................................*/

		if (doubly_linked_list.back().right_endpoint == input_argument.time_series_length - 2) {
			doubly_linked_list.back().right_endpoint++;
			doubly_linked_list.back().rectangle_width++;
		}
		pre_right_endpoint = doubly_linked_list.back().right_endpoint;

		/*.......................................................................................................................................................................*/
#ifdef _DEBUG
		assert(segment_3.min_point.id <= segment_3.right_endpoint && segment_3.max_point.id <= segment_3.right_endpoint);
		assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
	}
	/*......................................................................................................*/

#ifdef _DEBUG
	assert(doubly_linked_list.size() <= initial_vector_size);
	assert(doubly_linked_list.back().right_endpoint == input_argument.time_series_length - 1);

	//test segment width
	assert(doubly_linked_list.front().rectangle_width == doubly_linked_list.front().right_endpoint + 1);
	for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
		assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint);
	}

#endif

	/*=============================================Y Porjection Method==================================================================================*/
	//if (whole_difference_map.size() < 21) {
	//	//Use Y projection method
	//	input_argument.is_y_projection = true;
	//	yProjectionAPLAInitial(input_argument, original_time_series, whole_difference_map, area_vector);//190730
	//	//cout << "#$#$@%%#$%$^((_))+_)_+)+)+)+_)_+  Whole points difference is: " << whole_difference_map.size() << endl;
	//	yProjectionAPLAMerge(input_argument, original_time_series, whole_difference_map, area_vector);//190731
	//	//++++input: width right endpoint
	//	//++++Output: a&b apla coefficient, sum value
	//	getPLAByAdaptiveSegment(input_argument, original_time_series, area_vector);//190617 sum_value, a, b, apla_coefficient
	//	return;
	//	/*for (auto&& au : whole_difference_map) {
	//		cout << au.first << " " << au.second<<endl;
	//	}
	//	cout << endl;*/
	//}
	/*.................................................................................................................................................*/
	/*---------------------------------------------------- Split Segment increase vector----------------------------------------------------------------------------------------*/

	/*......................................................................................................................................................................*/
#ifdef _DEBUG
	//assert(doubly_linked_list.size() >= input_argument.point_dimension);
	for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
		assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint && doubly_linked_list[segment_id].rectangle_width > 1);
	}
#endif
	//assert(result_area_vector.size() <= area_vector.size());
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// Output: Min Max Point
	//for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		//getSegmentMinMaxPoint(original_time_series, doubly_linked_list[segment_id]);
	//}
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// input: width right endpoint
	// Output: a&b apla coefficient, sum value
	//getPLAByAdaptiveSegment(input_argument, original_time_series, doubly_linked_list);//190822 sum_value, a, b, apla_coefficient
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
}

//190918 Linked List
//************************************
// Method:initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursiveSpeed2
// Qualifier: Recursive split and merge segment. Add split merge process. a,b,width,right_endpoint,apla_coefficient, sum_value. Split segment into 3 sub-segment by minmax point
// 190918 Use Linded list
// date:191002 10:33
// author:
//************************************
TEMPLATE
void APLA::initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursiveSpeed2(typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list) {//190918 Recursive merge and split segment
#ifdef _DEBUG
	assert(input_argument.segment_length_first == input_argument.segment_length_second + 1);
	assert(input_argument.segment_length_first > 2);
#endif
	/*=======================================================================       Initial variable      =============================================================*/
	/*================================Y-Projection Method===================================*/
	//map<double, int> whole_difference_map;
	/*=====================================================================================*/
	/*=============================================      Burst Time Series 191007     =============================================*/
	//std::multiset<double> point_value_set;//191007
	//vector<AREA_COEFFICIENT> burst_segment;//191007
	//int time_series_end = input_argument.time_series_length / 2;
	//int initial_segment_right_endpoint = INF;//191008
	//double& frequent_value = *std::min_element(original_time_series, original_time_series + time_series_end);
	//int frequent_number = std::count(original_time_series, original_time_series + time_series_end, frequent_value);
	//cout << "++++++++++++++++++++++++++" << frequent_value<<" : "<< frequent_number  <<" : " << time_series_end <<" : "<< time_series_end / frequent_number << endl;
	//if (time_series_end / frequent_number < 2) {
	//	input_argument.burst_frquent_value = frequent_value;
	//}
	/*============================================================================================================================*/
	int original_id = 0;//190617
	int initial_vector_size = input_argument.point_dimension;// = input_argument.point_dimension < 3 ? 3 : input_argument.point_dimension;//190812

	/*---------------------Initial segment size---------------------------*/
	while (initial_vector_size % 3 != 0) {
		++initial_vector_size;
	}
	/*--------------------------------------------------------------------*/
	//initial_vector_size *= 10;
	//vector<AREA_COEFFICIENT> result_area_vector;
	AREA_COEFFICIENT segment_1, segment_2, segment_3;
	int pre_right_endpoint = -1;
	int rest_segment_number = initial_vector_size;
	bool can_merge_end = true;
	int rest_time_series_length = INF;
	/*======================================================================================================*/

	/*====================================While Loop==========================================================================*/
	while (pre_right_endpoint < input_argument.time_series_length - 1 && rest_segment_number > 0) {
		//while (result_area_vector.size() < area_vector.size()) {
#ifdef _DEBUG
		assert(pre_right_endpoint < input_argument.time_series_length);
		assert(doubly_linked_list.size() <= initial_vector_size);
#endif
		segment_3.min_point.id = INF;
		segment_3.min_point.value = INF;
		segment_3.max_point.id = -INF;
		segment_3.max_point.value = -INF;

		rest_time_series_length = input_argument.time_series_length - (pre_right_endpoint + 1);
		int max_size = ceil(rest_time_series_length / 2);
		if (rest_segment_number >= max_size) {
			rest_segment_number = max_size;
			can_merge_end = false;
		}
		auto remainder = rest_time_series_length % rest_segment_number;//For PLA
		auto segment_width_second = (rest_time_series_length - remainder) / rest_segment_number;
		//auto segment_width_first = segment_width_second + 1;
		/*-----------------------if max size or segment size == 1 or 2-----------------------------*/

		/*=========================Rest Segment Number 1 & 2===========================*/
		if (rest_segment_number == 1) {
			segment_1.right_endpoint = input_argument.time_series_length - 1;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;

			//mergeEndSegment(original_time_series, result_area_vector, segment_1);
			//if (segment_1.rectangle_width != INF && segment_1.right_endpoint != INF) {
			rest_segment_number--;
			segment_1.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_1);
			//}
			pre_right_endpoint = segment_1.right_endpoint;
#ifdef _DEBUG
			assert(pre_right_endpoint < input_argument.time_series_length&& segment_1.rectangle_width > 1);
#endif
			continue;
		}

		if (rest_segment_number == 2) {
			segment_2.right_endpoint = input_argument.time_series_length - 1;
			segment_2.rectangle_width = max_size;
			segment_1.right_endpoint = segment_2.right_endpoint - segment_2.rectangle_width;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;
#ifdef _DEBUG
			assert(segment_1.rectangle_width == rest_time_series_length - max_size && segment_1.right_endpoint == segment_1.rectangle_width + pre_right_endpoint);
#endif
			//mergeEndSegment(original_time_series, result_area_vector, segment_1);
			//if (segment_1.rectangle_width != INF && segment_1.right_endpoint != INF) {
			--rest_segment_number;
			segment_1.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_1);
			//}
			//mergeEndSegment(original_time_series, result_area_vector, segment_2);
			//if (segment_2.rectangle_width != INF && segment_2.right_endpoint != INF) {
			--rest_segment_number;
			segment_2.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_2);
			//}
			pre_right_endpoint = segment_2.right_endpoint;
#ifdef _DEBUG
			assert(pre_right_endpoint == input_argument.time_series_length - 1 && segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1);
#endif
			continue;
		}
		/*..........................................................................*/

		/*......................................................................................................*/
#ifdef _DEBUG
		assert(segment_width_second > 1 && rest_segment_number > -1);
#endif
		/*-- Get segment_3 right endpoint & rectangle width --*/
		segment_3.right_endpoint = segment_width_second * 3;
		segment_3.rectangle_width = segment_3.right_endpoint;
		switch (remainder) {
		case 0:
			break;
		case 1:
			segment_3.right_endpoint++;
			segment_3.rectangle_width++;
			break;
		case 2:
			segment_3.right_endpoint += 2;
			segment_3.rectangle_width += 2;
			break;
		default:
			segment_3.right_endpoint += 3;
			segment_3.rectangle_width += 3;
		}
		segment_3.right_endpoint += pre_right_endpoint;
		/*.................................................*/

#ifdef _DEBUG
		assert(segment_3.rectangle_width > 5 && segment_3.right_endpoint < input_argument.time_series_length&& segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif

		/*===========================Y Projection Method============================================*/
		//segment_3.segment_right_point.id = segment_3.right_endpoint;
		//segment_3.segment_right_point.value = original_time_series[int(segment_3.right_endpoint)];
		/*==========================================================================================*/

		/*===========================================For Burst time series========================================*/
		//if (input_argument.burst_frquent_value != INF) {
			//initial_segment_right_endpoint = segment_3.right_endpoint;
			//while (float(original_time_series[int(segment_3.right_endpoint)]) == float(original_time_series[int(segment_3.right_endpoint + 2)])  || float(original_time_series[int(segment_3.right_endpoint)]) == float(original_time_series[int(segment_3.right_endpoint + 1)]) || float(original_time_series[int(segment_3.right_endpoint + 1)]) == float(original_time_series[int(segment_3.right_endpoint - 1)])  || float(original_time_series[int(segment_3.right_endpoint + 1)]) == float(original_time_series[int(segment_3.right_endpoint - 2)]) || float(original_time_series[int(segment_3.right_endpoint)] - original_time_series[int(segment_3.right_endpoint - 1)]) == float(original_time_series[int(segment_3.right_endpoint + 1)] - original_time_series[int(segment_3.right_endpoint)])) {
		/*while (float(original_time_series[int(segment_3.right_endpoint)]) == float(original_time_series[int(segment_3.right_endpoint + 1)]) || float(original_time_series[int(segment_3.right_endpoint + 1)]) == float(original_time_series[int(segment_3.right_endpoint - 1)]) || float(original_time_series[int(segment_3.right_endpoint + 1)]) == float(original_time_series[int(segment_3.right_endpoint - 2)]) || float(original_time_series[int(segment_3.right_endpoint)] - original_time_series[int(segment_3.right_endpoint - 1)]) == float(original_time_series[int(segment_3.right_endpoint + 1)] - original_time_series[int(segment_3.right_endpoint)])) {
			++segment_3.right_endpoint;
			++segment_3.rectangle_width;
		}*/
		//}
		//191124 for time series that is a line, only has one value
		while (original_time_series[int(segment_3.right_endpoint)] == original_time_series[int(segment_3.right_endpoint + 1)] && segment_3.right_endpoint < input_argument.time_series_length) {
			++segment_3.right_endpoint;
			++segment_3.rectangle_width;
		}
		/*=========================================================================================================*/

		int final_min_id = 0;
		int final_max_id = 0;
		/*-----------------------------------------------Get min max point of segment-----------------------------------------------------------------*/
		for (original_id = pre_right_endpoint + 1; original_id <= segment_3.right_endpoint; original_id++) {
			//assert(original_id >= 0);
			//cout<<original_id<<": "<< original_time_series[original_id]<<", ";

			//point_value_set.emplace_hint(point_value_set.begin() , original_time_series[original_id]);

			if (segment_3.min_point.value > original_time_series[original_id]) {
				segment_3.min_point.value = original_time_series[original_id];
				segment_3.min_point.id = original_id;
				//first_min_id = original_id;
			}
			else if (segment_3.min_point.value == original_time_series[original_id]) {
				final_min_id = original_id;
			}

			if (segment_3.max_point.value < original_time_series[original_id]) {
				segment_3.max_point.value = original_time_series[original_id];
				segment_3.max_point.id = original_id;
				//first_max_id = original_id;
			}
			else if (segment_3.max_point.value == original_time_series[original_id]) {
				final_max_id = original_id;
			}

			/*====================================Y Projection Method============================================*/
			//+ Distinguish if time series is burst time series or not
			//auto whole_find_difference = whole_difference_map.find(original_time_series[original_id]);
			//if (whole_find_difference != whole_difference_map.end())
				//whole_find_difference->second++;
			//else
				//whole_difference_map.emplace_hint(whole_difference_map.end(), original_time_series[original_id], 1);
			/*====================================================================================================*/
		}
		/*--------------------------------------------------------------------------------------------------------------------------------------*/

		/*=====================================================191004 Recognize burst time series==============================================================*/

#ifdef _DEBUG
		//assert(point_value_set.size() == segment_3.rectangle_width);
		//cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << endl;
		//cout << *point_value_set.begin() << endl;
		//cout << point_value_set.size() << " : "<< point_value_set.count(*point_value_set.begin())<<" : "<< point_value_set.size() / point_value_set.count(*point_value_set.begin()) << endl;
#endif
		//if (point_value_set.size() / point_value_set.count(*point_value_set.begin()) < 3.0) {
			//assert(0);
		//}

		//point_value_set.clear();
		/*=====================================================================================================================================================*/

		/*==================================================get minimal distance of min max points==============================================================*/
		/*int total_distance = final_min_id + final_max_id;
		if (segment_3.min_point.id != segment_3.max_point.id && total_distance != 0) {
			set<pair<int, pair<int, int>>> min_minmax_distance;
			final_min_id = max(segment_3.min_point.id, final_min_id);
			final_max_id = max(segment_3.max_point.id, final_max_id);
#ifdef _DEBUG
			assert(final_min_id >= 0 && final_max_id >= 0);
			if (final_min_id == final_max_id)
				assert(original_time_series[int(segment_3.min_point.id)] == original_time_series[final_min_id] && original_time_series[int(segment_3.max_point.id)] == original_time_series[final_max_id]);
#endif
			min_minmax_distance.emplace(make_pair(abs(segment_3.min_point.id - segment_3.max_point.id), make_pair(segment_3.min_point.id, segment_3.max_point.id)));
			min_minmax_distance.emplace(make_pair(abs(segment_3.min_point.id - final_max_id), make_pair(segment_3.min_point.id, final_max_id)));
			min_minmax_distance.emplace(make_pair(abs(final_min_id - segment_3.max_point.id), make_pair(final_min_id, segment_3.max_point.id)));
			min_minmax_distance.emplace(make_pair(abs(final_min_id - final_max_id), make_pair(final_min_id, final_max_id)));

			segment_3.min_point.id = (*min_minmax_distance.begin()).second.first;
			segment_3.max_point.id = (*min_minmax_distance.begin()).second.second;
		}*/
		/*==============================================================================================================================================================*/

		/*=======================================Not Flat==================================================================================*/
		if (segment_3.max_point.id != segment_3.min_point.id && segment_3.max_point.value != segment_3.min_point.value) {
			segment_1.right_endpoint = min(segment_3.min_point.id, segment_3.max_point.id);
			segment_2.right_endpoint = max(segment_3.min_point.id, segment_3.max_point.id);

			segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
			segment_2.rectangle_width = segment_2.right_endpoint - segment_1.right_endpoint;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;

			/*--------------------------seg1=1,seg3=1 or 0-----------------------------------------------*/
			//segment1==1, segment3==0/1, The segment is monotony increase or decrease
			if (segment_1.rectangle_width == 1 && segment_3.rectangle_width < 2) {//segment_left_id == segment1 right endpoint
#ifdef _DEBUG
				assert(segment_2.rectangle_width > 1);
#endif
				if (segment_3.rectangle_width == 1) {
#ifdef _DEBUG
					assert(segment_2.rectangle_width == segment_3.right_endpoint - pre_right_endpoint - 2);
#endif
					segment_3.right_endpoint--;
				}
				segment_3.rectangle_width = segment_2.rectangle_width + 1;
				segment_2.right_endpoint = INF;
				segment_2.rectangle_width = INF;
				segment_1.right_endpoint = INF;
				segment_1.rectangle_width = INF;
				//rest_segment_size+=2;

				/*---------------------------------------------------------          Split monotony segment        ---------------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint && segment_3.rectangle_width > 1 && segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				if (segment_3.rectangle_width > 3) {
					splitSegmentBySplitedPoint(original_time_series, segment_2, segment_3);
				}
				/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
			}
			/*--------------------------------------------------------------------------------------------------------------------------------------*/
			/*--------------------------seg1 width > 1, seg3=1 or 0-----------------------------------------------*/
			else if (segment_1.rectangle_width > 1 && segment_3.rectangle_width < 2) {
				if (segment_3.rectangle_width == 1) {
#ifdef _DEBUG
					assert(segment_2.rectangle_width == segment_3.right_endpoint - segment_1.right_endpoint - 1);
#endif
					segment_3.right_endpoint--;
				}
				segment_3.rectangle_width = segment_2.rectangle_width;
				segment_2.right_endpoint = INF;
				segment_2.rectangle_width = INF;
				//rest_segment_size++;
#ifdef _DEBUG
				assert(segment_1.rectangle_width + segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
				/*--------------------------------------------------   Split monotony segment    -------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				if (segment_3.rectangle_width > 3) {
					splitSegmentBySplitedPoint(original_time_series, segment_2, segment_3);
				}
				/*--------------------------------------------------------------------------------------------------------------------------------------------*/
				if (segment_3.rectangle_width == 1) {
					segment_1.rectangle_width--;
					segment_3.rectangle_width++;
					segment_1.right_endpoint--;
#ifdef _DEBUG
					assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
				}
			}
			/*................................................................................................................................................*/
			/*--------------------------seg1 width == 1, seg3>1-----------------------------------------------*/
			else if (segment_1.rectangle_width == 1 && segment_3.rectangle_width > 1) {
				segment_2.rectangle_width++;
				segment_1.right_endpoint = INF;
				segment_1.rectangle_width = INF;
				//rest_segment_size++;
#ifdef _DEBUG
				assert(segment_2.rectangle_width + segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
				/*-------------------------------------------------- Split monotony segment-------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				if (segment_2.rectangle_width > 3) {
					splitSegmentBySplitedPoint(original_time_series, segment_1, segment_2);
				}
				/*--------------------------------------------------------------------------------------------------------------------------------------*/
			}
			else {
				if (segment_2.rectangle_width == 0) {
					assert(0);
					//++segment_size;
					//segment_2.right_endpoint = INF;// .at(0);
					//segment_2.rectangle_width = INF;// .at(0);
				}
				if (segment_2.rectangle_width == 1) {
					segment_3.rectangle_width++;
					//++rest_segment_size;
					segment_2.right_endpoint = INF;// .at(0);
					segment_2.rectangle_width = INF;// .at(0);
				}

#ifdef _DEBUG
				assert(segment_1.rectangle_width != INF && segment_3.rectangle_width != INF);
				assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
				//assert(0);
			}
			/*-----------------------------------------------------------------------------------------------------------------------------------------------.*/

#ifdef _DEBUG
			assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
		}/*=========================================Flat=========================================================*/
		else {
			segment_2.right_endpoint = INF;
			segment_2.rectangle_width = INF;
			segment_1.right_endpoint = INF;
			segment_1.rectangle_width = INF;
#ifdef _DEBUG
			assert(segment_1.right_endpoint == INF && segment_1.rectangle_width == INF && segment_2.right_endpoint == INF && segment_2.rectangle_width == INF);
			assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
			assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
		}

		/*----------------------------------------- Merge previous segments--------------------------------------------------------------------*/

		/*if (segment_1.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_1);
		}
		else if (segment_2.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_2);
		}
		else if (segment_3.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_3);
		}*/

		/*-------------------------------------------------------------------------------------------------------------------------------------*/
		//int old_id = result_area_vector.size() - 1;
		/*-----------------------------------------    Push back Vector   ----------------------------------------------------------------------*/
		if (segment_1.right_endpoint != INF) {
			rest_segment_number--;
			segment_1.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_1);
		}
		if (segment_2.right_endpoint != INF) {
			rest_segment_number--;
			segment_2.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_2);
		}
		if (segment_3.right_endpoint != INF) {
			rest_segment_number--;
			segment_3.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_3);
		}
		/*----------------------------------------------------------------------------------------------------------------------------------------*/

		if (doubly_linked_list.back().right_endpoint == input_argument.time_series_length - 2) {
			doubly_linked_list.back().right_endpoint++;
			doubly_linked_list.back().rectangle_width++;
		}
		pre_right_endpoint = doubly_linked_list.back().right_endpoint;

		/*.......................................................................................................................................................................*/
#ifdef _DEBUG
		assert(segment_3.min_point.id <= segment_3.right_endpoint && segment_3.max_point.id <= segment_3.right_endpoint);
		assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
	}
	/*......................................................................................................*/

#ifdef _DEBUG
	assert(doubly_linked_list.size() <= initial_vector_size);
	assert(doubly_linked_list.back().right_endpoint == input_argument.time_series_length - 1);

	//test segment width
	assert(doubly_linked_list.front().rectangle_width == doubly_linked_list.front().right_endpoint + 1);
	for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
		assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint);
	}

#endif
	/*===============================================    Y Projection Method     =====================================================================*/
	//if (whole_difference_map.size() < 21) {
	//	//Use Y projection method
	//	input_argument.is_y_projection = true;
	//	yProjectionAPLAInitial(input_argument, original_time_series, whole_difference_map, area_vector);//190730
	//	//cout << "#$#$@%%#$%$^((_))+_)_+)+)+)+_)_+  Whole points difference is: " << whole_difference_map.size() << endl;
	//	yProjectionAPLAMerge(input_argument, original_time_series, whole_difference_map, area_vector);//190731
	//	//++++input: width right endpoint
	//	//++++Output: a&b apla coefficient, sum value
	//	getPLAByAdaptiveSegment(input_argument, original_time_series, area_vector);//190617 sum_value, a, b, apla_coefficient
	//	return;
	//	/*for (auto&& au : whole_difference_map) {
	//		cout << au.first << " " << au.second<<endl;
	//	}
	//	cout << endl;*/
	//}
	/*=================================================================================================================================================*/
	/*---------------------------------------------------- Split Segment increase vector----------------------------------------------------------------------------------------*/

	/*......................................................................................................................................................................*/
#ifdef _DEBUG
	//assert(doubly_linked_list.size() >= input_argument.point_dimension);
	for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
		assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint && doubly_linked_list[segment_id].rectangle_width > 1);
	}
	//assert right enpoint & width of every segment
	assertRightEndpoint_Width(doubly_linked_list);
#endif
	//assert(result_area_vector.size() <= area_vector.size());
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// Output: Min Max Point
	//for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		//getSegmentMinMaxPoint(original_time_series, doubly_linked_list[segment_id]);
	//}
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// input: width right endpoint
	// Output: a&b apla coefficient, sum value
	//getPLAByAdaptiveSegment(input_argument, original_time_series, doubly_linked_list);//190822 sum_value, a, b, apla_coefficienty_projection_argument.whole_difference_map
	getPLAByAdaptiveSegmentAndMinMax(input_argument, original_time_series, doubly_linked_list);//191031 sum_value, a, b, apla_coefficient, min & max point
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
}

//191209 Y projection initialization
//************************************
// Method:initial_threshold_and_all
// Qualifier: Y projection initialization
// 190918 Use Linded list i
// NOtice s_y_projection = true
// date:191209 13:25
// author:
//************************************
TEMPLATE
template<typename T>
inline void APLA::initial_threshold_and_all(typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, const int& const original_id, int& const min_max_count, const T& const segment_3, T& const temp_segment, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<T>& const all_segment_linked_list) {
	//+ Distinguish if time series is burst time series or not
	//if (y_projection_argument.whole_difference_map.size() < input_argument.time_series_length / 2 && all_segment_linked_list.size() < input_argument.time_series_length / 2) {
	if (y_projection_argument.whole_difference_map.size() < input_argument.time_series_length / 10) {
		y_projection_argument.is_y_projection = true;
#ifdef _DEBUG
		if (!all_segment_linked_list.empty())
			assert(all_segment_linked_list.back().right_endpoint >= temp_segment.right_endpoint - temp_segment.rectangle_width);
#endif

		auto whole_find_difference = y_projection_argument.whole_difference_map.find(original_time_series[original_id]);
		if (whole_find_difference != y_projection_argument.whole_difference_map.end())
			whole_find_difference->second++;
		else
			y_projection_argument.whole_difference_map.emplace_hint(y_projection_argument.whole_difference_map.end(), original_time_series[original_id], 1);

		/*==========================================================================================================================================*/
//		//all_flat_segment_linked_list
//		if (min_max_count > 2) {
//			if (original_time_series[original_id] == segment_3.min_point.value || original_time_series[original_id] == segment_3.max_point.value) {
//				temp_segment.rectangle_width++;
//				temp_segment.right_endpoint++;
//				if (original_time_series[original_id] != original_time_series[original_id + 1] && original_time_series[original_id + 1] != segment_3.min_point.value && original_time_series[original_id + 1] != segment_3.max_point.value) {
//#ifdef _DEBUG
//					if (!all_segment_linked_list.empty())
//						assert(temp_segment.rectangle_width != 0 && all_segment_linked_list.back().right_endpoint == temp_segment.right_endpoint - temp_segment.rectangle_width);
//					assert(temp_segment.right_endpoint <= segment_3.right_endpoint);
//#endif
//					temp_segment.segment_right_height_difference = original_time_series[original_id + 1] - original_time_series[original_id];
//					assert(temp_segment.right_endpoint < input_argument.time_series_length);
//					all_segment_linked_list.add(temp_segment);
//					min_max_count = 0;
//					temp_segment.rectangle_width = 0;
//				}
//			}
//			else {
//				assert(0);
//			}
//		}
//		else if (original_time_series[original_id] != original_time_series[original_id + 1]) {
//			temp_segment.rectangle_width++;
//			temp_segment.right_endpoint++;
//			if (original_time_series[original_id + 1] != segment_3.min_point.value && original_time_series[original_id + 1] != segment_3.max_point.value && min_max_count > 0) {
//#ifdef _DEBUG
//				if (!all_segment_linked_list.empty())
//					assert(temp_segment.rectangle_width != 0 && all_segment_linked_list.back().right_endpoint == temp_segment.right_endpoint - temp_segment.rectangle_width);
//				assert(temp_segment.right_endpoint <= segment_3.right_endpoint);
//#endif
//
//				temp_segment.segment_right_height_difference = original_time_series[original_id + 1] - original_time_series[original_id];
//				assert(temp_segment.right_endpoint < input_argument.time_series_length);
//				all_segment_linked_list.add(temp_segment);
//				min_max_count = 0;
//				temp_segment.rectangle_width = 0;
//			}
//		}
//		else {
//			temp_segment.rectangle_width++;
//			temp_segment.right_endpoint++;
//		}
		/*===================================================================================================================================================*/
	}
	else {
		y_projection_argument.is_y_projection = false;
	}

}


//************************************
// Method:initial_threshold_and_all
// Qualifier: Y projection initialization
// 190918 Use Linded list i
// NOtice s_y_projection = true
// date:191209 13:25
// date: 200212 Add template, use vector to instead pointer for time sieres;
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
inline void APLA::initial_threshold_and_all(const U& const input_argument, const vector<T>& const original_time_series_vector, const int& const original_id, int& const min_max_count, const Y& const segment_3, Y& const temp_segment, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<Y>& const all_segment_linked_list) {
	//+ Distinguish if time series is burst time series or not
	//if (y_projection_argument.whole_difference_map.size() < input_argument.time_series_length / 2 && all_segment_linked_list.size() < input_argument.time_series_length / 2) {
	if (y_projection_argument.whole_difference_map.size() < input_argument.time_series_length / 10) {
		y_projection_argument.is_y_projection = true;
#ifdef _DEBUG
		if (!all_segment_linked_list.empty())
			assert(all_segment_linked_list.back().right_endpoint >= temp_segment.right_endpoint - temp_segment.rectangle_width);
#endif

		auto whole_find_difference = y_projection_argument.whole_difference_map.find(original_time_series_vector[original_id]);
		if (whole_find_difference != y_projection_argument.whole_difference_map.end())
			whole_find_difference->second++;
		else
			y_projection_argument.whole_difference_map.emplace_hint(y_projection_argument.whole_difference_map.end(), original_time_series_vector[original_id], 1);

		/*==========================================================================================================================================*/
//		//all_flat_segment_linked_list
//		if (min_max_count > 2) {
//			if (original_time_series[original_id] == segment_3.min_point.value || original_time_series[original_id] == segment_3.max_point.value) {
//				temp_segment.rectangle_width++;
//				temp_segment.right_endpoint++;
//				if (original_time_series[original_id] != original_time_series[original_id + 1] && original_time_series[original_id + 1] != segment_3.min_point.value && original_time_series[original_id + 1] != segment_3.max_point.value) {
//#ifdef _DEBUG
//					if (!all_segment_linked_list.empty())
//						assert(temp_segment.rectangle_width != 0 && all_segment_linked_list.back().right_endpoint == temp_segment.right_endpoint - temp_segment.rectangle_width);
//					assert(temp_segment.right_endpoint <= segment_3.right_endpoint);
//#endif
//					temp_segment.segment_right_height_difference = original_time_series[original_id + 1] - original_time_series[original_id];
//					assert(temp_segment.right_endpoint < input_argument.time_series_length);
//					all_segment_linked_list.add(temp_segment);
//					min_max_count = 0;
//					temp_segment.rectangle_width = 0;
//				}
//			}
//			else {
//				assert(0);
//			}
//		}
//		else if (original_time_series[original_id] != original_time_series[original_id + 1]) {
//			temp_segment.rectangle_width++;
//			temp_segment.right_endpoint++;
//			if (original_time_series[original_id + 1] != segment_3.min_point.value && original_time_series[original_id + 1] != segment_3.max_point.value && min_max_count > 0) {
//#ifdef _DEBUG
//				if (!all_segment_linked_list.empty())
//					assert(temp_segment.rectangle_width != 0 && all_segment_linked_list.back().right_endpoint == temp_segment.right_endpoint - temp_segment.rectangle_width);
//				assert(temp_segment.right_endpoint <= segment_3.right_endpoint);
//#endif
//
//				temp_segment.segment_right_height_difference = original_time_series[original_id + 1] - original_time_series[original_id];
//				assert(temp_segment.right_endpoint < input_argument.time_series_length);
//				all_segment_linked_list.add(temp_segment);
//				min_max_count = 0;
//				temp_segment.rectangle_width = 0;
//			}
//		}
//		else {
//			temp_segment.rectangle_width++;
//			temp_segment.right_endpoint++;
//		}
		/*===================================================================================================================================================*/
	}
	else {
		y_projection_argument.is_y_projection = false;
	}
}

//************************************
// Method:initial_threshold_and_all
// Qualifier:Y projection initialization. delete minmax point.
// 190918 Use Linded list i
// NOtice s_y_projection = true
// date:200314 13:25
// date: 200314  Concise above function. Delete redundant variable
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
inline void APLA::initial_threshold_and_all(const U& const input_argument, const T& const point_value, Y& const y_projection_argument) {
	//+ Distinguish if time series is burst time series or not
	//if (y_projection_argument.whole_difference_map.size() < input_argument.time_series_length / 2 && all_segment_linked_list.size() < input_argument.time_series_length / 2) {
	if (y_projection_argument.whole_difference_map.size() < input_argument.time_series_length / 10) {
		y_projection_argument.is_y_projection = true;
		auto whole_find_difference = y_projection_argument.whole_difference_map.find(point_value);
		if (whole_find_difference != y_projection_argument.whole_difference_map.end())
			whole_find_difference->second++;
		else
			y_projection_argument.whole_difference_map.emplace_hint(y_projection_argument.whole_difference_map.end(), point_value, 1);
	}
	else {
		y_projection_argument.is_y_projection = false;
	}
}

//200429 get the right endpoint of long segment_3
//************************************
// Method:get_minmax_y_projection
// Qualifier: Y projection initialization
// 190918 Use Linded list
// date:191209 14:56
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U, typename T1>
inline void APLA::get_segment_3_right_endpoint(const T& const segment_width_second, const Y& const remainder, const U& const pre_right_endpoint, T1& const segment_3) {
	/*-- Get segment_3 right endpoint & rectangle width --*/
	segment_3.right_endpoint = segment_width_second * 3;

	switch (remainder) {
	case 0:
		break;
	case 1:
		segment_3.right_endpoint++;
		//segment_3.rectangle_width++;
		break;
	case 2:
		segment_3.right_endpoint += 2;
		//segment_3.rectangle_width += 2;
		break;
	default:
		segment_3.right_endpoint += 3;
		//segment_3.rectangle_width += 3;
	}

	segment_3.rectangle_width = segment_3.right_endpoint;
	segment_3.right_endpoint += pre_right_endpoint;
	/*---------------------------------------------------*/
#ifdef _DEBUG
	assert(segment_3.rectangle_width > 5 && segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
}

//************************************
// Method:get_minmax_y_projection
// Qualifier: Y projection initialization
// 190918 Use Linded list
// date:191209 14:56
// author:
//************************************
TEMPLATE
template<typename T>
void APLA::get_minmax_y_projection(typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, const int& const pre_right_endpoint, T& const segment_3, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<T>& const all_segment_linked_list) {

	int min_max_count = 0;
	T temp_segment;
	temp_segment.rectangle_width = 0;
	if (all_segment_linked_list.empty()) temp_segment.right_endpoint = pre_right_endpoint;
	else temp_segment.right_endpoint = all_segment_linked_list.back().right_endpoint;

#ifdef _DEBUG
	assert(temp_segment.right_endpoint < input_argument.time_series_length);
#endif

	/*-----------------------------------------------Get min max point of segment-----------------------------------------------------------------*/
	for (int original_id = pre_right_endpoint + 1; original_id <= segment_3.right_endpoint; original_id++) {

		/*if (segment_3.right_endpoint == 510) {
			cout << " . ";
		}*/

		//assert(original_id >= 0);
		//cout<<original_id<<": "<< original_time_series[original_id]<<", ";

		//point_value_set.emplace_hint(point_value_set.begin() , original_time_series[original_id]);

		if (segment_3.min_point.value > original_time_series[original_id]) {
			segment_3.min_point.value = original_time_series[original_id];
			segment_3.min_point.id = original_id;
			//first_min_id = original_id;
		}
		else if (segment_3.min_point.value == original_time_series[original_id]) {
			//final_min_id = original_id;
			min_max_count++;
		}

		if (segment_3.max_point.value < original_time_series[original_id]) {
			segment_3.max_point.value = original_time_series[original_id];
			segment_3.max_point.id = original_id;
			//first_max_id = original_id;
		}
		else if (segment_3.max_point.value == original_time_series[original_id]) {
			//final_max_id = original_id;
			min_max_count++;
		}

		/*==================================== Y Projection Method ============================================*/
		if (input_argument.change_file) {
			initial_threshold_and_all(input_argument, original_time_series, original_id, min_max_count, segment_3, temp_segment, y_projection_argument, all_segment_linked_list);
		}
		/*====================================================================================================*/

	}

	/*====================================191004 Recognize burst time series==========================================*/
	/*assert(temp_segment.right_endpoint <= input_argument.time_series_length);
	if (y_projection_argument.is_y_projection == true) {
		if (temp_segment.rectangle_width != 0) {

			temp_segment.rectangle_width -= temp_segment.right_endpoint - segment_3.right_endpoint;
			temp_segment.right_endpoint = segment_3.right_endpoint;


			if (!all_segment_linked_list.empty())
				assert(all_segment_linked_list.back().right_endpoint == temp_segment.right_endpoint - temp_segment.rectangle_width);
			assert(temp_segment.right_endpoint == segment_3.right_endpoint);

			temp_segment.segment_right_height_difference = original_time_series[int(temp_segment.right_endpoint) + 1] - original_time_series[int(temp_segment.right_endpoint)];
			all_segment_linked_list.add(temp_segment);
			min_max_count = 0;
		}
		assert(segment_3.right_endpoint == all_segment_linked_list.back().right_endpoint);
		for (int segment_id = 1; segment_id < all_segment_linked_list.size(); segment_id++) {
			const auto& const left_segment = all_segment_linked_list[segment_id - 1];
			const auto& const right_segment = all_segment_linked_list[segment_id];
			assert(left_segment.right_endpoint == right_segment.right_endpoint - right_segment.rectangle_width && right_segment.segment_right_height_difference != INF);
		}
	}*/
	/*=======================================================================================================================*/

}

//191209 get_minmax_y_projection
//200212 Add template, use vector to instead pointer for time sereis 
//************************************
// Method:get_minmax_y_projection
// Qualifier: Y projection initialization
// 190918 Use Linded list
// date:200212 14:56
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
void APLA::get_minmax_y_projection(U& const input_argument, const vector<T>& const original_time_series_vector, const int& const pre_right_endpoint, Y& const segment_3, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<Y>& const all_segment_linked_list) {

	int min_max_count = 0;

	/*........................             temp segment       ..........................*/
	Y temp_segment;
	temp_segment.rectangle_width = 0;
	if (all_segment_linked_list.empty()) temp_segment.right_endpoint = pre_right_endpoint;
	else temp_segment.right_endpoint = all_segment_linked_list.back().right_endpoint;
	/*...................................................................................*/

#ifdef _DEBUG
	assert(temp_segment.right_endpoint < input_argument.time_series_length);
#endif

	for (int original_id = pre_right_endpoint + 1; original_id <= segment_3.right_endpoint; original_id++) {

		/*if (segment_3.right_endpoint == 510) {
			cout << " . ";
		}*/

		//assert(original_id >= 0);
		//cout<<original_id<<": "<< original_time_series[original_id]<<", ";

		//point_value_set.emplace_hint(point_value_set.begin() , original_time_series[original_id]);


		/*-----------------------------     Min & Max Point ID    ------------------------*/
		if (segment_3.min_point.value > original_time_series_vector[original_id]) {
			segment_3.min_point.value = original_time_series_vector[original_id];
			segment_3.min_point.id = original_id;
			//first_min_id = original_id;
		}
		else if (segment_3.min_point.value == original_time_series_vector[original_id]) {
			//final_min_id = original_id;
			min_max_count++;
		}

		if (segment_3.max_point.value < original_time_series_vector[original_id]) {
			segment_3.max_point.value = original_time_series_vector[original_id];
			segment_3.max_point.id = original_id;
			//first_max_id = original_id;
		}
		else if (segment_3.max_point.value == original_time_series_vector[original_id]) {
			//final_max_id = original_id;
			min_max_count++;
		}
		/*----------------------------------------------------------------------------------*/
		/*----------------------------     Y Projection Method     -------------------------*/
		if (input_argument.change_file) {
			//200314 minmax point
			//initial_threshold_and_all(input_argument, original_time_series_vector, original_id, min_max_count, segment_3, temp_segment, y_projection_argument, all_segment_linked_list);
			initial_threshold_and_all(input_argument, original_time_series_vector[original_id], y_projection_argument);
		}
		/*----------------------------------------------------------------------------------*/

	}

	/*====================================191004 Recognize burst time series==========================================*/
	/*assert(temp_segment.right_endpoint <= input_argument.time_series_length);
	if (y_projection_argument.is_y_projection == true) {
		if (temp_segment.rectangle_width != 0) {

			temp_segment.rectangle_width -= temp_segment.right_endpoint - segment_3.right_endpoint;
			temp_segment.right_endpoint = segment_3.right_endpoint;


			if (!all_segment_linked_list.empty())
				assert(all_segment_linked_list.back().right_endpoint == temp_segment.right_endpoint - temp_segment.rectangle_width);
			assert(temp_segment.right_endpoint == segment_3.right_endpoint);

			temp_segment.segment_right_height_difference = original_time_series[int(temp_segment.right_endpoint) + 1] - original_time_series[int(temp_segment.right_endpoint)];
			all_segment_linked_list.add(temp_segment);
			min_max_count = 0;
		}
		assert(segment_3.right_endpoint == all_segment_linked_list.back().right_endpoint);
		for (int segment_id = 1; segment_id < all_segment_linked_list.size(); segment_id++) {
			const auto& const left_segment = all_segment_linked_list[segment_id - 1];
			const auto& const right_segment = all_segment_linked_list[segment_id];
			assert(left_segment.right_endpoint == right_segment.right_endpoint - right_segment.rectangle_width && right_segment.segment_right_height_difference != INF);
		}
	}*/
	/*=======================================================================================================================*/
}

//200316 Add template, use vector to instead pointer for time sereis 
//************************************
// Method:get_minmax_y_projection
// Qualifier: get min&max id of long segment, and coefficients of y_projection_argument
// 190918 Use Linked list
// date:200316 08:10
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
void APLA::get_minmax_y_projection(const U& const input_argument, const vector<T>& const original_time_series_vector, const int& const segment_begin_id, const int& const segment_end_id, int& const id_min_point, int& const id_max_point, Y& const y_projection_argument) {

#ifdef _DEBUG
	assert(segment_begin_id != int(INF) && segment_end_id != int(INF) && segment_begin_id < segment_end_id);
#endif

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	double temp_min_value = original_time_series_vector[segment_begin_id];
	double temp_max_value = original_time_series_vector[segment_begin_id];
	id_min_point = id_max_point = segment_begin_id;
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	for (int original_id = segment_begin_id; original_id <= segment_end_id; original_id++) {

		/*#######################     Min & Max Point ID, determine is flat segment or not    ###########################*/
		//min id
		if (temp_min_value > original_time_series_vector[original_id]) {
			id_min_point = original_id;
			temp_min_value = original_time_series_vector[original_id];
		}
		//max id
		if (temp_max_value < original_time_series_vector[original_id]) {
			id_max_point = original_id;
			temp_max_value = original_time_series_vector[original_id];
		}
		/*###############################################################################################################*/
		/*####################################     Y Projection Method     ##############################################*/
		if (input_argument.change_file) {
			//200314 minmax point
			//initial_threshold_and_all(input_argument, original_time_series_vector, original_id, min_max_count, segment_3, temp_segment, y_projection_argument, all_segment_linked_list);
			initial_threshold_and_all(input_argument, original_time_series_vector[original_id], y_projection_argument);
		}
		/*###############################################################################################################*/

	}
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

#ifdef _DEBUG
	assert(id_min_point != int(INF) && id_max_point != int(INF) && id_min_point <= segment_end_id && id_max_point <= segment_end_id);
#endif

}


//************************************
// Method:assign_three_segments_by_minmax
// Qualifier: get minmax point in long segment, use minmax point as endpoint to get three short segment. 
//
// 190918 Use Linded list
// date:200424 10:56
// author:
//************************************
TEMPLATE
template<typename T, typename T1, typename Y, typename U, typename U1>
void APLA::assign_three_segments_by_minmax(U& const input_argument, const vector<T>& const original_time_series_vector, const T1& const  pre_right_endpoint, int& const id_min_point, int& const id_max_point, Y& const segment_1, Y& const segment_2, Y& const segment_3, U1& const output_argument) {
	/*....................................................................................................................................................*/
#ifdef _DEBUG
	assert(!original_time_series_vector.empty() && id_min_point <= segment_3.right_endpoint && id_max_point <= segment_3.right_endpoint && segment_3.right_endpoint != INF);
#endif
	/*....................................................................................................................................................*/

	/*################################################      Not Flat   ################################################################################*/
		//if (segment_3.max_point.id != segment_3.min_point.id && segment_3.max_point.value != segment_3.min_point.value) {
	if (id_min_point != id_max_point) {
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!         Update right end point & width: segment1, 2, 3       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		/*segment_1.right_endpoint = min(segment_3.min_point.id, segment_3.max_point.id);
		segment_2.right_endpoint = max(segment_3.min_point.id, segment_3.max_point.id);*/
		segment_1.right_endpoint = min(id_min_point, id_max_point);
		segment_2.right_endpoint = max(id_min_point, id_max_point);

		segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
		segment_2.rectangle_width = segment_2.right_endpoint - segment_1.right_endpoint;
		segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   seg1=1,seg3=1 or 0    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		//segment1==1, segment3==0/1, The segment is monotony increase or decrease
		if (segment_1.rectangle_width == 1 && segment_3.rectangle_width < 2) {//segment_left_id == segment1 right endpoint
			/*....................................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_2.rectangle_width > 1);
#endif
			/*....................................................................................................................................................*/
			if (segment_3.rectangle_width == 1) {
				/*....................................................................................................................................................*/
#ifdef _DEBUG
				assert(segment_2.rectangle_width == segment_3.right_endpoint - pre_right_endpoint - 2);
#endif
				/*....................................................................................................................................................*/
				segment_3.right_endpoint--;
				//segment_2.rectangle_width++;
			}
			segment_3.rectangle_width = segment_2.rectangle_width + 1;
			segment_2.right_endpoint = segment_2.rectangle_width = segment_1.right_endpoint = segment_1.rectangle_width = INF;
			//rest_segment_size+=2;

			/*..................................................................................................................*/
#ifdef _DEBUG
			assert(segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint && segment_3.rectangle_width > 1 && segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
			/*..................................................................................................................*/

			/*+++++++++++++++++++++++++++++++++++++++++++++++++       Split monotony segment     ++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			//200302 split segment3. get segment 2 & segment 3: right endpoint and rectangle width
			if (segment_3.rectangle_width > 3) {//Split segment 3.  renew segment 2 and segment 3 apla a&b coefficients
				/*========  a&b is the sign of insert_segment_back_linkedlist() method, means this segment has not splitted  =========*/
				segment_3.apla.a = INF;
				/*====================================================================================================================*/
				/*===============================================================================*/
				splitSegmentBySplitedPoint(original_time_series_vector, input_argument.option_split_method, segment_2, segment_3, output_argument);
				/*===============================================================================*/
			}
			/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		}
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!              seg1 > 1, seg3== 1 or 0            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		else if (segment_1.rectangle_width > 1 && segment_3.rectangle_width < 2) {
			if (segment_3.rectangle_width == 1) {
				/*.........................................................................................*/
#ifdef _DEBUG
				assert(segment_2.rectangle_width == segment_3.right_endpoint - segment_1.right_endpoint - 1);
#endif
				/*.........................................................................................*/
				segment_3.right_endpoint--;
				//segment_2.rectangle_width++;
			}
			segment_3.rectangle_width = segment_2.rectangle_width;
			segment_2.right_endpoint = segment_2.rectangle_width = INF;
			//rest_segment_size++;

			/*.........................................................................................*/
#ifdef _DEBUG
			assert(segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length&& segment_1.rectangle_width + segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
			/*.........................................................................................*/

			/*+++++++++++++++++++++++++++++++++++++++++++++++++           Split monotony segment        ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			//200302 split segment3. get segment 2 & segment 3: right endpoint and rectangle width
			//Split segment 3.  renew segment 3 apla a&b coefficients
			if (segment_3.rectangle_width > 3) {
				/*========  a&b is the sign of insert_segment_back_linkedlist() method, means this segment has not splitted  =========*/
				segment_3.apla.a = INF;
				/*====================================================================================================================*/
				/*=======================      split long segment       =========================*/
				splitSegmentBySplitedPoint(original_time_series_vector, input_argument.option_split_method, segment_2, segment_3, output_argument);
				/*===============================================================================*/

			}
			/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			if (segment_3.rectangle_width == 1) {
				segment_1.rectangle_width--;
				segment_3.rectangle_width++;
				segment_1.right_endpoint--;
				/*.........................................................................................*/
#ifdef _DEBUG
				assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
				/*.........................................................................................*/
			}
		}
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!               seg1 == 1, seg3 > 1            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		else if (segment_1.rectangle_width == 1 && segment_3.rectangle_width > 1) {
			segment_2.rectangle_width++;
			segment_1.right_endpoint = segment_1.rectangle_width = INF;
			//rest_segment_size++;
			/*..............................................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_2.rectangle_width + segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint && segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
			/*..........................................................................................................................................................*/

			/*+++++++++++++++++++++++++++++++++++++          Split monotony segment      +++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			//200302 split segment2. get segment 1 & segment 2: right endpoint and rectangle width
			if (segment_2.rectangle_width > 3) {// //Split segment 2.  renew segment 2 apla a&b coefficients
				/*========  a&b is the sign of insert_segment_back_linkedlist() method, means this segment has not splitted  =========*/
				segment_2.apla.a = INF;
				/*====================================================================================================================*/
				/*===============================================================================*/
				splitSegmentBySplitedPoint(original_time_series_vector, input_argument.option_split_method, segment_1, segment_2, output_argument);
				/*===============================================================================*/
			}
			/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		}
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!                 seg1 width == 1, seg3 > 1          !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		else {
			/*++++++++++++++++++++++++++++++++++++++++++      seg2 width == 1, delete seg2, seg3++    +++++++++++++++++++++++++++++++++++++++++++++*/
			if (segment_2.rectangle_width == 0) {
				assert(0);
				//++segment_size;
				//segment_2.right_endpoint = INF;// .at(0);
				//segment_2.rectangle_width = INF;// .at(0);
			}
			else if (segment_2.rectangle_width == 1) {
				segment_3.rectangle_width++;
				//++rest_segment_size;
				segment_2.right_endpoint = segment_2.rectangle_width = INF;// .at(0);
			}
			/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

			/*............................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_1.rectangle_width != INF && segment_3.rectangle_width != INF && segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
			/*.............................................................................................................................................*/
		}
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		/*.....................................................................................................*/
#ifdef _DEBUG
		assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
		/*.....................................................................................................*/
	}
	/*######################################################################################################################################################*/
	/*#########################################################       Flat Segment      ####################################################################*/
	else {
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!       segment 3    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		//get_ab_minmax_flat_segment(original_time_series_vector, segment_3);
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  segment 1, segment 2 initial   !!!!!!!!!!!!!!!!!!!!!!!!*/
		segment_2.right_endpoint = segment_2.rectangle_width = segment_1.right_endpoint = segment_1.rectangle_width = INF;
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

		/*........................................................................................................................................*/
#ifdef _DEBUG
		assert(segment_1.right_endpoint == INF && segment_1.rectangle_width == INF && segment_2.right_endpoint == INF && segment_2.rectangle_width == INF && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
		assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
		/*........................................................................................................................................*/
	}
	/*########################################################################################################################################################*/
}

//200428
//************************************
// Method:initialMSPLA
// Qualifier: Merge normal initial & Y projection
// 190918 Use Linded list
// date:200428 17:21
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
inline void APLA::insert_segment_back_linkedlist(T& const temp_coefficient, DoublyLinkedList<Y>& const doubly_linked_list, U& const rest_segment_number) {
	if (temp_coefficient.right_endpoint != INF) {
		/*######  reduce the rest segment number #########*/
		rest_segment_number--;
		/*################################################*/

		/*#######  reduce the rest segment number ########*/
		//no need to new Y. After min density method, already get a&b sum value, 
		if (temp_coefficient.apla.a == INF) {
			temp_coefficient.right_subsegment = new Y;
		}
		else {
			/*......................................................................................*/
#ifdef _DEBUG
			assert(temp_coefficient.apla.b != INF);
			assert_segment_a_b(temp_coefficient);
			assert_segment_minmax(temp_coefficient);
#endif
			/*.......................................................................................*/
		}
		/*###############################################*/

		/*#######  reduce the rest segment number ########*/
		doubly_linked_list.add(temp_coefficient);
		/*###############################################*/

		/*##############       Initial a&b, min&max point and density       ######################*/
		//for following compute loop linked list a& b segment, a& b already know, no need to compute
		/*!!!!!!!!!!!!!!!!!    initialize a&b    !!!!!!!!!!!!!!!!!!!!!!*/
		temp_coefficient.apla.a = temp_coefficient.apla.b = INF;
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		temp_coefficient.right_subsegment->segment_density = INF;
		/*!!!!!!!!!!!!   initialize segment density  !!!!!!!!!!!!!!!!!!*/
		/*!!!!!!!!   initialize segment min&max point    !!!!!!!!!!!!!!*/
		initialize_segment_minmax(temp_coefficient);
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		/*#######################################################################################*/
	}
}

//************************************
// Method:initialMSPLA
// Qualifier: Merge normal initial & Y projection
// 190918 Use Linded list
// date:191209 13:25
// author:
//************************************
TEMPLATE
template<typename T>
void APLA::initialMSPLA(int null, typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<T>& const all_segment_linked_list, DoublyLinkedList<T>& const cluster_linked_list, DoublyLinkedList<T>& const doubly_linked_list) {
	assert(0);
#ifdef _DEBUG
	assert(input_argument.segment_length_first == input_argument.segment_length_second + 1);
	assert(input_argument.segment_length_first > 2);
#endif
	/*=======================================================================       Initial variable      =============================================================*/
	/*================================Y-Projection Method===================================*/
	//int threshould_number = 0;
	//std::map<double, int> y_segment_number_map;
	//map<double, int> whole_difference_map;
	//y_projection_argument.is_y_projection = true;
	/*=====================================================================================*/
	/*=============================================      Burst Time Series 191007     =============================================*/
	//std::multiset<double> point_value_set;//191007
	//vector<AREA_COEFFICIENT> burst_segment;//191007
	//int time_series_end = input_argument.time_series_length / 2;
	//int initial_segment_right_endpoint = INF;//191008
	//double& frequent_value = *std::min_element(original_time_series, original_time_series + time_series_end);
	//int frequent_number = std::count(original_time_series, original_time_series + time_series_end, frequent_value);
	//cout << "++++++++++++++++++++++++++" << frequent_value<<" : "<< frequent_number  <<" : " << time_series_end <<" : "<< time_series_end / frequent_number << endl;
	//if (time_series_end / frequent_number < 2) {
	//	input_argument.burst_frquent_value = frequent_value;
	//}
	/*============================================================================================================================*/
	int original_id = 0;//190617
	int initial_vector_size = input_argument.point_dimension;// = input_argument.point_dimension < 3 ? 3 : input_argument.point_dimension;//190812
	/*---------------------Initial segment size---------------------------*/
	while (initial_vector_size % 3 != 0) {
		++initial_vector_size;
	}
	/*--------------------------------------------------------------------*/
	//initial_vector_size *= 10;
	//vector<AREA_COEFFICIENT> result_area_vector;
	AREA_COEFFICIENT segment_1, segment_2, segment_3;
	//AREA_COEFFICIENT temp_segment;
	int pre_right_endpoint = -1;
	int rest_segment_number = initial_vector_size;
	bool can_merge_end = true;
	int rest_time_series_length = INF;
	/*======================================================================================================*/

	/*====================================While Loop==========================================================================*/
	while (pre_right_endpoint < input_argument.time_series_length - 1 && rest_segment_number > 0) {
		//while (result_area_vector.size() < area_vector.size()) {
#ifdef _DEBUG
		assert(pre_right_endpoint < input_argument.time_series_length);
		assert(doubly_linked_list.size() <= initial_vector_size);
#endif
		segment_3.min_point.id = INF;
		segment_3.min_point.value = INF;
		segment_3.max_point.id = -INF;
		segment_3.max_point.value = -INF;

		rest_time_series_length = input_argument.time_series_length - (pre_right_endpoint + 1);
		int max_size = ceil(rest_time_series_length / 2);
		if (rest_segment_number >= max_size) {
			rest_segment_number = max_size;
			can_merge_end = false;
		}
		auto remainder = rest_time_series_length % rest_segment_number;//For PLA
		auto segment_width_second = (rest_time_series_length - remainder) / rest_segment_number;
		//auto segment_width_first = segment_width_second + 1;
		/*-----------------------if max size or segment size == 1 or 2-----------------------------*/

		/*=========================Rest Segment Number 1 & 2===========================*/
		if (rest_segment_number == 1) {

			segment_3.right_endpoint = input_argument.time_series_length - 1;
			segment_3.rectangle_width = segment_3.right_endpoint - pre_right_endpoint;

			//mergeEndSegment(original_time_series, result_area_vector, segment_1);
			//if (segment_1.rectangle_width != INF && segment_1.right_endpoint != INF) {

			/*==================================== get Min&Max Point, Y Projection Method ============================================*/
			get_minmax_y_projection(input_argument, original_time_series, pre_right_endpoint, segment_3, y_projection_argument, all_segment_linked_list);
			/*========================================================================================================================*/
			rest_segment_number--;
			segment_3.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_3);
			//}
			pre_right_endpoint = segment_3.right_endpoint;
#ifdef _DEBUG
			assert(pre_right_endpoint < input_argument.time_series_length&& segment_3.rectangle_width > 1);
#endif
			continue;
		}
		/*====================================================================================================================================================*/
		if (rest_segment_number == 2) {
			segment_3.right_endpoint = input_argument.time_series_length - 1;
			segment_3.rectangle_width = segment_3.right_endpoint - pre_right_endpoint;

			/*====================================get Min&Max Point, Y Projection Method ===============================================*/
			get_minmax_y_projection(input_argument, original_time_series, pre_right_endpoint, segment_3, y_projection_argument, all_segment_linked_list);
			/*==========================================================================================================================*/

			segment_2.right_endpoint = input_argument.time_series_length - 1;
			segment_2.rectangle_width = max_size;
			segment_1.right_endpoint = segment_2.right_endpoint - segment_2.rectangle_width;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;
#ifdef _DEBUG
			assert(segment_1.rectangle_width == rest_time_series_length - max_size && segment_1.right_endpoint == segment_1.rectangle_width + pre_right_endpoint);
#endif
			//mergeEndSegment(original_time_series, result_area_vector, segment_1);
			//if (segment_1.rectangle_width != INF && segment_1.right_endpoint != INF) {
			--rest_segment_number;
			segment_1.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_1);
			//}
			//mergeEndSegment(original_time_series, result_area_vector, segment_2);
			//if (segment_2.rectangle_width != INF && segment_2.right_endpoint != INF) {
			--rest_segment_number;
			segment_2.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_2);
			//}
			pre_right_endpoint = segment_2.right_endpoint;

#ifdef _DEBUG
			assert(pre_right_endpoint == input_argument.time_series_length - 1 && segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1);
#endif
			continue;
		}
		/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/


		/*......................................................................................................*/
#ifdef _DEBUG
		assert(segment_width_second > 1 && rest_segment_number > -1);
#endif
		/*-- Get segment_3 right endpoint & rectangle width --*/
		segment_3.right_endpoint = segment_width_second * 3;
		segment_3.rectangle_width = segment_3.right_endpoint;
		switch (remainder) {
		case 0:
			break;
		case 1:
			segment_3.right_endpoint++;
			segment_3.rectangle_width++;
			break;
		case 2:
			segment_3.right_endpoint += 2;
			segment_3.rectangle_width += 2;
			break;
		default:
			segment_3.right_endpoint += 3;
			segment_3.rectangle_width += 3;
		}
		segment_3.right_endpoint += pre_right_endpoint;
		/*.................................................*/

#ifdef _DEBUG
		assert(segment_3.rectangle_width > 5 && segment_3.right_endpoint < input_argument.time_series_length&& segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
		//cout << "right endpoint: " << segment_3.right_endpoint << " width: "<< segment_3.rectangle_width<<endl;
		/*===========================Y Projection Method============================================*/
		//segment_3.segment_right_point.id = segment_3.right_endpoint;
		//segment_3.segment_right_point.value = original_time_series[int(segment_3.right_endpoint)];
		/*==========================================================================================*/

		/*===========================================For Burst time series========================================*/
		//if (input_argument.burst_frquent_value != INF) {
			//initial_segment_right_endpoint = segment_3.right_endpoint;
		//while (float(original_time_series[int(segment_3.right_endpoint)]) == float(original_time_series[int(segment_3.right_endpoint + 2)]) || float(original_time_series[int(segment_3.right_endpoint)]) == float(original_time_series[int(segment_3.right_endpoint + 1)]) || float(original_time_series[int(segment_3.right_endpoint + 1)]) == float(original_time_series[int(segment_3.right_endpoint - 1)]) || float(original_time_series[int(segment_3.right_endpoint + 1)]) == float(original_time_series[int(segment_3.right_endpoint - 2)]) || float(original_time_series[int(segment_3.right_endpoint)] - original_time_series[int(segment_3.right_endpoint - 1)]) == float(original_time_series[int(segment_3.right_endpoint + 1)] - original_time_series[int(segment_3.right_endpoint)])) {
		while (float(original_time_series[int(segment_3.right_endpoint)]) == float(original_time_series[int(segment_3.right_endpoint + 1)]) || float(original_time_series[int(segment_3.right_endpoint + 1)]) == float(original_time_series[int(segment_3.right_endpoint - 1)]) || float(original_time_series[int(segment_3.right_endpoint + 1)]) == float(original_time_series[int(segment_3.right_endpoint - 2)]) || float(original_time_series[int(segment_3.right_endpoint)] - original_time_series[int(segment_3.right_endpoint - 1)]) == float(original_time_series[int(segment_3.right_endpoint + 1)] - original_time_series[int(segment_3.right_endpoint)])) {
			++segment_3.right_endpoint;
			++segment_3.rectangle_width;
		}
		//}
		//191124 for time series that is a line, only has one value
		while (original_time_series[int(segment_3.right_endpoint)] == original_time_series[int(segment_3.right_endpoint + 1)] && segment_3.right_endpoint < input_argument.time_series_length) {
			++segment_3.right_endpoint;
			++segment_3.rectangle_width;
		}
		if (input_argument.time_series_length - segment_3.right_endpoint < 7) segment_3.right_endpoint = input_argument.time_series_length - 1;
		/*=========================================================================================================*/

		/*=======================================get MinMax, Projection==================================================================================*/
		get_minmax_y_projection(input_argument, original_time_series, pre_right_endpoint, segment_3, y_projection_argument, all_segment_linked_list);
		/*===============================================================================================================================================*/

		/*=======================================Not Flat==================================================================================*/
		if (segment_3.max_point.id != segment_3.min_point.id && segment_3.max_point.value != segment_3.min_point.value) {
			segment_1.right_endpoint = min(segment_3.min_point.id, segment_3.max_point.id);
			segment_2.right_endpoint = max(segment_3.min_point.id, segment_3.max_point.id);

			segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
			segment_2.rectangle_width = segment_2.right_endpoint - segment_1.right_endpoint;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;

			/*--------------------------seg1=1,seg3=1 or 0-----------------------------------------------*/
			//segment1==1, segment3==0/1, The segment is monotony increase or decrease
			if (segment_1.rectangle_width == 1 && segment_3.rectangle_width < 2) {//segment_left_id == segment1 right endpoint
#ifdef _DEBUG
				assert(segment_2.rectangle_width > 1);
#endif
				if (segment_3.rectangle_width == 1) {
#ifdef _DEBUG
					assert(segment_2.rectangle_width == segment_3.right_endpoint - pre_right_endpoint - 2);
#endif
					segment_3.right_endpoint--;
					//segment_2.rectangle_width++;
				}
				segment_3.rectangle_width = segment_2.rectangle_width + 1;
				segment_2.right_endpoint = INF;
				segment_2.rectangle_width = INF;
				segment_1.right_endpoint = INF;
				segment_1.rectangle_width = INF;
				//rest_segment_size+=2;

				/*---------------------------------------------------------          Split monotony segment        ---------------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint && segment_3.rectangle_width > 1 && segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				if (segment_3.rectangle_width > 3) {
					splitSegmentBySplitedPoint(original_time_series, segment_2, segment_3);
				}
				/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
			}
			/*--------------------------------------------------------------------------------------------------------------------------------------*/
			/*--------------------------seg1 width > 1, seg3=1 or 0-----------------------------------------------*/
			else if (segment_1.rectangle_width > 1 && segment_3.rectangle_width < 2) {
				if (segment_3.rectangle_width == 1) {
#ifdef _DEBUG
					assert(segment_2.rectangle_width == segment_3.right_endpoint - segment_1.right_endpoint - 1);
#endif
					segment_3.right_endpoint--;
					//segment_2.rectangle_width++;
				}
				segment_3.rectangle_width = segment_2.rectangle_width;
				segment_2.right_endpoint = INF;
				segment_2.rectangle_width = INF;
				//rest_segment_size++;
#ifdef _DEBUG
				assert(segment_1.rectangle_width + segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
				/*--------------------------------------------------   Split monotony segment    -------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				if (segment_3.rectangle_width > 3) {
					splitSegmentBySplitedPoint(original_time_series, segment_2, segment_3);
				}
				/*--------------------------------------------------------------------------------------------------------------------------------------------*/
				if (segment_3.rectangle_width == 1) {
					segment_1.rectangle_width--;
					segment_3.rectangle_width++;
					segment_1.right_endpoint--;
#ifdef _DEBUG
					assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
				}
			}
			/*................................................................................................................................................*/
			/*--------------------------seg1 width == 1, seg3>1-----------------------------------------------*/
			else if (segment_1.rectangle_width == 1 && segment_3.rectangle_width > 1) {
				segment_2.rectangle_width++;
				segment_1.right_endpoint = INF;
				segment_1.rectangle_width = INF;
				//rest_segment_size++;
#ifdef _DEBUG
				assert(segment_2.rectangle_width + segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
				/*-------------------------------------------------- Split monotony segment-------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				if (segment_2.rectangle_width > 3) {
					splitSegmentBySplitedPoint(original_time_series, segment_1, segment_2);
				}
				/*--------------------------------------------------------------------------------------------------------------------------------------*/
			}
			else {
				if (segment_2.rectangle_width == 0) {
					assert(0);
					//++segment_size;
					//segment_2.right_endpoint = INF;// .at(0);
					//segment_2.rectangle_width = INF;// .at(0);
				}
				if (segment_2.rectangle_width == 1) {
					segment_3.rectangle_width++;
					//++rest_segment_size;
					segment_2.right_endpoint = INF;// .at(0);
					segment_2.rectangle_width = INF;// .at(0);
				}

#ifdef _DEBUG
				assert(segment_1.rectangle_width != INF && segment_3.rectangle_width != INF);
				assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
				//assert(0);
			}
			/*-----------------------------------------------------------------------------------------------------------------------------------------------.*/

#ifdef _DEBUG
			assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
		}/*=========================================Flat=========================================================*/
		else {
			segment_2.right_endpoint = INF;
			segment_2.rectangle_width = INF;
			segment_1.right_endpoint = INF;
			segment_1.rectangle_width = INF;
#ifdef _DEBUG
			assert(segment_1.right_endpoint == INF && segment_1.rectangle_width == INF && segment_2.right_endpoint == INF && segment_2.rectangle_width == INF);
			assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
			assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
		}

		/*----------------------------------------- Merge previous segments--------------------------------------------------------------------*/

		/*if (segment_1.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_1);
		}
		else if (segment_2.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_2);
		}
		else if (segment_3.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_3);
		}*/

		/*-------------------------------------------------------------------------------------------------------------------------------------*/
		//int old_id = result_area_vector.size() - 1;
		/*-----------------------------------------    Push back Vector   ----------------------------------------------------------------------*/
		if (segment_1.right_endpoint != INF) {
			rest_segment_number--;
			segment_1.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_1);
		}
		if (segment_2.right_endpoint != INF) {
			rest_segment_number--;
			segment_2.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_2);
		}
		if (segment_3.right_endpoint != INF) {
			rest_segment_number--;
			segment_3.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_3);
		}
		/*----------------------------------------------------------------------------------------------------------------------------------------*/

		if (doubly_linked_list.back().right_endpoint == input_argument.time_series_length - 2) {
			doubly_linked_list.back().right_endpoint++;
			doubly_linked_list.back().rectangle_width++;
		}
		pre_right_endpoint = doubly_linked_list.back().right_endpoint;

		/*.......................................................................................................................................................................*/
#ifdef _DEBUG
		assert(segment_3.min_point.id <= segment_3.right_endpoint && segment_3.max_point.id <= segment_3.right_endpoint);
		assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
	}
	/*......................................................................................................*/

#ifdef _DEBUG
	assert(doubly_linked_list.size() <= initial_vector_size);
	assert(doubly_linked_list.back().right_endpoint == input_argument.time_series_length - 1);

	//test segment width
	assert(doubly_linked_list.front().rectangle_width == doubly_linked_list.front().right_endpoint + 1);
	for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
		assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint);
	}
#endif

	/*===============================================    Y Projection Method     =====================================================================*/
	if (y_projection_argument.is_y_projection && input_argument.change_file) {// is y proejction & already change file
		AREA_COEFFICIENT temp_coefficient;
		/*--------------------------------------------------   get threshold   ------------------------------------------------------------*/
		/*.............................count most points .....................................*/
		std::map<int, double, std::greater<int>> number_value_map;// number of y value bigger to small.
		for (auto&& au : y_projection_argument.whole_difference_map) {
			number_value_map.emplace(au.second, au.first);
		}
		// initial threshold
		y_projection_argument.flat_segment_min = number_value_map.begin()->second;//first threshold. min value in flat segment
		y_projection_argument.flat_segment_max = y_projection_argument.flat_segment_min;
		/*.................................................................................*/

		/*................. Special case: time series is a line ..................................*/
		if (y_projection_argument.whole_difference_map.size() < 2) {
#ifdef _DEBUG
			cout << "!333333333333333333333333333333333333333333333333333333333333333333YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY\n";
			assert(!y_projection_argument.whole_difference_map.empty() && y_projection_argument.flat_segment_min != INF && y_projection_argument.flat_segment_max == y_projection_argument.flat_segment_min);
#endif

			y_projection_argument.is_y_projection = true;
			temp_coefficient.right_endpoint = input_argument.time_series_length - 1;
			temp_coefficient.rectangle_width = input_argument.time_series_length;
			temp_coefficient.is_flat = true;
			temp_coefficient.segment_right_height_difference = 0;

			cluster_linked_list.add(temp_coefficient);
			all_segment_linked_list.add(temp_coefficient);
#ifdef _DEBUG
			assert(cluster_linked_list.back().right_endpoint == input_argument.time_series_length - 1 && cluster_linked_list.size() == all_segment_linked_list.size());
			assert(y_projection_argument.flat_segment_max != INF && y_projection_argument.flat_segment_min != INF && y_projection_argument.flat_segment_min == y_projection_argument.flat_segment_max);
#endif
		}
		/*.........................................................................*/
		/*.................if y value has several y values.........................*/
		else {
			/*------------------------------------------   get second threshold   ----------------------------------------------*/
#ifdef _DEBUG
			assert(!y_projection_argument.whole_difference_map.empty() && y_projection_argument.flat_segment_min != INF && y_projection_argument.flat_segment_max == y_projection_argument.flat_segment_min);
#endif
			const auto& const second_most_y_pair = next(number_value_map.begin(), 1);//second threshold number
			const auto& const bigger_than_threshold_pair = next(y_projection_argument.whole_difference_map.find(y_projection_argument.flat_segment_min), 1);// bigger than threshold
			const auto& const smaller_than_threshold_pair = prev(y_projection_argument.whole_difference_map.find(y_projection_argument.flat_segment_min), 1);//smaller than threshold

			//no bigger most y value
			if (bigger_than_threshold_pair == y_projection_argument.whole_difference_map.end()) {
				if (second_most_y_pair->second == smaller_than_threshold_pair->first) {
					y_projection_argument.flat_segment_max = y_projection_argument.flat_segment_min;//threshold
					y_projection_argument.flat_segment_min = second_most_y_pair->second;
				}
			}//no smaller y value
			else if (smaller_than_threshold_pair == y_projection_argument.whole_difference_map.end()) {
				if (second_most_y_pair->second == bigger_than_threshold_pair->first) {
					y_projection_argument.flat_segment_max = second_most_y_pair->second;//threshold
				}
			}
			else {
				if (second_most_y_pair->second == smaller_than_threshold_pair->first) {
#ifdef _DEBUG
					assert(second_most_y_pair->second != bigger_than_threshold_pair->first);
#endif
					//y_projection_argument.flat_segment_max = y_projection_argument.flat_segment_min;//threshold
					y_projection_argument.flat_segment_min = second_most_y_pair->second;
				}
				else if (second_most_y_pair->second == bigger_than_threshold_pair->first) {
#ifdef _DEBUG
					assert(second_most_y_pair->second != smaller_than_threshold_pair->first);
#endif
					y_projection_argument.flat_segment_max = second_most_y_pair->second;//threshold
				}

			}

			//if (number_value_map.begin()->first / second_y_number->first > 2) {
			//	y_projection_argument.flat_segment_max = y_projection_argument.flat_segment_min;//threshold
			//}
			//else {
			//	y_projection_argument.flat_segment_max = max(second_y_number->second, y_projection_argument.flat_segment_min);//threshold
			//	y_projection_argument.flat_segment_min = min(second_y_number->second, y_projection_argument.flat_segment_min);
			//}

#ifdef _DEBUG
			assert(y_projection_argument.flat_segment_max != INF && y_projection_argument.flat_segment_min != INF && y_projection_argument.flat_segment_min <= y_projection_argument.flat_segment_max);
#endif
			/*-------------------------------------------------------------------------------------------------------------------------------------*/

			/*-------------------------------------------get all & cluster linked list------------------------------------------------------------------*/
			//get_y_all_cluster_segment(input_argument, original_time_series, y_projection_argument, all_segment_linked_list, cluster_linked_list);
			get_y_all_cluster_segment_200213(input_argument, original_time_series, y_projection_argument, all_segment_linked_list, cluster_linked_list);
			/*------------------------------------------------------------------------------------------------------------------------------------------*/

			//if (flat_segment_number / double(all_segment_linked_list.size()) < 0.5) {
			//if (input_argument.total_flat_segment_length / double(input_argument.time_series_length) > 0.5) {

			if (cluster_linked_list.size() <= double(input_argument.time_series_length) / 10 && number_value_map.begin()->first > double(input_argument.time_series_length) / 10 && y_projection_argument.total_flat_segment_length > double(input_argument.time_series_length) / 2) {
#ifdef _DEBUG
				cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!************************YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY\n";
				cout << "After initial, All segment size: " << all_segment_linked_list.size() << "  Burst size " << cluster_linked_list.size() << endl;
				cout << "Total flat length: " << y_projection_argument.total_flat_segment_length << "  total flat number:  " << y_projection_argument.flat_segment_number << ",   " << y_projection_argument.flat_segment_number / y_projection_argument.total_flat_segment_length << endl;
				cout << "Y size: " << y_projection_argument.whole_difference_map.size() << endl;
				cout << "most frequent point number : " << number_value_map.begin()->first << endl;
#endif
				y_projection_argument.is_y_projection = true;
			}
			else {
#ifdef _DEBUG
				cout << "NNNNNNNNNNNNNN               NNNNNNNNNNNNN                        NNNNNNNNNNNNNNNNNNNNNNNNNNN NNNNNNNNNNNNNNNN          NNNNNNNNNNNNNNNNNNNNNNNN\n";
				cout << "After initial, All segment size: " << all_segment_linked_list.size() << "  Burst size " << cluster_linked_list.size() << endl;
				cout << "Total flat length: " << y_projection_argument.total_flat_segment_length << "  total flat number:  " << y_projection_argument.flat_segment_number << ",   " << y_projection_argument.flat_segment_number / y_projection_argument.total_flat_segment_length << endl;
				cout << "Y size: " << y_projection_argument.whole_difference_map.size() << endl;
				cout << "most frequent point number : " << number_value_map.begin()->first << endl;
#endif
				y_projection_argument.is_y_projection = false;
			}
		}
	}

	/*=========================================================================================================================================================*/

	/*---------------------------------------------------- Split Segment increase vector----------------------------------------------------------------------------------------*/

	/*......................................................................................................................................................................*/
#ifdef _DEBUG
	//assert(doubly_linked_list.size() >= input_argument.point_dimension);
	for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
		assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint && doubly_linked_list[segment_id].rectangle_width > 1);
	}
	//assert right enpoint & width of every segment
	assertRightEndpoint_Width(doubly_linked_list);
#endif
	//assert(result_area_vector.size() <= area_vector.size());
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// Output: Min Max Point
	//for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		//getSegmentMinMaxPoint(original_time_series, doubly_linked_list[segment_id]);
	//}
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// No need for burst time series
	// input: width right endpoint
	// Output: a&b apla coefficient, sum value, minmax point
	//getPLAByAdaptiveSegment(input_argument, original_time_series, doubly_linked_list);//190822 sum_value, a, b, apla_coefficienty_projection_argument.whole_difference_map
	if (!y_projection_argument.is_y_projection) {// normal time series
		getPLAByAdaptiveSegmentAndMinMax(input_argument, original_time_series, doubly_linked_list);//191031 sum_value, a, b, apla_coefficient, min & max point
	}
	else {// burst time series, use Y-projection
		doubly_linked_list.clear();
	}
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
}

//200212 merge Y projection & MSPLA
	//200212 Add template. Use vector to instead pointer for time series
//************************************
// Method:initialMSPLA
// Qualifier: Merge normal initial & Y projection
// 190918 Use Linded list
// date:200212 13:25
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
void APLA::initialMSPLA(U& const input_argument, const vector<T>& const original_time_series_vector, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<Y>& const all_segment_linked_list, DoublyLinkedList<Y>& const cluster_linked_list, DoublyLinkedList<Y>& const doubly_linked_list) {
	assert(0);
#ifdef _DEBUG
	assert(input_argument.segment_length_first == input_argument.segment_length_second + 1);
	assert(input_argument.segment_length_first > 2);
#endif
	/*=======================================================================       Initial variable      =============================================================*/
	/*================================Y-Projection Method===================================*/
	//int threshould_number = 0;
	//std::map<double, int> y_segment_number_map;
	//map<double, int> whole_difference_map;
	//y_projection_argument.is_y_projection = true;
	/*=====================================================================================*/
	/*=============================================      Burst Time Series 191007     =============================================*/
	//std::multiset<double> point_value_set;//191007
	//vector<AREA_COEFFICIENT> burst_segment;//191007
	//int time_series_end = input_argument.time_series_length / 2;
	//int initial_segment_right_endpoint = INF;//191008
	//double& frequent_value = *std::min_element(original_time_series, original_time_series + time_series_end);
	//int frequent_number = std::count(original_time_series, original_time_series + time_series_end, frequent_value);
	//cout << "++++++++++++++++++++++++++" << frequent_value<<" : "<< frequent_number  <<" : " << time_series_end <<" : "<< time_series_end / frequent_number << endl;
	//if (time_series_end / frequent_number < 2) {
	//	input_argument.burst_frquent_value = frequent_value;
	//}
	/*============================================================================================================================*/
	int original_id = 0;//190617
	int initial_vector_size = input_argument.point_dimension;// = input_argument.point_dimension < 3 ? 3 : input_argument.point_dimension;//190812
	/*---------------------Initial segment size---------------------------*/
	while (initial_vector_size % 3 != 0) {
		++initial_vector_size;
	}
	/*--------------------------------------------------------------------*/
	//initial_vector_size *= 3;
	//vector<AREA_COEFFICIENT> result_area_vector;
	Y segment_1, segment_2, segment_3;
	//AREA_COEFFICIENT temp_segment;
	int pre_right_endpoint = -1;
	int rest_segment_number = initial_vector_size;
	bool can_merge_end = true;
	int rest_time_series_length = INF;
	/*======================================================================================================*/

	/*====================================While Loop==========================================================================*/
	while (pre_right_endpoint < input_argument.time_series_length - 1 && rest_segment_number > 0) {
		//while (result_area_vector.size() < area_vector.size()) {
#ifdef _DEBUG
		assert(pre_right_endpoint < input_argument.time_series_length);
		assert(doubly_linked_list.size() <= initial_vector_size);
#endif
		segment_3.min_point.id = INF;
		segment_3.min_point.value = INF;
		segment_3.max_point.id = -INF;
		segment_3.max_point.value = -INF;

		rest_time_series_length = input_argument.time_series_length - (pre_right_endpoint + 1);
		int max_size = ceil(rest_time_series_length / 2);
		if (rest_segment_number >= max_size) {
			rest_segment_number = max_size;
			can_merge_end = false;
		}
		auto remainder = rest_time_series_length % rest_segment_number;//For PLA
		auto segment_width_second = (rest_time_series_length - remainder) / rest_segment_number;
		//auto segment_width_first = segment_width_second + 1;
		/*-----------------------if max size or segment size == 1 or 2-----------------------------*/

		/*=========================Rest Segment Number 1 & 2===========================*/
		if (rest_segment_number == 1) {

			segment_3.right_endpoint = input_argument.time_series_length - 1;
			segment_3.rectangle_width = segment_3.right_endpoint - pre_right_endpoint;

			//mergeEndSegment(original_time_series, result_area_vector, segment_1);
			//if (segment_1.rectangle_width != INF && segment_1.right_endpoint != INF) {

			/*==================================== Y Projection Method ============================================*/
			get_minmax_y_projection(input_argument, original_time_series_vector, pre_right_endpoint, segment_3, y_projection_argument, all_segment_linked_list);
			/*=====================================================================================================*/
			rest_segment_number--;
			segment_3.right_subsegment = new Y;
			doubly_linked_list.add(segment_3);
			//}
			pre_right_endpoint = segment_3.right_endpoint;
#ifdef _DEBUG
			assert(pre_right_endpoint < input_argument.time_series_length&& segment_3.rectangle_width > 1);
#endif
			continue;
		}
		/*====================================================================================================================================================*/
		if (rest_segment_number == 2) {
			segment_3.right_endpoint = input_argument.time_series_length - 1;
			segment_3.rectangle_width = segment_3.right_endpoint - pre_right_endpoint;

			/*==================================== Y Projection Method ============================================*/
			get_minmax_y_projection(input_argument, original_time_series_vector, pre_right_endpoint, segment_3, y_projection_argument, all_segment_linked_list);
			/*=====================================================================================================*/

			segment_2.right_endpoint = input_argument.time_series_length - 1;
			segment_2.rectangle_width = max_size;
			segment_1.right_endpoint = segment_2.right_endpoint - segment_2.rectangle_width;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;
#ifdef _DEBUG
			assert(segment_1.rectangle_width == rest_time_series_length - max_size && segment_1.right_endpoint == segment_1.rectangle_width + pre_right_endpoint);
#endif
			//mergeEndSegment(original_time_series, result_area_vector, segment_1);
			//if (segment_1.rectangle_width != INF && segment_1.right_endpoint != INF) {
			--rest_segment_number;
			segment_1.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_1);
			//}
			//mergeEndSegment(original_time_series, result_area_vector, segment_2);
			//if (segment_2.rectangle_width != INF && segment_2.right_endpoint != INF) {
			--rest_segment_number;
			segment_2.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_2);
			//}
			pre_right_endpoint = segment_2.right_endpoint;

#ifdef _DEBUG
			assert(pre_right_endpoint == input_argument.time_series_length - 1 && segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1);
#endif
			continue;
		}
		/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/

		/*......................................................................................................*/
#ifdef _DEBUG
		assert(segment_width_second > 1 && rest_segment_number > -1);
#endif
		/*-- Get segment_3 right endpoint & rectangle width --*/
		segment_3.right_endpoint = segment_width_second * 3;
		segment_3.rectangle_width = segment_3.right_endpoint;
		switch (remainder) {
		case 0:
			break;
		case 1:
			segment_3.right_endpoint++;
			segment_3.rectangle_width++;
			break;
		case 2:
			segment_3.right_endpoint += 2;
			segment_3.rectangle_width += 2;
			break;
		default:
			segment_3.right_endpoint += 3;
			segment_3.rectangle_width += 3;
		}
		segment_3.right_endpoint += pre_right_endpoint;
		/*.................................................*/

#ifdef _DEBUG
		assert(segment_3.rectangle_width > 5 && segment_3.right_endpoint < input_argument.time_series_length&& segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
		//cout << "right endpoint: " << segment_3.right_endpoint << " width: "<< segment_3.rectangle_width<<endl;
		/*===========================Y Projection Method============================================*/
		//segment_3.segment_right_point.id = segment_3.right_endpoint;
		//segment_3.segment_right_point.value = original_time_series[int(segment_3.right_endpoint)];
		/*==========================================================================================*/

		/*===========================================For Burst time series========================================*/
		//if (input_argument.burst_frquent_value != INF) {
			//initial_segment_right_endpoint = segment_3.right_endpoint;
		//while (float(original_time_series[int(segment_3.right_endpoint)]) == float(original_time_series[int(segment_3.right_endpoint + 2)]) || float(original_time_series[int(segment_3.right_endpoint)]) == float(original_time_series[int(segment_3.right_endpoint + 1)]) || float(original_time_series[int(segment_3.right_endpoint + 1)]) == float(original_time_series[int(segment_3.right_endpoint - 1)]) || float(original_time_series[int(segment_3.right_endpoint + 1)]) == float(original_time_series[int(segment_3.right_endpoint - 2)]) || float(original_time_series[int(segment_3.right_endpoint)] - original_time_series[int(segment_3.right_endpoint - 1)]) == float(original_time_series[int(segment_3.right_endpoint + 1)] - original_time_series[int(segment_3.right_endpoint)])) {
		if (segment_3.right_endpoint + 1 < input_argument.time_series_length) {
			while (float(original_time_series_vector[int(segment_3.right_endpoint)]) == float(original_time_series_vector[int(segment_3.right_endpoint + 1)]) || float(original_time_series_vector[int(segment_3.right_endpoint + 1)]) == float(original_time_series_vector[int(segment_3.right_endpoint - 1)]) || float(original_time_series_vector[int(segment_3.right_endpoint + 1)]) == float(original_time_series_vector[int(segment_3.right_endpoint - 2)]) || float(original_time_series_vector[int(segment_3.right_endpoint)] - original_time_series_vector[int(segment_3.right_endpoint - 1)]) == float(original_time_series_vector[int(segment_3.right_endpoint + 1)] - original_time_series_vector[int(segment_3.right_endpoint)])) {
				++segment_3.right_endpoint;
				++segment_3.rectangle_width;
				if (segment_3.right_endpoint + 1 >= input_argument.time_series_length) break;
			}
			//}
			//191124 for time series that is a line, only has one value
			/*while (original_time_series_vector[int(segment_3.right_endpoint)] == original_time_series_vector[int(segment_3.right_endpoint + 1)] && segment_3.right_endpoint < input_argument.time_series_length) {
				++segment_3.right_endpoint;
				++segment_3.rectangle_width;
				if (segment_3.right_endpoint + 1 >= input_argument.time_series_length) break;
			}*/
		}

		if (input_argument.time_series_length - segment_3.right_endpoint < 7) segment_3.right_endpoint = input_argument.time_series_length - 1;
		/*=========================================================================================================*/

		/*=======================================get MinMax, Projection==================================================================================*/
		get_minmax_y_projection(input_argument, original_time_series_vector, pre_right_endpoint, segment_3, y_projection_argument, all_segment_linked_list);
		/*===============================================================================================================================================*/

		/*=======================================Not Flat==================================================================================*/
		if (segment_3.max_point.id != segment_3.min_point.id && segment_3.max_point.value != segment_3.min_point.value) {
			segment_1.right_endpoint = min(segment_3.min_point.id, segment_3.max_point.id);
			segment_2.right_endpoint = max(segment_3.min_point.id, segment_3.max_point.id);

			segment_3.rectangle_width = segment_3.right_endpoint - segment_2.right_endpoint;
			segment_2.rectangle_width = segment_2.right_endpoint - segment_1.right_endpoint;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;

			/*--------------------------seg1=1,seg3=1 or 0-----------------------------------------------*/
			//segment1==1, segment3==0/1, The segment is monotony increase or decrease
			if (segment_1.rectangle_width == 1 && segment_3.rectangle_width < 2) {//segment_left_id == segment1 right endpoint
#ifdef _DEBUG
				assert(segment_2.rectangle_width > 1);
#endif
				if (segment_3.rectangle_width == 1) {
#ifdef _DEBUG
					assert(segment_2.rectangle_width == segment_3.right_endpoint - pre_right_endpoint - 2);
#endif
					segment_3.right_endpoint--;
					//segment_2.rectangle_width++;
				}
				segment_3.rectangle_width = segment_2.rectangle_width + 1;
				segment_2.right_endpoint = INF;
				segment_2.rectangle_width = INF;
				segment_1.right_endpoint = INF;
				segment_1.rectangle_width = INF;
				//rest_segment_size+=2;

				/*---------------------------------------------------------          Split monotony segment        ---------------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint && segment_3.rectangle_width > 1 && segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				if (segment_3.rectangle_width > 3) {//Split segment 3.  renew segment 3 apla a&b coefficients, split segmenet 3 into segment 2 and segment 3
					segment_3.apla.a = INF;
					splitSegmentBySplitedPoint(original_time_series_vector, input_argument.option_split_method, segment_2, segment_3);
				}
				/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
			}
			/*--------------------------------------------------------------------------------------------------------------------------------------*/
			/*--------------------------seg1 width > 1, seg3=1 or 0-----------------------------------------------*/
			else if (segment_1.rectangle_width > 1 && segment_3.rectangle_width < 2) {
				if (segment_3.rectangle_width == 1) {
#ifdef _DEBUG
					assert(segment_2.rectangle_width == segment_3.right_endpoint - segment_1.right_endpoint - 1);
#endif
					segment_3.right_endpoint--;
					//segment_2.rectangle_width++;
				}
				segment_3.rectangle_width = segment_2.rectangle_width;
				segment_2.right_endpoint = INF;
				segment_2.rectangle_width = INF;
				//rest_segment_size++;
#ifdef _DEBUG
				assert(segment_1.rectangle_width + segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
				/*--------------------------------------------------   Split monotony segment    -------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				if (segment_3.rectangle_width > 3) {//Split segment 3.  renew segment 3 apla a&b coefficients
					segment_3.apla.a = INF;
					splitSegmentBySplitedPoint(original_time_series_vector, input_argument.option_split_method, segment_2, segment_3);
				}
				/*--------------------------------------------------------------------------------------------------------------------------------------------*/
				if (segment_3.rectangle_width == 1) {
					segment_1.rectangle_width--;
					segment_3.rectangle_width++;
					segment_1.right_endpoint--;
#ifdef _DEBUG
					assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
				}
			}
			/*................................................................................................................................................*/
			/*--------------------------seg1 width == 1, seg3>1-----------------------------------------------*/
			else if (segment_1.rectangle_width == 1 && segment_3.rectangle_width > 1) {
				segment_2.rectangle_width++;
				segment_1.right_endpoint = INF;
				segment_1.rectangle_width = INF;
				//rest_segment_size++;
#ifdef _DEBUG
				assert(segment_2.rectangle_width + segment_3.rectangle_width == segment_3.right_endpoint - pre_right_endpoint);
#endif
				/*-------------------------------------------------- Split monotony segment-------------------------------------------------------------*/
#ifdef _DEBUG
				assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
#endif
				if (segment_2.rectangle_width > 3) {// //Split segment 2.  renew segment 2 apla a&b coefficients
					segment_2.apla.a = INF;
					splitSegmentBySplitedPoint(original_time_series_vector, input_argument.option_split_method, segment_1, segment_2);
				}
				/*--------------------------------------------------------------------------------------------------------------------------------------*/
			}
			else {
				if (segment_2.rectangle_width == 0) {
					assert(0);
					//++segment_size;
					//segment_2.right_endpoint = INF;// .at(0);
					//segment_2.rectangle_width = INF;// .at(0);
				}
				if (segment_2.rectangle_width == 1) {
					segment_3.rectangle_width++;
					//++rest_segment_size;
					segment_2.right_endpoint = INF;// .at(0);
					segment_2.rectangle_width = INF;// .at(0);
				}

#ifdef _DEBUG
				assert(segment_1.rectangle_width != INF && segment_3.rectangle_width != INF);
				assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
				//assert(0);
			}
			/*-----------------------------------------------------------------------------------------------------------------------------------------------.*/

#ifdef _DEBUG
			assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
		}/*=========================================Flat=========================================================*/
		else {
			segment_2.right_endpoint = INF;
			segment_2.rectangle_width = INF;
			segment_1.right_endpoint = INF;
			segment_1.rectangle_width = INF;
#ifdef _DEBUG
			assert(segment_1.right_endpoint == INF && segment_1.rectangle_width == INF && segment_2.right_endpoint == INF && segment_2.rectangle_width == INF);
			assert(segment_3.rectangle_width != INF && segment_3.right_endpoint > 0 && segment_3.right_endpoint < input_argument.time_series_length);
			assert(segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
		}

		/*----------------------------------------- Merge previous segments--------------------------------------------------------------------*/

		/*if (segment_1.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_1);
		}
		else if (segment_2.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_2);
		}
		else if (segment_3.right_endpoint != INF && !result_area_vector.empty() && can_merge_end) {
			mergeEndSegment(original_time_series, result_area_vector, segment_3);
		}*/

		/*-------------------------------------------------------------------------------------------------------------------------------------*/
		//int old_id = result_area_vector.size() - 1;
		/*-----------------------------------------    Push back Vector   ----------------------------------------------------------------------*/
		if (segment_1.right_endpoint != INF) {
			rest_segment_number--;
			segment_1.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_1);
		}
		if (segment_2.right_endpoint != INF) {
			rest_segment_number--;
			segment_2.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_2);
		}
		if (segment_3.right_endpoint != INF) {
			rest_segment_number--;
			segment_3.right_subsegment = new AREA_COEFFICIENT;
			doubly_linked_list.add(segment_3);
		}
		/*----------------------------------------------------------------------------------------------------------------------------------------*/

		if (doubly_linked_list.back().right_endpoint == input_argument.time_series_length - 2) {
			doubly_linked_list.back().right_endpoint++;
			doubly_linked_list.back().rectangle_width++;
		}
		pre_right_endpoint = doubly_linked_list.back().right_endpoint;

		/*.......................................................................................................................................................................*/
#ifdef _DEBUG
		assert(segment_3.min_point.id <= segment_3.right_endpoint && segment_3.max_point.id <= segment_3.right_endpoint);
		assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
	}
	/*......................................................................................................*/

#ifdef _DEBUG
	assert(doubly_linked_list.size() <= initial_vector_size);
	assert(doubly_linked_list.back().right_endpoint == input_argument.time_series_length - 1);

	//test segment width
	assert(doubly_linked_list.front().rectangle_width == doubly_linked_list.front().right_endpoint + 1);
	for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
		assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint);
	}
#endif

	/*===============================================    Y Projection Method     =====================================================================*/
	if (y_projection_argument.is_y_projection && input_argument.change_file) {// is y proejction & already change file
		AREA_COEFFICIENT temp_coefficient;
		/*--------------------------------------------------   get threshold   ------------------------------------------------------------*/
		/*.............................count most points .....................................*/
		std::map<int, double, std::greater<int>> number_value_map;// number of y value bigger to small.
		for (auto&& au : y_projection_argument.whole_difference_map) {
			number_value_map.emplace(au.second, au.first);
		}
		// initial threshold
		y_projection_argument.flat_segment_min = number_value_map.begin()->second;//first threshold. min value in flat segment
		y_projection_argument.flat_segment_max = y_projection_argument.flat_segment_min;
		/*.................................................................................*/

		/*................. Special case: time series is a line ..................................*/
		if (y_projection_argument.whole_difference_map.size() < 2) {
#ifdef _DEBUG
			cout << "!!!!!!!!!!!!!!!!!!!!!     Whole time series is a line   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n";
			assert(!y_projection_argument.whole_difference_map.empty() && y_projection_argument.flat_segment_min != INF && y_projection_argument.flat_segment_max == y_projection_argument.flat_segment_min);
#endif

			y_projection_argument.is_y_projection = true;
			temp_coefficient.right_endpoint = input_argument.time_series_length - 1;
			temp_coefficient.rectangle_width = input_argument.time_series_length;
			temp_coefficient.is_flat = true;
			temp_coefficient.segment_right_height_difference = 0;

			cluster_linked_list.add(temp_coefficient);
			all_segment_linked_list.add(temp_coefficient);
#ifdef _DEBUG
			assert(cluster_linked_list.back().right_endpoint == input_argument.time_series_length - 1 && cluster_linked_list.size() == all_segment_linked_list.size());
			assert(y_projection_argument.flat_segment_max != INF && y_projection_argument.flat_segment_min != INF && y_projection_argument.flat_segment_min == y_projection_argument.flat_segment_max);
#endif
		}
		/*.........................................................................*/
		/*.................if y value has several y values.........................*/
		else {
			/*------------------------------------------   get second threshold   ----------------------------------------------*/
#ifdef _DEBUG
			assert(!y_projection_argument.whole_difference_map.empty() && y_projection_argument.flat_segment_min != INF && y_projection_argument.flat_segment_max == y_projection_argument.flat_segment_min);
#endif
			const auto& const second_most_y_pair = next(number_value_map.begin(), 1);//second threshold number
			const auto& const bigger_than_threshold_pair = next(y_projection_argument.whole_difference_map.find(y_projection_argument.flat_segment_min), 1);// bigger than threshold
			const auto& const smaller_than_threshold_pair = prev(y_projection_argument.whole_difference_map.find(y_projection_argument.flat_segment_min), 1);//smaller than threshold

			//no bigger most y value
			if (bigger_than_threshold_pair == y_projection_argument.whole_difference_map.end()) {
				if (second_most_y_pair->second == smaller_than_threshold_pair->first) {
					y_projection_argument.flat_segment_max = y_projection_argument.flat_segment_min;//threshold
					y_projection_argument.flat_segment_min = second_most_y_pair->second;
				}
			}//no smaller y value
			else if (smaller_than_threshold_pair == y_projection_argument.whole_difference_map.end()) {
				if (second_most_y_pair->second == bigger_than_threshold_pair->first) {
					y_projection_argument.flat_segment_max = second_most_y_pair->second;//threshold
				}
			}
			else {
				if (second_most_y_pair->second == smaller_than_threshold_pair->first) {
#ifdef _DEBUG
					assert(second_most_y_pair->second != bigger_than_threshold_pair->first);
#endif
					//y_projection_argument.flat_segment_max = y_projection_argument.flat_segment_min;//threshold
					y_projection_argument.flat_segment_min = second_most_y_pair->second;
				}
				else if (second_most_y_pair->second == bigger_than_threshold_pair->first) {
#ifdef _DEBUG
					assert(second_most_y_pair->second != smaller_than_threshold_pair->first);
#endif
					y_projection_argument.flat_segment_max = second_most_y_pair->second;//threshold
				}

			}

			//if (number_value_map.begin()->first / second_y_number->first > 2) {
			//	y_projection_argument.flat_segment_max = y_projection_argument.flat_segment_min;//threshold
			//}
			//else {
			//	y_projection_argument.flat_segment_max = max(second_y_number->second, y_projection_argument.flat_segment_min);//threshold
			//	y_projection_argument.flat_segment_min = min(second_y_number->second, y_projection_argument.flat_segment_min);
			//}

#ifdef _DEBUG
			assert(y_projection_argument.flat_segment_max != INF && y_projection_argument.flat_segment_min != INF && y_projection_argument.flat_segment_min <= y_projection_argument.flat_segment_max);
#endif
			/*-------------------------------------------------------------------------------------------------------------------------------------*/

			/*-------------------------------------------get all & cluster linked list------------------------------------------------------------------*/
			//get_y_all_cluster_segment(input_argument, original_time_series_vector, y_projection_argument, all_segment_linked_list, cluster_linked_list);
			get_y_all_cluster_segment_200213(input_argument, original_time_series_vector, y_projection_argument, all_segment_linked_list, cluster_linked_list);
			/*------------------------------------------------------------------------------------------------------------------------------------------*/

			//if (flat_segment_number / double(all_segment_linked_list.size()) < 0.5) {
			//if (input_argument.total_flat_segment_length / double(input_argument.time_series_length) > 0.5) {

			if (cluster_linked_list.size() <= double(input_argument.time_series_length) / 10 && number_value_map.begin()->first > double(input_argument.time_series_length) / 10 && y_projection_argument.total_flat_segment_length > double(input_argument.time_series_length) / 2) {
#ifdef _DEBUG
				cout << "It is a Burst TIme Siers YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY\n";
				cout << "After initial, All segment size: " << all_segment_linked_list.size() << "  Burst size " << cluster_linked_list.size() << endl;
				cout << "Total flat length: " << y_projection_argument.total_flat_segment_length << "  total flat number:  " << y_projection_argument.flat_segment_number << ",   " << y_projection_argument.flat_segment_number / y_projection_argument.total_flat_segment_length << endl;
				cout << "Y size: " << y_projection_argument.whole_difference_map.size() << endl;
				cout << "most frequent point number : " << number_value_map.begin()->first << endl;
#endif
				y_projection_argument.is_y_projection = true;
			}
			else {
#ifdef _DEBUG
				cout << "NNNNNNNNNNNNNN     This is not a burst time series !          NNNNNNNNNNNNN                        NNNNNNNNNNNNNNNNNNNNNNNNNNN NNNNNNNNNNNNNNNN          NNNNNNNNNNNNNNNNNNNNNNNN\n";
				cout << "After initial, All segment size: " << all_segment_linked_list.size() << "  Burst size " << cluster_linked_list.size() << endl;
				cout << "Total flat length: " << y_projection_argument.total_flat_segment_length << "  total flat number:  " << y_projection_argument.flat_segment_number << ",   " << y_projection_argument.flat_segment_number / y_projection_argument.total_flat_segment_length << endl;
				cout << "Y size: " << y_projection_argument.whole_difference_map.size() << endl;
				cout << "most frequent point number : " << number_value_map.begin()->first << endl;
#endif
				y_projection_argument.is_y_projection = false;
			}
		}
	}

	/*=========================================================================================================================================================*/

	/*---------------------------------------------------- Split Segment increase vector----------------------------------------------------------------------------------------*/

	/*......................................................................................................................................................................*/
#ifdef _DEBUG
	//assert(doubly_linked_list.size() >= input_argument.point_dimension);
	for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
		assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint && doubly_linked_list[segment_id].rectangle_width > 1);
	}
	//assert right enpoint & width of every segment
	assertRightEndpoint_Width(doubly_linked_list);
#endif
	//assert(result_area_vector.size() <= area_vector.size());
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// Output: Min Max Point
	//for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		//getSegmentMinMaxPoint(original_time_series, doubly_linked_list[segment_id]);
	//}
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// No need for burst time series
	// input: width right endpoint
	// Output: a&b apla coefficient, sum value, minmax point
	//getPLAByAdaptiveSegment(input_argument, original_time_series, doubly_linked_list);//190822 sum_value, a, b, apla_coefficienty_projection_argument.whole_difference_map
	if (!y_projection_argument.is_y_projection) {// normal time series
		getPLAByAdaptiveSegmentAndMinMax(input_argument, original_time_series_vector, doubly_linked_list);//191031 sum_value, a, b, apla_coefficient, min & max point
	}
	else {// burst time series, use Y-projection
		doubly_linked_list.clear();
	}
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
}

//200212 merge Y projection & MSPLA
	//200212 Add template. Use vector to instead pointer for time series
//************************************
// Method:initialMSPLA
// Qualifier: Merge normal initial & Y projection
// 190918 Use Linded list
// date:200212 13:25
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U, typename U1>
void APLA::initialMSPLA(U& const input_argument, const vector<T>& const original_time_series_vector, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<Y>& const all_segment_linked_list, DoublyLinkedList<Y>& const cluster_linked_list, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument) {
#ifdef _DEBUG
	assert(input_argument.segment_length_first == input_argument.segment_length_second + 1 && input_argument.segment_length_first > 2);
#endif
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&            Initial variable           &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*================================            Y-Projection Method      ===================================*/
	//int threshould_number = 0;
	//std::map<double, int> y_segment_number_map;
	//map<double, int> whole_difference_map;
	//y_projection_argument.is_y_projection = true;
	/*========================================================================================================*/

	/*=============================================      Burst Time Series 191007     =============================================*/
	//std::multiset<double> point_value_set;//191007
	//vector<AREA_COEFFICIENT> burst_segment;//191007
	//int time_series_end = input_argument.time_series_length / 2;
	//int initial_segment_right_endpoint = INF;//191008
	//double& frequent_value = *std::min_element(original_time_series, original_time_series + time_series_end);
	//int frequent_number = std::count(original_time_series, original_time_series + time_series_end, frequent_value);
	//cout << "++++++++++++++++++++++++++" << frequent_value<<" : "<< frequent_number  <<" : " << time_series_end <<" : "<< time_series_end / frequent_number << endl;
	//if (time_series_end / frequent_number < 2) {
	//	input_argument.burst_frquent_value = frequent_value;
	//}
	/*============================================================================================================================*/
	//int original_id = 0;//190617

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	int id_min_point = int(INF);
	int id_max_point = int(INF);
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*####################################           Initial Segment Number          #############################################*/
	int initial_vector_size = input_argument.point_dimension; // = input_argument.point_dimension < 3 ? 3 : input_argument.point_dimension;//190812

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!     Initial segment size     !!!!!!!!!!!!!!!!!!!!!!!!!*/
	while (initial_vector_size % 3 != 0) {
		++initial_vector_size;
	}
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	//initial_vector_size *= 3;

	/*!!!!!!!!!!!!!!!!         200330 Evaluation initial_N with accuracy  !!!!!!!!!!!!!!!!!!!*/
	/*if (input_argument.initial_N != INF) {
		initial_vector_size = input_argument.initial_N;
	}
	else {
		input_argument.initial_N = initial_vector_size;
	}*/
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	/*############################################################################################################################*/

	/*#############################################################################################################################*/
	//vector<AREA_COEFFICIENT> result_area_vector;
	Y segment_1, segment_2, segment_3;
	//AREA_COEFFICIENT temp_segment;
	int pre_right_endpoint = -1;
	int rest_segment_number = initial_vector_size;
	//bool can_merge_end = true;
	int rest_time_series_length = INF;
	int max_size = INF;
	int remainder = INF;
	double segment_width_second = INF;
	/*############################################################################################################################*/
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&                  While Loop                  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	while (pre_right_endpoint < input_argument.time_series_length - 1 && rest_segment_number > 0) {
		//while (result_area_vector.size() < area_vector.size()) {
		/*.........................................................................................*/
#ifdef _DEBUG
		assert(pre_right_endpoint < input_argument.time_series_length&& doubly_linked_list.size() <= initial_vector_size);
#endif
		/*.........................................................................................*/
		/*...200314 delete minmax point......*/
		/*segment_3.min_point.id = INF;
		segment_3.min_point.value = INF;
		segment_3.max_point.id = -INF;
		segment_3.max_point.value = -INF;*/
		/*..................................*/

		/*####################################           get remainder         ############################################*/
		rest_time_series_length = input_argument.time_series_length - (pre_right_endpoint + 1);
		max_size = ceil(rest_time_series_length / 2);
		if (rest_segment_number >= max_size) {
			rest_segment_number = max_size;
			//can_merge_end = false;
		}
		remainder = rest_time_series_length % rest_segment_number;//For PLA
		segment_width_second = (rest_time_series_length - remainder) / rest_segment_number;
		/*#################################################################################################################*/

		//auto segment_width_first = segment_width_second + 1;
		/*-----------------------if max size or segment size == 1 or 2-----------------------------*/
		/*-----------------------------------------------------------------------------------------*/

		/*#################################################               Rest Segment Number 1 & 2         ########################################################################################*/
		if (rest_segment_number == 1) {
			segment_3.right_endpoint = input_argument.time_series_length - 1;
			segment_3.rectangle_width = segment_3.right_endpoint - pre_right_endpoint;

			/*==================================== get min&max points, a&b, Y Projection coefficients of the last segment ============================================*/
			//get_minmax_y_projection(input_argument, original_time_series_vector, pre_right_endpoint, segment_3, y_projection_argument, all_segment_linked_list);
			get_minmax_y_projection(input_argument, original_time_series_vector, pre_right_endpoint + 1, segment_3.right_endpoint, id_min_point, id_max_point, y_projection_argument);
			/*========================================================================================================================================================*/

			segment_3.right_subsegment = new Y;
			doubly_linked_list.add(segment_3);
			pre_right_endpoint = segment_3.right_endpoint;
			/*.........................................................................................*/
#ifdef _DEBUG
			assert(pre_right_endpoint < input_argument.time_series_length&& segment_3.rectangle_width > 1);
#endif
			/*.........................................................................................*/
			rest_segment_number = 0;
			continue;
		}

		if (rest_segment_number == 2) {
			segment_3.right_endpoint = input_argument.time_series_length - 1;
			segment_3.rectangle_width = segment_3.right_endpoint - pre_right_endpoint;
			/*==================================== get min&max points, a&b, Y Projection coefficients of the last segment ============================================*/
			//get_minmax_y_projection(input_argument, original_time_series_vector, pre_right_endpoint, segment_3, y_projection_argument, all_segment_linked_list);
			get_minmax_y_projection(input_argument, original_time_series_vector, pre_right_endpoint + 1, segment_3.right_endpoint, id_min_point, id_max_point, y_projection_argument);
			/*========================================================================================================================================================*/
			segment_2.right_endpoint = input_argument.time_series_length - 1;
			segment_2.rectangle_width = max_size;
			segment_1.right_endpoint = segment_2.right_endpoint - segment_2.rectangle_width;
			segment_1.rectangle_width = segment_1.right_endpoint - pre_right_endpoint;
			/*.........................................................................................*/
#ifdef _DEBUG
			assert(segment_1.rectangle_width == rest_time_series_length - max_size && segment_1.right_endpoint == segment_1.rectangle_width + pre_right_endpoint);
#endif
			/*.........................................................................................*/
			segment_1.right_subsegment = new Y;
			doubly_linked_list.add(segment_1);

			segment_2.right_subsegment = new Y;
			doubly_linked_list.add(segment_2);

			pre_right_endpoint = segment_2.right_endpoint;
			/*.........................................................................................*/
#ifdef _DEBUG
			assert(pre_right_endpoint == input_argument.time_series_length - 1 && segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1);
#endif
			/*.........................................................................................*/
			rest_segment_number = 0;
			continue;
		}
		/*###############################################################################################################################################################*/

		/*######################################################       Long Segment_3 Right endpoint       ##############################################################*/
		/*.........................................................................................*/
#ifdef _DEBUG
		assert(segment_width_second > 1 && rest_segment_number > -1);
#endif
		/*.........................................................................................*/

		get_segment_3_right_endpoint(segment_width_second, remainder, pre_right_endpoint, segment_3);

		/*.........................................................................................*/
#ifdef _DEBUG
		assert(segment_3.right_endpoint < input_argument.time_series_length);
#endif
		/*.........................................................................................*/
		/*###############################################################################################################################################################*/

		//cout << "right endpoint: " << segment_3.right_endpoint << " width: "<< segment_3.rectangle_width<<endl;
		/*===========================Y Projection Method============================================*/
		//segment_3.segment_right_point.id = segment_3.right_endpoint;
		//segment_3.segment_right_point.value = original_time_series[int(segment_3.right_endpoint)];
		/*==========================================================================================*/

		/*############################################################            If Burst time series, extend segment_3              ###################################################################*/
		//if (input_argument.burst_frquent_value != INF) {
			//initial_segment_right_endpoint = segment_3.right_endpoint;
		//while (float(original_time_series[int(segment_3.right_endpoint)]) == float(original_time_series[int(segment_3.right_endpoint + 2)]) || float(original_time_series[int(segment_3.right_endpoint)]) == float(original_time_series[int(segment_3.right_endpoint + 1)]) || float(original_time_series[int(segment_3.right_endpoint + 1)]) == float(original_time_series[int(segment_3.right_endpoint - 1)]) || float(original_time_series[int(segment_3.right_endpoint + 1)]) == float(original_time_series[int(segment_3.right_endpoint - 2)]) || float(original_time_series[int(segment_3.right_endpoint)] - original_time_series[int(segment_3.right_endpoint - 1)]) == float(original_time_series[int(segment_3.right_endpoint + 1)] - original_time_series[int(segment_3.right_endpoint)])) {
		if (segment_3.right_endpoint + 1 < input_argument.time_series_length) {
			while (float(original_time_series_vector[int(segment_3.right_endpoint)]) == float(original_time_series_vector[int(segment_3.right_endpoint + 1)]) || float(original_time_series_vector[int(segment_3.right_endpoint + 1)]) == float(original_time_series_vector[int(segment_3.right_endpoint - 1)]) || float(original_time_series_vector[int(segment_3.right_endpoint + 1)]) == float(original_time_series_vector[int(segment_3.right_endpoint - 2)]) || float(original_time_series_vector[int(segment_3.right_endpoint)] - original_time_series_vector[int(segment_3.right_endpoint - 1)]) == float(original_time_series_vector[int(segment_3.right_endpoint + 1)] - original_time_series_vector[int(segment_3.right_endpoint)])) {
				++segment_3.right_endpoint;
				//++segment_3.rectangle_width;
				if (segment_3.right_endpoint + 1 >= input_argument.time_series_length) break;
			}
			segment_3.rectangle_width = segment_3.right_endpoint - pre_right_endpoint;
			//}
			//191124 for time series that is a line, only has one value
			/*while (original_time_series_vector[int(segment_3.right_endpoint)] == original_time_series_vector[int(segment_3.right_endpoint + 1)] && segment_3.right_endpoint < input_argument.time_series_length) {
				++segment_3.right_endpoint;
				++segment_3.rectangle_width;
				if (segment_3.right_endpoint + 1 >= input_argument.time_series_length) break;
			}*/
		}
		/*###################################################################################################################################################################################*/

		if (input_argument.time_series_length - segment_3.right_endpoint < 7) segment_3.right_endpoint = input_argument.time_series_length - 1;

		/*############################################################        get Min & Max point id, Projection       ######################################################################*/
		//get_minmax_y_projection(input_argument, original_time_series_vector, pre_right_endpoint, segment_3, y_projection_argument, all_segment_linked_list);
		get_minmax_y_projection(input_argument, original_time_series_vector, pre_right_endpoint + 1, segment_3.right_endpoint, id_min_point, id_max_point, y_projection_argument);
		/*####################################################################################################################################################################################*/

		/*####################################################            Split long segmnt into 3 segments by min&max points            #######################################################################*/
		assign_three_segments_by_minmax(input_argument, original_time_series_vector, pre_right_endpoint, id_min_point, id_max_point, segment_1, segment_2, segment_3, output_argument);
		/*######################################################################################################################################################################################################*/

		/*########################################    Push back Vector   ########################################################################*/
		insert_segment_back_linkedlist(segment_1, doubly_linked_list, rest_segment_number);
		insert_segment_back_linkedlist(segment_2, doubly_linked_list, rest_segment_number);
		insert_segment_back_linkedlist(segment_3, doubly_linked_list, rest_segment_number);
		/*########################################################################################################################################*/

		/*################################            The last right endpoint is time series length - 1            #############################################################*/
		if (doubly_linked_list.back().right_endpoint == input_argument.time_series_length - 2) {
			//already have a&b
			if (doubly_linked_list.back().apla.a != INF) {
				auto short_segment = doubly_linked_list.back();
				doubly_linked_list.back().right_endpoint++;
				doubly_linked_list.back().rectangle_width++;
				get_ab_segment_by_accumulation(original_time_series_vector, short_segment, doubly_linked_list.back());
				//get_minmax_segment_by_accumulation(original_time_series_vector.back(), doubly_linked_list.back());
			}
			else {//do not have a&b
				doubly_linked_list.back().right_endpoint++;
				doubly_linked_list.back().rectangle_width++;
			}
		}
		/*#####################################################################################################################################################################*/
		/*..............................................................................................*/
		pre_right_endpoint = doubly_linked_list.back().right_endpoint;
		/*..............................................................................................*/
		/*..............................................................................................*/
#ifdef _DEBUG
		//200314 minmax point 
		//assert(segment_3.min_point.id <= segment_3.right_endpoint && segment_3.max_point.id <= segment_3.right_endpoint);
		assert(segment_1.rectangle_width > 1 && segment_2.rectangle_width > 1 && segment_3.rectangle_width > 1);
#endif
		/*...............................................................................................*/
	}
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*...................................................................................................*/
#ifdef _DEBUG
	assert(doubly_linked_list.size() <= initial_vector_size && doubly_linked_list.back().right_endpoint == input_argument.time_series_length - 1 && doubly_linked_list.front().rectangle_width == doubly_linked_list.front().right_endpoint + 1);
	//test segment width
	for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
		const auto& const segment_current = doubly_linked_list[segment_id];
		const auto& const segment_previous = doubly_linked_list[segment_id - 1];
		assert(segment_current.rectangle_width == segment_current.right_endpoint - segment_previous.right_endpoint);
	}
#endif
	/*...................................................................................................*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&           Y Projection Method          &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	/*....................200304 Evaluate Y projection method == false. No y projection method...........*/
	//y_projection_argument.is_y_projection = false;
	/*...................................................................................................*/
	if (y_projection_argument.is_y_projection && input_argument.change_file) {// is y proejction & already change file
		initial_y_projection_all_cluster(input_argument, original_time_series_vector, y_projection_argument, all_segment_linked_list, cluster_linked_list);
	}
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&                Evaluation              &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
#ifdef _DEBUG
	//assert(doubly_linked_list.size() >= input_argument.point_dimension);
	for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
		const auto& const segment_current = doubly_linked_list[segment_id];
		assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint && doubly_linked_list[segment_id].rectangle_width > 1);
	}
	//assert right enpoint & width of every segment
	assertRightEndpoint_Width(doubly_linked_list);
#endif
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	//assert(result_area_vector.size() <= area_vector.size());
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// Output: Min Max Point
	//for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		//getSegmentMinMaxPoint(original_time_series, doubly_linked_list[segment_id]);
	//}
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&       get a&b, minmax point of each segment     &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	// No need for burst time series
	// input: width right endpoint
	// Output: a&b apla coefficient, sum value, minmax point
	//getPLAByAdaptiveSegment(input_argument, original_time_series, doubly_linked_list);//190822 sum_value, a, b, apla_coefficienty_projection_argument.whole_difference_map
	if (!y_projection_argument.is_y_projection) {// normal time series
		//200312 if one segment uses min density spit method, no need to compute a&b, sum value again
		//200318 No need sum value & minmax point
		//getPLAByAdaptiveSegmentAndMinMax(input_argument, original_time_series_vector, doubly_linked_list);//191031 sum_value, a, b, apla_coefficient, min & max point
		//200319 get a&b, triangle density, area difference of each segment
		//get_each_segment_ab_density_difference(original_time_series_vector, doubly_linked_list);
	}
	else {// burst time series, use Y-projection
		doubly_linked_list.clear();
	}
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
}

//************************************
// Method:loop_to_get_split_point
// Qualifier: loop to get split point at initial part.
// compute right endpoint, width, a&b and minmax point
// date:200731 07:39
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
void APLA::loop_to_get_split_point(const vector<T>& const original_time_series_vector, Y& const current_segment, Y& const accumulate_segment, Y& const next_two_points_segment, DoublyLinkedList<Y>& const doubly_linked_list) {
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!                Loop Part               !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*+++++++++++++++++++++++++++++++++++++++++++++         two points & accumulate loop          ++++++++++++++++++++++++++++++++++++++++++++++++*/

	while (accumulate_segment.right_endpoint < original_time_series_vector.size()) {
		//while (next_two_points_segment.right_endpoint < original_time_series_vector.size()) {
			//for (int id_array = 2; accumulate_segment.right_endpoint < input_argument.time_series_length; id_array++) {
			/*....................................................................................................................................................*/
#ifdef _DEBUG
		assert(current_segment.right_endpoint + 1 == accumulate_segment.right_endpoint && accumulate_segment.right_endpoint + 1 == next_two_points_segment.right_endpoint && current_segment.rectangle_width + 1 == accumulate_segment.rectangle_width && next_two_points_segment.rectangle_width == 2);
#endif
		/*....................................................................................................................................................*/

		/*=============================================================== compute a&b, minax of segment ===============================================================================*/
		/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
		/*-------------------------------------------------------------------------------------------------------------*/
		/*get_ab_segment_by_accumulation(original_time_series_vector, current_segment, accumulate_segment);
		get_minmax_segment_by_accumulation(original_time_series_vector[accumulate_segment.right_endpoint], current_segment, accumulate_segment);*/
		get_ab_minmax_segment_by_accumulation(original_time_series_vector[accumulate_segment.right_endpoint], current_segment, accumulate_segment);
		//next_two_points_segment.right_endpoint = accumulate_segment.right_endpoint + 1;
		/*-------------------------------------------------------------------------------------------------------------*/

		/*-------------------------------------------------------------------------------------------------------------*/
		//get_ab_minmax_segment_by_accumulation(original_time_series_vector[segment_whole.right_endpoint + 1], segment_whole);
		//get_ab_minmax_segment_by_accumulation(original_time_series_vector[segment_accumulation_split_half.right_endpoint], segment_split_half, segment_accumulation_split_half);
		/*-------------------------------------------------------------------------------------------------------------*/
		/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

		/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
		if (next_two_points_segment.right_endpoint < original_time_series_vector.size()) {
			/*-----------------------------------------------------------------------*/
			/*getAandBSlopInterceptTwoPoint(original_time_series_vector[next_two_points_segment.right_endpoint - 1], original_time_series_vector[next_two_points_segment.right_endpoint], next_two_points_segment);
			get_segment_two_point_minmax(original_time_series_vector[next_two_points_segment.right_endpoint - 1], original_time_series_vector[next_two_points_segment.right_endpoint], next_two_points_segment);*/
			get_segment_two_points_ab_minmax(original_time_series_vector[next_two_points_segment.right_endpoint - 1], original_time_series_vector[next_two_points_segment.right_endpoint], next_two_points_segment);
			/*-----------------------------------------------------------------------*/
		}
		else {

			/*...................................................................................*/
#ifdef _DEBUG
			assert(accumulate_segment.right_endpoint + 1 == original_time_series_vector.size());
#endif
			/*...................................................................................*/

			current_segment = accumulate_segment;
			break;
		}
		/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
		/*=====================================================================================================================================================================*/

		/*====================================================================================================================================*/
		if (next_two_points_segment.right_endpoint < original_time_series_vector.size() && fabs(current_segment.apla.a - next_two_points_segment.apla.a) < EPS && fabs(current_segment.apla.a * current_segment.rectangle_width + current_segment.apla.b - next_two_points_segment.apla.b) < EPS) {
			//if (current_segment.apla.a == accumulate_segment.apla.a && current_segment.apla.b == accumulate_segment.apla.b) {
				// for gradient decrease series: like 1,2,3,4

				/*
				   Update current segment right endpoint, width, minmax point. Keep a&b
				*/
			current_segment.right_endpoint = next_two_points_segment.right_endpoint;
			current_segment.rectangle_width += 2;
			current_segment.apla.a > 0 ? current_segment.max_point = next_two_points_segment.max_point : current_segment.min_point = next_two_points_segment.min_point;

			/*------------------------------------------------------    a & b coefficient    ---------------------------------------------------------------*/
			//coefficient of equation
			//a
			current_segment.apla.a_minuend = (current_segment.rectangle_width - 1) / 2.0;//(l-1)/2
			current_segment.apla.a_divisor = (current_segment.rectangle_width - 1) * (current_segment.rectangle_width + 1) * current_segment.rectangle_width;//l(l-1)(l+1)
			//b
			current_segment.apla.b_minuend = 2.0 * current_segment.rectangle_width - 1;//2l-1
			current_segment.apla.b_divisor = (current_segment.rectangle_width + 1) * current_segment.rectangle_width;//l(l+1)
			/*----------------------------------------------------------------------------------------------------------------------------------------------*/

			/*...................................................................................*/
#ifdef _DEBUG
			assert_segment_minmax(original_time_series_vector, current_segment);
#endif
			/*...................................................................................*/
		}
		else if (if_similar_ab_two_segments(current_segment, accumulate_segment)) {
			// for gradient decrease series: like 1,1,1,4
			current_segment = accumulate_segment;
		}
		else if (next_two_points_segment.right_endpoint < original_time_series_vector.size() && current_segment.min_point.value == next_two_points_segment.min_point.value && current_segment.max_point.value == next_two_points_segment.max_point.value) {
			// for fix Amplitude: like 1,2,2,2,1,2,2,2,1,2,2. Try MBR, minmax valule is fixed
			/*
			   Update current segment right endpoint, width, a&b
			*/
			const Y temp_left_segment = current_segment;

			current_segment.right_endpoint = next_two_points_segment.right_endpoint;
			current_segment.rectangle_width += 2;
			getAAndBByPLAShortSegSpeed(temp_left_segment, next_two_points_segment, current_segment);

			/*...................................................................................*/
#ifdef _DEBUG
			assert_segment_a_b(original_time_series_vector, current_segment);
#endif
			/*...................................................................................*/
		}
		else {

			/*...................................................................................*/
#ifdef _DEBUG
			assert(current_segment.rectangle_width > 1 && current_segment.right_endpoint + 1 == accumulate_segment.right_endpoint);
			assert_segment_minmax(original_time_series_vector, current_segment);
#endif
			/*...................................................................................*/

			/*:::::::::::::::::::::::::::::::::: whether to merge short segments :::::::::::::::::::::::::::::::::::::::::::*/
			get_triangle_density_by_accumulate_segment(current_segment, accumulate_segment);
			/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

			doubly_linked_list.emplace_back(current_segment);
			current_segment = next_two_points_segment;
		}
		/*====================================================================================================================================*/

		/*====================================================================================================================================*/
		//next_two_points_segment.right_endpoint += 2;
		next_two_points_segment.right_endpoint = current_segment.right_endpoint + 2;

		accumulate_segment.right_endpoint = current_segment.right_endpoint + 1;
		accumulate_segment.rectangle_width = current_segment.rectangle_width + 1;
		/*====================================================================================================================================*/

		/*++++++++++   whether needs to merge segments   ++++++++*/
		/*
		  This is low probablity thing, categorize.
		*/
		/*if (doubly_linked_list.size() > 1 && if_equal_ab(doubly_linked_list[doubly_linked_list.size() - 2], doubly_linked_list.back())) {

#ifdef _DEBUG
			assert(doubly_linked_list[doubly_linked_list.size() - 2].rectangle_width == doubly_linked_list.back().rectangle_width);
#endif
			Y temp_right_segment = doubly_linked_list.back();
			doubly_linked_list.back().rectangle_width += doubly_linked_list[doubly_linked_list.size() - 2].rectangle_width;
			getAAndBByPLAShortSegSpeed(doubly_linked_list[doubly_linked_list.size() - 2], temp_right_segment, doubly_linked_list.back());
#ifdef _DEBUG
			assert_segment_a_b(original_time_series_vector, doubly_linked_list.back());
#endif
			doubly_linked_list.removeNode(*doubly_linked_list.get_tail_node()->previous_node());
		}*/
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	}
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
}


//************************************
// Method:insert_last_segment_compute_merge_split_coefficients
// Qualifier: add segment in linkedlist, compute merged segment infor, split area difference.
// date:200819 14:14
// author:
//************************************
TEMPLATE
template <typename T, typename Y, typename U, typename U1>
void APLA::insert_last_segment_compute_merge_split_coefficients(const vector<T>& const original_time_series_vector, Y& const current_segment, multimap<U, DoublyListNode<Y>&, greater<U>>& const merge_segment_density_map, multimap<U, DoublyListNode<Y>&, std::greater<U>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument) {

	/*...................................................................................*/
#ifdef _DEBUG
	/*cout << "Before insert MAP: \n";
	TOOL::print_multimap_second(merge_segment_density_map);*/
	assert_bound(original_time_series_vector, doubly_linked_list);
#endif
	/*...................................................................................*/

	/********************************* 200817 get merged triangle area ******************************************/
	current_segment.right_subsegment = new Y;
	/************************************************************************************************************/

	/*********************************      add linked list   ***************************************************/
	doubly_linked_list.emplace_back(current_segment);
	/************************************************************************************************************/

	/********************************* 200817 get merged triangle area ******************************************/
	//auto& const node_segment_current = doubly_linked_list.getNode(segment_id);
	auto& const node_segment_current = *doubly_linked_list.get_tail_node();
	getMergedSubSegmentInformation(original_time_series_vector, node_segment_current, output_argument);//20817
	/************************************************************************************************************/
	/*****************************     200818  MAP insertion: Density     ***************************************/
	if (doubly_linked_list.size() > 1) {
		merge_segment_density_map.emplace(doubly_linked_list.back().right_subsegment->segment_density, node_segment_current);
	}
	/************************************************************************************************************/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!    200818 Get Area difference   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	//const auto& const area_difference = getAreaDifference(original_time_series, doubly_linked_list[segment_id]);
	//const long double& const area_difference = getAreaDifference(original_time_series_vector, doubly_linked_list.back()); 210203
	if (doubly_linked_list.back().area_difference > 0 && doubly_linked_list.back().rectangle_width > 3) {
		split_area_difference_map.emplace(doubly_linked_list.back().area_difference, node_segment_current);
	}
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	//evaluate_segment_upper_lower_bound(input_argument, original_time_series_vector, current_segment);

	/*...................................................................................*/
#ifdef _DEBUG
	assert_segment_bound(original_time_series_vector, doubly_linked_list.back());
	assert_bound(original_time_series_vector, doubly_linked_list);
	/*cout << "After insert MAP: \n";
	TOOL::print_multimap_second(merge_segment_density_map);
	cout << "List end segment coefficients: \n";
	print_segment_coefficients(doubly_linked_list.back());*/
	//cout << "List end long segment coefficients: \n";
	//print_segment_coefficients(doubly_linked_list.back().right_subsegment);
#endif
	/*...................................................................................*/
}

//************************************
// Method:get_right_endpoint_by_accumulation_area
// Qualifier: get split point in one segment by biggest accumulation area
// date:200803 10:26
// author:
//************************************
TEMPLATE
template <typename T, typename T1, typename Y, typename U, typename U1>
void APLA::get_right_endpoint_by_accumulation_area(U& const input_argument, const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument) {

	/*##############################################################################################################################################################################*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   Create elements  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	Y current_segment, accumulate_segment;

	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	current_segment.right_endpoint = 1;

	current_segment.rectangle_width = accumulate_segment.right_endpoint = 2;
	//getAandBSlopInterceptTwoPoint(original_time_series_vector.front(), original_time_series_vector[1], current_segment);
	//get_segment_two_point_minmax(original_time_series_vector.front(), original_time_series_vector[1], current_segment);
	//get_segment_two_points_ab_minmax(original_time_series_vector.front(), original_time_series_vector[1], current_segment);//210203
	getAandBSlopInterceptTwoPoint(original_time_series_vector.front(), original_time_series_vector[1], current_segment);
	accumulate_segment.rectangle_width = accumulate_segment.right_endpoint + 1;
	/*------------   210113 upper bound   -----------------*/
	//current_segment.segment_right_height_difference = 0;
	current_segment.area_difference = current_segment.bound.upper_bound_diff = current_segment.bound.upper_bound_area = 0;
	/*-----------------------------------------------------*/
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
	//COMPARE_GREATER_SEGMENT_DENSITY compare_greater_density;
	//priority_queue<APCA_NODE_PAIR, vector<APCA_NODE_PAIR>, COMPARE_GREATER_SEGMENT_DENSITY > priority_queue_smallest_increment_density;
	//priority_queue<long double, vector<long double>, std::greater<long double>> priority_queue_smallest_increment_density;
	priority_queue<long double> priority_queue_smallest_increment_density;
	//long double smallest_increment_density = INF;//210225
	/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  get initial threshold increment area  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	//Y left_part_smallest_accumulation_density;
	// get accumulate segment a&b minmax
	//get_ab_minmax_segment_by_accumulation(original_time_series_vector[accumulate_segment.right_endpoint], current_segment, accumulate_segment);
	//left_part_smallest_accumulation_density.segment_density = get_triangle_density_by_accumulate_segment(current_segment, accumulate_segment);
	//smallest_increment_density = 1.0 / fabs(original_time_series_vector[1] - original_time_series_vector.front());
	//cout << "Initial increment threshold: "<< initial_increment_threshold << endl;
	priority_queue_smallest_increment_density.emplace(1.0 / fabs(original_time_series_vector[1] - original_time_series_vector.front()));

	/*doubly_linked_list.emplace_back(current_segment);
	accumulate_segment.right_endpoint = current_segment.right_endpoint + 1;
	accumulate_segment.rectangle_width = current_segment.rectangle_width + 1;*/
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*##############################################################################################################################################################################*/

	/*##############################################################################################################################################################################*/
	//for (int id_array = 2; id_array < original_time_series_vector.size(); id_array++) {
	while (current_segment.right_endpoint < original_time_series_vector.size()) {

		/*..........................................................................................................................................................*/
#ifdef _DEBUG
		assert(current_segment.right_endpoint + 1 == accumulate_segment.right_endpoint && current_segment.rectangle_width + 1 == accumulate_segment.rectangle_width);
#endif
		/*..........................................................................................................................................................*/

		/*::::::::::::::::::::::::::::::::::::::::::           If get end of time series           :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
		if (current_segment.right_endpoint == original_time_series_vector.size() - 1) {

			insert_last_segment_compute_merge_split_coefficients(original_time_series_vector, current_segment, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);

			/*===========================200129 Approximaiton Process=================*/
			if (doubly_linked_list.size() > input_argument.point_dimension) {
				//optimization_coefficients.right_endpoint_last_merged_segment = merge_segment_density_map.begin()->second._value.right_endpoint;
				mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
			}
			/*========================================================================*/

			break;
		}
		/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

		/*=============================================================== compute a&b, minax of segment ===============================================================================*/
		/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
		/*-------------------------------------------------------------------------------------------------------------*/
		/*get_ab_segment_by_accumulation(original_time_series_vector, current_segment, accumulate_segment);
		get_minmax_segment_by_accumulation(original_time_series_vector[accumulate_segment.right_endpoint], current_segment, accumulate_segment);*/
		get_ab_minmax_segment_by_accumulation(original_time_series_vector[accumulate_segment.right_endpoint], current_segment, accumulate_segment);
		//next_two_points_segment.right_endpoint = accumulate_segment.right_endpoint + 1;
		/*-------------------------------------------------------------------------------------------------------------*/
		/*------------ 210113 compute upper bound -------------*/
		get_line_segment_height_diference_from_accumulate(original_time_series_vector, current_segment, accumulate_segment, output_argument);
		/*-----------------------------------------------------*/

		/*..................................................*/
#ifdef _DEBUG
		/*cout << "current segment coefficients: \n";
		print_segment_coefficients(current_segment);
		cout << "Increment segment coefficients: \n";
		print_segment_coefficients(accumulate_segment);*/
		assert_segment_bound(original_time_series_vector, current_segment);
		assert_segment_bound(original_time_series_vector, accumulate_segment);
#endif
		/*..................................................*/

		/*--------------------------------------------------------------------------------------------------------------*/
		//get_ab_minmax_segment_by_accumulation(original_time_series_vector[segment_whole.right_endpoint + 1], segment_whole);
		//get_ab_minmax_segment_by_accumulation(original_time_series_vector[segment_accumulation_split_half.right_endpoint], segment_split_half, segment_accumulation_split_half);
		/*-------------------------------------------------------------------------------------------------------------*/
		/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

		/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
//		if (next_two_points_segment.right_endpoint < original_time_series_vector.size()) {
//			/*-----------------------------------------------------------------------*/
//			/*getAandBSlopInterceptTwoPoint(original_time_series_vector[next_two_points_segment.right_endpoint - 1], original_time_series_vector[next_two_points_segment.right_endpoint], next_two_points_segment);
//			get_segment_two_point_minmax(original_time_series_vector[next_two_points_segment.right_endpoint - 1], original_time_series_vector[next_two_points_segment.right_endpoint], next_two_points_segment);*/
//			get_segment_two_points_ab_minmax(original_time_series_vector[next_two_points_segment.right_endpoint - 1], original_time_series_vector[next_two_points_segment.right_endpoint], next_two_points_segment);
//			/*-----------------------------------------------------------------------*/
//		}
//		else {
//
//			/*...................................................................................*/
//#ifdef _DEBUG
//			assert(accumulate_segment.right_endpoint + 1 == original_time_series_vector.size());
//#endif
//			/*...................................................................................*/
//
//			current_segment = accumulate_segment;
//			break;
//		}
		/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
		/*=====================================================================================================================================================================*/

		/*====================================================================================================================================*/
//		if (fabs(current_segment.apla.a - next_two_points_segment.apla.a) < EPS && fabs(current_segment.apla.a * current_segment.rectangle_width + current_segment.apla.b - next_two_points_segment.apla.b) < EPS) {
//			//if (current_segment.apla.a == accumulate_segment.apla.a && current_segment.apla.b == accumulate_segment.apla.b) {
//				// for gradient decrease series: like 1,2,3,4
//
//				/*
//				   Update current segment right endpoint, width, minmax point. Keep a&b
//				*/
//			current_segment.right_endpoint = next_two_points_segment.right_endpoint;
//			current_segment.rectangle_width += 2;
//			current_segment.apla.a > 0 ? current_segment.max_point = next_two_points_segment.max_point : current_segment.min_point = next_two_points_segment.min_point;
//
//			/*------------------------------------------------------    a & b coefficient    ---------------------------------------------------------------*/
//			//coefficient of equation
//			//a
//			current_segment.apla.a_minuend = (current_segment.rectangle_width - 1) / 2.0;//(l-1)/2
//			current_segment.apla.a_divisor = (current_segment.rectangle_width - 1) * (current_segment.rectangle_width + 1) * current_segment.rectangle_width;//l(l-1)(l+1)
//			//b
//			current_segment.apla.b_minuend = 2.0 * current_segment.rectangle_width - 1;//2l-1
//			current_segment.apla.b_divisor = (current_segment.rectangle_width + 1) * current_segment.rectangle_width;//l(l+1)
//			/*----------------------------------------------------------------------------------------------------------------------------------------------*/
//
//			/*...................................................................................*/
//#ifdef _DEBUG
//			assert_segment_minmax(original_time_series_vector, current_segment);
//#endif
//			/*...................................................................................*/
//		}


		if (if_similar_ab_two_segments(current_segment, accumulate_segment)) {
			/*..................................................*/
#ifdef _DEBUG
			assert_segment_bound(original_time_series_vector, current_segment);
			assert_segment_bound(original_time_series_vector, accumulate_segment);
#endif
			/*..................................................*/
			//if (if_similar_ab_two_segments(current_segment, accumulate_segment) || accumulate_segment.right_endpoint == original_time_series_vector.size() - 1) {
				// for gradient decrease series: like 1,1,1,4
			current_segment = accumulate_segment;

			/*------------   210113 upper bound   -----------------*/
			//current_segment.segment_right_height_difference = 0;
			/*-----------------------------------------------------*/
		}
		else {

			/*.....................................................................................................................*/
#ifdef _DEBUG
			assert(current_segment.rectangle_width > 1 && current_segment.right_endpoint + 1 == accumulate_segment.right_endpoint);
			//assert_segment_minmax(original_time_series_vector, current_segment);
			assert_segment_bound(original_time_series_vector, current_segment);
			assert_segment_bound(original_time_series_vector, accumulate_segment);
#endif
			/*.....................................................................................................................*/

			//cout << "current right endpoint: " << current_segment.right_endpoint << ", segment width: " << current_segment.rectangle_width << ", current threshold density : "<< left_part_smallest_accumulation_density.segment_density << endl;
			//cout << "current queue.top(): " << priority_queue_smallest_increment_density.top() << endl;

			/*:::::::::::::::::::::::::::::::::: whether to merge short segments :::::::::::::::::::::::::::::::::::::::::::*/
			get_triangle_density_by_accumulate_segment(current_segment, accumulate_segment);
			/*------------ 210113 compute upper bound -------------*/
			//get_line_segment_height_diference_from_accumulate(original_time_series_vector, current_segment, accumulate_segment);
			/*-----------------------------------------------------*/
			/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

			/*....................................................................................................................................................*/
#ifdef _DEBUG
			/*cout << "Compute Increment Area: \n";
			print_segment_coefficients(current_segment);*/
#endif
			/*....................................................................................................................................................*/

			/*:::::::::::::::::::::::::::::::::: whether to merge short segments :::::::::::::::::::::::::::::::::::::::::::*/
			if (priority_queue_smallest_increment_density.size() < input_argument.point_dimension - 1) {

				/*.......................................................................................................................................*/
#ifdef _DEBUG
				//assert(current_segment.segment_right_height_difference != -INF);
				assert(current_segment.bound.upper_bound_diff != -INF && current_segment.bound.upper_bound_area != -INF);
				//cout << "When Queue size: " << priority_queue_smallest_increment_density.size() << " < " << input_argument.point_dimension - 1 << endl;
				assert_segment_bound(original_time_series_vector, current_segment);
				assert_segment_bound(original_time_series_vector, accumulate_segment);
#endif
				/*.......................................................................................................................................*/

				/**********************                when accumulate segment right_endpiont is the last point in time series         **********************************/
				if (accumulate_segment.right_endpoint == original_time_series_vector.size() - 1) {
					current_segment = accumulate_segment;
					insert_last_segment_compute_merge_split_coefficients(original_time_series_vector, current_segment, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
					break;
				}
				/**********************************************************************************************************************************************************/

				/*....................................................................................................................................................*/
#ifdef _DEBUG
				//cout << "Begin to insert increment area: " << 1.0 / current_segment.segment_density << endl;
#endif
				/*....................................................................................................................................................*/

				/********************************* priority queue ****************************************************/
				priority_queue_smallest_increment_density.emplace(current_segment.segment_density);
				/*****************************************************************************************************/

				/*....................................................................................................................................................*/
#ifdef _DEBUG
				//cout << "When Queue size: " << priority_queue_smallest_increment_density.size() << endl;
#endif
				/*....................................................................................................................................................*/

				insert_last_segment_compute_merge_split_coefficients(original_time_series_vector, current_segment, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);

				///********************************* 200817 get merged triangle area ******************************************/
				//current_segment.right_subsegment = new Y;
				///************************************************************************************************************/

				///*********************************        add linked list   *************************************************/
				//doubly_linked_list.emplace_back(current_segment);
				///************************************************************************************************************/

				///********************************* 200817 get merged triangle area ******************************************/
				////auto& const node_segment_current = doubly_linked_list.getNode(segment_id);
				//auto& const node_segment_current = *doubly_linked_list.get_tail_node();
				//getMergedSubSegmentInformation(original_time_series_vector, node_segment_current);//20817
				///************************************************************************************************************/

				///*****************************     200818  MAP insertion: Density     ***************************************/
				//if(doubly_linked_list.size() > 1){
				//	merge_segment_density_map.emplace(doubly_linked_list.back().right_subsegment->segment_density, node_segment_current);
				//}
				///************************************************************************************************************/

				///*!!!!!!!!!!!!!!!!!!!!!!!!!!!!    200818 Get Area difference   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
				////const auto& const area_difference = getAreaDifference(original_time_series, doubly_linked_list[segment_id]);
				//const long double& const area_difference = getAreaDifference(original_time_series_vector, doubly_linked_list.back());

				//if (area_difference > 0){
				//	split_area_difference_map.emplace(area_difference, node_segment_current);
				//}
				///*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

				/********************************************** new twe points segment *********************************************************************/
				current_segment.right_endpoint += 2;
				current_segment.rectangle_width = 2;
				//current_segment.segment_right_height_difference = 0;
				current_segment.area_difference = current_segment.bound.upper_bound_diff = current_segment.bound.upper_bound_area = 0;
				//get_segment_two_points_ab_minmax(original_time_series_vector[current_segment.right_endpoint - 1], original_time_series_vector[current_segment.right_endpoint], current_segment);
				getAandBSlopInterceptTwoPoint(original_time_series_vector[current_segment.right_endpoint - 1], original_time_series_vector[current_segment.right_endpoint], current_segment);
				/*******************************************************************************************************************************************/

			}
			//if (accumulate_segment.right_endpoint < original_time_series_vector.size() - 1 && get_triangle_density_by_accumulate_segment(current_segment, accumulate_segment) < left_part_smallest_accumulation_density.segment_density) {
			else if (current_segment.segment_density < priority_queue_smallest_increment_density.top()) {// increment density smaller than threshold, means area > threshold,has split point

				/*.......................................................................................................*/
#ifdef _DEBUG
				//cout << "When current increment are :" << 1 / current_segment.segment_density << " > queue.top: " << 1 / priority_queue_smallest_increment_density.top() <<". Update"<< endl;
				//assert(current_segment.segment_right_height_difference != -INF);
				assert(current_segment.bound.upper_bound_diff != -INF && current_segment.bound.upper_bound_area != -INF);
				//assert(priority_queue_smallest_increment_density.size() == input_argument.point_dimension - 1);
				assert_segment_bound(original_time_series_vector, current_segment);
				assert_segment_bound(original_time_series_vector, accumulate_segment);
#endif
				/*.......................................................................................................*/

				//left_part_smallest_accumulation_density = current_segment;

				/**********************                when accumulate segment right_endpiont is the last point in time series         **********************************/
				if (accumulate_segment.right_endpoint == original_time_series_vector.size() - 1) {
					/*..................................................................................................................*/
#ifdef _DEBUG
					assert_segment_bound(original_time_series_vector, current_segment);
					assert_segment_bound(original_time_series_vector, accumulate_segment);
#endif
					/*..................................................................................................................*/
					current_segment = accumulate_segment;
					insert_last_segment_compute_merge_split_coefficients(original_time_series_vector, current_segment, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);

					/*-----------------------------------------     Merge Operation     ----------------------------------------------------------*/
					if (doubly_linked_list.size() > input_argument.point_dimension) {
						//optimization_coefficients.right_endpoint_last_merged_segment = merge_segment_density_map.begin()->second._value.right_endpoint;
						mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
					}
					/*----------------------------------------------------------------------------------------------------------------------------*/

					break;
				}
				/**********************************************************************************************************************************************************/

				/*********************************      Priority Queue    ***************************************************/
				/*...........................................................................*/
#ifdef _DEBUG
				//cout << "Before Update queue: Use current increment : " << 1 / current_segment.segment_density << ", erase queue.top: " << 1 / priority_queue_smallest_increment_density.top() << endl;
#endif
				/*...........................................................................*/

				priority_queue_smallest_increment_density.pop();
				priority_queue_smallest_increment_density.emplace(current_segment.segment_density);

				/*...........................................................................*/
#ifdef _DEBUG
				//cout <<"After Update queue: queue.top: " << 1 / priority_queue_smallest_increment_density.top() << endl;
#endif
				/*...........................................................................*/

				/************************************************************************************************************/

				/********* get merged triangle area, add linked list, MAP insertion: Density, Get Area difference ***********/
				insert_last_segment_compute_merge_split_coefficients(original_time_series_vector, current_segment, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
				/************************************************************************************************************/

				///********************************* 200817 get merged triangle area ******************************************/
				//current_segment.right_subsegment = new Y;
				///************************************************************************************************************/

				///*********************************      add linked list   ***************************************************/
				//doubly_linked_list.emplace_back(current_segment);
				///************************************************************************************************************/

				///********************************* 200817 get merged triangle area ******************************************/
				////auto& const node_segment_current = doubly_linked_list.getNode(segment_id);
				//auto& const node_segment_current = *doubly_linked_list.get_tail_node();
				//getMergedSubSegmentInformation(original_time_series_vector, node_segment_current);//20817
				///************************************************************************************************************/

				///*****************************     200818  MAP insertion: Density     ***************************************/
				//if (doubly_linked_list.size() > 1) {
				//	merge_segment_density_map.emplace(doubly_linked_list.back().right_subsegment->segment_density, node_segment_current);
				//}
				///************************************************************************************************************/

				///*!!!!!!!!!!!!!!!!!!!!!!!!!!!!    200818 Get Area difference   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
				////const auto& const area_difference = getAreaDifference(original_time_series, doubly_linked_list[segment_id]);
				//const long double& const area_difference = getAreaDifference(original_time_series_vector, doubly_linked_list.back());
				//if (area_difference > 0){
				//	split_area_difference_map.emplace(area_difference, node_segment_current);
				//}
				///*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

				/*===========================    210301 Merge Operation     =================*/
				if (doubly_linked_list.size() > input_argument.point_dimension) {

					//optimization_coefficients.right_endpoint_last_merged_segment = merge_segment_density_map.begin()->second._value.right_endpoint;
					mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);

				}
				/*================================================================================*/

				/********************************************** new twe points segment **************************************/
				current_segment.right_endpoint += 2;
				current_segment.rectangle_width = 2;
				//current_segment.segment_right_height_difference = 0;
				current_segment.area_difference = current_segment.bound.upper_bound_diff = current_segment.bound.upper_bound_area = 0;
				//get_segment_two_points_ab_minmax(original_time_series_vector[current_segment.right_endpoint - 1], original_time_series_vector[current_segment.right_endpoint], current_segment); 210203
				getAandBSlopInterceptTwoPoint(original_time_series_vector[current_segment.right_endpoint - 1], original_time_series_vector[current_segment.right_endpoint], current_segment);
				/************************************************************************************************************/
				/*..................................................................................................................*/
#ifdef _DEBUG
				assert_segment_bound(original_time_series_vector, current_segment);
				assert_segment_bound(original_time_series_vector, accumulate_segment);
#endif
				/*..................................................................................................................*/
			}
			else {
				/*..................................................................................................................*/
#ifdef _DEBUG
				assert_segment_bound(original_time_series_vector, current_segment);
				assert_segment_bound(original_time_series_vector, accumulate_segment);
#endif
				/*..................................................................................................................*/
				current_segment = accumulate_segment;
			}
			/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
			//current_segment = next_two_points_segment;
		}
		/*====================================================================================================================================*/

		/*====================================================================================================================================*/
		//next_two_points_segment.right_endpoint += 2;
		//next_two_points_segment.right_endpoint = current_segment.right_endpoint + 2;

		accumulate_segment.right_endpoint = current_segment.right_endpoint + 1;
		accumulate_segment.rectangle_width = current_segment.rectangle_width + 1;
		/*====================================================================================================================================*/
	}
	/*##############################################################################################################################################################################*/

	/*..................................................................................................................*/
#ifdef _DEBUG
	assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
#endif
	/*..................................................................................................................*/

	/*############################################################                one line time series         #####################################################################*/

	if (doubly_linked_list.size() == 1) {
		assert(0);
		//return;
		/*..................................................................................................................*/
#ifdef _DEBUG
		assert(split_area_difference_map.size() == 0 && merge_segment_density_map.empty());
#endif
		/*..................................................................................................................*/

		y_projection_merge_line(input_argument, original_time_series_vector, doubly_linked_list);

		return;
	}

	/*##############################################################################################################################################################################*/

	/*##############################################################################################################################################################################*/

	bool temp_is_burst = false;

	while (doubly_linked_list.size() < input_argument.point_dimension) {

		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!     191124 for burst time series   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		if (split_area_difference_map.size() == 0) {
			assert(0);
			temp_is_burst = true;

			/*............................................*/
#ifdef _DEBUG
			assert(input_argument.point_dimension != INF);
#endif
			/*............................................*/

			/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			split_burst_segment(original_time_series_vector, input_argument.point_dimension, doubly_linked_list);
			/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			break;

		}
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		splitSegmentBySlope(original_time_series_vector, input_argument.option_split_method, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	}

	/*##############################################################################################################################################################################*/

	/*..................................................................................................................*/
#ifdef _DEBUG
	if (temp_is_burst == false)
		assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
#endif
	/*..................................................................................................................*/

	/*##############################################################################################################################################################################*/
	///********************************* 200817 get merged triangle area ******************************************/
	//current_segment.right_subsegment = new Y;
	///************************************************************************************************************/

	///**************************************** add linked list ***************************************************/
	//doubly_linked_list.emplace_back(current_segment);
	///************************************************************************************************************/

	///********************************* 200817 get merged triangle area ******************************************/
	////auto& const node_segment_current = doubly_linked_list.getNode(segment_id);
	//auto& const node_segment_current = *doubly_linked_list.get_tail_node();
	//getMergedSubSegmentInformation(original_time_series_vector, node_segment_current);//20817
	///************************************************************************************************************/

	///*****************************     200818  MAP insertion: Density     ***************************************/
	//if (doubly_linked_list.size() > 1) {
	//	merge_segment_density_map.emplace(doubly_linked_list.back().right_subsegment->segment_density, node_segment_current);
	//}
	///************************************************************************************************************/

	///*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!    200818 Get Area difference   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	//			//const auto& const area_difference = getAreaDifference(original_time_series, doubly_linked_list[segment_id]);
	//const long double& const area_difference = getAreaDifference(original_time_series_vector, doubly_linked_list.back());
	//if (area_difference > 0)
	//	split_area_difference_map.emplace(area_difference, node_segment_current);
	///*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	/*##############################################################################################################################################################################*/

	/*............................................................................................................................................*/
#ifdef _DEBUG
	assert_merge_map_triangle_density(merge_segment_density_map);
	assert(doubly_linked_list.back().right_endpoint == original_time_series_vector.size() - 1);
	//assert_minmax_value(original_time_series_vector, doubly_linked_list);
	assert_bound(original_time_series_vector, doubly_linked_list);
	/*##################################################           Print Result        ###############################################################################################*/
	//cout << "!! Split point:  right end point: " << left_part_smallest_accumulation_density.right_endpoint << ", Density : "<< left_part_smallest_accumulation_density.segment_density << endl;
	//TOOL::print_each_segment_coefficient_with_order(doubly_linked_list);
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/*cout << "Priority queue of increment density: \n";
	while (!priority_queue_smallest_increment_density.empty()) {
		std::cout << 1 / priority_queue_smallest_increment_density.top() << ", ";
		priority_queue_smallest_increment_density.pop();
	}
	cout << '\n';*/
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*+++++++++++++++++++++++++++  200818 Print right subsegment  ++++++++++++++++++++++++++++++++++++++++++++++*/
	/*if (temp_is_burst == false) {
		cout << "Print right endpoint & width: \n";
		for (auto au : doubly_linked_list) {
			cout << "Right endpoint: " << au.right_subsegment->right_endpoint << " Width: " << au.right_subsegment->rectangle_width << " a&b: " << au.right_subsegment->apla.a << "," << au.right_subsegment->apla.b << " Density: " << au.right_subsegment->segment_density << "; ";
		}
		cout << endl;
	}*/
	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


	/*****************************     200818  MAP insertion: Density     ***************************************/
	/*cout << "Print MAP: \n";
	for (auto&& au : merge_segment_density_map) {
		cout << 1 / au.first << ", ";
	}
	cout << endl;*/
	/************************************************************************************************************/
#endif
	/*..........................................................................................................................................*/
	/*##############################################################################################################################################################################*/
}

//210301 No split & merge operation
//************************************
// Method:get_right_endpoint_by_accumulation_area_no_split_merge
// Qualifier: get split point in one segment by biggest accumulation area
// date:210301 11:19
// author:
//************************************
TEMPLATE
template <typename T, typename T1, typename Y, typename U, typename U1>
void APLA::get_right_endpoint_by_accumulation_area_no_split_merge(U& const input_argument, const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument) {
	/*##############################################################################################################################################################################*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   Create elements  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	Y current_segment, accumulate_segment;
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	current_segment.right_endpoint = 1;
	current_segment.rectangle_width = accumulate_segment.right_endpoint = 2;
	//getAandBSlopInterceptTwoPoint(original_time_series_vector.front(), original_time_series_vector[1], current_segment);
	//get_segment_two_point_minmax(original_time_series_vector.front(), original_time_series_vector[1], current_segment);
	//get_segment_two_points_ab_minmax(original_time_series_vector.front(), original_time_series_vector[1], current_segment);//210203
	getAandBSlopInterceptTwoPoint(original_time_series_vector.front(), original_time_series_vector[1], current_segment);
	accumulate_segment.rectangle_width = accumulate_segment.right_endpoint + 1;
	/*------------   210113 upper bound   -----------------*/
	//current_segment.segment_right_height_difference = 0;
	current_segment.area_difference = current_segment.bound.upper_bound_diff = current_segment.bound.upper_bound_area = 0;
	/*-----------------------------------------------------*/
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/*:--------------------------------------------------------------------*/
	//COMPARE_GREATER_SEGMENT_DENSITY compare_greater_density;
	//priority_queue<APCA_NODE_PAIR, vector<APCA_NODE_PAIR>, COMPARE_GREATER_SEGMENT_DENSITY > priority_queue_smallest_increment_density;
	//priority_queue<long double, vector<long double>, std::greater<long double>> priority_queue_smallest_increment_density;
	priority_queue<long double> priority_queue_smallest_increment_density;//are min to max
	//long double smallest_increment_density = INF;//210225
	/*--------------------------------------------------------------------*/
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  get initial threshold increment area  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	//Y left_part_smallest_accumulation_density;
	// get accumulate segment a&b minmax
	//get_ab_minmax_segment_by_accumulation(original_time_series_vector[accumulate_segment.right_endpoint], current_segment, accumulate_segment);
	//left_part_smallest_accumulation_density.segment_density = get_triangle_density_by_accumulate_segment(current_segment, accumulate_segment);
	//smallest_increment_density = 1.0 / fabs(original_time_series_vector[1] - original_time_series_vector.front());
	//cout << "Initial increment threshold: "<< initial_increment_threshold << endl;
	priority_queue_smallest_increment_density.emplace(1.0 / fabs(original_time_series_vector[1] - original_time_series_vector.front()));

	/*doubly_linked_list.emplace_back(current_segment);
	accumulate_segment.right_endpoint = current_segment.right_endpoint + 1;
	accumulate_segment.rectangle_width = current_segment.rectangle_width + 1;*/
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*##############################################################################################################################################################################*/

	/*##############################################################################################################################################################################*/
	//for (int id_array = 2; id_array < original_time_series_vector.size(); id_array++) {
	while (current_segment.right_endpoint < original_time_series_vector.size()) {

		/*..........................................................................................................................................................*/
#ifdef _DEBUG
		assert(current_segment.right_endpoint + 1 == accumulate_segment.right_endpoint && current_segment.rectangle_width + 1 == accumulate_segment.rectangle_width);
#endif
		/*..........................................................................................................................................................*/

		/*::::::::::::::::::::::::::::::::::::::::::           If get end of time series           :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
		if (current_segment.right_endpoint == original_time_series_vector.size() - 1) {

			insert_last_segment_compute_merge_split_coefficients(original_time_series_vector, current_segment, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);

			/*===========================   210301 Merge operation     =================*/
			//if (doubly_linked_list.size() > input_argument.point_dimension) {
			//	//optimization_coefficients.right_endpoint_last_merged_segment = merge_segment_density_map.begin()->second._value.right_endpoint;
				//mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
			//}
			/*========================================================================*/
			break;
		}
		/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

		/*==================================================== compute a&b, minax of segment ======================================================*/
		/*-------------------------------------------------------------------------------------------------------------*/
		/*get_ab_segment_by_accumulation(original_time_series_vector, current_segment, accumulate_segment);
		get_minmax_segment_by_accumulation(original_time_series_vector[accumulate_segment.right_endpoint], current_segment, accumulate_segment);*/
		get_ab_minmax_segment_by_accumulation(original_time_series_vector[accumulate_segment.right_endpoint], current_segment, accumulate_segment);
		//next_two_points_segment.right_endpoint = accumulate_segment.right_endpoint + 1;
		/*-------------------------------------------------------------------------------------------------------------*/
		/*------------ 210113 compute upper bound -------------*/
		get_line_segment_height_diference_from_accumulate(original_time_series_vector, current_segment, accumulate_segment, output_argument);
		/*-----------------------------------------------------*/

		/*..................................................*/
#ifdef _DEBUG
		/*cout << "current segment coefficients: \n";
		print_segment_coefficients(current_segment);
		cout << "Increment segment coefficients: \n";
		print_segment_coefficients(accumulate_segment);*/
		assert_segment_bound(original_time_series_vector, current_segment);
		assert_segment_bound(original_time_series_vector, accumulate_segment);
#endif
		/*..................................................*/
		/*=====================================================================================================================================*/

		if (if_similar_ab_two_segments(current_segment, accumulate_segment)) {
			/*..................................................*/
#ifdef _DEBUG
			assert_segment_bound(original_time_series_vector, current_segment);
			assert_segment_bound(original_time_series_vector, accumulate_segment);
#endif
			/*..................................................*/
			//if (if_similar_ab_two_segments(current_segment, accumulate_segment) || accumulate_segment.right_endpoint == original_time_series_vector.size() - 1) {
			// for gradient decrease series: like 1,1,1,4
			current_segment = accumulate_segment;

			/*------------   210113 upper bound   -----------------*/
			//current_segment.segment_right_height_difference = 0;
			/*-----------------------------------------------------*/
		}
		else {

			/*.....................................................................................................................*/
#ifdef _DEBUG
			assert(current_segment.rectangle_width > 1 && current_segment.right_endpoint + 1 == accumulate_segment.right_endpoint);
			//assert_segment_minmax(original_time_series_vector, current_segment);
			assert_segment_bound(original_time_series_vector, current_segment);
			assert_segment_bound(original_time_series_vector, accumulate_segment);
#endif
			/*.....................................................................................................................*/

			//cout << "current right endpoint: " << current_segment.right_endpoint << ", segment width: " << current_segment.rectangle_width << ", current threshold density : "<< left_part_smallest_accumulation_density.segment_density << endl;
			//cout << "current queue.top(): " << priority_queue_smallest_increment_density.top() << endl;

			/*:::::::::::::::::::::: whether to get new endpoint (increment area)  :::::::::::::::::::::::::::::::::::::::::*/
			get_triangle_density_by_accumulate_segment(current_segment, accumulate_segment);
			/*------------ 210113 compute upper bound -------------*/
			//get_line_segment_height_diference_from_accumulate(original_time_series_vector, current_segment, accumulate_segment);
			/*-----------------------------------------------------*/
			/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

			/*..............................................*/
#ifdef _DEBUG
			/*cout << "Compute Increment Area: \n";
			print_segment_coefficients(current_segment);*/
#endif
			/*..............................................*/

			/*:::::::::::::::::::::::::::::::::: whether to merge short segments :::::::::::::::::::::::::::::::::::::::::::*/
			if (priority_queue_smallest_increment_density.size() < input_argument.point_dimension - 1) {

				/*.......................................................................................................................................*/
#ifdef _DEBUG
				//assert(current_segment.segment_right_height_difference != -INF);
				assert(current_segment.bound.upper_bound_diff != -INF && current_segment.bound.upper_bound_area != -INF);
				//cout << "When Queue size: " << priority_queue_smallest_increment_density.size() << " < " << input_argument.point_dimension - 1 << endl;
				assert_segment_bound(original_time_series_vector, current_segment);
				assert_segment_bound(original_time_series_vector, accumulate_segment);
#endif
				/*.......................................................................................................................................*/

				/**********************                when accumulate segment right_endpiont is the last point in time series         **********************************/
				if (accumulate_segment.right_endpoint == original_time_series_vector.size() - 1) {
					current_segment = accumulate_segment;
					insert_last_segment_compute_merge_split_coefficients(original_time_series_vector, current_segment, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
					break;
				}
				/**********************************************************************************************************************************************************/

				/*....................................................................................................................................................*/
#ifdef _DEBUG
				//cout << "Begin to insert increment area: " << 1.0 / current_segment.segment_density << endl;
#endif
				/*....................................................................................................................................................*/

				/********************************* priority queue ****************************************************/
				priority_queue_smallest_increment_density.emplace(current_segment.segment_density);
				/*****************************************************************************************************/

				/*....................................................................................................................................................*/
#ifdef _DEBUG
				//cout << "When Queue size: " << priority_queue_smallest_increment_density.size() << endl;
#endif
				/*....................................................................................................................................................*/

				insert_last_segment_compute_merge_split_coefficients(original_time_series_vector, current_segment, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);

				///*!!!!!!!!!!!!!!!!!!!!!!!!!!!!    200818 Get Area difference   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
				////const auto& const area_difference = getAreaDifference(original_time_series, doubly_linked_list[segment_id]);
				//const long double& const area_difference = getAreaDifference(original_time_series_vector, doubly_linked_list.back());

				//if (area_difference > 0){
				//	split_area_difference_map.emplace(area_difference, node_segment_current);
				//}
				///*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

				/********************************************** new twe points segment *********************************************************************/
				current_segment.right_endpoint += 2;
				current_segment.rectangle_width = 2;
				//current_segment.segment_right_height_difference = 0;
				current_segment.area_difference = current_segment.bound.upper_bound_diff = current_segment.bound.upper_bound_area = 0;
				//get_segment_two_points_ab_minmax(original_time_series_vector[current_segment.right_endpoint - 1], original_time_series_vector[current_segment.right_endpoint], current_segment);
				getAandBSlopInterceptTwoPoint(original_time_series_vector[current_segment.right_endpoint - 1], original_time_series_vector[current_segment.right_endpoint], current_segment);
				/*******************************************************************************************************************************************/
			}
			//if (accumulate_segment.right_endpoint < original_time_series_vector.size() - 1 && get_triangle_density_by_accumulate_segment(current_segment, accumulate_segment) < left_part_smallest_accumulation_density.segment_density) {
			else if (current_segment.segment_density < priority_queue_smallest_increment_density.top()) {// increment density smaller than threshold, means area > threshold,has split point

				/*.......................................................................................................*/
#ifdef _DEBUG
				//cout << "When current increment are :" << 1 / current_segment.segment_density << " > queue.top: " << 1 / priority_queue_smallest_increment_density.top() <<". Update"<< endl;
				//assert(current_segment.segment_right_height_difference != -INF);
				assert(current_segment.bound.upper_bound_diff != -INF && current_segment.bound.upper_bound_area != -INF);
				//assert(priority_queue_smallest_increment_density.size() == input_argument.point_dimension - 1);
				assert_segment_bound(original_time_series_vector, current_segment);
				assert_segment_bound(original_time_series_vector, accumulate_segment);
#endif
				/*.......................................................................................................*/

				//left_part_smallest_accumulation_density = current_segment;

				/**********************                when accumulate segment right_endpiont is the last point in time series         **********************************/
				if (accumulate_segment.right_endpoint == original_time_series_vector.size() - 1) {
					/*..................................................................................................................*/
#ifdef _DEBUG
					assert_segment_bound(original_time_series_vector, current_segment);
					assert_segment_bound(original_time_series_vector, accumulate_segment);
#endif
					/*..................................................................................................................*/
					current_segment = accumulate_segment;
					insert_last_segment_compute_merge_split_coefficients(original_time_series_vector, current_segment, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);

					/*-----------------------------------------  210301   Merge Operation     ----------------------------------------------------------*/
					//if (doubly_linked_list.size() > input_argument.point_dimension) {
					//	//optimization_coefficients.right_endpoint_last_merged_segment = merge_segment_density_map.begin()->second._value.right_endpoint;
					//	mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
					//}
					/*----------------------------------------------------------------------------------------------------------------------------------*/

					break;
				}
				/**********************************************************************************************************************************************************/

				/*********************************      Priority Queue    ***************************************************/
				/*...........................................................................*/
#ifdef _DEBUG
				//cout << "Before Update queue: Use current increment : " << 1 / current_segment.segment_density << ", erase queue.top: " << 1 / priority_queue_smallest_increment_density.top() << endl;
#endif
				/*...........................................................................*/

				priority_queue_smallest_increment_density.pop();
				priority_queue_smallest_increment_density.emplace(current_segment.segment_density);

				/*...........................................................................*/
#ifdef _DEBUG
				//cout <<"After Update queue: queue.top: " << 1 / priority_queue_smallest_increment_density.top() << endl;
#endif
				/*...........................................................................*/

				/************************************************************************************************************/

				/********* get merged triangle area, add linked list, MAP insertion: Density, Get Area difference ***********/
				insert_last_segment_compute_merge_split_coefficients(original_time_series_vector, current_segment, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
				/************************************************************************************************************/

				///********************************* 200817 get merged triangle area ******************************************/
				//current_segment.right_subsegment = new Y;
				///************************************************************************************************************/

				///*********************************      add linked list   ***************************************************/
				//doubly_linked_list.emplace_back(current_segment);
				///************************************************************************************************************/

				///********************************* 200817 get merged triangle area ******************************************/
				////auto& const node_segment_current = doubly_linked_list.getNode(segment_id);
				//auto& const node_segment_current = *doubly_linked_list.get_tail_node();
				//getMergedSubSegmentInformation(original_time_series_vector, node_segment_current);//20817
				///************************************************************************************************************/

				///*****************************     200818  MAP insertion: Density     ***************************************/
				//if (doubly_linked_list.size() > 1) {
				//	merge_segment_density_map.emplace(doubly_linked_list.back().right_subsegment->segment_density, node_segment_current);
				//}
				///************************************************************************************************************/

				///*!!!!!!!!!!!!!!!!!!!!!!!!!!!!    200818 Get Area difference   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
				////const auto& const area_difference = getAreaDifference(original_time_series, doubly_linked_list[segment_id]);
				//const long double& const area_difference = getAreaDifference(original_time_series_vector, doubly_linked_list.back());
				//if (area_difference > 0){
				//	split_area_difference_map.emplace(area_difference, node_segment_current);
				//}
				///*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

				/*===========================    210301 Merge Operation     =================*/
				//if (doubly_linked_list.size() > input_argument.point_dimension) {

				//	//optimization_coefficients.right_endpoint_last_merged_segment = merge_segment_density_map.begin()->second._value.right_endpoint;
				//	mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);

				//}
				/*================================================================================*/

				/********************************************** new twe points segment **************************************/
				current_segment.right_endpoint += 2;
				current_segment.rectangle_width = 2;
				//current_segment.segment_right_height_difference = 0;
				current_segment.area_difference = current_segment.bound.upper_bound_diff = current_segment.bound.upper_bound_area = 0;
				//get_segment_two_points_ab_minmax(original_time_series_vector[current_segment.right_endpoint - 1], original_time_series_vector[current_segment.right_endpoint], current_segment); 210203
				getAandBSlopInterceptTwoPoint(original_time_series_vector[current_segment.right_endpoint - 1], original_time_series_vector[current_segment.right_endpoint], current_segment);
				/************************************************************************************************************/
				/*..................................................................................................................*/
#ifdef _DEBUG
				assert_segment_bound(original_time_series_vector, current_segment);
				assert_segment_bound(original_time_series_vector, accumulate_segment);
#endif
				/*..................................................................................................................*/
			}
			else {
				/*..................................................................................................................*/
#ifdef _DEBUG
				assert_segment_bound(original_time_series_vector, current_segment);
				assert_segment_bound(original_time_series_vector, accumulate_segment);
#endif
				/*..................................................................................................................*/
				current_segment = accumulate_segment;
			}
			/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
			//current_segment = next_two_points_segment;
		}
		/*====================================================================================================================================*/

		/*====================================================================================================================================*/
		//next_two_points_segment.right_endpoint += 2;
		//next_two_points_segment.right_endpoint = current_segment.right_endpoint + 2;

		accumulate_segment.right_endpoint = current_segment.right_endpoint + 1;
		accumulate_segment.rectangle_width = current_segment.rectangle_width + 1;
		/*====================================================================================================================================*/
	}
	/*##############################################################################################################################################################################*/

	/*..................................................................................................................*/
#ifdef _DEBUG
	assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
#endif
	/*..................................................................................................................*/

	

	/*##############################################################################################################################################################################*/
	///********************************* 200817 get merged triangle area ******************************************/
	//current_segment.right_subsegment = new Y;
	///************************************************************************************************************/

	///**************************************** add linked list ***************************************************/
	//doubly_linked_list.emplace_back(current_segment);
	///************************************************************************************************************/

	///********************************* 200817 get merged triangle area ******************************************/
	////auto& const node_segment_current = doubly_linked_list.getNode(segment_id);
	//auto& const node_segment_current = *doubly_linked_list.get_tail_node();
	//getMergedSubSegmentInformation(original_time_series_vector, node_segment_current);//20817
	///************************************************************************************************************/

	///*****************************     200818  MAP insertion: Density     ***************************************/
	//if (doubly_linked_list.size() > 1) {
	//	merge_segment_density_map.emplace(doubly_linked_list.back().right_subsegment->segment_density, node_segment_current);
	//}
	///************************************************************************************************************/

	///*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!    200818 Get Area difference   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	//			//const auto& const area_difference = getAreaDifference(original_time_series, doubly_linked_list[segment_id]);
	//const long double& const area_difference = getAreaDifference(original_time_series_vector, doubly_linked_list.back());
	//if (area_difference > 0)
	//	split_area_difference_map.emplace(area_difference, node_segment_current);
	///*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	/*##############################################################################################################################################################################*/

	/*............................................................................................................................................*/
#ifdef _DEBUG
	assert_merge_map_triangle_density(merge_segment_density_map);
	assert(doubly_linked_list.back().right_endpoint == original_time_series_vector.size() - 1);
	//assert_minmax_value(original_time_series_vector, doubly_linked_list);
	assert_bound(original_time_series_vector, doubly_linked_list);
	assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
	/*##################################################           Print Result        ###############################################################################################*/
	//cout << "!! Split point:  right end point: " << left_part_smallest_accumulation_density.right_endpoint << ", Density : "<< left_part_smallest_accumulation_density.segment_density << endl;
	//TOOL::print_each_segment_coefficient_with_order(doubly_linked_list);
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/*cout << "Priority queue of increment density: \n";
	while (!priority_queue_smallest_increment_density.empty()) {
		std::cout << 1 / priority_queue_smallest_increment_density.top() << ", ";
		priority_queue_smallest_increment_density.pop();
	}
	cout << '\n';*/
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*+++++++++++++++++++++++++++  200818 Print right subsegment  ++++++++++++++++++++++++++++++++++++++++++++++*/
	/*if (temp_is_burst == false) {
		cout << "Print right endpoint & width: \n";
		for (auto au : doubly_linked_list) {
			cout << "Right endpoint: " << au.right_subsegment->right_endpoint << " Width: " << au.right_subsegment->rectangle_width << " a&b: " << au.right_subsegment->apla.a << "," << au.right_subsegment->apla.b << " Density: " << au.right_subsegment->segment_density << "; ";
		}
		cout << endl;
	}*/
	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


	/*****************************     200818  MAP insertion: Density     ***************************************/
	/*cout << "Print MAP: \n";
	for (auto&& au : merge_segment_density_map) {
		cout << 1 / au.first << ", ";
	}
	cout << endl;*/
	/************************************************************************************************************/
#endif
	/*..........................................................................................................................................*/
	/*##############################################################################################################################################################################*/
}

//************************************
// Method:get_right_endpoint_by_accumulation_area_no_split_merge
// Qualifier: get split point in one segment by biggest accumulation area
// date:210301 11:19
// author:
//************************************
//210301 No split & merge operation, no threshold
TEMPLATE
template<typename T, typename T1, typename Y, typename U, typename U1>
void APLA::get_right_endpoint_by_accumulation_area_no_split_merge_threshold(U& const input_argument, const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument) {
	/*##############################################################################################################################################################################*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   Create elements  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	Y current_segment, accumulate_segment;

	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	current_segment.right_endpoint = 1;

	current_segment.rectangle_width = accumulate_segment.right_endpoint = 2;
	//getAandBSlopInterceptTwoPoint(original_time_series_vector.front(), original_time_series_vector[1], current_segment);
	//get_segment_two_point_minmax(original_time_series_vector.front(), original_time_series_vector[1], current_segment);
	//get_segment_two_points_ab_minmax(original_time_series_vector.front(), original_time_series_vector[1], current_segment);//210203
	getAandBSlopInterceptTwoPoint(original_time_series_vector.front(), original_time_series_vector[1], current_segment);
	accumulate_segment.rectangle_width = accumulate_segment.right_endpoint + 1;
	/*------------   210113 upper bound   -----------------*/
	//current_segment.segment_right_height_difference = 0;
	current_segment.area_difference = current_segment.bound.upper_bound_diff = current_segment.bound.upper_bound_area = 0;
	/*-----------------------------------------------------*/
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
	//COMPARE_GREATER_SEGMENT_DENSITY compare_greater_density;
	//priority_queue<APCA_NODE_PAIR, vector<APCA_NODE_PAIR>, COMPARE_GREATER_SEGMENT_DENSITY > priority_queue_smallest_increment_density;
	//priority_queue<long double, vector<long double>, std::greater<long double>> priority_queue_smallest_increment_density;
	//priority_queue<long double> priority_queue_smallest_increment_density;

	long double priority_queue_smallest_increment_density;
	//long double smallest_increment_density = INF;//210225
	/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  get initial threshold increment area  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	//Y left_part_smallest_accumulation_density;
	// get accumulate segment a&b minmax
	//get_ab_minmax_segment_by_accumulation(original_time_series_vector[accumulate_segment.right_endpoint], current_segment, accumulate_segment);
	//left_part_smallest_accumulation_density.segment_density = get_triangle_density_by_accumulate_segment(current_segment, accumulate_segment);
	//smallest_increment_density = 1.0 / fabs(original_time_series_vector[1] - original_time_series_vector.front());
	//cout << "Initial increment threshold: "<< initial_increment_threshold << endl;
	//priority_queue_smallest_increment_density.emplace(1.0 / fabs(original_time_series_vector[1] - original_time_series_vector.front()));
	priority_queue_smallest_increment_density = 1.0 / fabs(original_time_series_vector[1] - original_time_series_vector.front());
	/*doubly_linked_list.emplace_back(current_segment);
	accumulate_segment.right_endpoint = current_segment.right_endpoint + 1;
	accumulate_segment.rectangle_width = current_segment.rectangle_width + 1;*/
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*##############################################################################################################################################################################*/

	/*##############################################################################################################################################################################*/
	//for (int id_array = 2; id_array < original_time_series_vector.size(); id_array++) {
	while (current_segment.right_endpoint < original_time_series_vector.size()) {

		/*..........................................................................................................................................................*/
#ifdef _DEBUG
		assert(current_segment.right_endpoint + 1 == accumulate_segment.right_endpoint && current_segment.rectangle_width + 1 == accumulate_segment.rectangle_width);
#endif
		/*..........................................................................................................................................................*/

		/*::::::::::::::::::::::::::::::::::::::::::           If get end of time series           :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
		if (current_segment.right_endpoint == original_time_series_vector.size() - 1) {

			insert_last_segment_compute_merge_split_coefficients(original_time_series_vector, current_segment, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);

			/*===========================   210301 Merge operation     =================*/
			//if (doubly_linked_list.size() > input_argument.point_dimension) {
			//	//optimization_coefficients.right_endpoint_last_merged_segment = merge_segment_density_map.begin()->second._value.right_endpoint;
			//	mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
			//}
			/*========================================================================*/

			break;
		}
		/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

		/*=============================================================== compute a&b, minax of segment ===============================================================================*/
		/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
		/*-------------------------------------------------------------------------------------------------------------*/
		/*get_ab_segment_by_accumulation(original_time_series_vector, current_segment, accumulate_segment);
		get_minmax_segment_by_accumulation(original_time_series_vector[accumulate_segment.right_endpoint], current_segment, accumulate_segment);*/
		get_ab_minmax_segment_by_accumulation(original_time_series_vector[accumulate_segment.right_endpoint], current_segment, accumulate_segment);
		//next_two_points_segment.right_endpoint = accumulate_segment.right_endpoint + 1;
		/*-------------------------------------------------------------------------------------------------------------*/
		/*------------ 210113 compute upper bound -------------*/
		get_line_segment_height_diference_from_accumulate(original_time_series_vector, current_segment, accumulate_segment, output_argument);
		/*-----------------------------------------------------*/

		/*..................................................*/
#ifdef _DEBUG
		/*cout << "current segment coefficients: \n";
		print_segment_coefficients(current_segment);
		cout << "Increment segment coefficients: \n";
		print_segment_coefficients(accumulate_segment);*/
		assert_segment_bound(original_time_series_vector, current_segment);
		assert_segment_bound(original_time_series_vector, accumulate_segment);
#endif
		/*..................................................*/

		if (if_similar_ab_two_segments(current_segment, accumulate_segment)) {
			/*..................................................*/
#ifdef _DEBUG
			assert_segment_bound(original_time_series_vector, current_segment);
			assert_segment_bound(original_time_series_vector, accumulate_segment);
#endif
			/*..................................................*/
			//if (if_similar_ab_two_segments(current_segment, accumulate_segment) || accumulate_segment.right_endpoint == original_time_series_vector.size() - 1) {
				// for gradient decrease series: like 1,1,1,4
			current_segment = accumulate_segment;

			/*------------   210113 upper bound   -----------------*/
			//current_segment.segment_right_height_difference = 0;
			/*-----------------------------------------------------*/
		}
		else {

			/*.....................................................................................................................*/
#ifdef _DEBUG
			assert(current_segment.rectangle_width > 1 && current_segment.right_endpoint + 1 == accumulate_segment.right_endpoint);
			//assert_segment_minmax(original_time_series_vector, current_segment);
			assert_segment_bound(original_time_series_vector, current_segment);
			assert_segment_bound(original_time_series_vector, accumulate_segment);
#endif
			/*.....................................................................................................................*/

			//cout << "current right endpoint: " << current_segment.right_endpoint << ", segment width: " << current_segment.rectangle_width << ", current threshold density : "<< left_part_smallest_accumulation_density.segment_density << endl;
			//cout << "current queue.top(): " << priority_queue_smallest_increment_density.top() << endl;

			/*:::::::::::::::::::::::::::::::::: whether to merge short segments :::::::::::::::::::::::::::::::::::::::::::*/
			get_triangle_density_by_accumulate_segment(current_segment, accumulate_segment);
			/*------------ 210113 compute upper bound -------------*/
			//get_line_segment_height_diference_from_accumulate(original_time_series_vector, current_segment, accumulate_segment);
			/*-----------------------------------------------------*/
			/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

			if (current_segment.segment_density < priority_queue_smallest_increment_density) {// increment density smaller than threshold, means area > threshold,has split point

				/*.......................................................................................................*/
#ifdef _DEBUG
				//cout << "When current increment are :" << 1 / current_segment.segment_density << " > queue.top: " << 1 / priority_queue_smallest_increment_density.top() <<". Update"<< endl;
				//assert(current_segment.segment_right_height_difference != -INF);
				assert(current_segment.bound.upper_bound_diff != -INF && current_segment.bound.upper_bound_area != -INF);
				//assert(priority_queue_smallest_increment_density.size() == input_argument.point_dimension - 1);
				assert_segment_bound(original_time_series_vector, current_segment);
				assert_segment_bound(original_time_series_vector, accumulate_segment);
#endif
				/*.......................................................................................................*/

				//left_part_smallest_accumulation_density = current_segment;

				/**********************                when accumulate segment right_endpiont is the last point in time series         **********************************/
				if (accumulate_segment.right_endpoint == original_time_series_vector.size() - 1) {
					/*..................................................................................................................*/
#ifdef _DEBUG
					assert_segment_bound(original_time_series_vector, current_segment);
					assert_segment_bound(original_time_series_vector, accumulate_segment);
#endif
					/*..................................................................................................................*/
					current_segment = accumulate_segment;
					insert_last_segment_compute_merge_split_coefficients(original_time_series_vector, current_segment, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);

					/*-----------------------------------------  210301   Merge Operation     ----------------------------------------------------------*/
					//if (doubly_linked_list.size() > input_argument.point_dimension) {
					//	//optimization_coefficients.right_endpoint_last_merged_segment = merge_segment_density_map.begin()->second._value.right_endpoint;
					//	mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
					//}
					/*----------------------------------------------------------------------------------------------------------------------------------*/

					break;
				}
				/**********************************************************************************************************************************************************/

				/*********************************      Priority Queue    ***************************************************/
				/*...........................................................................*/
#ifdef _DEBUG
				//cout << "Before Update queue: Use current increment : " << 1 / current_segment.segment_density << ", erase queue.top: " << 1 / priority_queue_smallest_increment_density.top() << endl;
#endif
				/*...........................................................................*/

				//priority_queue_smallest_increment_density.pop();
				//priority_queue_smallest_increment_density.emplace(current_segment.segment_density);

				priority_queue_smallest_increment_density = current_segment.segment_density;

				/*...........................................................................*/
#ifdef _DEBUG
				//cout <<"After Update queue: queue.top: " << 1 / priority_queue_smallest_increment_density.top() << endl;
#endif
				/*...........................................................................*/

				/************************************************************************************************************/

				/********* get merged triangle area, add linked list, MAP insertion: Density, Get Area difference ***********/
				insert_last_segment_compute_merge_split_coefficients(original_time_series_vector, current_segment, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
				/************************************************************************************************************/


				///*!!!!!!!!!!!!!!!!!!!!!!!!!!!!    200818 Get Area difference   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
				////const auto& const area_difference = getAreaDifference(original_time_series, doubly_linked_list[segment_id]);
				//const long double& const area_difference = getAreaDifference(original_time_series_vector, doubly_linked_list.back());
				//if (area_difference > 0){
				//	split_area_difference_map.emplace(area_difference, node_segment_current);
				//}
				///*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

				/*===========================    210301 Merge Operation     =================*/
				//if (doubly_linked_list.size() > input_argument.point_dimension) {

				//	//optimization_coefficients.right_endpoint_last_merged_segment = merge_segment_density_map.begin()->second._value.right_endpoint;
				//	mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);

				//}
				/*================================================================================*/

				/********************************************** new twe points segment **************************************/
				current_segment.right_endpoint += 2;
				current_segment.rectangle_width = 2;
				//current_segment.segment_right_height_difference = 0;
				current_segment.area_difference = current_segment.bound.upper_bound_diff = current_segment.bound.upper_bound_area = 0;
				//get_segment_two_points_ab_minmax(original_time_series_vector[current_segment.right_endpoint - 1], original_time_series_vector[current_segment.right_endpoint], current_segment); 210203
				getAandBSlopInterceptTwoPoint(original_time_series_vector[current_segment.right_endpoint - 1], original_time_series_vector[current_segment.right_endpoint], current_segment);
				/************************************************************************************************************/
				/*..................................................................................................................*/
#ifdef _DEBUG
				assert_segment_bound(original_time_series_vector, current_segment);
				assert_segment_bound(original_time_series_vector, accumulate_segment);
#endif
				/*..................................................................................................................*/
			}
			else {
				/*..................................................................................................................*/
#ifdef _DEBUG
				assert_segment_bound(original_time_series_vector, current_segment);
				assert_segment_bound(original_time_series_vector, accumulate_segment);
#endif
				/*..................................................................................................................*/
				current_segment = accumulate_segment;
			}
			/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
			//current_segment = next_two_points_segment;
		}
		/*====================================================================================================================================*/

		/*====================================================================================================================================*/
		//next_two_points_segment.right_endpoint += 2;
		//next_two_points_segment.right_endpoint = current_segment.right_endpoint + 2;

		accumulate_segment.right_endpoint = current_segment.right_endpoint + 1;
		accumulate_segment.rectangle_width = current_segment.rectangle_width + 1;
		/*====================================================================================================================================*/
	}
	/*##############################################################################################################################################################################*/

	/*..................................................................................................................*/
#ifdef _DEBUG
	assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
#endif
	/*..................................................................................................................*/

	/*############################################################                one line time series         #####################################################################*/

	if (doubly_linked_list.size() == 1) {
		assert(0);
		//return;
		/*..................................................................................................................*/
#ifdef _DEBUG
		assert(split_area_difference_map.size() == 0 && merge_segment_density_map.empty());
#endif
		/*..................................................................................................................*/

		y_projection_merge_line(input_argument, original_time_series_vector, doubly_linked_list);

		return;
	}

	/*##############################################################################################################################################################################*/

	/*############################################################# Split & Merge Operation #############################################################################################*/

	bool temp_is_burst = false;

	while (doubly_linked_list.size() < input_argument.point_dimension) {

		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!     191124 for burst time series   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		if (split_area_difference_map.size() == 0) {
			assert(0);
			temp_is_burst = true;

			/*............................................*/
#ifdef _DEBUG
			assert(input_argument.point_dimension != INF);
#endif
			/*............................................*/

			/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			split_burst_segment(original_time_series_vector, input_argument.point_dimension, doubly_linked_list);
			/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			break;

		}
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		splitSegmentBySlope(original_time_series_vector, input_argument.option_split_method, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	}

	while (doubly_linked_list.size() > input_argument.point_dimension) {
		mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
	}

	/*##############################################################################################################################################################################*/

	/*..................................................................................................................*/
#ifdef _DEBUG
	if (temp_is_burst == false)
		assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
	assert_merge_map_triangle_density(merge_segment_density_map);
	assert(doubly_linked_list.back().right_endpoint == original_time_series_vector.size() - 1);
	//assert_minmax_value(original_time_series_vector, doubly_linked_list);
	assert_bound(original_time_series_vector, doubly_linked_list);
	/*##################################################           Print Result        ###############################################################################################*/
	//cout << "!! Split point:  right end point: " << left_part_smallest_accumulation_density.right_endpoint << ", Density : "<< left_part_smallest_accumulation_density.segment_density << endl;
	//TOOL::print_each_segment_coefficient_with_order(doubly_linked_list);
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/*cout << "Priority queue of increment density: \n";
	while (!priority_queue_smallest_increment_density.empty()) {
		std::cout << 1 / priority_queue_smallest_increment_density.top() << ", ";
		priority_queue_smallest_increment_density.pop();
	}
	cout << '\n';*/
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*+++++++++++++++++++++++++++  200818 Print right subsegment  ++++++++++++++++++++++++++++++++++++++++++++++*/
	/*if (temp_is_burst == false) {
		cout << "Print right endpoint & width: \n";
		for (auto au : doubly_linked_list) {
			cout << "Right endpoint: " << au.right_subsegment->right_endpoint << " Width: " << au.right_subsegment->rectangle_width << " a&b: " << au.right_subsegment->apla.a << "," << au.right_subsegment->apla.b << " Density: " << au.right_subsegment->segment_density << "; ";
		}
		cout << endl;
	}*/
	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


	/*****************************     200818  MAP insertion: Density     ***************************************/
	/*cout << "Print MAP: \n";
	for (auto&& au : merge_segment_density_map) {
		cout << 1 / au.first << ", ";
	}
	cout << endl;*/
	/************************************************************************************************************/
#endif
	/*..........................................................................................................................................*/
	/*##############################################################################################################################################################################*/
}

//************************************
// Method:get_whole_area_difference
// Qualifier: compute area difference of whole linked list
// linked list size <= N
// date:200924 09:56
// author:
//************************************
TEMPLATE
template<typename T>
long double APLA::get_whole_area_difference(const DoublyLinkedList<T>& const doubly_linked_list) {
	long double area_difference_sum = 0.0;

	for (auto&& au : doubly_linked_list) {
		/*.........................................................*/
#ifdef _DEBUG
		assert(au.area_difference != INF);
#endif
		/*.........................................................*/
		area_difference_sum += pow(au.area_difference, 2.0);
	}

	return sqrt(area_difference_sum);
}

//************************************
// Method:get_whole_area_difference_by_map
// Qualifier: compute area difference of whole linked list by MAP, not by linked list
// linked list size <= N
// date:201005
// author:
//************************************
TEMPLATE
template<typename T>
long double APLA::get_whole_area_difference_by_map(const T& const map) {
	long double area_difference_sum = 0.0;

	for (auto&& au : map) {
		/*.........................................................*/
#ifdef _DEBUG
		assert(au.second._value.area_difference != INF);
#endif
		/*.........................................................*/
		area_difference_sum += au.second._value.area_difference;
	}
	return area_difference_sum;
}

//************************************
// Method:optimize_segment_max_area_difference
// Qualifier: move the left / right endpoint of max area difference segment
// date:201002  12:29
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename T1>
void APLA::optimize_segment_max_area_difference(const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>& const, std::greater<T1>>& const split_area_difference_map) {

	/*............................................................................................................................................................*/
#ifdef _DEBUG
	assert(!split_area_difference_map.empty());
	assert_split_map_area_difference(split_area_difference_map);
	//evaluate right point, min&max point, width. a&b, sum value
	//assertLinkedList(original_time_series_vector, doubly_linked_list);
#endif
	/*............................................................................................................................................................*/

	/*#################################################### Coefficients of Split #################################################################################*/

	/*===============================     width = 2, no space to decrease    =========================================*/
	while (split_area_difference_map.begin()->second._value.rectangle_width < 3 || split_area_difference_map.begin()->second._value.area_difference == 0) {
		//split_area_difference_map.begin()->second._value.optimization_coefficient.finish_right = true;
		eraseMapByKey(split_area_difference_map, split_area_difference_map.begin()->second._value.right_endpoint, split_area_difference_map.begin()->second._value.area_difference);
		if (split_area_difference_map.empty()) return;
	}
	/*================================================================================================================*/

	/*========================================   Split Candidate Long segment  ========================================*/
	auto& const node_max_area_difference = split_area_difference_map.begin()->second;
	auto& const segment_middle = node_max_area_difference._value;
	/*================================================================================================================*/

	/**********************************    new Sub left segment    **************************************/
	//DoublyListNode<Y>* node_left_new = new DoublyListNode<Y>;
	//Y& const left_segment = node_left_new->_value;
	/****************************************************************************************************/

	/**************************    new long, sub left, sub right segment    *****************************/
	//Y original_splited_segment = segment_middle, new_sub_segment_left, new_sub_segment_right;
	/****************************************************************************************************/

	/************************       If the splited segment is head segment      *************************/
	/*bool is_head_node_split = false;
	if (splited_node_segment.right_endpoint + 1 == splited_node_segment.rectangle_width)
		is_head_node_split = true;*/
		/*****************************************************************************************************/

		/*##########################################################################################################################################################*/

		/*########################################### Move endpoint of max area difference #########################################################################*/
	if (!node_max_area_difference._prev) {//head node
		/*............................................................................................................................................................*/
#ifdef _DEBUG
		assert(segment_middle.right_endpoint + 1 == segment_middle.rectangle_width && !segment_middle.optimization_coefficient.finish_right);
		assert_split_map_area_difference(split_area_difference_map);
#endif
		/*............................................................................................................................................................*/

		Y& const segment_right = node_max_area_difference._next->_value;

		if (segment_middle.area_difference == 0 && segment_right.area_difference == 0) {
			segment_middle.optimization_coefficient.finish_right = true;
			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
			/*..............................................................................................................................*/
#ifdef _DEBUG
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/
			if (split_area_difference_map.empty()) return;
			if (segment_right.optimization_coefficient.finish_right) {
				eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
				if (split_area_difference_map.empty()) return;
			}

			/*..............................................................................................................................*/
#ifdef _DEBUG
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/

			return;
		}

		Y temp_segment_decrease_right;
		temp_segment_decrease_right.right_endpoint = segment_middle.right_endpoint - 1;
		temp_segment_decrease_right.rectangle_width = segment_middle.rectangle_width - 1;
		temp_segment_decrease_right.optimization_coefficient = segment_middle.optimization_coefficient;

		get_ab_segment_by_decrement(original_time_series_vector, segment_middle, temp_segment_decrease_right);

		/*if (segment_middle.min_point.id == segment_middle.right_endpoint || segment_middle.max_point.id == segment_middle.right_endpoint) {
			getSegmentMinMaxPoint(original_time_series_vector, temp_segment_decrease_right);
		}
		else { 210203
			temp_segment_decrease_right.min_point = segment_middle.min_point;
			temp_segment_decrease_right.max_point = segment_middle.max_point;
		}*/

		//get_area_difference_segment(original_time_series_vector, temp_segment_decrease_right);
		getAreaDifference(original_time_series_vector, temp_segment_decrease_right);

		Y temp_segment_increase_left;
		temp_segment_increase_left.right_endpoint = segment_right.right_endpoint;
		temp_segment_increase_left.rectangle_width = segment_right.rectangle_width + 1;
		temp_segment_increase_left.optimization_coefficient = segment_right.optimization_coefficient;

		get_ab_segment_by_accumulation_left(original_time_series_vector[segment_right.right_endpoint - segment_right.rectangle_width], segment_right, temp_segment_increase_left);
		if (original_time_series_vector[segment_right.right_endpoint - segment_right.rectangle_width] > segment_right.max_point.value) {
			temp_segment_increase_left.max_point.value = original_time_series_vector[segment_right.right_endpoint - segment_right.rectangle_width];
			temp_segment_increase_left.max_point.id = segment_right.right_endpoint - segment_right.rectangle_width;
		}
		else {
			temp_segment_increase_left.max_point = segment_right.max_point;
		}

		if (original_time_series_vector[segment_right.right_endpoint - segment_right.rectangle_width] < segment_right.min_point.value) {
			temp_segment_increase_left.min_point.value = original_time_series_vector[segment_right.right_endpoint - segment_right.rectangle_width];
			temp_segment_increase_left.min_point.id = segment_right.right_endpoint - segment_right.rectangle_width;
		}
		else {
			temp_segment_increase_left.min_point = segment_right.min_point;
		}

#ifdef _DEBUG
		assert_segment_a_b_minmax(original_time_series_vector, temp_segment_increase_left);
#endif

		//get_ab_minmax_segment(original_time_series_vector, temp_segment_increase_left);
		//get_area_difference_segment(original_time_series_vector, temp_segment_increase_left);
		getAreaDifference(original_time_series_vector, temp_segment_increase_left);


		if (temp_segment_decrease_right.area_difference + temp_segment_increase_left.area_difference < segment_middle.area_difference + segment_right.area_difference) {
			/*---------------------           Area Difference MAP Update:  left decrease & right increase        ---------------------------------*/
			/*............................................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_middle.area_difference > 0);
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*............................................................................................................................................................*/

			/*..............................................................................................................................*/
#ifdef _DEBUG
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/

			if (temp_segment_decrease_right.area_difference > 0) {
				updateMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference, temp_segment_decrease_right.area_difference);//201005 For area difference
			}
			else {
				eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
			}

			if (segment_right.area_difference > 0 && temp_segment_increase_left.area_difference > 0) {
				updateMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference, temp_segment_increase_left.area_difference);//201005 For area difference
			}
			else if (temp_segment_increase_left.area_difference > 0) {
				split_area_difference_map.emplace(temp_segment_increase_left.area_difference, *node_max_area_difference._next);
			}
			else if (segment_right.area_difference > 0 && temp_segment_increase_left.area_difference == 0) {
				eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
			}

			/*------------------------------------------------------------------------------------------------------------------------------------*/
			segment_middle = temp_segment_decrease_right;
			segment_right = temp_segment_increase_left;

			/*............................................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_middle.right_endpoint + 1 == segment_middle.rectangle_width);
#endif
			/*............................................................................................................................................................*/
		}
		else {
			/*............................................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_middle.right_endpoint + 1 == segment_middle.rectangle_width && segment_middle.rectangle_width > 2);
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*............................................................................................................................................................*/

			segment_middle.optimization_coefficient.finish_right = true;
			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);

			/*..............................................................................................................................*/
#ifdef _DEBUG
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/

			if (split_area_difference_map.empty()) return;
			if (segment_right.optimization_coefficient.finish_right) {
				if (segment_right.area_difference > 0)
					eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
				if (split_area_difference_map.empty()) return;
			}
		}
	}
	else if (node_max_area_difference._next) {//middle node
	/*..............................................................................................................................*/
#ifdef _DEBUG
		assert_split_map_area_difference(split_area_difference_map);
#endif
		/*..............................................................................................................................*/

		Y& const segment_left = node_max_area_difference._prev->_value;
		Y& const segment_right = node_max_area_difference._next->_value;

		if (segment_middle.area_difference == 0 && segment_right.area_difference == 0) {
			segment_middle.optimization_coefficient.finish_right = true;

			if (segment_left.optimization_coefficient.finish_right == true) {
				eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
				if (split_area_difference_map.empty()) return;
			}

			if (segment_right.optimization_coefficient.finish_right == true) {
				eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
				if (split_area_difference_map.empty()) return;
			}

		}

		if (segment_middle.area_difference == 0 && segment_left.area_difference == 0) {
			segment_left.optimization_coefficient.finish_right = true;
			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
			if (split_area_difference_map.empty()) return;
			const auto& const left_node = node_max_area_difference._prev;
			if (!(*left_node)._prev || ((*left_node)._prev && (*left_node)._prev->_value.optimization_coefficient.finish_right)) {//left is head node or LR finish optimization 
				eraseMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference);
				if (split_area_difference_map.empty()) return;
			}

			return;
		}

		const int id_left = segment_middle.right_endpoint - segment_middle.rectangle_width + 1;
		const long double height_difference_left = fabs(segment_middle.apla.b - original_time_series_vector[id_left]);
		const long double height_difference_right = fabs(segment_middle.apla.a * (segment_middle.rectangle_width - 1) + segment_middle.apla.b - original_time_series_vector[segment_middle.right_endpoint]);

		if ((height_difference_left < height_difference_right && segment_middle.optimization_coefficient.finish_right == false) || (segment_left.optimization_coefficient.finish_right == true && segment_middle.optimization_coefficient.finish_right == false)) {

			/*............................................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_middle.optimization_coefficient.finish_right == false);
			if (height_difference_left >= height_difference_right) {
				assert(segment_left.optimization_coefficient.finish_right == true);
			}
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*............................................................................................................................................................*/

			Y temp_segment_decrease_right;
			temp_segment_decrease_right.right_endpoint = segment_middle.right_endpoint - 1;
			temp_segment_decrease_right.rectangle_width = segment_middle.rectangle_width - 1;
			temp_segment_decrease_right.optimization_coefficient = segment_middle.optimization_coefficient;

			get_ab_segment_by_decrement(original_time_series_vector, segment_middle, temp_segment_decrease_right);

			/*if (segment_middle.min_point.id == segment_middle.right_endpoint || segment_middle.max_point.id == segment_middle.right_endpoint) {
				getSegmentMinMaxPoint(original_time_series_vector, temp_segment_decrease_right);
			}
			else { 210203
				temp_segment_decrease_right.min_point = segment_middle.min_point;
				temp_segment_decrease_right.max_point = segment_middle.max_point;
			}*/

			//get_area_difference_segment(original_time_series_vector, temp_segment_decrease_right);
			getAreaDifference(original_time_series_vector, temp_segment_decrease_right);

			Y temp_segment_increase_left;
			temp_segment_increase_left.right_endpoint = segment_right.right_endpoint;
			temp_segment_increase_left.rectangle_width = segment_right.rectangle_width + 1;
			temp_segment_increase_left.optimization_coefficient = segment_right.optimization_coefficient;


			get_ab_segment_by_accumulation_left(original_time_series_vector[segment_right.right_endpoint - segment_right.rectangle_width], segment_right, temp_segment_increase_left);
			if (original_time_series_vector[segment_right.right_endpoint - segment_right.rectangle_width] > segment_right.max_point.value) {
				temp_segment_increase_left.max_point.value = original_time_series_vector[segment_right.right_endpoint - segment_right.rectangle_width];
				temp_segment_increase_left.max_point.id = segment_right.right_endpoint - segment_right.rectangle_width;
			}
			else {
				temp_segment_increase_left.max_point = segment_right.max_point;
			}

			if (original_time_series_vector[segment_right.right_endpoint - segment_right.rectangle_width] < segment_right.min_point.value) {
				temp_segment_increase_left.min_point.value = original_time_series_vector[segment_right.right_endpoint - segment_right.rectangle_width];
				temp_segment_increase_left.min_point.id = segment_right.right_endpoint - segment_right.rectangle_width;
			}
			else {
				temp_segment_increase_left.min_point = segment_right.min_point;
			}
			//get_ab_minmax_segment(original_time_series_vector, temp_segment_increase_left);

#ifdef _DEBUG
			assert_segment_a_b_minmax(original_time_series_vector, temp_segment_increase_left);
			assert_segment_a_b_minmax(original_time_series_vector, temp_segment_decrease_right);
#endif

			//get_area_difference_segment(original_time_series_vector, temp_segment_increase_left);
			getAreaDifference(original_time_series_vector, temp_segment_increase_left);

			if (temp_segment_decrease_right.area_difference + temp_segment_increase_left.area_difference < segment_middle.area_difference + segment_right.area_difference) {
				/*............................................................................................................................................................*/
#ifdef _DEBUG
				assert(segment_middle.area_difference > 0);
				assert_split_map_area_difference(split_area_difference_map);
#endif
				/*............................................................................................................................................................*/

				/*---------------------           Area Difference MAP Update:  left decrease & right increase        ---------------------------------*/
				if (temp_segment_decrease_right.area_difference > 0) {
					updateMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference, temp_segment_decrease_right.area_difference);//201005 For area difference
				}
				else {
					eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
				}

				if (segment_right.area_difference > 0 && temp_segment_increase_left.area_difference > 0) {
					updateMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference, temp_segment_increase_left.area_difference);//201005 For area difference
				}
				else if (temp_segment_increase_left.area_difference > 0) {
					split_area_difference_map.emplace(temp_segment_increase_left.area_difference, *node_max_area_difference._next);
				}
				else if (segment_right.area_difference > 0 && temp_segment_increase_left.area_difference == 0) {
					eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
				}

				/*------------------------------------------------------------------------------------------------------------------------------------*/
				segment_middle = temp_segment_decrease_right;
				segment_right = temp_segment_increase_left;

				/*..............................................................................................................................*/
#ifdef _DEBUG
				assert_split_map_area_difference(split_area_difference_map);
#endif
				/*..............................................................................................................................*/
			}
			else {
				/*..............................................................................................................................*/
#ifdef _DEBUG
				assert_split_map_area_difference(split_area_difference_map);
#endif
				/*..............................................................................................................................*/
				segment_middle.optimization_coefficient.finish_right = true;

				if (segment_left.optimization_coefficient.finish_right == true && segment_middle.optimization_coefficient.finish_right == true) {
					eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
					if (split_area_difference_map.empty()) return;
				}

				if (segment_right.optimization_coefficient.finish_right == true) {
					if (segment_right.area_difference > 0)
						eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
					if (split_area_difference_map.empty()) return;
				}
			}
		}
		else if ((height_difference_left >= height_difference_right && segment_left.optimization_coefficient.finish_right == false) || (segment_left.optimization_coefficient.finish_right == false && segment_middle.optimization_coefficient.finish_right == true)) {
			auto& const segment_left = node_max_area_difference._prev->_value;
			/*............................................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_left.optimization_coefficient.finish_right == false);

			if (height_difference_left < height_difference_right) {
				assert(segment_middle.optimization_coefficient.finish_right == true);
			}
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/
			Y temp_segment_decrease_left;
			temp_segment_decrease_left.right_endpoint = segment_middle.right_endpoint;
			temp_segment_decrease_left.rectangle_width = segment_middle.rectangle_width - 1;
			temp_segment_decrease_left.optimization_coefficient = segment_middle.optimization_coefficient;

			get_ab_segment_by_decrement_left(original_time_series_vector, segment_middle, temp_segment_decrease_left);

			/*if (segment_middle.min_point.id == temp_segment_decrease_left.right_endpoint - temp_segment_decrease_left.rectangle_width || segment_middle.max_point.id == temp_segment_decrease_left.right_endpoint - temp_segment_decrease_left.rectangle_width) {
				getSegmentMinMaxPoint(original_time_series_vector, temp_segment_decrease_left);
			}
			else { // 210203
				temp_segment_decrease_left.min_point = segment_middle.min_point;
				temp_segment_decrease_left.max_point = segment_middle.max_point;
			}*/

			//get_ab_minmax_segment(original_time_series_vector, temp_segment_decrease_left);

			//get_area_difference_segment(original_time_series_vector, temp_segment_decrease_left);
			getAreaDifference(original_time_series_vector, temp_segment_decrease_left);

			Y temp_segment_increase_right;
			temp_segment_increase_right.right_endpoint = segment_left.right_endpoint + 1;
			temp_segment_increase_right.rectangle_width = segment_left.rectangle_width + 1;
			temp_segment_increase_right.optimization_coefficient = segment_left.optimization_coefficient;

			get_ab_minmax_segment_by_accumulation(original_time_series_vector[temp_segment_increase_right.right_endpoint], segment_left, temp_segment_increase_right);
			//get_area_difference_segment(original_time_series_vector, temp_segment_increase_right);
			getAreaDifference(original_time_series_vector, temp_segment_increase_right);
#ifdef _DEBUG
			assert_segment_a_b_minmax(original_time_series_vector, temp_segment_decrease_left);
			assert_segment_a_b_minmax(original_time_series_vector, temp_segment_increase_right);
#endif

			if (temp_segment_decrease_left.area_difference + temp_segment_increase_right.area_difference < segment_middle.area_difference + segment_left.area_difference) {

				/*............................................................................................................................................................*/
#ifdef _DEBUG
				assert(segment_middle.area_difference > 0);
#endif
				/*............................................................................................................................................................*/
				/*..............................................................................................................................*/
#ifdef _DEBUG
				assert_split_map_area_difference(split_area_difference_map);
#endif
				/*..............................................................................................................................*/

				/*---------------------           Area Difference MAP Update:  left decrease & right increase        ---------------------------------*/
				if (temp_segment_decrease_left.area_difference > 0) {
					updateMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference, temp_segment_decrease_left.area_difference);//201005 For area difference
				}
				else {
					eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
				}

				if (segment_left.area_difference > 0 && temp_segment_increase_right.area_difference > 0) {
					updateMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference, temp_segment_increase_right.area_difference);//201005 For area difference
				}
				else if (temp_segment_increase_right.area_difference > 0) {
					split_area_difference_map.emplace(temp_segment_increase_right.area_difference, *node_max_area_difference._prev);
				}
				else if (segment_left.area_difference > 0 && temp_segment_increase_right.area_difference == 0) {
					eraseMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference);
				}
				/*------------------------------------------------------------------------------------------------------------------------------------*/

				segment_middle = temp_segment_decrease_left;
				segment_left = temp_segment_increase_right;

				/*..............................................................................................................................*/
#ifdef _DEBUG
				assert_split_map_area_difference(split_area_difference_map);
#endif
				/*..............................................................................................................................*/
			}
			else {
				/*..............................................................................................................................*/
#ifdef _DEBUG
				assert_split_map_area_difference(split_area_difference_map);
#endif
				/*..............................................................................................................................*/
				segment_left.optimization_coefficient.finish_right = true;

				if (segment_middle.optimization_coefficient.finish_right == true) {
					eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
					if (split_area_difference_map.empty()) return;
				}

				const auto& const left_node = node_max_area_difference._prev;
				if (!(*left_node)._prev || ((*left_node)._prev && (*left_node)._prev->_value.optimization_coefficient.finish_right == true)) {
					if (segment_left.area_difference > 0)
						eraseMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference);
					if (split_area_difference_map.empty()) return;
				}
			}
		}
		else {
			/*..............................................................................................................................*/
#ifdef _DEBUG
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/
				//assert(0);
			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
			/*..............................................................................................................................*/
#ifdef _DEBUG
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/
			if (split_area_difference_map.empty()) return;
		}
	}
	else {//tail node

	/*..............................................................................................................................*/
#ifdef _DEBUG
		assert_split_map_area_difference(split_area_difference_map);
#endif
		/*..............................................................................................................................*/

		Y& const segment_left = node_max_area_difference._prev->_value;

		if (segment_middle.area_difference == 0 && segment_left.area_difference == 0) {
			segment_left.optimization_coefficient.finish_right = true;
			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
			if (split_area_difference_map.empty()) return;
			const auto& const left_node = node_max_area_difference._prev;
			if (!(*left_node)._prev || ((*left_node)._prev && (*left_node)._prev->_value.optimization_coefficient.finish_right)) {
				eraseMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference);
				if (split_area_difference_map.empty()) return;
			}
			return;
		}

		/*............................................................................................................................................................*/
#ifdef _DEBUG
		assert(node_max_area_difference._prev && !node_max_area_difference._next && segment_middle.optimization_coefficient.finish_right && !segment_left.optimization_coefficient.finish_right);
#endif
		/*.............................................................................................................................................................*/

		Y temp_segment_middle;
		temp_segment_middle.right_endpoint = segment_middle.right_endpoint;
		temp_segment_middle.rectangle_width = segment_middle.rectangle_width - 1;
		temp_segment_middle.optimization_coefficient = segment_middle.optimization_coefficient;

		get_ab_segment_by_decrement_left(original_time_series_vector, segment_middle, temp_segment_middle);

		if (segment_middle.min_point.id == temp_segment_middle.right_endpoint - temp_segment_middle.rectangle_width || segment_middle.max_point.id == temp_segment_middle.right_endpoint - temp_segment_middle.rectangle_width) {
			getSegmentMinMaxPoint(original_time_series_vector, temp_segment_middle);
		}
		else {
			temp_segment_middle.min_point = segment_middle.min_point;
			temp_segment_middle.max_point = segment_middle.max_point;
		}


		//get_ab_minmax_segment(original_time_series_vector, temp_segment_middle);
		//get_area_difference_segment(original_time_series_vector, temp_segment_middle);
		getAreaDifference(original_time_series_vector, temp_segment_middle);

		Y temp_segment_left;
		temp_segment_left.right_endpoint = segment_left.right_endpoint + 1;
		temp_segment_left.rectangle_width = segment_left.rectangle_width + 1;
		temp_segment_left.optimization_coefficient = segment_left.optimization_coefficient;
		get_ab_minmax_segment_by_accumulation(original_time_series_vector[temp_segment_left.right_endpoint], segment_left, temp_segment_left);
		//get_area_difference_segment(original_time_series_vector, temp_segment_left);
		getAreaDifference(original_time_series_vector, temp_segment_left);
#ifdef _DEBUG
		assert_segment_a_b_minmax(original_time_series_vector, temp_segment_middle);
		assert_segment_a_b_minmax(original_time_series_vector, temp_segment_left);
#endif

		if (temp_segment_middle.area_difference + temp_segment_left.area_difference < segment_middle.area_difference + segment_left.area_difference) {
			/*..............................................................................................................................*/
#ifdef _DEBUG
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/
			/*............................................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_middle.area_difference > 0);
#endif
			/*............................................................................................................................................................*/
			/*---------------------           Area Difference MAP Update:  left decrease & right increase        ---------------------------------*/
			if (temp_segment_middle.area_difference > 0) {
				updateMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference, temp_segment_middle.area_difference);//201005 For area difference
			}
			else {
				eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
			}

			if (segment_left.area_difference > 0 && temp_segment_left.area_difference > 0) {
				updateMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference, temp_segment_left.area_difference);//201005 For area difference
			}
			else if (temp_segment_left.area_difference > 0) {
				split_area_difference_map.emplace(temp_segment_left.area_difference, *node_max_area_difference._prev);
			}
			else if (segment_left.area_difference > 0 && temp_segment_left.area_difference == 0) {
				eraseMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference);
			}
			/*------------------------------------------------------------------------------------------------------------------------------------*/

			segment_middle = temp_segment_middle;
			segment_left = temp_segment_left;
			/*..............................................................................................................................*/
#ifdef _DEBUG
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/
		}
		else {
			/*..............................................................................................................................*/
#ifdef _DEBUG
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/
			segment_left.optimization_coefficient.finish_right = true;
			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
			/*..............................................................................................................................*/
#ifdef _DEBUG
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/
			if (split_area_difference_map.empty()) return;
			const auto& const left_node = node_max_area_difference._prev;
			if (!(*left_node)._prev || ((*left_node)._prev && (*left_node)._prev->_value.optimization_coefficient.finish_right)) {
				if (segment_left.area_difference > 0)
					eraseMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference);
				if (split_area_difference_map.empty()) return;
			}
		}

	}
	/*##########################################################################################################################################################*/

	/*.....................................................................*/
#ifdef _DEBUG
	assert_split_map_area_difference(split_area_difference_map);
	//assert(!split_area_difference_map.empty());
	//evaluate right point, min&max point, width. a&b, sum value
	//assertLinkedList(original_time_series_vector, doubly_linked_list);
#endif
	/*...................................................................*/
}

//201103 Speed up. move the left / right endpoint of max area difference segment
TEMPLATE
template<typename T, typename Y, typename T1>
bool APLA::optimize_segment_max_area_difference_speed(const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map) {
	/*............................................................................................................................................................*/
#ifdef _DEBUG
	assert(!split_area_difference_map.empty());
	assert_split_map_area_difference(split_area_difference_map);
	//evaluate right point, min&max point, width. a&b, sum value
	//assertLinkedList(original_time_series_vector, doubly_linked_list);
#endif
	/*............................................................................................................................................................*/

	/*#################################################### Coefficients of Split #################################################################################*/

	/*===============================     width = 2, no space to decrease    =========================================*/
	while (split_area_difference_map.begin()->second._value.rectangle_width < 3 || split_area_difference_map.begin()->second._value.area_difference == 0) {
		//split_area_difference_map.begin()->second._value.optimization_coefficient.finish_right = true;
		eraseMapByKey(split_area_difference_map, split_area_difference_map.begin()->second._value.right_endpoint, split_area_difference_map.begin()->second._value.area_difference);
		if (split_area_difference_map.empty()) return false;
	}
	/*================================================================================================================*/

	/*========================================   Split Candidate Long segment  ========================================*/
	auto& const node_max_area_difference = split_area_difference_map.begin()->second;
	auto& const segment_middle = node_max_area_difference._value;
	/*================================================================================================================*/

	/**********************************    new Sub left segment    **************************************/
	//DoublyListNode<Y>* node_left_new = new DoublyListNode<Y>;
	//Y& const left_segment = node_left_new->_value;
	/****************************************************************************************************/

	/**************************    new long, sub left, sub right segment    *****************************/
	//Y original_splited_segment = segment_middle, new_sub_segment_left, new_sub_segment_right;
	/****************************************************************************************************/

	/************************       If the splited segment is head segment      *************************/
	/*bool is_head_node_split = false;
	if (splited_node_segment.right_endpoint + 1 == splited_node_segment.rectangle_width)
		is_head_node_split = true;*/
		/*****************************************************************************************************/

		/*##########################################################################################################################################################*/

		/*########################################### Move endpoint of max area difference #########################################################################*/
	if (!node_max_area_difference._prev) {//head node
		/*............................................................................................................................................................*/
#ifdef _DEBUG
		assert(segment_middle.right_endpoint + 1 == segment_middle.rectangle_width && !segment_middle.optimization_coefficient.finish_right);
		assert_split_map_area_difference(split_area_difference_map);
#endif
		/*............................................................................................................................................................*/

		Y& const segment_right = node_max_area_difference._next->_value;

		if (segment_middle.area_difference == 0 && segment_right.area_difference == 0) {
			segment_middle.optimization_coefficient.finish_right = true;
			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
			/*..............................................................................................................................*/
#ifdef _DEBUG
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/
			if (split_area_difference_map.empty()) return false;
			if (segment_right.optimization_coefficient.finish_right) {
				eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
				if (split_area_difference_map.empty()) return false;
			}

			/*..............................................................................................................................*/
#ifdef _DEBUG
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/

			return false;
		}

		Y temp_segment_decrease_right;
		temp_segment_decrease_right.right_endpoint = segment_middle.right_endpoint - 1;
		temp_segment_decrease_right.rectangle_width = segment_middle.rectangle_width - 1;
		temp_segment_decrease_right.optimization_coefficient = segment_middle.optimization_coefficient;

		get_ab_segment_by_decrement(original_time_series_vector, segment_middle, temp_segment_decrease_right);

		if (segment_middle.min_point.id == segment_middle.right_endpoint || segment_middle.max_point.id == segment_middle.right_endpoint) {
			getSegmentMinMaxPoint(original_time_series_vector, temp_segment_decrease_right);
		}
		else {
			temp_segment_decrease_right.min_point = segment_middle.min_point;
			temp_segment_decrease_right.max_point = segment_middle.max_point;
		}

		//get_area_difference_segment(original_time_series_vector, temp_segment_decrease_right);
		getAreaDifference(original_time_series_vector, temp_segment_decrease_right);

		Y temp_segment_increase_left;
		temp_segment_increase_left.right_endpoint = segment_right.right_endpoint;
		temp_segment_increase_left.rectangle_width = segment_right.rectangle_width + 1;
		temp_segment_increase_left.optimization_coefficient = segment_right.optimization_coefficient;

		get_ab_segment_by_accumulation_left(original_time_series_vector[segment_right.right_endpoint - segment_right.rectangle_width], segment_right, temp_segment_increase_left);
		if (original_time_series_vector[segment_right.right_endpoint - segment_right.rectangle_width] > segment_right.max_point.value) {
			temp_segment_increase_left.max_point.value = original_time_series_vector[segment_right.right_endpoint - segment_right.rectangle_width];
			temp_segment_increase_left.max_point.id = segment_right.right_endpoint - segment_right.rectangle_width;
		}
		else {
			temp_segment_increase_left.max_point = segment_right.max_point;
		}

		if (original_time_series_vector[segment_right.right_endpoint - segment_right.rectangle_width] < segment_right.min_point.value) {
			temp_segment_increase_left.min_point.value = original_time_series_vector[segment_right.right_endpoint - segment_right.rectangle_width];
			temp_segment_increase_left.min_point.id = segment_right.right_endpoint - segment_right.rectangle_width;
		}
		else {
			temp_segment_increase_left.min_point = segment_right.min_point;
		}

#ifdef _DEBUG
		assert_segment_a_b_minmax(original_time_series_vector, temp_segment_increase_left);
#endif

		//get_ab_minmax_segment(original_time_series_vector, temp_segment_increase_left);
		//get_area_difference_segment(original_time_series_vector, temp_segment_increase_left);
		getAreaDifference(original_time_series_vector, temp_segment_increase_left);

		if (temp_segment_decrease_right.area_difference + temp_segment_increase_left.area_difference < segment_middle.area_difference + segment_right.area_difference) {
			/*---------------------           Area Difference MAP Update:  left decrease & right increase        ---------------------------------*/
			/*............................................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_middle.area_difference > 0);
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*............................................................................................................................................................*/

			if (temp_segment_decrease_right.area_difference > 0) {
				updateMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference, temp_segment_decrease_right.area_difference);//201005 For area difference
			}
			else {
				eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
			}

			if (segment_right.area_difference > 0 && temp_segment_increase_left.area_difference > 0) {
				updateMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference, temp_segment_increase_left.area_difference);//201005 For area difference
			}
			else if (temp_segment_increase_left.area_difference > 0) {
				split_area_difference_map.emplace(temp_segment_increase_left.area_difference, *node_max_area_difference._next);
			}
			else if (segment_right.area_difference > 0 && temp_segment_increase_left.area_difference == 0) {
				eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
			}

			/*------------------------------------------------------------------------------------------------------------------------------------*/
			segment_middle = temp_segment_decrease_right;
			segment_right = temp_segment_increase_left;

			/*............................................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_middle.right_endpoint + 1 == segment_middle.rectangle_width);
#endif
			/*............................................................................................................................................................*/
			return true;
		}
		else {
			/*............................................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_middle.right_endpoint + 1 == segment_middle.rectangle_width && segment_middle.rectangle_width > 2);
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*............................................................................................................................................................*/

			segment_middle.optimization_coefficient.finish_right = true;
			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);

			/*..............................................................................................................................*/
#ifdef _DEBUG
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/

			if (split_area_difference_map.empty()) return false;
			if (segment_right.optimization_coefficient.finish_right) {
				if (segment_right.area_difference > 0)
					eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
				if (split_area_difference_map.empty()) return false;
			}

			return false;
		}
	}
	else if (node_max_area_difference._next) {//middle node
		/*..............................................................................................................................*/
#ifdef _DEBUG
		assert_split_map_area_difference(split_area_difference_map);
#endif
		/*..............................................................................................................................*/

		Y& const segment_left = node_max_area_difference._prev->_value;
		Y& const segment_right = node_max_area_difference._next->_value;

		if (segment_middle.area_difference == 0 && segment_right.area_difference == 0) {
			segment_middle.optimization_coefficient.finish_right = true;

			if (segment_left.optimization_coefficient.finish_right == true) {
				eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
				if (split_area_difference_map.empty()) return false;
			}

			if (segment_right.optimization_coefficient.finish_right == true) {
				eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
				if (split_area_difference_map.empty()) return false;
			}
		}

		if (segment_middle.area_difference == 0 && segment_left.area_difference == 0) {
			segment_left.optimization_coefficient.finish_right = true;
			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
			if (split_area_difference_map.empty()) return false;
			const auto& const left_node = node_max_area_difference._prev;
			if (!(*left_node)._prev || ((*left_node)._prev && (*left_node)._prev->_value.optimization_coefficient.finish_right)) {//left is head node or LR finish optimization 
				eraseMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference);
				if (split_area_difference_map.empty()) return false;
			}

			return false;
		}

		const int id_left = segment_middle.right_endpoint - segment_middle.rectangle_width + 1;
		const long double height_difference_left = fabs(segment_middle.apla.b - original_time_series_vector[id_left]);
		const long double height_difference_right = fabs(segment_middle.apla.a * (segment_middle.rectangle_width - 1) + segment_middle.apla.b - original_time_series_vector[segment_middle.right_endpoint]);

		if ((height_difference_left < height_difference_right && segment_middle.optimization_coefficient.finish_right == false) || (segment_left.optimization_coefficient.finish_right == true && segment_middle.optimization_coefficient.finish_right == false)) {

			/*............................................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_middle.optimization_coefficient.finish_right == false);
			if (height_difference_left >= height_difference_right) {
				assert(segment_left.optimization_coefficient.finish_right == true);
			}
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*............................................................................................................................................................*/

			Y temp_segment_decrease_right;
			temp_segment_decrease_right.right_endpoint = segment_middle.right_endpoint - 1;
			temp_segment_decrease_right.rectangle_width = segment_middle.rectangle_width - 1;
			temp_segment_decrease_right.optimization_coefficient = segment_middle.optimization_coefficient;

			get_ab_segment_by_decrement(original_time_series_vector, segment_middle, temp_segment_decrease_right);

			if (segment_middle.min_point.id == segment_middle.right_endpoint || segment_middle.max_point.id == segment_middle.right_endpoint) {
				getSegmentMinMaxPoint(original_time_series_vector, temp_segment_decrease_right);
			}
			else {
				temp_segment_decrease_right.min_point = segment_middle.min_point;
				temp_segment_decrease_right.max_point = segment_middle.max_point;
			}

			//get_area_difference_segment(original_time_series_vector, temp_segment_decrease_right);
			getAreaDifference(original_time_series_vector, temp_segment_decrease_right);

			Y temp_segment_increase_left;
			temp_segment_increase_left.right_endpoint = segment_right.right_endpoint;
			temp_segment_increase_left.rectangle_width = segment_right.rectangle_width + 1;
			temp_segment_increase_left.optimization_coefficient = segment_right.optimization_coefficient;


			get_ab_segment_by_accumulation_left(original_time_series_vector[segment_right.right_endpoint - segment_right.rectangle_width], segment_right, temp_segment_increase_left);
			if (original_time_series_vector[segment_right.right_endpoint - segment_right.rectangle_width] > segment_right.max_point.value) {
				temp_segment_increase_left.max_point.value = original_time_series_vector[segment_right.right_endpoint - segment_right.rectangle_width];
				temp_segment_increase_left.max_point.id = segment_right.right_endpoint - segment_right.rectangle_width;
			}
			else {
				temp_segment_increase_left.max_point = segment_right.max_point;
			}

			if (original_time_series_vector[segment_right.right_endpoint - segment_right.rectangle_width] < segment_right.min_point.value) {
				temp_segment_increase_left.min_point.value = original_time_series_vector[segment_right.right_endpoint - segment_right.rectangle_width];
				temp_segment_increase_left.min_point.id = segment_right.right_endpoint - segment_right.rectangle_width;
			}
			else {
				temp_segment_increase_left.min_point = segment_right.min_point;
			}
			//get_ab_minmax_segment(original_time_series_vector, temp_segment_increase_left);

#ifdef _DEBUG
			assert_segment_a_b_minmax(original_time_series_vector, temp_segment_increase_left);
			assert_segment_a_b_minmax(original_time_series_vector, temp_segment_decrease_right);
#endif

			//get_area_difference_segment(original_time_series_vector, temp_segment_increase_left);
			getAreaDifference(original_time_series_vector, temp_segment_increase_left);

			if (temp_segment_decrease_right.area_difference + temp_segment_increase_left.area_difference < segment_middle.area_difference + segment_right.area_difference) {
				/*............................................................................................................................................................*/
#ifdef _DEBUG
				assert(segment_middle.area_difference > 0);
				assert_split_map_area_difference(split_area_difference_map);
#endif
				/*............................................................................................................................................................*/

				/*---------------------           Area Difference MAP Update:  left decrease & right increase        ---------------------------------*/
				if (temp_segment_decrease_right.area_difference > 0) {
					updateMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference, temp_segment_decrease_right.area_difference);//201005 For area difference
				}
				else {
					eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
				}

				if (segment_right.area_difference > 0 && temp_segment_increase_left.area_difference > 0) {
					updateMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference, temp_segment_increase_left.area_difference);//201005 For area difference
				}
				else if (temp_segment_increase_left.area_difference > 0) {
					split_area_difference_map.emplace(temp_segment_increase_left.area_difference, *node_max_area_difference._next);
				}
				else if (segment_right.area_difference > 0 && temp_segment_increase_left.area_difference == 0) {
					eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
				}

				/*------------------------------------------------------------------------------------------------------------------------------------*/
				segment_middle = temp_segment_decrease_right;
				segment_right = temp_segment_increase_left;

				/*..............................................................................................................................*/
#ifdef _DEBUG
				assert_split_map_area_difference(split_area_difference_map);
#endif
				/*..............................................................................................................................*/

				return true;
			}
			else {
				/*..............................................................................................................................*/
#ifdef _DEBUG
				assert_split_map_area_difference(split_area_difference_map);
#endif
				/*..............................................................................................................................*/
				segment_middle.optimization_coefficient.finish_right = true;

				if (segment_left.optimization_coefficient.finish_right == true && segment_middle.optimization_coefficient.finish_right == true) {
					eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
					if (split_area_difference_map.empty()) return false;
				}

				if (segment_right.optimization_coefficient.finish_right == true) {
					if (segment_right.area_difference > 0)
						eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
					if (split_area_difference_map.empty()) return false;
				}
				return false;
			}
		}
		else if ((height_difference_left >= height_difference_right && segment_left.optimization_coefficient.finish_right == false) || (segment_left.optimization_coefficient.finish_right == false && segment_middle.optimization_coefficient.finish_right == true)) {
			auto& const segment_left = node_max_area_difference._prev->_value;
			/*............................................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_left.optimization_coefficient.finish_right == false);

			if (height_difference_left < height_difference_right) {
				assert(segment_middle.optimization_coefficient.finish_right == true);
			}
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/
			Y temp_segment_decrease_left;
			temp_segment_decrease_left.right_endpoint = segment_middle.right_endpoint;
			temp_segment_decrease_left.rectangle_width = segment_middle.rectangle_width - 1;
			temp_segment_decrease_left.optimization_coefficient = segment_middle.optimization_coefficient;

			get_ab_segment_by_decrement_left(original_time_series_vector, segment_middle, temp_segment_decrease_left);

			if (segment_middle.min_point.id == temp_segment_decrease_left.right_endpoint - temp_segment_decrease_left.rectangle_width || segment_middle.max_point.id == temp_segment_decrease_left.right_endpoint - temp_segment_decrease_left.rectangle_width) {
				getSegmentMinMaxPoint(original_time_series_vector, temp_segment_decrease_left);
			}
			else {
				temp_segment_decrease_left.min_point = segment_middle.min_point;
				temp_segment_decrease_left.max_point = segment_middle.max_point;
			}

			//get_ab_minmax_segment(original_time_series_vector, temp_segment_decrease_left);

			getAreaDifference(original_time_series_vector, temp_segment_decrease_left);

			Y temp_segment_increase_right;
			temp_segment_increase_right.right_endpoint = segment_left.right_endpoint + 1;
			temp_segment_increase_right.rectangle_width = segment_left.rectangle_width + 1;
			temp_segment_increase_right.optimization_coefficient = segment_left.optimization_coefficient;

			get_ab_minmax_segment_by_accumulation(original_time_series_vector[temp_segment_increase_right.right_endpoint], segment_left, temp_segment_increase_right);
			getAreaDifference(original_time_series_vector, temp_segment_increase_right);

#ifdef _DEBUG
			assert_segment_a_b_minmax(original_time_series_vector, temp_segment_decrease_left);
			assert_segment_a_b_minmax(original_time_series_vector, temp_segment_increase_right);
#endif

			if (temp_segment_decrease_left.area_difference + temp_segment_increase_right.area_difference < segment_middle.area_difference + segment_left.area_difference) {

				/*............................................................................................................................................................*/
#ifdef _DEBUG
				assert(segment_middle.area_difference > 0);
				assert_split_map_area_difference(split_area_difference_map);
#endif
				/*..............................................................................................................................*/

				/*---------------------           Area Difference MAP Update:  left decrease & right increase        ---------------------------------*/
				if (temp_segment_decrease_left.area_difference > 0) {
					updateMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference, temp_segment_decrease_left.area_difference);//201005 For area difference
				}
				else {
					eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
				}

				if (segment_left.area_difference > 0 && temp_segment_increase_right.area_difference > 0) {
					updateMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference, temp_segment_increase_right.area_difference);//201005 For area difference
				}
				else if (temp_segment_increase_right.area_difference > 0) {
					split_area_difference_map.emplace(temp_segment_increase_right.area_difference, *node_max_area_difference._prev);
				}
				else if (segment_left.area_difference > 0 && temp_segment_increase_right.area_difference == 0) {
					eraseMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference);
				}
				/*------------------------------------------------------------------------------------------------------------------------------------*/

				segment_middle = temp_segment_decrease_left;
				segment_left = temp_segment_increase_right;

				/*..............................................................................................................................*/
#ifdef _DEBUG
				assert_split_map_area_difference(split_area_difference_map);
#endif
				/*..............................................................................................................................*/

				return true;
			}
			else {
				/*..............................................................................................................................*/
#ifdef _DEBUG
				assert_split_map_area_difference(split_area_difference_map);
#endif
				/*..............................................................................................................................*/
				segment_left.optimization_coefficient.finish_right = true;

				if (segment_middle.optimization_coefficient.finish_right == true) {
					eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
					if (split_area_difference_map.empty()) return false;
				}

				const auto& const left_node = node_max_area_difference._prev;
				if (!(*left_node)._prev || ((*left_node)._prev && (*left_node)._prev->_value.optimization_coefficient.finish_right == true)) {
					if (segment_left.area_difference > 0)
						eraseMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference);
					if (split_area_difference_map.empty()) return false;
				}
				return true;
			}
		}
		else {
			/*..............................................................................................................................*/
#ifdef _DEBUG
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/
				//assert(0);
			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
			/*..............................................................................................................................*/
#ifdef _DEBUG
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/
			if (split_area_difference_map.empty()) return false;

			return true;
		}
	}
	else {//tail node

		/*..............................................................................................................................*/
#ifdef _DEBUG
		assert_split_map_area_difference(split_area_difference_map);
#endif
		/*..............................................................................................................................*/

		Y& const segment_left = node_max_area_difference._prev->_value;

		if (segment_middle.area_difference == 0 && segment_left.area_difference == 0) {
			segment_left.optimization_coefficient.finish_right = true;
			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
			if (split_area_difference_map.empty()) return false;
			const auto& const left_node = node_max_area_difference._prev;
			if (!(*left_node)._prev || ((*left_node)._prev && (*left_node)._prev->_value.optimization_coefficient.finish_right)) {
				eraseMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference);
				if (split_area_difference_map.empty()) return false;
			}
			return false;
		}

		/*............................................................................................................................................................*/
#ifdef _DEBUG
		assert(node_max_area_difference._prev && !node_max_area_difference._next && segment_middle.optimization_coefficient.finish_right && !segment_left.optimization_coefficient.finish_right);
#endif
		/*.............................................................................................................................................................*/

		Y temp_segment_middle;
		temp_segment_middle.right_endpoint = segment_middle.right_endpoint;
		temp_segment_middle.rectangle_width = segment_middle.rectangle_width - 1;
		temp_segment_middle.optimization_coefficient = segment_middle.optimization_coefficient;

		get_ab_segment_by_decrement_left(original_time_series_vector, segment_middle, temp_segment_middle);

		if (segment_middle.min_point.id == temp_segment_middle.right_endpoint - temp_segment_middle.rectangle_width || segment_middle.max_point.id == temp_segment_middle.right_endpoint - temp_segment_middle.rectangle_width) {
			getSegmentMinMaxPoint(original_time_series_vector, temp_segment_middle);
		}
		else {
			temp_segment_middle.min_point = segment_middle.min_point;
			temp_segment_middle.max_point = segment_middle.max_point;
		}

		//get_ab_minmax_segment(original_time_series_vector, temp_segment_middle);
		getAreaDifference(original_time_series_vector, temp_segment_middle);

		Y temp_segment_left;
		temp_segment_left.right_endpoint = segment_left.right_endpoint + 1;
		temp_segment_left.rectangle_width = segment_left.rectangle_width + 1;
		temp_segment_left.optimization_coefficient = segment_left.optimization_coefficient;
		get_ab_minmax_segment_by_accumulation(original_time_series_vector[temp_segment_left.right_endpoint], segment_left, temp_segment_left);
		getAreaDifference(original_time_series_vector, temp_segment_left);

#ifdef _DEBUG
		assert_segment_a_b_minmax(original_time_series_vector, temp_segment_middle);
		assert_segment_a_b_minmax(original_time_series_vector, temp_segment_left);
#endif

		if (temp_segment_middle.area_difference + temp_segment_left.area_difference < segment_middle.area_difference + segment_left.area_difference) {
			/*..............................................................................................................................*/
#ifdef _DEBUG
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/
			/*............................................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_middle.area_difference > 0);
#endif
			/*............................................................................................................................................................*/
			/*---------------------           Area Difference MAP Update:  left decrease & right increase        ---------------------------------*/
			if (temp_segment_middle.area_difference > 0) {
				updateMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference, temp_segment_middle.area_difference);//201005 For area difference
			}
			else {
				eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
			}

			if (segment_left.area_difference > 0 && temp_segment_left.area_difference > 0) {
				updateMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference, temp_segment_left.area_difference);//201005 For area difference
			}
			else if (temp_segment_left.area_difference > 0) {
				split_area_difference_map.emplace(temp_segment_left.area_difference, *node_max_area_difference._prev);
			}
			else if (segment_left.area_difference > 0 && temp_segment_left.area_difference == 0) {
				eraseMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference);
			}
			/*------------------------------------------------------------------------------------------------------------------------------------*/

			segment_middle = temp_segment_middle;
			segment_left = temp_segment_left;
			/*..............................................................................................................................*/
#ifdef _DEBUG
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/

			return true;
		}
		else {
			/*..............................................................................................................................*/
#ifdef _DEBUG
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/
			segment_left.optimization_coefficient.finish_right = true;
			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
			/*..............................................................................................................................*/
#ifdef _DEBUG
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/
			if (split_area_difference_map.empty()) return false;
			const auto& const left_node = node_max_area_difference._prev;
			if (!(*left_node)._prev || ((*left_node)._prev && (*left_node)._prev->_value.optimization_coefficient.finish_right)) {
				if (segment_left.area_difference > 0)
					eraseMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference);
				if (split_area_difference_map.empty()) return false;
			}
			return false;
		}

	}
	/*##########################################################################################################################################################*/

	/*..............................................................................................................................*/
#ifdef _DEBUG
	assert_split_map_area_difference(split_area_difference_map);
	//assert(!split_area_difference_map.empty());
	//evaluate right point, min&max point, width. a&b, sum value
	//assertLinkedList(original_time_series_vector, doubly_linked_list);
#endif
	/*.............................................................................................................................*/
}

//************************************
// Method:copy_optimization_coefficient
// Qualifier: left segment copy right segment. No label of optimization
// date:201227  08:56
// author:
//************************************
TEMPLATE
template<typename T>
inline void APLA::copy_optimization_coefficient(T& const segment_main, const T& const segment_copied) {
	segment_main.right_endpoint = segment_copied.right_endpoint;
	segment_main.rectangle_width = segment_copied.rectangle_width;
	segment_main.apla = segment_copied.apla;
	/*segment_main.min_point = segment_copied.min_point; 210203
	segment_main.max_point = segment_copied.max_point;*/
	segment_main.area_difference = segment_copied.area_difference;
	/*--------------- upper bound ----------------*/
	segment_main.bound = segment_copied.bound;
	/*--------------------------------------------*/
	/*..............................................................................................................................*/
#ifdef _DEBUG
	assert_segment_bound(segment_copied);
#endif
	/*.............................................................................................................................*/
}

//************************************
// Method:initial_segment_decrease_right
// Qualifier: initial segemnt decrease right point, a&b, area difference.
// date:201203  23:48
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
inline bool APLA::initial_segment_decrease_right(const vector<T>& const original_time_series_vector, const Y& const segment_original, Y& const segment_decrease_right, U& const output_argument) {
#ifdef _DEBUG
	assert(!segment_original.optimization_coefficient.finish_decrease_right && segment_original.rectangle_width > 2);
#endif
	/*if (segment_original.rectangle_width < 3) {
		assert(0);
		segment_original.optimization_coefficient.finish_decrease_right = true;
		return false;
	}*/

	/*----------------------------------------------------------*/
	segment_decrease_right.right_endpoint = segment_original.right_endpoint - 1;
	segment_decrease_right.rectangle_width = segment_original.rectangle_width - 1;
	//segment_decrease_right.optimization_coefficient = segment_original.optimization_coefficient;
	/*----------------------------------------------------------*/

	if (segment_decrease_right.rectangle_width < 3) {
		segment_decrease_right.optimization_coefficient.finish_decrease_right = true;
	}

	/*-------------------------- a&b --------------------------------*/
	get_ab_segment_by_decrement(original_time_series_vector, segment_original, segment_decrease_right);
	/*---------------------------------------------------------------*/

	/*-------------------------- 210203 min&max ----------------------------*/
	/*if (segment_original.min_point.id == segment_original.right_endpoint || segment_original.max_point.id == segment_original.right_endpoint) {
		getSegmentMinMaxPoint(original_time_series_vector, segment_decrease_right);
	}
	else {
		segment_decrease_right.min_point = segment_original.min_point;
		segment_decrease_right.max_point = segment_original.max_point;
	}*/
	/*---------------------------------------------------------------*/

#ifdef _DEBUG
	//assert_segment_a_b_minmax(original_time_series_vector, segment_original);
	//assert_segment_a_b_minmax(original_time_series_vector, segment_decrease_right);
	assert_segment_a_b(original_time_series_vector, segment_original);
	assert_segment_a_b(original_time_series_vector, segment_decrease_right);
#endif

	/*-----------------------------------      compute upper bound       -------------------------------*/
	get_upper_bound_move_endpoint(original_time_series_vector, segment_original, segment_decrease_right, output_argument);
	/*--------------------------------------------------------------------------------------------------*/

	/*-------------------------- 210203 area difference --------------------*/
	//getAreaDifference(original_time_series_vector, segment_decrease_right);
	/*---------------------------------------------------------------*/
#ifdef _DEBUG
	assert_segment_bound(original_time_series_vector, segment_original);
	assert_segment_bound(original_time_series_vector, segment_decrease_right);
#endif
	return true;
}

//************************************
// Method:initial_segment_increase_right
// Qualifier: initial segemnt increase right point, a&b, area difference.
// date:201205  16:58
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
inline void APLA::initial_segment_increase_right(const vector<T>& const original_time_series_vector, const Y& const segment_original, Y& const segment_increase_right, U& const output_argument) {

	segment_increase_right.right_endpoint = segment_original.right_endpoint + 1;
	segment_increase_right.rectangle_width = segment_original.rectangle_width + 1;
	//segment_increase_right.optimization_coefficient = segment_original.optimization_coefficient;

	get_ab_minmax_segment_by_accumulation(original_time_series_vector[segment_increase_right.right_endpoint], segment_original, segment_increase_right);

	/*-----------------------------------      compute upper bound       -------------------------------*/
	get_upper_bound_move_endpoint(original_time_series_vector, segment_original, segment_increase_right, output_argument);
	/*--------------------------------------------------------------------------------------------------*/

	//getAreaDifference(original_time_series_vector, segment_increase_right); // 210203

#ifdef _DEBUG
	/*assert_segment_a_b_minmax(original_time_series_vector, segment_original);
	assert_segment_a_b_minmax(original_time_series_vector, segment_increase_right);*/
	assert_segment_a_b(original_time_series_vector, segment_original);
	assert_segment_a_b(original_time_series_vector, segment_increase_right);
	assert_segment_bound(original_time_series_vector, segment_original);
	assert_segment_bound(original_time_series_vector, segment_increase_right);
#endif
}

//************************************
// Method:initial_segment_increase_left
// Qualifier: initial segemnt increase left point, a&b, area difference.
// date:201204  00:39
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
inline void APLA::initial_segment_increase_left(const vector<T>& const original_time_series_vector, const Y& const segment_original, Y& const segment_increase_left, U& const output_argument) {
	segment_increase_left.right_endpoint = segment_original.right_endpoint;
	segment_increase_left.rectangle_width = segment_original.rectangle_width + 1;
	//segment_increase_left.optimization_coefficient = segment_original.optimization_coefficient;

	get_ab_segment_by_accumulation_left(original_time_series_vector[segment_original.right_endpoint - segment_original.rectangle_width], segment_original, segment_increase_left);

	/*if (original_time_series_vector[segment_original.right_endpoint - segment_original.rectangle_width] > segment_original.max_point.value) {
		segment_increase_left.max_point.value = original_time_series_vector[segment_original.right_endpoint - segment_original.rectangle_width];
		segment_increase_left.max_point.id = segment_original.right_endpoint - segment_original.rectangle_width;
	}
	else {
		segment_increase_left.max_point = segment_original.max_point;
	}

	if (original_time_series_vector[segment_original.right_endpoint - segment_original.rectangle_width] < segment_original.min_point.value) {
		segment_increase_left.min_point.value = original_time_series_vector[segment_original.right_endpoint - segment_original.rectangle_width];
		segment_increase_left.min_point.id = segment_original.right_endpoint - segment_original.rectangle_width;
	}
	else {
		segment_increase_left.min_point = segment_original.min_point;
	} 210203 */

#ifdef _DEBUG
	/*assert_segment_a_b_minmax(original_time_series_vector, segment_original);
	assert_segment_a_b_minmax(original_time_series_vector, segment_increase_left);*/
	assert_segment_a_b(original_time_series_vector, segment_original);
	assert_segment_a_b(original_time_series_vector, segment_increase_left);
#endif

	/*-----------------------------------      compute upper bound       -------------------------------*/
	get_upper_bound_move_endpoint(original_time_series_vector, segment_original, segment_increase_left, output_argument);
	/*--------------------------------------------------------------------------------------------------*/

	//get_ab_minmax_segment(original_time_series_vector, segment_increase_left);
	//getAreaDifference(original_time_series_vector, segment_increase_left); 210203

#ifdef _DEBUG
	assert_segment_bound(original_time_series_vector, segment_original);
	assert_segment_bound(original_time_series_vector, segment_increase_left);
#endif
}

//************************************
// Method:initial_segment_decrease_left
// Qualifier: initial segemnt decrease left point, a&b, area difference.
// date:201211  20:02
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
inline bool APLA::initial_segment_decrease_left(const vector<T>& const original_time_series_vector, const Y& const segment_original, Y& const segment_decrease_left, U& const output_argument) {
	assert(!segment_original.optimization_coefficient.finish_decrease_left && segment_original.rectangle_width > 2);

	/*if (segment_original.rectangle_width < 3) {
		assert(0);
		segment_original.optimization_coefficient.finish_decrease_left = true;
		return false;
	}*/

	segment_decrease_left.right_endpoint = segment_original.right_endpoint;
	segment_decrease_left.rectangle_width = segment_original.rectangle_width - 1;
	//segment_decrease_left.optimization_coefficient = segment_original.optimization_coefficient;

	if (segment_decrease_left.rectangle_width < 3) {
		segment_decrease_left.optimization_coefficient.finish_decrease_left = true;
	}

	get_ab_segment_by_decrement_left(original_time_series_vector, segment_original, segment_decrease_left);

	/*if (segment_original.min_point.id == segment_decrease_left.right_endpoint - segment_decrease_left.rectangle_width || segment_original.max_point.id == segment_decrease_left.right_endpoint - segment_decrease_left.rectangle_width) {
		getSegmentMinMaxPoint(original_time_series_vector, segment_decrease_left);
	}
	else {
		segment_decrease_left.min_point = segment_original.min_point;
		segment_decrease_left.max_point = segment_original.max_point;
	} 210203 */

	//get_ab_minmax_segment(original_time_series_vector, segment_decrease_left);
#ifdef _DEBUG
	/*assert_segment_a_b_minmax(original_time_series_vector, segment_original);
	assert_segment_a_b_minmax(original_time_series_vector, segment_decrease_left);*/

	assert_segment_a_b(original_time_series_vector, segment_original);
	assert_segment_a_b(original_time_series_vector, segment_decrease_left);
#endif

	/*-----------------------------------      compute upper bound       -------------------------------*/
	get_upper_bound_move_endpoint(original_time_series_vector, segment_original, segment_decrease_left, output_argument);
	/*--------------------------------------------------------------------------------------------------*/

	//getAreaDifference(original_time_series_vector, segment_decrease_left); 210203

#ifdef _DEBUG
	assert_segment_bound(original_time_series_vector, segment_original);
	assert_segment_bound(original_time_series_vector, segment_decrease_left);
#endif

	return true;
}

//************************************
// Method:compare_segment_right_decrease
// Qualifier: compare if segment decrease right endpoint can decrease area difference
// date:201204  01:11
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename T1>
inline bool APLA::compare_segment_right_decrease(multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map, T& const node_max_area_difference, Y& const segment_middle, const Y& const temp_segment_decrease_right, Y& const segment_right, const Y& const temp_segment_increase_left) {
	/*||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||       If Area Difference Decreased       ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||*/
	if (temp_segment_decrease_right.area_difference + temp_segment_increase_left.area_difference < segment_middle.area_difference + segment_right.area_difference) {
		/*---------------------           Area Difference MAP Update:  left decrease & right increase        ---------------------------------*/
		/*................................................................*/
#ifdef _DEBUG
		assert(segment_middle.area_difference > 0);
		assert_split_map_area_difference(split_area_difference_map);
#endif
		/*................................................................*/

		if (temp_segment_decrease_right.area_difference > 0) {
			updateMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference, temp_segment_decrease_right.area_difference);//201005 For area difference
		}
		else {
			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
		}

		if (segment_right.area_difference > 0 && temp_segment_increase_left.area_difference > 0) {
			updateMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference, temp_segment_increase_left.area_difference);//201005 For area difference
		}
		else if (temp_segment_increase_left.area_difference > 0) {
			split_area_difference_map.emplace(temp_segment_increase_left.area_difference, *node_max_area_difference._next);
		}
		else if (segment_right.area_difference > 0 && temp_segment_increase_left.area_difference == 0) {
			eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
		}

		/*------------------------------------------------------------------------------------------------------------------------------------*/

		segment_middle = temp_segment_decrease_right;
		segment_right = temp_segment_increase_left;

		/*...........................................................................*/
#ifdef _DEBUG
		assert(segment_middle.right_endpoint + 1 == segment_middle.rectangle_width);
#endif
		/*...........................................................................*/

		return true;
	}
	else {
		/*...............................................................................................................*/
#ifdef _DEBUG
		assert(segment_middle.rectangle_width > 2);
#endif
		/*................................................................................................................*/

		segment_middle.optimization_coefficient.finish_decrease_right = true;
		segment_middle.optimization_coefficient.finish_right = true;

		if (segment_right.optimization_coefficient.finish_right)
			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);

		if (split_area_difference_map.empty()) return false;

		if (segment_right.optimization_coefficient.finish_right) {
			if (segment_right.area_difference > 0)
				eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
			if (split_area_difference_map.empty()) return false;
		}
		//return false;
	}
	/*|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||*/
}

//************************************
// Method:compare_segment_left_decrease
// Qualifier: Compare if segment decrease left endpoint can decrease area difference
// date:201213  09:19
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename T1>
inline bool APLA::compare_segment_left_decrease(multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map, T& const node_max_area_difference, Y& const segment_middle, const Y& const temp_segment_decrease_left, Y& const segment_left, const Y& const temp_segment_increase_right) {
	if (temp_segment_decrease_left.area_difference + temp_segment_increase_right.area_difference < segment_middle.area_difference + segment_left.area_difference) {

		/*..............................................................................................................................*/
#ifdef _DEBUG
		assert(segment_middle.area_difference > 0);
		assert_split_map_area_difference(split_area_difference_map);
#endif
		/*..............................................................................................................................*/

		/*---------------------           Area Difference MAP Update:  left decrease & right increase        ---------------------------------*/
		if (temp_segment_decrease_left.area_difference > 0) {
			updateMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference, temp_segment_decrease_left.area_difference);//201005 For area difference
		}
		else {
			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
		}

		if (segment_left.area_difference > 0 && temp_segment_increase_right.area_difference > 0) {
			updateMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference, temp_segment_increase_right.area_difference);//201005 For area difference
		}
		else if (temp_segment_increase_right.area_difference > 0) {
			split_area_difference_map.emplace(temp_segment_increase_right.area_difference, *node_max_area_difference._prev);
		}
		else if (segment_left.area_difference > 0 && temp_segment_increase_right.area_difference == 0) {
			eraseMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference);
		}
		/*------------------------------------------------------------------------------------------------------------------------------------*/

		segment_middle = temp_segment_decrease_left;
		segment_left = temp_segment_increase_right;

		return true;
	}
	else {
		/*..............................................................................................................................*/
#ifdef _DEBUG
		assert_split_map_area_difference(split_area_difference_map);
#endif
		/*..............................................................................................................................*/
		segment_left.optimization_coefficient.finish_right = true;

		if (segment_middle.optimization_coefficient.finish_right == true) {
			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
			if (split_area_difference_map.empty()) return false;
		}

		const auto& const left_node = node_max_area_difference._prev;
		if (!(*left_node)._prev || ((*left_node)._prev && (*left_node)._prev->_value.optimization_coefficient.finish_right == true)) {
			if (segment_left.area_difference > 0)
				eraseMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference);
			if (split_area_difference_map.empty()) return false;
		}
		return true;
	}
}

//************************************
// Method:optimize_segment_max_area_difference_speed1
// Qualifier: 201203 Speed up. move the left / right endpoint of max area difference segment
// date:201213  09:19
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename T1>
bool APLA::optimize_segment_max_area_difference_speed1(const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map) {
	/*........................................................................*/
#ifdef _DEBUG
	assert(!split_area_difference_map.empty());
	assert_split_map_area_difference(split_area_difference_map);
	//evaluate right point, min&max point, width. a&b, sum value
	//assertLinkedList(original_time_series_vector, doubly_linked_list);
#endif
	/*.......................................................................*/

	/*#################################################### Coefficients of Split #################################################################################*/

	/*===============================     width = 2, no space to decrease    =========================================*/
	while (split_area_difference_map.begin()->second._value.rectangle_width < 3 || split_area_difference_map.begin()->second._value.area_difference == 0) {
		//split_area_difference_map.begin()->second._value.optimization_coefficient.finish_right = true;
		eraseMapByKey(split_area_difference_map, split_area_difference_map.begin()->second._value.right_endpoint, split_area_difference_map.begin()->second._value.area_difference);
		if (split_area_difference_map.empty()) return false;
	}
	/*================================================================================================================*/

	/*========================================   Split Candidate Long segment  ========================================*/
	auto& const node_max_area_difference = split_area_difference_map.begin()->second;
	auto& const segment_middle = node_max_area_difference._value;
	/*=================================================================================================================*/

	/*##########################################################################################################################################################*/

	/*########################################### Move endpoint of max area difference #########################################################################*/
	if (!node_max_area_difference._prev) {//head node
		/*.....................................................................................................................................*/
#ifdef _DEBUG
		assert(segment_middle.right_endpoint + 1 == segment_middle.rectangle_width && !segment_middle.optimization_coefficient.finish_right);
		assert_split_map_area_difference(split_area_difference_map);
#endif
		/*......................................................................................................................................*/

		segment_middle.optimization_coefficient.finish_decrease_left = true;

		/*---------------------    right segment  ---------------------*/
		Y& const segment_right = node_max_area_difference._next->_value;
		/*-------------------------------------------------------------*/

		/*:::::::  Head segment area difference == right segment == 0, no need to adjust endpoint :::::::::::::::::*/
		if (segment_middle.area_difference == 0 && segment_right.area_difference == 0) {

			/*********************************         Erase head node            *********************************/
			segment_middle.optimization_coefficient.finish_right = true;
			segment_middle.optimization_coefficient.finish_decrease_right = true;
			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
			if (split_area_difference_map.empty()) return false;
			/******************************************************************************************************/

			/*********************************         Erase right node            *********************************/
			//if (segment_right.optimization_coefficient.finish_decrease_left && segment_right.optimization_coefficient.finish_decrease_right) {
			if (segment_right.optimization_coefficient.finish_right) {
				eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
				if (split_area_difference_map.empty()) return false;
			}
			/******************************************************************************************************/

			/*..........................................................*/
#ifdef _DEBUG
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*...........................................................*/
			return false;
		}
		/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

		/*++++++++++++++++++++++++++++++++++++++++++++++++    Decrease right endpoint of Middle segment    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		Y temp_segment_decrease_right;
		initial_segment_decrease_right(original_time_series_vector, segment_middle, temp_segment_decrease_right);

		Y temp_segment_increase_left;
		initial_segment_increase_left(original_time_series_vector, segment_right, temp_segment_increase_left);

		/*||||||||||||||||||||||||||||||||||||||||||||||||       If Area Difference Decreased       |||||||||||||||||||||||||||||||||||||||||||||||||||||*/
		compare_segment_right_decrease(split_area_difference_map, node_max_area_difference, segment_middle, temp_segment_decrease_right, segment_right, temp_segment_increase_left);
		/*|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||*/
		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	}
	else if (node_max_area_difference._next) {//middle node

		/*..............................................................................................................................*/
#ifdef _DEBUG
		assert_split_map_area_difference(split_area_difference_map);
#endif
		/*..............................................................................................................................*/

		Y& const segment_left = node_max_area_difference._prev->_value;
		Y& const segment_right = node_max_area_difference._next->_value;

		/*::::::::  Middle segment area difference == right segment == 0 / Middle segment area difference == right segment == 0. No need to adjust endpoint  :::::::::*/
		/*==========================================      middle, right area difference == 0    ==========================================*/
		if (segment_middle.area_difference == 0 && segment_right.area_difference == 0) {
			segment_middle.optimization_coefficient.finish_right = true;

			if (segment_left.optimization_coefficient.finish_right) {
				eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
				if (split_area_difference_map.empty()) return false;
			}

			if (segment_right.optimization_coefficient.finish_right) {
				eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
				if (split_area_difference_map.empty()) return false;
			}
		}
		/*=================================================================================================================================*/
		/*==========================================       left, middle area difference == 0     ==========================================*/
		if (segment_middle.area_difference == 0 && segment_left.area_difference == 0) {
			segment_left.optimization_coefficient.finish_right = true;

			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
			if (split_area_difference_map.empty()) return false;

			const auto& const left_node = node_max_area_difference._prev;
			if (!(*left_node)._prev || ((*left_node)._prev && (*left_node)._prev->_value.optimization_coefficient.finish_right)) {//left is head node or LR finish optimization 
				eraseMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference);
				if (split_area_difference_map.empty()) return false;
			}

			//return false;
		}
		/*=================================================================================================================================*/
		/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

		const int id_left = segment_middle.right_endpoint - segment_middle.rectangle_width + 1;
		const long double height_difference_left = fabs(segment_middle.apla.b - original_time_series_vector[id_left]);
		const long double height_difference_right = fabs(segment_middle.apla.a * (segment_middle.rectangle_width - 1) + segment_middle.apla.b - original_time_series_vector[segment_middle.right_endpoint]);

		/*+++++++++++++++++++++    Left height difference <  Right height difference / Left segment has finished && middle segment has not finished    ++++++++++++++++++*/
		if ((height_difference_left < height_difference_right && segment_middle.optimization_coefficient.finish_right == false) || (segment_left.optimization_coefficient.finish_right == true && segment_middle.optimization_coefficient.finish_right == false)) {

			/*............................................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_middle.optimization_coefficient.finish_right == false);
			if (height_difference_left >= height_difference_right) {
				assert(segment_left.optimization_coefficient.finish_right == true);
			}
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*............................................................................................................................................................*/

			Y temp_segment_decrease_right;
			initial_segment_decrease_right(original_time_series_vector, segment_middle, temp_segment_decrease_right);

			Y temp_segment_increase_left;
			initial_segment_increase_left(original_time_series_vector, segment_right, temp_segment_increase_left);

			/*||||||||||||||||||||||||||||||||||||||||||||||||       If Area Difference Decreased       |||||||||||||||||||||||||||||||||||||||||||||||||||||*/
			compare_segment_right_decrease(split_area_difference_map, node_max_area_difference, segment_middle, temp_segment_decrease_right, segment_right, temp_segment_increase_left);
			/*|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||*/
		}/*+++++++++++++++++++++    Left height difference >= Right height difference / Left segment has not finished && middle segment has finished    ++++++++++++++++++*/
		else if ((height_difference_left >= height_difference_right && segment_left.optimization_coefficient.finish_right == false) || (segment_left.optimization_coefficient.finish_right == false && segment_middle.optimization_coefficient.finish_right == true)) {
			auto& const segment_left = node_max_area_difference._prev->_value;
			/*............................................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_left.optimization_coefficient.finish_right == false);

			if (height_difference_left < height_difference_right) {
				assert(segment_middle.optimization_coefficient.finish_right == true);
			}
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/

			Y temp_segment_decrease_left;
			initial_segment_decrease_left(original_time_series_vector, segment_middle, temp_segment_decrease_left);

			Y temp_segment_increase_right;
			initial_segment_increase_right(original_time_series_vector, segment_left, temp_segment_increase_right);

			/*||||||||||||||||||||||||||||||||||||||||||||||||       If Area Difference Decreased       |||||||||||||||||||||||||||||||||||||||||||||||||||||*/
			compare_segment_left_decrease(split_area_difference_map, node_max_area_difference, segment_middle, temp_segment_decrease_left, segment_left, temp_segment_increase_right);
			/*|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||*/
		}
		else {
			//assert(0);
			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
			if (split_area_difference_map.empty()) return false;
			return true;
		}
	}
	else {//tail node

		/*..............................................................................................................................*/
#ifdef _DEBUG
		assert_split_map_area_difference(split_area_difference_map);
#endif
		/*..............................................................................................................................*/

		Y& const segment_left = node_max_area_difference._prev->_value;

		if (segment_middle.area_difference == 0 && segment_left.area_difference == 0) {
			segment_left.optimization_coefficient.finish_right = true;
			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
			if (split_area_difference_map.empty()) return false;
			const auto& const left_node = node_max_area_difference._prev;
			if (!(*left_node)._prev || ((*left_node)._prev && (*left_node)._prev->_value.optimization_coefficient.finish_right)) {
				eraseMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference);
				if (split_area_difference_map.empty()) return false;
			}
			return false;
		}

		/*............................................................................................................................................................*/
#ifdef _DEBUG
		assert(node_max_area_difference._prev && !node_max_area_difference._next && segment_middle.optimization_coefficient.finish_right && !segment_left.optimization_coefficient.finish_right);
#endif
		/*.............................................................................................................................................................*/

		Y temp_segment_middle;
		initial_segment_decrease_left(original_time_series_vector, segment_middle, temp_segment_middle);

		Y temp_segment_left;
		initial_segment_increase_right(original_time_series_vector, segment_left, temp_segment_left);

		compare_segment_left_decrease(split_area_difference_map, node_max_area_difference, segment_middle, temp_segment_middle, segment_left, temp_segment_left);

	}
	/*##########################################################################################################################################################*/

	/*..............................................................................................................................*/
#ifdef _DEBUG
	assert_split_map_area_difference(split_area_difference_map);
	//assert(!split_area_difference_map.empty());
	//evaluate right point, min&max point, width. a&b, sum value
	//assertLinkedList(original_time_series_vector, doubly_linked_list);
#endif
	/*.............................................................................................................................*/
}

//************************************
// Method:erase_node_if_no_need_adjust
// Qualifier:
// date:201214  10:12
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline bool APLA::erase_node_if_no_need_adjust(multimap<T, DoublyListNode<Y>& const, greater<T>>& const split_area_difference_map, const DoublyListNode<Y>& const node_candidate_erase) {

	/*..........................................................*/
#ifdef _DEBUG
	assert_split_map_optimization(split_area_difference_map);
#endif
	/*..........................................................*/
	if (split_area_difference_map.empty()) return false;

	const Y& const segment_candidate_erase = node_candidate_erase._value;

	if (find_key_in_map(split_area_difference_map, segment_candidate_erase.area_difference) && (!node_candidate_erase._prev || (segment_candidate_erase.optimization_coefficient.finish_decrease_left && node_candidate_erase._prev->_value.optimization_coefficient.finish_decrease_right))) {
		if (!node_candidate_erase._next || (segment_candidate_erase.optimization_coefficient.finish_decrease_right && node_candidate_erase._next->_value.optimization_coefficient.finish_decrease_left)) {
			eraseMapByKey(split_area_difference_map, segment_candidate_erase.right_endpoint, segment_candidate_erase.area_difference);
			if (split_area_difference_map.empty()) return false;
			return true;
		}
		else return true;
	}
	else return true;

}

//************************************
// Method:Update_segment_map_by_min_area_difference
// Qualifier:
// date:201214  11:13
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline void APLA::update_segment_map_by_min_area_difference(multimap<T, DoublyListNode<Y>& const, greater<T>>& const split_area_difference_map, Y& const segment_decrease, const Y& const temp_segment_decrease, Y& const segment_increase, const Y& const temp_segment_increase, DoublyListNode<Y>& const node_increase) {

	/*---------------------           Area Difference MAP Update:  left decrease & right increase        ---------------------------------*/
	/*................................................................*/
#ifdef _DEBUG
	assert(segment_decrease.area_difference > 0);
	assert_split_map_area_difference(split_area_difference_map);

	for (auto&& au : split_area_difference_map) {
		assert(au.first > 0 && au.second._value.rectangle_width > 2);
	}
#endif
	/*................................................................*/

	if (temp_segment_decrease.area_difference > 0 && temp_segment_decrease.rectangle_width > 2) {
		updateMapByKey(split_area_difference_map, segment_decrease.right_endpoint, segment_decrease.area_difference, temp_segment_decrease.area_difference);//201005 For area difference
	}
	else if (segment_decrease.rectangle_width > 3) {
		eraseMapByKey(split_area_difference_map, segment_decrease.right_endpoint, segment_decrease.area_difference);
	}

	if (segment_increase.area_difference > 0 && temp_segment_increase.area_difference > 0 && segment_increase.rectangle_width > 2) {
		updateMapByKey(split_area_difference_map, segment_increase.right_endpoint, segment_increase.area_difference, temp_segment_increase.area_difference);//201005 For area difference
	}
	else if (temp_segment_increase.area_difference > 0) {
		split_area_difference_map.emplace(temp_segment_increase.area_difference, node_increase);
	}
	else if (segment_increase.area_difference > 0 && temp_segment_increase.area_difference == 0 && segment_increase.rectangle_width > 2) {
		eraseMapByKey(split_area_difference_map, segment_increase.right_endpoint, segment_increase.area_difference);
	}

	/*------------------------------------------------------------------------------------------------------------------------------------*/

	segment_decrease = temp_segment_decrease;
	segment_increase = temp_segment_increase;
}


//************************************
// Method:update_segment_map_by_min_area_difference
// Qualifier:
// date:201223  15:41
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline void APLA::update_segment_map_by_min_area_difference(multimap<T, DoublyListNode<Y>& const, greater<T>>& const split_area_difference_map, const Y& const temp_segment_move, DoublyListNode<Y>& const node_original) {
	/*####################################    Area Difference MAP Update:  left decrease & right increase    ####################################*/
	/*..........................................................*/
#ifdef _DEBUG
	assert_split_map_optimization(split_area_difference_map);
#endif
	/*..........................................................*/

	if (split_area_difference_map.empty()) return;

	Y& const segment_original = node_original._value;

	if (find_key_in_map(split_area_difference_map, segment_original.area_difference)) {

		/*...................................................................................*/
#ifdef _DEBUG
		//assert(segment_original.area_difference > 0 && segment_original.rectangle_width > 2);
#endif
		/*...................................................................................*/

		if (!segment_original.optimization_coefficient.finish_decrease_left || !segment_original.optimization_coefficient.finish_decrease_right) {
			updateMapByKey(split_area_difference_map, segment_original.right_endpoint, segment_original.area_difference, temp_segment_move.area_difference);//201005 For area difference
		}
		else {
			eraseMapByKey(split_area_difference_map, segment_original.right_endpoint, segment_original.area_difference);
			//erase_node_if_no_need_adjust(split_area_difference_map, node_original);
		}
	}
	else if (!segment_original.optimization_coefficient.finish_decrease_left || !segment_original.optimization_coefficient.finish_decrease_right) {
		/*...................................................................................*/
#ifdef _DEBUG
		assert(!find_key_in_map(split_area_difference_map, segment_original.area_difference));
		//assert(!segment_original.optimization_coefficient.finish_decrease_left || !segment_original.optimization_coefficient.finish_decrease_right);
#endif
		/*...................................................................................*/

		split_area_difference_map.emplace(temp_segment_move.area_difference, node_original);
	}

	/*################################################################################################################################################*/

	//segment_original = temp_segment_move;
	copy_optimization_coefficient(segment_original, temp_segment_move);

	/*.........................................................*/
#ifdef _DEBUG
	assert_split_map_optimization(split_area_difference_map);
#endif
	/*.........................................................*/
}

//************************************
// Method:erase_if_adjacent_segments_are_zeros
// Qualifier:
// date:201215 16:01
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline void APLA::erase_if_adjacent_segments_are_zeros(multimap<T, DoublyListNode<Y>& const, greater<T>>& const split_area_difference_map, DoublyListNode<Y>& const node_middle) {
	Y& const segment_middle = node_middle._value;
	Y& const segment_right = node_middle._next->_value;

	if (segment_middle.rectangle_width < 3)
		segment_middle.optimization_coefficient.finish_decrease_left = segment_middle.optimization_coefficient.finish_decrease_right = true;

	if (segment_right.rectangle_width < 3)
		segment_right.optimization_coefficient.finish_decrease_left = segment_right.optimization_coefficient.finish_decrease_right = true;

	/*======================      middle, right area difference == 0    ===================================*/
	if (segment_middle.area_difference == 0 && segment_right.area_difference == 0) {
		segment_middle.optimization_coefficient.finish_decrease_right = true;
		segment_right.optimization_coefficient.finish_decrease_left = true;
	}
	/*======================================================================================================*/

	/********************************* Erase middle node    *****************************/
	erase_node_if_no_need_adjust(split_area_difference_map, node_middle);
	/************************************************************************************/

	if (split_area_difference_map.empty()) return;

	/****************************   Erase right node    *********************************/
	erase_node_if_no_need_adjust(split_area_difference_map, *node_middle._next);
	/*************************************************************************************/
}

//************************************
// Method:adjust_compute_segment_right
// Qualifier:
// date:201215 20:31
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename T1, typename U>
bool APLA::adjust_compute_segment_right(const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map, DoublyListNode<Y>& const node_middle, U& const output_argument) {
	/*...........................................................*/
#ifdef _DEBUG
	assert_split_map_optimization(split_area_difference_map);
#endif
	/*...........................................................*/

	/*---------------------    right segment  ---------------------*/
	Y& const segment_middle = node_middle._value;
	Y& const segment_right = node_middle._next->_value;
	/*-------------------------------------------------------------*/

	/*..........................................................*/
#ifdef _DEBUG
	assert_if_finish_move(segment_middle, segment_right);
#endif
	/*......................................................*/

	Y temp_segment_middle_decrease_right;
	Y temp_segment_right_increase_left;
	Y temp_segment_middle_increase_right;
	Y temp_segment_right_decrease_left;

	multimap<long double, size_t> map_new_area_difference_adjust_type;

	long double area_difference_min_current = segment_middle.area_difference + segment_right.area_difference;

	map_new_area_difference_adjust_type.emplace(0, 0);

	/*++++++++++++++++++++++++++++++++++++++++++++++++    Decrease right endpoint of Middle segment    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	compute_segment_decrease_right(original_time_series_vector, 1, area_difference_min_current, map_new_area_difference_adjust_type, segment_middle, segment_right, temp_segment_middle_decrease_right, temp_segment_right_increase_left, output_argument);
	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*++++++++++++++++++++++++++++++++++++++++++++++++    Increase right endpoint of Middle segment    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	compute_segment_increase_right(original_time_series_vector, 2, area_difference_min_current, map_new_area_difference_adjust_type, segment_middle, segment_right, temp_segment_middle_increase_right, temp_segment_right_decrease_left, output_argument);
	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*++++++++++++++++++++++++++++++++++++++++++++++++    Increase right endpoint of Middle segment    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/*segment_middle.optimization_coefficient.finish_decrease_right = true;
	segment_right.optimization_coefficient.finish_decrease_left = true;*/

	switch (map_new_area_difference_adjust_type.begin()->second) {
	case 0: {
		if (!node_middle._prev) {

			if (segment_middle.rectangle_width > 2) {

				/*..................................................................*/
#ifdef _DEBUG
				//assert(segment_middle.optimization_coefficient.finish_decrease_left);
#endif
				/*..................................................................*/

				eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);

				//erase_node_if_no_need_adjust(split_area_difference_map, *(node_middle._next));
				label_right_node_erase_emplace_map(split_area_difference_map, node_middle);

			}

		}
		else if (!node_middle._next->_next) {

			/*..................................................................*/
#ifdef _DEBUG
			assert(segment_right.optimization_coefficient.finish_decrease_right);
#endif
			/*..................................................................*/

			eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
			//erase_node_if_no_need_adjust(split_area_difference_map, node_middle);
			label_left_node_erase_emplace_map(split_area_difference_map, *(node_middle._next));
		}
		else {
			assert(0);
		}

		/*.................................................*/
#ifdef _DEBUG
		assert_if_finish_move(segment_middle, segment_right);
		assert_split_map_optimization(split_area_difference_map);
#endif
		/*.................................................*/

		return false;

		break;
	}
	case 1: {// middle segment should decrease right point, right segment should increase left.
		//update_segment_map_by_min_area_difference(split_area_difference_map, segment_middle, temp_segment_middle_decrease_right, segment_right, temp_segment_right_increase_left, *(node_middle._next));

		if (!node_middle._prev) {// Head Node

			/*..................................................................*/
#ifdef _DEBUG
			assert(segment_middle.optimization_coefficient.finish_decrease_left);
#endif
			/*..................................................................*/

			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
			update_right_node_label_map(split_area_difference_map, node_middle, temp_segment_middle_decrease_right, temp_segment_right_increase_left);
			/*copy_optimization_coefficient(segment_middle, temp_segment_middle_decrease_right);
			update_segment_map_by_min_area_difference(split_area_difference_map, temp_segment_right_increase_left, *(node_middle._next));*/
		}
		else if (!node_middle._next->_next) {// Tail Node

			/*..................................................................*/
#ifdef _DEBUG
			assert(segment_right.optimization_coefficient.finish_decrease_right);
#endif
			/*..................................................................*/

			eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
			update_left_node_label_map(split_area_difference_map, *(node_middle._next), temp_segment_middle_decrease_right, temp_segment_right_increase_left);
			/*copy_optimization_coefficient(segment_right, temp_segment_right_increase_left);
			update_segment_map_by_min_area_difference(split_area_difference_map, temp_segment_middle_decrease_right, node_middle);*/
		}
		else {
			assert(0);
		}
		/*.................................................*/
#ifdef _DEBUG
		assert_if_finish_move(segment_middle, segment_right);
		assert_split_map_optimization(split_area_difference_map);
#endif
		/*.................................................*/
		/*update_segment_map_by_min_area_difference(split_area_difference_map, temp_segment_middle_decrease_right, node_middle);
		if (split_area_difference_map.empty()) return false;
		update_segment_map_by_min_area_difference(split_area_difference_map, temp_segment_right_increase_left, *(node_middle._next));*/

		return true;
		break;
	}
	case 2: {// middle segment should increase right point, right segment should decrease left

		if (!node_middle._prev) {// Head Node

			/*..................................................................*/
#ifdef _DEBUG
			assert(segment_middle.optimization_coefficient.finish_decrease_left);
#endif
			/*..................................................................*/

			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
			update_right_node_label_map(split_area_difference_map, node_middle, temp_segment_middle_increase_right, temp_segment_right_decrease_left);
			/*copy_optimization_coefficient(segment_middle, temp_segment_middle_increase_right);
			update_segment_map_by_min_area_difference(split_area_difference_map, temp_segment_right_decrease_left, *(node_middle._next));*/
		}
		else if (!node_middle._next->_next) {// Tail Node

			/*..................................................................*/
#ifdef _DEBUG
			assert(segment_right.optimization_coefficient.finish_decrease_right);
#endif
			/*..................................................................*/

			eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
			update_left_node_label_map(split_area_difference_map, *(node_middle._next), temp_segment_middle_increase_right, temp_segment_right_decrease_left);
			/*copy_optimization_coefficient(segment_right, temp_segment_right_decrease_left);
			update_segment_map_by_min_area_difference(split_area_difference_map, temp_segment_middle_increase_right, node_middle);*/
		}
		else {
			assert(0);
		}

		/*.................................................*/
#ifdef _DEBUG
		assert_if_finish_move(segment_middle, segment_right);
		assert_split_map_optimization(split_area_difference_map);
#endif
		/*.................................................*/

		/*update_segment_map_by_min_area_difference(split_area_difference_map, temp_segment_middle_increase_right, node_middle);
		if (split_area_difference_map.empty()) return false;
		update_segment_map_by_min_area_difference(split_area_difference_map, temp_segment_right_decrease_left, *(node_middle._next))*/;

		return true;
		break;
	}
	default:
		assert(0);
	}
	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

}

//************************************
// Method:assert_if_finish_move
// Qualifier:
// date:201226 12:14
// author:
//************************************
TEMPLATE
template<typename T>
inline bool APLA::assert_if_finish_move(const T& const segment_middle, const T& const segment_right) {
	assert(segment_middle.right_endpoint == segment_right.right_endpoint - segment_right.rectangle_width);
	if (segment_middle.optimization_coefficient.finish_decrease_right) {
		assert(segment_right.optimization_coefficient.finish_decrease_left);
	}
	else {
		assert(!segment_right.optimization_coefficient.finish_decrease_left);
	}
	return true;
}

//************************************
// Method:compute_segment_decrease_increase_right
// Qualifier:
// date:201226 09:34
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename T1, typename T2, typename T3, typename T4, typename U>
void APLA::compute_segment_decrease_right(const vector<T>& const original_time_series_vector, const T3 type_move, T4& const area_difference_min_other, multimap<T1, T2>& const map_new_area_difference_adjust_type, const Y& const segment_original_middle, const Y& const segment_original_right, Y& const segment_middle_decrease_right, Y& const segment_right_increase_left, U& const output_argument) {

	/*...............................................................................................................................*/
#ifdef _DEBUG
	assert_if_finish_move(segment_original_middle, segment_original_right);
	assert_segment_bound(original_time_series_vector, segment_original_middle);
	assert_segment_bound(original_time_series_vector, segment_original_right);
#endif
	/*...............................................................................................................................*/

	if (!segment_original_middle.optimization_coefficient.finish_decrease_right) {

		Y segment_middle_copy = segment_original_middle;
		Y segment_right_copy = segment_original_right;

		long double area_difference_min_current = segment_middle_copy.area_difference + segment_right_copy.area_difference;

		/*++++++++++++++++++++++++++++++++++++++++++++++++    Decrease right endpoint of Middle segment    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		while (segment_middle_copy.rectangle_width > 2) {

			initial_segment_decrease_right(original_time_series_vector, segment_middle_copy, segment_middle_decrease_right, output_argument);
			initial_segment_increase_left(original_time_series_vector, segment_right_copy, segment_right_increase_left, output_argument);

			/*..............................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_middle_decrease_right.right_endpoint == segment_right_increase_left.right_endpoint - segment_right_increase_left.rectangle_width);
#endif
			/*..............................................................................................................................................*/

			const long double area_difference_move = segment_middle_decrease_right.area_difference + segment_right_increase_left.area_difference;

			if (area_difference_move < area_difference_min_current) {
				area_difference_min_current = area_difference_move;

				copy_optimization_coefficient(segment_middle_copy, segment_middle_decrease_right);
				copy_optimization_coefficient(segment_right_copy, segment_right_increase_left);
				//segment_middle_copy = segment_middle_decrease_right;
				//segment_right_copy = segment_right_increase_left;
			}
			else {
				copy_optimization_coefficient(segment_middle_decrease_right, segment_middle_copy);
				copy_optimization_coefficient(segment_right_increase_left, segment_right_copy);
				/*segment_middle_decrease_right = segment_middle_copy;
				segment_right_increase_left = segment_right_copy;*/

				break;
			}
		}

		//if (segment_middle_decrease_right.right_endpoint != segment_original_middle.right_endpoint) {
		if (area_difference_min_current < area_difference_min_other) {
			area_difference_min_other = area_difference_min_current;
			map_new_area_difference_adjust_type.emplace(segment_middle_decrease_right.area_difference + segment_right_increase_left.area_difference - segment_original_middle.area_difference - segment_original_right.area_difference, type_move);
		}
		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	}

	//segment_middle_decrease_right.optimization_coefficient.finish_decrease_right = true;
}

//************************************
// Method:compute_segment_increase_right
// Qualifier:
// date:201226 11:14
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename T1, typename T2, typename T3, typename T4, typename U>
void APLA::compute_segment_increase_right(const vector<T>& const original_time_series_vector, const T3 type_move, T4& const area_difference_min_other, multimap<T1, T2>& const map_new_area_difference_adjust_type, const Y& const segment_original_middle, const Y& const segment_original_right, Y& const segment_middle_increase_right, Y& const segment_right_decrease_left, U& const output_argument) {
	/*...............................................................................................................................*/
#ifdef _DEBUG
	assert_if_finish_move(segment_original_middle, segment_original_right);
	assert_segment_bound(original_time_series_vector, segment_original_middle);
	assert_segment_bound(original_time_series_vector, segment_original_right);
#endif
	/*...............................................................................................................................*/

	if (!segment_original_right.optimization_coefficient.finish_decrease_left) {

		Y segment_middle_copy = segment_original_middle;
		Y segment_right_copy = segment_original_right;

		long double area_difference_min_current = segment_middle_copy.area_difference + segment_right_copy.area_difference;

		/*++++++++++++++++++++++++++++++++++++++++++++++++    Increase right endpoint of Middle segment    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		while (segment_right_copy.rectangle_width > 2) {

			initial_segment_increase_right(original_time_series_vector, segment_middle_copy, segment_middle_increase_right, output_argument);
			initial_segment_decrease_left(original_time_series_vector, segment_right_copy, segment_right_decrease_left, output_argument);

			/*..............................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_middle_increase_right.right_endpoint == segment_right_decrease_left.right_endpoint - segment_right_decrease_left.rectangle_width);
#endif
			/*..............................................................................................................................................*/

			const long double area_difference_move = segment_middle_increase_right.area_difference + segment_right_decrease_left.area_difference;

			if (area_difference_move < area_difference_min_current) {
				area_difference_min_current = area_difference_move;

				copy_optimization_coefficient(segment_middle_copy, segment_middle_increase_right);
				copy_optimization_coefficient(segment_right_copy, segment_right_decrease_left);
				/*segment_middle_copy = segment_middle_increase_right;
				segment_right_copy = segment_right_decrease_left;*/
			}
			else {
				copy_optimization_coefficient(segment_middle_increase_right, segment_middle_copy);
				copy_optimization_coefficient(segment_right_decrease_left, segment_right_copy);
				/*segment_middle_increase_right = segment_middle_copy;
				segment_right_decrease_left = segment_right_copy;*/
				break;
			}
		}

		//if (segment_middle_increase_right.right_endpoint != segment_original_middle.right_endpoint) {
		if (area_difference_min_current < area_difference_min_other) {
			area_difference_min_other = area_difference_min_current;
			map_new_area_difference_adjust_type.emplace(segment_middle_increase_right.area_difference + segment_right_decrease_left.area_difference - segment_original_middle.area_difference - segment_original_right.area_difference, type_move);
		}
		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	}

	//segment_right_decrease_left.optimization_coefficient.finish_decrease_left = true;
}

//210901 right move midle endpint in adjacent segments with defined width, increase right enpint of left segment and decrease left endpoitn of rightn segment
TEMPLATE
template<typename T, typename Y, typename U, typename T1>
void APLA::endpoint_increase_right_adjacent_segment(const vector<T>& const original_time_series_vector, const Y& const width_move, U& const segment_left, T1& const segment_right) {
	/*...............................................................................................................................*/
#ifdef _DEBUG
	assert(segment_left.right_endpoint == segment_right.right_endpoint - segment_right.rectangle_width);
#endif
	/*...............................................................................................................................*/
	
	/*++++++++++++++++++++++++++++++++++++++++++++++++    Decrease right endpoint of Middle segment    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	for (int time_loop = 0; time_loop < width_move; time_loop++) {
		get_ab_accumulation_segment(original_time_series_vector[segment_left.right_endpoint + 1], segment_left);
		get_ab_segment_by_decrement_left(original_time_series_vector[segment_left.right_endpoint], segment_right);

		/*..............................................................................................................................................*/
#ifdef _DEBUG
		assert(segment_left.right_endpoint == segment_right.right_endpoint - segment_right.rectangle_width);
		assert_segment_a_b(original_time_series_vector, segment_left);
		assert_segment_a_b(original_time_series_vector, segment_right);
#endif
		/*..............................................................................................................................................*/
	}

	/*..............................................................................................................................................*/
#ifdef _DEBUG
	assert(segment_left.right_endpoint == segment_right.right_endpoint - segment_right.rectangle_width);
	assert_segment_a_b(original_time_series_vector, segment_left);
	assert_segment_a_b(original_time_series_vector, segment_right);
#endif
	/*..............................................................................................................................................*/

}

//210907 Average Value. right move midle endpint in adjacent segments with defined width, increase right enpint of left segment and decrease left endpoitn of rightn segment
TEMPLATE
template<typename T, typename Y, typename U, typename T1>
void APLA::endpoint_increase_right_adjacent_segment_average(const vector<T>& const original_time_series_vector, const Y& const width_move, U& const segment_left, T1& const segment_right) {
	/*...............................................................................................................................*/
#ifdef _DEBUG
	assert(segment_left.right_endpoint == segment_right.right_endpoint - segment_right.rectangle_width);
#endif
	/*...............................................................................................................................*/

	/*++++++++++++++++++++++++++++++++++++++++++++++++    Decrease right endpoint of Middle segment    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	for (int time_loop = 0; time_loop < width_move; time_loop++) {
		get_ab_accumulation_segment_average(original_time_series_vector[segment_left.right_endpoint + 1], segment_left);
		get_ab_segment_by_decrement_left_average(original_time_series_vector[segment_left.right_endpoint], segment_right);

		/*..............................................................................................................................................*/
#ifdef _DEBUG
		assert(segment_left.right_endpoint == segment_right.right_endpoint - segment_right.rectangle_width);
		assert_segment_average(original_time_series_vector, segment_left);
		assert_segment_average(original_time_series_vector, segment_right);
#endif
		/*..............................................................................................................................................*/
	}

	/*..............................................................................................................................................*/
#ifdef _DEBUG
	assert(segment_left.right_endpoint == segment_right.right_endpoint - segment_right.rectangle_width);
	assert_segment_average(original_time_series_vector, segment_left);
	assert_segment_average(original_time_series_vector, segment_right);
#endif
	/*..............................................................................................................................................*/
}

//210901 right move midle endpint in adjacent segments with defined width, decrease right enpint of left segment and increase left endpoitn of rightn segment
TEMPLATE
template<typename T, typename Y, typename U, typename T1>
void APLA::endpoint_decrease_right_adjacent_segment(const vector<T>& const original_time_series_vector, const Y& const width_move, U& const segment_left, T1& const segment_right) {
	/*...............................................................................................................................*/
#ifdef _DEBUG
	assert(segment_left.right_endpoint == segment_right.right_endpoint - segment_right.rectangle_width);
#endif
	/*...............................................................................................................................*/

	/*++++++++++++++++++++++++++++++++++++++++++++++++    Decrease right endpoint of Middle segment    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	for (int time_loop = 0; time_loop < width_move; time_loop++) {
		get_ab_segment_by_decrement_right(original_time_series_vector[segment_left.right_endpoint], segment_left);
		get_ab_segment_by_accumulation_left(original_time_series_vector[segment_left.right_endpoint + 1], segment_right);

		/*..............................................................................................................................................*/
#ifdef _DEBUG
		assert(segment_left.right_endpoint == segment_right.right_endpoint - segment_right.rectangle_width);
		assert_segment_a_b(original_time_series_vector, segment_left);
		assert_segment_a_b(original_time_series_vector, segment_right);
#endif
		/*..............................................................................................................................................*/
	}

	/*..............................................................................................................................................*/
#ifdef _DEBUG
	assert(segment_left.right_endpoint == segment_right.right_endpoint - segment_right.rectangle_width);
	assert_segment_a_b(original_time_series_vector, segment_left);
	assert_segment_a_b(original_time_series_vector, segment_right);
#endif
	/*..............................................................................................................................................*/
}

//210916 Average Value. right move midle endpint in adjacent segments with defined width, decrease right enpint of left segment and increase left endpoitn of rightn segment
TEMPLATE
template<typename T, typename Y, typename U, typename T1>
void APLA::endpoint_decrease_right_adjacent_segment_average(const vector<T>& const original_time_series_vector, const Y& const width_move, U& const segment_left, T1& const segment_right) {
	/*...............................................................................................................................*/
#ifdef _DEBUG
	assert(segment_left.right_endpoint == segment_right.right_endpoint - segment_right.rectangle_width);
	assert_segment_average(original_time_series_vector, segment_left);
	assert_segment_average(original_time_series_vector, segment_right);
#endif
	/*...............................................................................................................................*/

	/*++++++++++++++++++++++++++++++++++++++++++++++++    Decrease right endpoint of Middle segment    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	for (int time_loop = 0; time_loop < width_move; time_loop++) {
		get_ab_segment_by_decrement_right_average(original_time_series_vector[segment_left.right_endpoint], segment_left);
		get_ab_segment_by_accumulation_left_average(original_time_series_vector[segment_left.right_endpoint + 1], segment_right);

		/*..............................................................................................................................................*/
#ifdef _DEBUG
		assert(segment_left.right_endpoint == segment_right.right_endpoint - segment_right.rectangle_width);
		assert_segment_average(original_time_series_vector, segment_left);
		assert_segment_average(original_time_series_vector, segment_right);
#endif
		/*..............................................................................................................................................*/
	}

	/*..............................................................................................................................................*/
#ifdef _DEBUG
	assert(segment_left.right_endpoint == segment_right.right_endpoint - segment_right.rectangle_width);
	assert_segment_average(original_time_series_vector, segment_left);
	assert_segment_average(original_time_series_vector, segment_right);
#endif
	/*..............................................................................................................................................*/
}

/*=========================================     210907 Average     ==================================================================================*/
TEMPLATE
template<typename T>
inline bool APLA::assert_segment_average(const T& const segment) {
	assert(segment.apla.a == 0 && segment.right_endpoint != INF && segment.rectangle_width != INF);
	return true;
}

TEMPLATE
template<typename T, typename Y>
bool APLA::assert_segment_average(const vector<T>& const original_time_series_vector, const Y& const segment) {
	assert_segment_average(segment);
	long double average = 0;
	for (int id_point = segment.right_endpoint - segment.rectangle_width + 1; id_point <= segment.right_endpoint; id_point++) {
		average += original_time_series_vector[id_point];
	}
	average /= double(segment.rectangle_width);
	assert(fabs(average - segment.apla.b) < 0.1);
	return true;
}

TEMPLATE
template<typename T, typename Y>
bool APLA::assert_endpoint_average(const vector<T>& const original_time_series_vector, const DoublyLinkedList<Y>& const list) {
	assertRightEndpoint_Width(list);
	for (int id_segment = 0; id_segment < list.size(); id_segment++) {
		assert_segment_average(original_time_series_vector, list[id_segment]);
	}
	return true;
}

TEMPLATE
template<typename T, typename Y>
void APLA::get_average_segment(const vector<T>& const original_time_series_vector, Y& const segment) {
	segment.apla.a = segment.apla.b = 0;
	for (int id_point = segment.right_endpoint - segment.rectangle_width + 1; id_point <= segment.right_endpoint; id_point++) {
		segment.apla.b += original_time_series_vector[id_point];
	}
	get_apla_coefficients_segment(segment);
	segment.apla.b /= double(segment.rectangle_width);
}

TEMPLATE
template<typename T, typename Y, typename U>
inline void APLA::get_sub_average_by_long_segment(const T& const long_segment, const Y& const sub_segment_1, U& const sub_segment_2) {

	sub_segment_2.apla.a = 0;
	get_apla_coefficients_segment(sub_segment_2);
	sub_segment_2.apla.b = (long_segment.apla.b * long_segment.rectangle_width - sub_segment_1.apla.b * sub_segment_1.rectangle_width) / sub_segment_2.rectangle_width;
	/*........................................*/
#ifdef _DEBUG
	assert_segment_average(long_segment);
	assert_segment_average(sub_segment_1);
#endif
	/*........................................*/

}
/*===================================================================================================================================================*/

//****************************************
// Method:is_seg_out_map
// Qualifier: short segment and flat segment outside split multimap
// date:201228 06:51
// author:
//****************************************
TEMPLATE
template<typename T>
inline bool APLA::is_seg_out_map(const T& const segment) {
	if (!segment.optimization_coefficient.finish_decrease_left && !segment.optimization_coefficient.finish_decrease_right) {
		if (segment.rectangle_width < 4 || segment.area_difference == 0) {
			return true;
		}
	}
	else if (segment.optimization_coefficient.finish_decrease_left && segment.optimization_coefficient.finish_decrease_right) {
		return true;
	}

	return false;
}

//****************************************
// Method:label_left_node_erase_emplace_map
// Qualifier: 1 Label left, middle node. 2 Erase , Emplace MAP
// date:201228 15:23
// author:
//****************************************
TEMPLATE
template<typename Y, typename T1>
inline void APLA::label_left_node_erase_emplace_map(multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map, DoublyListNode<Y>& const node_middle) {

	Y& const segment_left = node_middle._prev->_value;
	Y& const segment_middle = node_middle._value;

	/****************************    Erase middle, right node    ********************************/
		//Out MAP FF F <3 =0
	if (!segment_left.optimization_coefficient.finish_decrease_left && !segment_left.optimization_coefficient.finish_decrease_right && (segment_left.rectangle_width < 4 || segment_left.area_difference == 0)) {
		/*.....................................................*/
#ifdef _DEBUG
		assert(!segment_middle.optimization_coefficient.finish_decrease_left);
		assert(!find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
		/*.....................................................*/
		split_area_difference_map.emplace(segment_left.area_difference, *(node_middle._prev));
		segment_left.optimization_coefficient.finish_decrease_right = true;
		segment_middle.optimization_coefficient.finish_decrease_left = true;
	}//TTT
	else if (segment_left.optimization_coefficient.finish_decrease_left && segment_left.optimization_coefficient.finish_decrease_right && segment_middle.optimization_coefficient.finish_decrease_left) {
		/*.....................................................*/
#ifdef _DEBUG
		assert(!find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
		/*.....................................................*/
	}//In MAP T/F FF                                             
	else if (!segment_left.optimization_coefficient.finish_decrease_right && !segment_middle.optimization_coefficient.finish_decrease_left) {
		/*.....................................................*/
#ifdef _DEBUG
		assert(find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
		/*.....................................................*/
		//TFF
		if (segment_left.optimization_coefficient.finish_decrease_left) {
			eraseMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference);
		}
		else {//FFF
			/*.....................................................*/
#ifdef _DEBUG
			assert(segment_left.rectangle_width > 3 && segment_left.area_difference > 0);
#endif
			/*.....................................................*/
		}

		segment_left.optimization_coefficient.finish_decrease_right = true;
		segment_middle.optimization_coefficient.finish_decrease_left = true;
	}//In MAP FTT    
	else if (!segment_left.optimization_coefficient.finish_decrease_left && segment_left.optimization_coefficient.finish_decrease_right && segment_middle.optimization_coefficient.finish_decrease_left) {
		/*.....................................................*/
#ifdef _DEBUG
		assert(find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
		/*.....................................................*/
	}
	else {
		assert(0);
	}
}

//****************************************
// Method:label_right_node_erase_emplace_map
// Qualifier: 1 Label middle, right node. 2 Erase, Emplace MAP
// date:201228 15:36
// author:
//****************************************
TEMPLATE
template<typename Y, typename T1>
inline void APLA::label_right_node_erase_emplace_map(multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map, DoublyListNode<Y>& const node_middle) {
	Y& const segment_middle = node_middle._value;
	Y& const segment_right = node_middle._next->_value;

	//Out MAP F FF <3 =0
	if (!segment_right.optimization_coefficient.finish_decrease_left && !segment_right.optimization_coefficient.finish_decrease_right && (segment_right.rectangle_width < 4 || segment_right.area_difference == 0)) {
		/*.....................................................*/
#ifdef _DEBUG
		assert(!segment_middle.optimization_coefficient.finish_decrease_right);
		assert(!find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
		/*.....................................................*/
		split_area_difference_map.emplace(segment_right.area_difference, *(node_middle._next));
		//T TF
		segment_middle.optimization_coefficient.finish_decrease_right = true;
		segment_right.optimization_coefficient.finish_decrease_left = true;
	}//T TT
	else if (segment_middle.optimization_coefficient.finish_decrease_right && segment_right.optimization_coefficient.finish_decrease_left && segment_right.optimization_coefficient.finish_decrease_right) {
		/*.....................................................*/
#ifdef _DEBUG
		assert(!find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
		/*.....................................................*/
	}//In MAP  F F (T/F)                                             
	else if (!segment_middle.optimization_coefficient.finish_decrease_right && !segment_right.optimization_coefficient.finish_decrease_left) {
		/*.....................................................*/
#ifdef _DEBUG
		assert(find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
		/*.....................................................*/
		//F FT
		if (segment_right.optimization_coefficient.finish_decrease_right) {
			eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
		}
		else {//F FF
			/*.....................................................*/
#ifdef _DEBUG
			assert(segment_right.rectangle_width > 3 && segment_right.area_difference > 0);
#endif
			/*.....................................................*/
		}

		segment_middle.optimization_coefficient.finish_decrease_right = true;
		segment_right.optimization_coefficient.finish_decrease_left = true;
	}//In MAP T TF   
	else if (segment_middle.optimization_coefficient.finish_decrease_right && segment_right.optimization_coefficient.finish_decrease_left && !segment_right.optimization_coefficient.finish_decrease_right) {
		/*.....................................................*/
#ifdef _DEBUG
		assert(find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
		/*.....................................................*/
	}
	else {
		assert(0);
	}
}

//****************************************
// Method:update_left_node_label_map
// Qualifier: 1 Update, Label left, middle node. 2 Update, Erase, Emplace MAP
// date:201228 15:36
// author:
//****************************************
TEMPLATE
template<typename Y, typename T1>
inline void APLA::update_left_node_label_map(multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map, DoublyListNode<Y>& const node_middle, const Y& const segment_left_move, const Y& const segment_middle_move) {
	Y& const segment_left = node_middle._prev->_value;
	Y& const segment_middle = node_middle._value;
	//Out MAP FF F <3 =0
	if (!segment_left.optimization_coefficient.finish_decrease_left && !segment_left.optimization_coefficient.finish_decrease_right && (segment_left.rectangle_width < 4 || segment_left.area_difference == 0)) {
		/*.....................................................*/
#ifdef _DEBUG
		assert(!segment_middle.optimization_coefficient.finish_decrease_left);
		assert(!find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
		/*.....................................................*/
		split_area_difference_map.emplace(segment_left_move.area_difference, *(node_middle._prev));
		segment_left.optimization_coefficient.finish_decrease_right = true;
		segment_middle.optimization_coefficient.finish_decrease_left = true;

		copy_optimization_coefficient(segment_left, segment_left_move);
		copy_optimization_coefficient(segment_middle, segment_middle_move);

	}//TTT
	else if (segment_left.optimization_coefficient.finish_decrease_left && segment_left.optimization_coefficient.finish_decrease_right && segment_middle.optimization_coefficient.finish_decrease_left) {
		/*.....................................................*/
#ifdef _DEBUG
		assert(!find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
		/*.....................................................*/
	}//In MAP T/F FF                                             
	else if (!segment_left.optimization_coefficient.finish_decrease_right && !segment_middle.optimization_coefficient.finish_decrease_left) {
		/*.....................................................*/
#ifdef _DEBUG
		assert(find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
		/*.....................................................*/
		//TF F
		if (segment_left.optimization_coefficient.finish_decrease_left) {
			eraseMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference);
		}
		else {//FF F
			/*.....................................................*/
#ifdef _DEBUG
			assert(segment_left.rectangle_width > 3 && segment_left.area_difference > 0);
#endif
			/*.....................................................*/
			updateMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference, segment_left_move.area_difference);
		}

		segment_left.optimization_coefficient.finish_decrease_right = true;
		segment_middle.optimization_coefficient.finish_decrease_left = true;

		copy_optimization_coefficient(segment_left, segment_left_move);
		copy_optimization_coefficient(segment_middle, segment_middle_move);

	}//In MAP FT T    
	else if (!segment_left.optimization_coefficient.finish_decrease_left && segment_left.optimization_coefficient.finish_decrease_right && segment_middle.optimization_coefficient.finish_decrease_left) {
		/*.....................................................*/
#ifdef _DEBUG
		assert(find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
		/*.....................................................*/
	}
	else {
		assert(0);
	}
}

//****************************************
// Method:update_right_node_label_map
// Qualifier: 1 Update, Label left, middle node. 2 Update, Erase, Emplace MAP
// date:201228 15:36
// author:
//****************************************
TEMPLATE
template<typename Y, typename T1>
inline void APLA::update_right_node_label_map(multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map, DoublyListNode<Y>& const node_middle, const Y& const segment_middle_move, const Y& const segment_right_move) {
	Y& const segment_middle = node_middle._value;
	Y& const segment_right = node_middle._next->_value;

	//Out MAP F FF <3 =0
	if (!segment_right.optimization_coefficient.finish_decrease_left && !segment_right.optimization_coefficient.finish_decrease_right && (segment_right.rectangle_width < 4 || segment_right.area_difference == 0)) {
		/*.....................................................*/
#ifdef _DEBUG
		assert(!segment_middle.optimization_coefficient.finish_decrease_right);
		assert(!find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
		/*.....................................................*/
		split_area_difference_map.emplace(segment_right_move.area_difference, *(node_middle._next));
		//T TF
		segment_middle.optimization_coefficient.finish_decrease_right = true;
		segment_right.optimization_coefficient.finish_decrease_left = true;

		copy_optimization_coefficient(segment_middle, segment_middle_move);
		copy_optimization_coefficient(segment_right, segment_right_move);

	}//T TT
	else if (segment_middle.optimization_coefficient.finish_decrease_right && segment_right.optimization_coefficient.finish_decrease_left && segment_right.optimization_coefficient.finish_decrease_right) {
		/*.....................................................*/
#ifdef _DEBUG
		assert(!find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
		/*.....................................................*/
	}//In MAP  F F (T/F)                                             
	else if (!segment_middle.optimization_coefficient.finish_decrease_right && !segment_right.optimization_coefficient.finish_decrease_left) {
		/*.....................................................*/
#ifdef _DEBUG
		assert(find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
		/*.....................................................*/
		//F FT
		if (segment_right.optimization_coefficient.finish_decrease_right) {
			eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
		}
		else {//F FF
			/*.....................................................*/
#ifdef _DEBUG
			assert(segment_right.rectangle_width > 3 && segment_right.area_difference > 0);
#endif
			/*.....................................................*/
			updateMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference, segment_right_move.area_difference);
		}

		segment_middle.optimization_coefficient.finish_decrease_right = true;
		segment_right.optimization_coefficient.finish_decrease_left = true;

		copy_optimization_coefficient(segment_middle, segment_middle_move);
		copy_optimization_coefficient(segment_right, segment_right_move);
	}//In MAP T TF   
	else if (segment_middle.optimization_coefficient.finish_decrease_right && segment_right.optimization_coefficient.finish_decrease_left && !segment_right.optimization_coefficient.finish_decrease_right) {
		/*.....................................................*/
#ifdef _DEBUG
		assert(find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
		/*.....................................................*/
	}
	else {
		assert(0);
	}
}

//****************************************
// Method:adjust_compute_segment_2_sides
// Qualifier:
// date:201224 13:11
// author:
//***************************************
TEMPLATE
template<typename T, typename Y, typename T1, typename U>
bool APLA::adjust_compute_segment_2_sides(const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map, DoublyListNode<Y>& const node_middle, U& const output_argument) {
	/*............................................................*/
#ifdef _DEBUG
	assert_split_map_optimization(split_area_difference_map);
	assert(find_key_in_map(split_area_difference_map, node_middle._value.area_difference));
	assert(find_endpoint_key_in_map(split_area_difference_map, node_middle._value.right_endpoint, node_middle._value.area_difference));
#endif
	/*...........................................................*/

	/*----    left / middle / right segment   ---------*/
	Y& const segment_left = node_middle._prev->_value;
	Y& const segment_middle = node_middle._value;
	Y& const segment_right = node_middle._next->_value;
	/*-------------------------------------------------*/

	/*---- 2012228 is original outside Split MAP? -----*/
	bool if_left_seg_out_map = is_seg_out_map(segment_left);
	bool if_right_seg_out_map = is_seg_out_map(segment_right);
	/*-------------------------------------------------*/

	/*.........................................................................................................................*/
#ifdef _DEBUG
	assert_segment_bound(original_time_series_vector, segment_left);
	assert_segment_bound(original_time_series_vector, segment_middle);
	assert_segment_bound(original_time_series_vector, segment_right);

	assert_if_finish_move(segment_left, segment_middle);
	assert_if_finish_move(segment_middle, segment_right);
	if (!if_left_seg_out_map) {
		assert(find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
	}
	if (!if_right_seg_out_map) {
		assert(find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
	}
#endif
	/*.........................................................................................................................*/

	/*----------- Right Side -----------*/
	Y temp_segment_middle_decrease_right;
	Y temp_segment_right_increase_left;
	Y temp_segment_middle_increase_right;
	Y temp_segment_right_decrease_left;
	/*----------------------------------*/

	/*----------- Left Side ------------*/
	Y temp_segment_left_decrease_right;
	Y temp_segment_middle_increase_left;
	Y temp_segment_left_increase_right;
	Y temp_segment_middle_decrease_left;
	/*----------------------------------*/

	multimap<long double, size_t> map_new_area_difference_adjust_type;

	long double area_difference_min_current = segment_middle.area_difference + segment_right.area_difference;

	map_new_area_difference_adjust_type.emplace(0, 0);

	/*++++++++++++++++++++++++++++++++++++++++++++++++    Decrease right endpoint of Middle segment    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	compute_segment_decrease_right(original_time_series_vector, 1, area_difference_min_current, map_new_area_difference_adjust_type, segment_middle, segment_right, temp_segment_middle_decrease_right, temp_segment_right_increase_left, output_argument);
	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*++++++++++++++++++++++++++++++++++++++++++++++++    Increase right endpoint of Middle segment    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	compute_segment_increase_right(original_time_series_vector, 2, area_difference_min_current, map_new_area_difference_adjust_type, segment_middle, segment_right, temp_segment_middle_increase_right, temp_segment_right_decrease_left, output_argument);
	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*++++++++++++++++++++++++++++++++++++++++++++++++    Increase left endpoint of Middle segment    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	compute_segment_decrease_right(original_time_series_vector, 3, area_difference_min_current, map_new_area_difference_adjust_type, segment_left, segment_middle, temp_segment_left_decrease_right, temp_segment_middle_increase_left, output_argument);
	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*++++++++++++++++++++++++++++++++++++++++++++++++    Decrease left endpoint of Middle segment    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	compute_segment_increase_right(original_time_series_vector, 4, area_difference_min_current, map_new_area_difference_adjust_type, segment_left, segment_middle, temp_segment_left_increase_right, temp_segment_middle_decrease_left, output_argument);
	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*++++++++++++++++++++++++++++++++++++++++++++++++    Increase right endpoint of Middle segment    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*-----------------------------       Erase Middle Segment       ---------------------------------------*/
	eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
	/*------------------------------------------------------------------------------------------------------*/

	/*segment_left.optimization_coefficient.finish_decrease_right = true;
	segment_middle.optimization_coefficient.finish_decrease_left = true;
	segment_middle.optimization_coefficient.finish_decrease_right = true;
	segment_right.optimization_coefficient.finish_decrease_left = true;*/

	switch (map_new_area_difference_adjust_type.begin()->second) {
	case 0: {

		/****************************    Erase middle, right node    ********************************/
		//Out MAP FF F <3 =0
		if (!segment_left.optimization_coefficient.finish_decrease_left && !segment_left.optimization_coefficient.finish_decrease_right && (segment_left.rectangle_width < 4 || segment_left.area_difference == 0)) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(!segment_middle.optimization_coefficient.finish_decrease_left);
			assert(!find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
			/*.....................................................*/
			split_area_difference_map.emplace(segment_left.area_difference, *(node_middle._prev));
			segment_left.optimization_coefficient.finish_decrease_right = true;
			segment_middle.optimization_coefficient.finish_decrease_left = true;
		}//TTT
		else if (segment_left.optimization_coefficient.finish_decrease_left && segment_left.optimization_coefficient.finish_decrease_right && segment_middle.optimization_coefficient.finish_decrease_left) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(!find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
			/*.....................................................*/
		}//In MAP T/F FF                                             
		else if (!segment_left.optimization_coefficient.finish_decrease_right && !segment_middle.optimization_coefficient.finish_decrease_left) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
			/*.....................................................*/
			//TFF
			if (segment_left.optimization_coefficient.finish_decrease_left) {
				eraseMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference);
			}
			else {//FFF
				/*.....................................................*/
#ifdef _DEBUG
				assert(segment_left.rectangle_width > 3 && segment_left.area_difference > 0);
#endif
				/*.....................................................*/
			}

			segment_left.optimization_coefficient.finish_decrease_right = true;
			segment_middle.optimization_coefficient.finish_decrease_left = true;
		}//In MAP FTT    
		else if (!segment_left.optimization_coefficient.finish_decrease_left && segment_left.optimization_coefficient.finish_decrease_right && segment_middle.optimization_coefficient.finish_decrease_left) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
			/*.....................................................*/
		}
		else {
			assert(0);
		}


		//Out MAP F FF <3 =0
		if (!segment_right.optimization_coefficient.finish_decrease_left && !segment_right.optimization_coefficient.finish_decrease_right && (segment_right.rectangle_width < 4 || segment_right.area_difference == 0)) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(!segment_middle.optimization_coefficient.finish_decrease_right);
			assert(!find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
			/*.....................................................*/
			split_area_difference_map.emplace(segment_right.area_difference, *(node_middle._next));
			//T TF
			segment_middle.optimization_coefficient.finish_decrease_right = true;
			segment_right.optimization_coefficient.finish_decrease_left = true;
		}//T TT
		else if (segment_middle.optimization_coefficient.finish_decrease_right && segment_right.optimization_coefficient.finish_decrease_left && segment_right.optimization_coefficient.finish_decrease_right) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(!find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
			/*.....................................................*/
		}//In MAP  F F (T/F)                                             
		else if (!segment_middle.optimization_coefficient.finish_decrease_right && !segment_right.optimization_coefficient.finish_decrease_left) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
			/*.....................................................*/
			//F FT
			if (segment_right.optimization_coefficient.finish_decrease_right) {
				eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
			}
			else {//F FF
				/*.....................................................*/
#ifdef _DEBUG
				assert(segment_right.rectangle_width > 3 && segment_right.area_difference > 0);
#endif
				/*.....................................................*/
			}

			segment_middle.optimization_coefficient.finish_decrease_right = true;
			segment_right.optimization_coefficient.finish_decrease_left = true;
		}//In MAP T TF   
		else if (segment_middle.optimization_coefficient.finish_decrease_right && segment_right.optimization_coefficient.finish_decrease_left && !segment_right.optimization_coefficient.finish_decrease_right) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
			/*.....................................................*/
		}
		else {
			assert(0);
		}

		//erase_node_if_no_need_adjust(split_area_difference_map, *(node_middle._prev));
		//erase_node_if_no_need_adjust(split_area_difference_map, *(node_middle._next));
		//eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
		/****************************************************************************************/

		/*.....................................................*/
#ifdef _DEBUG
		assert_if_finish_move(segment_left, segment_middle);
		assert_if_finish_move(segment_middle, segment_right);
		assert_split_map_optimization(split_area_difference_map);
#endif
		/*.....................................................*/

		return false;

		break;
	}
	case 1: {// middle segment should decrease right point, right segment should increase left.
		//update_segment_map_by_min_area_difference(split_area_difference_map, segment_middle, temp_segment_middle_decrease_right, segment_right, temp_segment_right_increase_left, *(node_middle._next));
		//update_segment_map_by_min_area_difference(split_area_difference_map, temp_segment_middle_decrease_right, node_middle);
		//eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
		//segment_middle = temp_segment_middle_decrease_right;
		/*erase_node_if_no_need_adjust(split_area_difference_map, *(node_middle._prev));
		copy_optimization_coefficient(segment_middle, temp_segment_middle_decrease_right);
		update_segment_map_by_min_area_difference(split_area_difference_map, temp_segment_right_increase_left, *(node_middle._next));*/

		//Out MAP FF F <3 =0
		if (!segment_left.optimization_coefficient.finish_decrease_left && !segment_left.optimization_coefficient.finish_decrease_right && (segment_left.rectangle_width < 4 || segment_left.area_difference == 0)) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(!segment_middle.optimization_coefficient.finish_decrease_left);
			assert(!find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
			/*.....................................................*/
			split_area_difference_map.emplace(segment_left.area_difference, *(node_middle._prev));
			segment_left.optimization_coefficient.finish_decrease_right = true;
			segment_middle.optimization_coefficient.finish_decrease_left = true;
		}//TTT
		else if (segment_left.optimization_coefficient.finish_decrease_left && segment_left.optimization_coefficient.finish_decrease_right && segment_middle.optimization_coefficient.finish_decrease_left) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(!find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
			/*.....................................................*/
		}//In MAP T/F FF                                             
		else if (!segment_left.optimization_coefficient.finish_decrease_right && !segment_middle.optimization_coefficient.finish_decrease_left) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
			/*.....................................................*/
			//TFF
			if (segment_left.optimization_coefficient.finish_decrease_left) {
				eraseMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference);
			}
			else {//FFF
				/*.....................................................*/
#ifdef _DEBUG
				assert(segment_left.rectangle_width > 3 && segment_left.area_difference > 0);
#endif
				/*.....................................................*/
			}

			segment_left.optimization_coefficient.finish_decrease_right = true;
			segment_middle.optimization_coefficient.finish_decrease_left = true;
		}//In MAP FTT    
		else if (!segment_left.optimization_coefficient.finish_decrease_left && segment_left.optimization_coefficient.finish_decrease_right && segment_middle.optimization_coefficient.finish_decrease_left) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
			/*.....................................................*/
		}
		else {
			assert(0);
		}


		//Out MAP F FF <3 =0
		if (!segment_right.optimization_coefficient.finish_decrease_left && !segment_right.optimization_coefficient.finish_decrease_right && (segment_right.rectangle_width < 4 || segment_right.area_difference == 0)) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(!segment_middle.optimization_coefficient.finish_decrease_right);
			assert(!find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
			/*.....................................................*/
			split_area_difference_map.emplace(temp_segment_right_increase_left.area_difference, *(node_middle._next));
			//T TF
			segment_middle.optimization_coefficient.finish_decrease_right = true;
			segment_right.optimization_coefficient.finish_decrease_left = true;

			copy_optimization_coefficient(segment_middle, temp_segment_middle_decrease_right);
			copy_optimization_coefficient(segment_right, temp_segment_right_increase_left);

		}//T TT
		else if (segment_middle.optimization_coefficient.finish_decrease_right && segment_right.optimization_coefficient.finish_decrease_left && segment_right.optimization_coefficient.finish_decrease_right) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(!find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
			/*.....................................................*/
		}//In MAP  F F (T/F)                                             
		else if (!segment_middle.optimization_coefficient.finish_decrease_right && !segment_right.optimization_coefficient.finish_decrease_left) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
			/*.....................................................*/
			//F FT
			if (segment_right.optimization_coefficient.finish_decrease_right) {
				eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
			}
			else {//F FF
				/*.....................................................*/
#ifdef _DEBUG
				assert(segment_right.rectangle_width > 3 && segment_right.area_difference > 0);
#endif
				/*.....................................................*/
				updateMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference, temp_segment_right_increase_left.area_difference);
			}

			segment_middle.optimization_coefficient.finish_decrease_right = true;
			segment_right.optimization_coefficient.finish_decrease_left = true;

			copy_optimization_coefficient(segment_middle, temp_segment_middle_decrease_right);
			copy_optimization_coefficient(segment_right, temp_segment_right_increase_left);
		}//In MAP T TF   
		else if (segment_middle.optimization_coefficient.finish_decrease_right && segment_right.optimization_coefficient.finish_decrease_left && !segment_right.optimization_coefficient.finish_decrease_right) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
			/*.....................................................*/
		}
		else {
			assert(0);
		}

		/*.....................................................*/
#ifdef _DEBUG		
		assert_if_finish_move(segment_left, segment_middle);
		assert_if_finish_move(segment_middle, segment_right);
		assert_split_map_optimization(split_area_difference_map);
#endif
		/*.....................................................*/

		return true;
		break;
	}
	case 2: {// middle segment should increase right point, right segment should decrease left

		/*----middle segment with max area difference should increase right----*/
		//update_segment_map_by_min_area_difference(split_area_difference_map, segment_right, temp_segment_right_decrease_left, segment_middle, temp_segment_middle_increase_right, node_middle);
		//update_segment_map_by_min_area_difference(split_area_difference_map, temp_segment_middle_increase_right, node_middle);
		//eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
		//segment_middle = temp_segment_middle_increase_right;

		/*erase_node_if_no_need_adjust(split_area_difference_map, *(node_middle._prev));
		copy_optimization_coefficient(segment_middle, temp_segment_middle_increase_right);
		update_segment_map_by_min_area_difference(split_area_difference_map, temp_segment_right_decrease_left, *(node_middle._next));*/

		//Out MAP FF F <3 =0
		if (!segment_left.optimization_coefficient.finish_decrease_left && !segment_left.optimization_coefficient.finish_decrease_right && (segment_left.rectangle_width < 4 || segment_left.area_difference == 0)) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(!segment_middle.optimization_coefficient.finish_decrease_left);
			assert(!find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
			/*.....................................................*/
			split_area_difference_map.emplace(segment_left.area_difference, *(node_middle._prev));
			segment_left.optimization_coefficient.finish_decrease_right = true;
			segment_middle.optimization_coefficient.finish_decrease_left = true;
		}//TTT
		else if (segment_left.optimization_coefficient.finish_decrease_left && segment_left.optimization_coefficient.finish_decrease_right && segment_middle.optimization_coefficient.finish_decrease_left) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(!find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
			/*.....................................................*/
		}//In MAP T/F FF                                             
		else if (!segment_left.optimization_coefficient.finish_decrease_right && !segment_middle.optimization_coefficient.finish_decrease_left) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
			/*.....................................................*/
			//TFF
			if (segment_left.optimization_coefficient.finish_decrease_left) {
				eraseMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference);
			}
			else {//FFF
				/*.....................................................*/
#ifdef _DEBUG
				assert(segment_left.rectangle_width > 3 && segment_left.area_difference > 0);
#endif
				/*.....................................................*/
			}

			segment_left.optimization_coefficient.finish_decrease_right = true;
			segment_middle.optimization_coefficient.finish_decrease_left = true;
		}//In MAP FTT    
		else if (!segment_left.optimization_coefficient.finish_decrease_left && segment_left.optimization_coefficient.finish_decrease_right && segment_middle.optimization_coefficient.finish_decrease_left) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
			/*.....................................................*/
		}
		else {
			assert(0);
		}


		//Out MAP F FF <3 =0
		if (!segment_right.optimization_coefficient.finish_decrease_left && !segment_right.optimization_coefficient.finish_decrease_right && (segment_right.rectangle_width < 4 || segment_right.area_difference == 0)) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(!segment_middle.optimization_coefficient.finish_decrease_right);
			assert(!find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
			/*.....................................................*/
			split_area_difference_map.emplace(temp_segment_right_decrease_left.area_difference, *(node_middle._next));
			//T TF
			segment_middle.optimization_coefficient.finish_decrease_right = true;
			segment_right.optimization_coefficient.finish_decrease_left = true;

			copy_optimization_coefficient(segment_middle, temp_segment_middle_increase_right);
			copy_optimization_coefficient(segment_right, temp_segment_right_decrease_left);

		}//T TT
		else if (segment_middle.optimization_coefficient.finish_decrease_right && segment_right.optimization_coefficient.finish_decrease_left && segment_right.optimization_coefficient.finish_decrease_right) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(!find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
			/*.....................................................*/
		}//In MAP  F F (T/F)                                             
		else if (!segment_middle.optimization_coefficient.finish_decrease_right && !segment_right.optimization_coefficient.finish_decrease_left) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
			/*.....................................................*/
			//F FT
			if (segment_right.optimization_coefficient.finish_decrease_right) {
				eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
			}
			else {//F FF
				/*.....................................................*/
#ifdef _DEBUG
				assert(segment_right.rectangle_width > 3 && segment_right.area_difference > 0);
#endif
				/*.....................................................*/
				updateMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference, temp_segment_right_decrease_left.area_difference);
			}

			segment_middle.optimization_coefficient.finish_decrease_right = true;
			segment_right.optimization_coefficient.finish_decrease_left = true;

			copy_optimization_coefficient(segment_middle, temp_segment_middle_increase_right);
			copy_optimization_coefficient(segment_right, temp_segment_right_decrease_left);
		}//In MAP T TF   
		else if (segment_middle.optimization_coefficient.finish_decrease_right && segment_right.optimization_coefficient.finish_decrease_left && !segment_right.optimization_coefficient.finish_decrease_right) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
			/*.....................................................*/
		}
		else {
			assert(0);
		}

		/*.....................................................*/
#ifdef _DEBUG
		assert_if_finish_move(segment_left, segment_middle);
		assert_if_finish_move(segment_middle, segment_right);
		assert_split_map_optimization(split_area_difference_map);
#endif
		/*.....................................................*/

		return true;
		break;
	}
	case 3: {// left segment should decrease right point, middle segment should increase left.
		/*--middle segment with max area difference no need to increase right--*/
		//update_segment_map_by_min_area_difference(split_area_difference_map, segment_middle, temp_segment_middle_decrease_right, segment_right, temp_segment_right_increase_left, *(node_middle._next));
		//eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
		//segment_middle = temp_segment_middle_increase_left;
		//update_segment_map_by_min_area_difference(split_area_difference_map, temp_segment_left_decrease_right, *(node_middle._prev));
		//copy_optimization_coefficient(segment_middle, temp_segment_middle_increase_left);
		//erase_node_if_no_need_adjust(split_area_difference_map, *(node_middle._next));

		//Out MAP FF F <3 =0
		if (!segment_left.optimization_coefficient.finish_decrease_left && !segment_left.optimization_coefficient.finish_decrease_right && (segment_left.rectangle_width < 4 || segment_left.area_difference == 0)) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(!segment_middle.optimization_coefficient.finish_decrease_left);
			assert(!find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
			/*.....................................................*/
			split_area_difference_map.emplace(temp_segment_left_decrease_right.area_difference, *(node_middle._prev));
			segment_left.optimization_coefficient.finish_decrease_right = true;
			segment_middle.optimization_coefficient.finish_decrease_left = true;

			copy_optimization_coefficient(segment_left, temp_segment_left_decrease_right);
			copy_optimization_coefficient(segment_middle, temp_segment_middle_increase_left);

		}//TTT
		else if (segment_left.optimization_coefficient.finish_decrease_left && segment_left.optimization_coefficient.finish_decrease_right && segment_middle.optimization_coefficient.finish_decrease_left) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(!find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
			/*.....................................................*/
		}//In MAP T/F FF                                             
		else if (!segment_left.optimization_coefficient.finish_decrease_right && !segment_middle.optimization_coefficient.finish_decrease_left) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
			/*.....................................................*/
			//TF F
			if (segment_left.optimization_coefficient.finish_decrease_left) {
				eraseMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference);
			}
			else {//FF F
				/*.....................................................*/
#ifdef _DEBUG
				assert(segment_left.rectangle_width > 3 && segment_left.area_difference > 0);
#endif
				/*.....................................................*/
				updateMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference, temp_segment_left_decrease_right.area_difference);
			}

			segment_left.optimization_coefficient.finish_decrease_right = true;
			segment_middle.optimization_coefficient.finish_decrease_left = true;

			copy_optimization_coefficient(segment_left, temp_segment_left_decrease_right);
			copy_optimization_coefficient(segment_middle, temp_segment_middle_increase_left);

		}//In MAP FT T    
		else if (!segment_left.optimization_coefficient.finish_decrease_left && segment_left.optimization_coefficient.finish_decrease_right && segment_middle.optimization_coefficient.finish_decrease_left) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
			/*.....................................................*/
		}
		else {
			assert(0);
		}

		//Out MAP F FF <3 =0
		if (!segment_right.optimization_coefficient.finish_decrease_left && !segment_right.optimization_coefficient.finish_decrease_right && (segment_right.rectangle_width < 4 || segment_right.area_difference == 0)) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(!segment_middle.optimization_coefficient.finish_decrease_right);
			assert(!find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
			/*.....................................................*/
			split_area_difference_map.emplace(segment_right.area_difference, *(node_middle._next));
			//T TF
			segment_middle.optimization_coefficient.finish_decrease_right = true;
			segment_right.optimization_coefficient.finish_decrease_left = true;
		}//T TT
		else if (segment_middle.optimization_coefficient.finish_decrease_right && segment_right.optimization_coefficient.finish_decrease_left && segment_right.optimization_coefficient.finish_decrease_right) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(!find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
			/*.....................................................*/
		}//In MAP  F F (T/F)                                             
		else if (!segment_middle.optimization_coefficient.finish_decrease_right && !segment_right.optimization_coefficient.finish_decrease_left) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
			/*.....................................................*/
			//F FT
			if (segment_right.optimization_coefficient.finish_decrease_right) {
				eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
			}
			else {//F FF
				/*.....................................................*/
#ifdef _DEBUG
				assert(segment_right.rectangle_width > 3 && segment_right.area_difference > 0);
#endif
				/*.....................................................*/
			}

			segment_middle.optimization_coefficient.finish_decrease_right = true;
			segment_right.optimization_coefficient.finish_decrease_left = true;
		}//In MAP T TF   
		else if (segment_middle.optimization_coefficient.finish_decrease_right && segment_right.optimization_coefficient.finish_decrease_left && !segment_right.optimization_coefficient.finish_decrease_right) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
			/*.....................................................*/
		}
		else {
			assert(0);
		}

		/*.....................................................*/
#ifdef _DEBUG
		assert_if_finish_move(segment_left, segment_middle);
		assert_if_finish_move(segment_middle, segment_right);
		assert_split_map_optimization(split_area_difference_map);
#endif
		/*.....................................................*/

		return true;
		break;
	}
	case 4: {// left segment should increase right point, middle segment should decrease left

		/*----middle segment with max area difference should increase right----*/
		//update_segment_map_by_min_area_difference(split_area_difference_map, segment_right, temp_segment_right_decrease_left, segment_middle, temp_segment_middle_increase_right, node_middle);
		//segment_middle = temp_segment_middle_decrease_left;
		/*update_segment_map_by_min_area_difference(split_area_difference_map, temp_segment_left_increase_right, *(node_middle._prev));
		copy_optimization_coefficient(segment_middle, temp_segment_middle_decrease_left);
		erase_node_if_no_need_adjust(split_area_difference_map, *(node_middle._next));*/

		//Out MAP FF F <3 =0
		if (!segment_left.optimization_coefficient.finish_decrease_left && !segment_left.optimization_coefficient.finish_decrease_right && (segment_left.rectangle_width < 4 || segment_left.area_difference == 0)) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(!segment_middle.optimization_coefficient.finish_decrease_left);
			assert(!find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
			/*.....................................................*/
			split_area_difference_map.emplace(temp_segment_left_increase_right.area_difference, *(node_middle._prev));
			segment_left.optimization_coefficient.finish_decrease_right = true;
			segment_middle.optimization_coefficient.finish_decrease_left = true;

			copy_optimization_coefficient(segment_left, temp_segment_left_increase_right);
			copy_optimization_coefficient(segment_middle, temp_segment_middle_decrease_left);

		}//TTT
		else if (segment_left.optimization_coefficient.finish_decrease_left && segment_left.optimization_coefficient.finish_decrease_right && segment_middle.optimization_coefficient.finish_decrease_left) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(!find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
			/*.....................................................*/
		}//In MAP T/F FF                                             
		else if (!segment_left.optimization_coefficient.finish_decrease_right && !segment_middle.optimization_coefficient.finish_decrease_left) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
			/*.....................................................*/
			//TF F
			if (segment_left.optimization_coefficient.finish_decrease_left) {
				eraseMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference);
			}
			else {//FF F
				/*.....................................................*/
#ifdef _DEBUG
				assert(segment_left.rectangle_width > 3 && segment_left.area_difference > 0);
#endif
				/*.....................................................*/
				updateMapByKey(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference, temp_segment_left_increase_right.area_difference);
			}

			segment_left.optimization_coefficient.finish_decrease_right = true;
			segment_middle.optimization_coefficient.finish_decrease_left = true;

			copy_optimization_coefficient(segment_left, temp_segment_left_increase_right);
			copy_optimization_coefficient(segment_middle, temp_segment_middle_decrease_left);

		}//In MAP FT T    
		else if (!segment_left.optimization_coefficient.finish_decrease_left && segment_left.optimization_coefficient.finish_decrease_right && segment_middle.optimization_coefficient.finish_decrease_left) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(find_endpoint_key_in_map(split_area_difference_map, segment_left.right_endpoint, segment_left.area_difference));
#endif
			/*.....................................................*/
		}
		else {
			assert(0);
		}

		//Out MAP F FF <3 =0
		if (!segment_right.optimization_coefficient.finish_decrease_left && !segment_right.optimization_coefficient.finish_decrease_right && (segment_right.rectangle_width < 4 || segment_right.area_difference == 0)) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(!segment_middle.optimization_coefficient.finish_decrease_right);
			assert(!find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
			/*.....................................................*/
			split_area_difference_map.emplace(segment_right.area_difference, *(node_middle._next));
			//T TF
			segment_middle.optimization_coefficient.finish_decrease_right = true;
			segment_right.optimization_coefficient.finish_decrease_left = true;
		}//T TT
		else if (segment_middle.optimization_coefficient.finish_decrease_right && segment_right.optimization_coefficient.finish_decrease_left && segment_right.optimization_coefficient.finish_decrease_right) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(!find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
			/*.....................................................*/
		}//In MAP  F F (T/F)                                             
		else if (!segment_middle.optimization_coefficient.finish_decrease_right && !segment_right.optimization_coefficient.finish_decrease_left) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
			/*.....................................................*/
			//F FT
			if (segment_right.optimization_coefficient.finish_decrease_right) {
				eraseMapByKey(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference);
			}
			else {//F FF
				/*.....................................................*/
#ifdef _DEBUG
				assert(segment_right.rectangle_width > 3 && segment_right.area_difference > 0);
#endif
				/*.....................................................*/
			}

			segment_middle.optimization_coefficient.finish_decrease_right = true;
			segment_right.optimization_coefficient.finish_decrease_left = true;
		}//In MAP T TF   
		else if (segment_middle.optimization_coefficient.finish_decrease_right && segment_right.optimization_coefficient.finish_decrease_left && !segment_right.optimization_coefficient.finish_decrease_right) {
			/*.....................................................*/
#ifdef _DEBUG
			assert(find_endpoint_key_in_map(split_area_difference_map, segment_right.right_endpoint, segment_right.area_difference));
#endif
			/*.....................................................*/
		}
		else {
			assert(0);
		}

		/*.....................................................*/
#ifdef _DEBUG
		assert_if_finish_move(segment_left, segment_middle);
		assert_if_finish_move(segment_middle, segment_right);
		assert_split_map_optimization(split_area_difference_map);
#endif
		/*.....................................................*/

		return true;
		break;
	}
	default:
		assert(0);
	}
	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
}

//************************************
// Method:optimize_segment_max_area_difference_speed2
// Qualifier: Optimization of segment adjust, for max difference segment, adjust left / right endpoint of segment, choose the min area difference one.
// date:201213  09:19
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename T1>
bool APLA::optimize_segment_max_area_difference_speed2(const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map) {

	/*........................................................................*/
#ifdef _DEBUG
	assert(!split_area_difference_map.empty());
	assert_split_map_area_difference(split_area_difference_map);
	//evaluate right point, min&max point, width. a&b, sum value
	//assertLinkedList(original_time_series_vector, doubly_linked_list);
#endif
	/*.......................................................................*/

	/*####################################################        Coefficients of Split       #############################################################################*/

	/*===============================     width = 2, no space to decrease    =========================================*/
	while (split_area_difference_map.begin()->second._value.rectangle_width < 3 || split_area_difference_map.begin()->second._value.area_difference == 0) {
		//split_area_difference_map.begin()->second._value.optimization_coefficient.finish_right = true;
		eraseMapByKey(split_area_difference_map, split_area_difference_map.begin()->second._value.right_endpoint, split_area_difference_map.begin()->second._value.area_difference);
		if (split_area_difference_map.empty()) return false;
	}
	/*================================================================================================================*/

	/*=====================   Split Candidate Long segment with max area difference  =================================*/
	auto& const node_middle = split_area_difference_map.begin()->second;
	auto& const segment_middle = node_middle._value;
	/*.......................................................................................................*/
#ifdef _DEBUG
	assert(segment_middle.rectangle_width > 2 && segment_middle.area_difference > 0);
#endif
	/*.......................................................................................................*/
	/*================================================================================================================*/

	/*####################################################################################################################################################################*/

	/*###########################################       Move endpoint of max area difference         #########################################################################*/
	if (!node_middle._prev) {//head node

	/*||||||||||||||||||||||||||||||||||||||||||||||||||||||               Head Node             |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||*/

		/*---------------------    right segment  ---------------------*/
		Y& const segment_right = node_middle._next->_value;
		/*-------------------------------------------------------------*/

		/*.........................................................................................................................................................................*/
#ifdef _DEBUG
		assert(segment_middle.optimization_coefficient.finish_decrease_left && segment_middle.right_endpoint + 1 == segment_middle.rectangle_width && (!segment_middle.optimization_coefficient.finish_decrease_right || !segment_right.optimization_coefficient.finish_decrease_left));
		assert_split_map_area_difference(split_area_difference_map);
#endif
		/*..........................................................................................................................................................................*/

		/*+++++++++++++++++++++++++++              Head segment area difference == right segment == 0, no need to adjust endpoint           +++++++++++++++++++++++++++*/
		erase_if_adjacent_segments_are_zeros(split_area_difference_map, node_middle);
		if (segment_middle.optimization_coefficient.finish_decrease_right && segment_right.optimization_coefficient.finish_decrease_left) return false;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		adjust_compute_segment_right(original_time_series_vector, split_area_difference_map, node_middle);

		/*********************************   Erase head node    *****************************/
		erase_node_if_no_need_adjust(split_area_difference_map, node_middle);
		/************************************************************************************/

		return true;
	}
	else if (node_middle._next) {//middle node
	/*|||||||||||||||||||||||||||||||||||||||||||||||||||               Middle Node             ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||*/

		Y& const segment_left = node_middle._prev->_value;
		Y& const segment_right = node_middle._next->_value;

		/*~~~~~~~~~~~~~~~~~~~~~~~~~     label semgents which area not in split map (are_diff = 0 && with <= 3)  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

		/*..............................................................................................................................................................................*/
#ifdef _DEBUG
		assert_split_map_area_difference(split_area_difference_map);
		//assert(!segment_left.optimization_coefficient.finish_decrease_right || !segment_left.optimization_coefficient.finish_decrease_left || !segment_middle.optimization_coefficient.finish_decrease_right || !segment_middle.optimization_coefficient.finish_decrease_left || !segment_right.optimization_coefficient.finish_decrease_right || !segment_right.optimization_coefficient.finish_decrease_left);
#endif
		/*..............................................................................................................................................................................*/

		/*++++++++  Middle segment area difference == right segment == 0 / Middle segment area difference == right segment == 0. No need to adjust endpoint  +++++++++++*/

		/*-----------------------      middle, right area difference == 0    -----------------------------------*/
		erase_if_adjacent_segments_are_zeros(split_area_difference_map, node_middle);
		/*------------------------------------------------------------------------------------------------------*/
		/*---------------------       left, middle area difference == 0     ------------------------------------*/
		//erase_if_adjacent_segments_are_zeros(split_area_difference_map, *node_middle._prev);
		/*------------------------------------------------------------------------------------------------------*/
		/*------- If left and right endpoint of max area difference are both finish adjusting ------------------*/
		if (segment_left.optimization_coefficient.finish_decrease_right && segment_middle.optimization_coefficient.finish_decrease_left && segment_middle.optimization_coefficient.finish_decrease_right && segment_right.optimization_coefficient.finish_decrease_left)
			return false;
		/*------------------------------------------------------------------------------------------------------*/
		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++    Adjust left / right endpoint   ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		const long double height_difference_left = fabs(segment_middle.apla.b - original_time_series_vector[segment_middle.right_endpoint - segment_middle.rectangle_width + 1]);
		const long double height_difference_right = fabs(segment_middle.apla.a * (segment_middle.rectangle_width - 1) + segment_middle.apla.b - original_time_series_vector[segment_middle.right_endpoint]);

		/*=======================          Ajust right endpoint            ======================*/
		if ((height_difference_left < height_difference_right && (!segment_middle.optimization_coefficient.finish_decrease_right || !segment_right.optimization_coefficient.finish_decrease_left)) || (segment_left.optimization_coefficient.finish_decrease_right && segment_middle.optimization_coefficient.finish_decrease_left && (!segment_middle.optimization_coefficient.finish_decrease_right || !segment_right.optimization_coefficient.finish_decrease_left))) {
			return adjust_compute_segment_right(original_time_series_vector, split_area_difference_map, node_middle);
		}/*=======================         Ajust left endpoint             ======================*/
		else if ((height_difference_left >= height_difference_right && (!segment_left.optimization_coefficient.finish_decrease_right || !segment_middle.optimization_coefficient.finish_decrease_left)) || (segment_middle.optimization_coefficient.finish_decrease_right && segment_right.optimization_coefficient.finish_decrease_left && (!segment_left.optimization_coefficient.finish_decrease_right || !segment_middle.optimization_coefficient.finish_decrease_left))) {
			return adjust_compute_segment_right(original_time_series_vector, split_area_difference_map, *node_middle._prev);
		}
		else {
			assert(0);
			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
			if (split_area_difference_map.empty()) return false;
			return true;
		}
		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||*/
	}
	else {//tail node
	/*||||||||||||||||||||||||||||||||||||||||||||||||||||||||               Tail Node             ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||*/

		/*..........................................................*/
#ifdef _DEBUG
		assert_split_map_area_difference(split_area_difference_map);
		assert(segment_middle.optimization_coefficient.finish_decrease_right);
#endif
		/*..........................................................*/

		Y& const segment_left = node_middle._prev->_value;

		/*---------------------       left, middle area difference == 0     ------------------------------------*/
		erase_if_adjacent_segments_are_zeros(split_area_difference_map, *node_middle._prev);
		if (segment_left.optimization_coefficient.finish_decrease_right && segment_middle.optimization_coefficient.finish_decrease_left) return false;
		/*------------------------------------------------------------------------------------------------------*/

		/*............................................................................................................................................................*/
#ifdef _DEBUG
		assert(node_middle._prev && !node_middle._next && (!segment_left.optimization_coefficient.finish_decrease_right || !segment_middle.optimization_coefficient.finish_decrease_left));
#endif
		/*.............................................................................................................................................................*/

		adjust_compute_segment_right(original_time_series_vector, split_area_difference_map, *node_middle._prev);

		/*********************************   Erase head node    *****************************/
		erase_node_if_no_need_adjust(split_area_difference_map, node_middle);
		/************************************************************************************/

		return true;

	}
	/*##########################################################################################################################################################*/

	/*..............................................................................................................................*/
#ifdef _DEBUG
	assert_split_map_area_difference(split_area_difference_map);
	//assert(!split_area_difference_map.empty());
	//evaluate right point, min&max point, width. a&b, sum value
	//assertLinkedList(original_time_series_vector, doubly_linked_list);
#endif
	/*.............................................................................................................................*/
}

//************************************
// Method:optimize_segment_max_area_difference_speed3
// Qualifier: Optimization of segment adjust, for max difference segment, adjust both left & right endpoint of segment, choose the min area difference from original one.
// date:201224  09:19
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename T1, typename U>
bool APLA::optimize_segment_max_area_difference_speed3(const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>& const, greater<T1>>& const split_area_difference_map, U& const output_argument) {
	/*.....................................................................................*/
#ifdef _DEBUG
	assert(!split_area_difference_map.empty());
	assert_split_map_optimization(split_area_difference_map);
	//evaluate right point, min&max point, width. a&b, sum value
	//assertLinkedList(original_time_series_vector, doubly_linked_list);
	for (auto&& au : split_area_difference_map) {
		assert(!au.second._value.optimization_coefficient.finish_decrease_left || !au.second._value.optimization_coefficient.finish_decrease_right);
	}
#endif
	/*.....................................................................................*/

	/*####################################################        Coefficients of Split       #############################################################################*/

	/*===============================     width = 2, no space to decrease    =========================================*/
	/*while (split_area_difference_map.begin()->second._value.rectangle_width < 3 || split_area_difference_map.begin()->second._value.area_difference == 0) {
		eraseMapByKey(split_area_difference_map, split_area_difference_map.begin()->second._value.right_endpoint, split_area_difference_map.begin()->second._value.area_difference);
		if (split_area_difference_map.empty()) return false;
	}*/
	/*================================================================================================================*/

	/*============ Split Candidate Long segment with max area difference ==============*/
	auto& const node_middle = split_area_difference_map.begin()->second;
	Y& const segment_middle = node_middle._value;
	/*================================================================================*/

	/*####################################################################################################################################################################*/

	/*###########################################       Move endpoint of max area difference         #########################################################################*/
	if (!node_middle._prev) {//head node

	/*||||||||||||||||||||||||||||||||||||||||||||||||||||||               Head Node             |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||*/

		/*.........................................................................................................................................................................*/
#ifdef _DEBUG
		Y& const segment_right = node_middle._next->_value;
		assert(segment_middle.right_endpoint + 1 == segment_middle.rectangle_width);
		assert_split_map_optimization(split_area_difference_map);
		assert_segment_bound(original_time_series_vector, segment_middle);
		assert_segment_bound(original_time_series_vector, segment_right);
#endif
		/*..........................................................................................................................................................................*/

		/*+++++++++++++++++++++++++++              Head segment area difference == right segment == 0, no need to adjust endpoint           +++++++++++++++++++++++++++*/
		//erase_if_adjacent_segments_are_zeros(split_area_difference_map, node_middle);
		//if (segment_middle.optimization_coefficient.finish_decrease_right && segment_right.optimization_coefficient.finish_decrease_left) return false;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		segment_middle.optimization_coefficient.finish_decrease_left = true;
		if (segment_middle.optimization_coefficient.finish_decrease_right) {
			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
			return false;
		}

		/*--------------------- Update head node & next node / Erase head node ---------------------------*/
		return adjust_compute_segment_right(original_time_series_vector, split_area_difference_map, node_middle, output_argument);
		/*------------------------------------------------------------------------------------------------*/
		//return true;
	}
	else if (node_middle._next) {//middle node
	/*|||||||||||||||||||||||||||||||||||||||||||||||||||               Middle Node             ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||*/
		/*..............................................................................................................................................................................*/
#ifdef _DEBUG
		assert_split_map_optimization(split_area_difference_map);
		//assert(!segment_left.optimization_coefficient.finish_decrease_right || !segment_left.optimization_coefficient.finish_decrease_left || !segment_middle.optimization_coefficient.finish_decrease_right || !segment_middle.optimization_coefficient.finish_decrease_left || !segment_right.optimization_coefficient.finish_decrease_right || !segment_right.optimization_coefficient.finish_decrease_left);
		/*------- If left and right endpoint of max area difference are both finish adjusting ------------------*/
		Y& const segment_left = node_middle._prev->_value;
		Y& const segment_right = node_middle._next->_value;
		if (segment_left.optimization_coefficient.finish_decrease_right && segment_middle.optimization_coefficient.finish_decrease_left && segment_middle.optimization_coefficient.finish_decrease_right && segment_right.optimization_coefficient.finish_decrease_left)
			assert(0);
		/*------------------------------------------------------------------------------------------------------*/

		assert_segment_bound(original_time_series_vector, segment_left);
		assert_segment_bound(original_time_series_vector, segment_middle);
		assert_segment_bound(original_time_series_vector, segment_right);
#endif
		/*..............................................................................................................................................................................*/

		/*-----------------------      middle, right area difference == 0    -----------------------------------*/
		//erase_if_adjacent_segments_are_zeros(split_area_difference_map, node_middle);
		/*------------------------------------------------------------------------------------------------------*/

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++    Adjust left / right endpoint   ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		return adjust_compute_segment_2_sides(original_time_series_vector, split_area_difference_map, node_middle, output_argument);
		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||*/
	}
	else {//tail node
	/*||||||||||||||||||||||||||||||||||||||||||||||||||||||||               Tail Node             ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||*/

		/*..........................................................*/
#ifdef _DEBUG
		assert_split_map_optimization(split_area_difference_map);
#endif
		/*..........................................................*/

		/*---------------------       left, middle area difference == 0     ------------------------------------*/
		//erase_if_adjacent_segments_are_zeros(split_area_difference_map, *node_middle._prev);
		//if (segment_left.optimization_coefficient.finish_decrease_right && segment_middle.optimization_coefficient.finish_decrease_left) return false;
		/*------------------------------------------------------------------------------------------------------*/
		segment_middle.optimization_coefficient.finish_decrease_right = true;
		if (segment_middle.optimization_coefficient.finish_decrease_left) {
			eraseMapByKey(split_area_difference_map, segment_middle.right_endpoint, segment_middle.area_difference);
			return false;
		}

		/*............................................................................................................................................................*/
#ifdef _DEBUG
		Y& const segment_left = node_middle._prev->_value;
		assert(node_middle._prev && !node_middle._next && (!segment_left.optimization_coefficient.finish_decrease_right || !segment_middle.optimization_coefficient.finish_decrease_left));
		assert_segment_bound(original_time_series_vector, segment_left);
		assert_segment_bound(original_time_series_vector, segment_middle);
#endif
		/*.............................................................................................................................................................*/

		return adjust_compute_segment_right(original_time_series_vector, split_area_difference_map, *node_middle._prev, output_argument);

		//return true;

	}
	/*##########################################################################################################################################################*/

	/*....................................................................*/
#ifdef _DEBUG
	assert_split_map_optimization(split_area_difference_map);
	//assert(!split_area_difference_map.empty());
	//evaluate right point, min&max point, width. a&b, sum value
	//assertLinkedList(original_time_series_vector, doubly_linked_list);
#endif
	/*...................................................................*/
}

//************************************
// Method:optimization_segments
// Qualifier: After initialization, split&merge operation, begin to optimizaiton of endpoints of segment.
// Notice: The reference of MAP has no relationship with the reference of Linked List
// date:201002 10:09
// author:
//************************************
TEMPLATE
template<typename T, typename T1, typename Y, typename U, typename U1>
void APLA::optimization_segments_loop(U& const input_argument, const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument) {

	/*.................................................................................................................................*/
#ifdef _DEBUG
	assert(doubly_linked_list.size() == input_argument.point_dimension);
	//assert(right_endpoint_segment_max_density_merge == right_endpoint_segment_max_area_difference);
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	vector<int> initial_right_endpoint_vector;
	for (auto&& au : doubly_linked_list) {
		initial_right_endpoint_vector.emplace_back(au.right_endpoint);
	}
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	assert_split_map_area_difference(split_area_difference_map);
#endif
	/*.................................................................................................................................*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!     Initial optimization coefficients   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	doubly_linked_list.back().optimization_coefficient.finish_right = true;
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	/*+++++++++++++++++++    Candidate split segment is just the latest merged segments    ++++++++++++++++++++++++++++++*/
	while (!split_area_difference_map.empty()) {

		/****************************************************************************/
		long double area_difference_sum_old = INF;
		long double area_difference_sum_new = -INF;
		/****************************************************************************/
		while (area_difference_sum_old > area_difference_sum_new && !split_area_difference_map.empty()) {
			area_difference_sum_old = get_whole_area_difference(doubly_linked_list);
			//area_difference_sum_old = get_whole_area_difference_by_map(split_area_difference_map);

			/*..............................................................................................................................*/
#ifdef _DEBUG
			//cout << "Old sum area difference: "<< area_difference_sum_old  <<endl;
			//TOOL::print_each_segment_coefficient(doubly_linked_list);
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/

			/*::::::::::::::::::::::::::::::::::::::::::::::::::             Optimization Operation             ::::::::::::::::::::::::::::::::::::::::::::::::::::*/
			optimize_segment_max_area_difference(original_time_series_vector, split_area_difference_map);
			//int split_method_option = 0;
			//split_merge_optimization(original_time_series_vector, split_method_option, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
			/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/


			/*..............................................................................................................................*/
#ifdef _DEBUG
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/

			area_difference_sum_new = get_whole_area_difference(doubly_linked_list);
			//area_difference_sum_new = get_whole_area_difference_by_map(split_area_difference_map);

			//evaluate_upper_lower_bound(input_argument, original_time_series_vector, doubly_linked_list);
			/*..............................................................................................................................*/
	//#ifdef _DEBUG
			//evaluate right point, min&max point, width. a&b, sum value
			//assertLinkedList(original_time_series_vector, doubly_linked_list);
			//cout << "New sum area difference: " << area_difference_sum_new << endl;
			//TOOL::print_each_segment_coefficient(doubly_linked_list);
			//assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
	//#endif
			/*..............................................................................................................................*/
		}
	}
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*...................................................................................................................*/
#ifdef _DEBUG
	//vector<T> reconstruct_time_series_vector;

	///*###################################           Print linked list          ###########################*/
	//cout << "After OO segment coefficients: \n";
	//TOOL::print_each_segment_coefficient(doubly_linked_list);
	///*####################################################################################################*/

	///*############################    200907 get reconstruct time series       ###########################*/
	//getAPLAReconstructSeries(doubly_linked_list, reconstruct_time_series_vector);
	//cout << "Reconstruct time series:";
	//TOOL::print_vector(reconstruct_time_series_vector);
	///*####################################################################################################*/

	///*#######    get a&b of every segment & get sum deviation & get reconstruction time series     #######*/
	////getAPLA(input_argument, original_time_series, doubly_linked_list);
	//long double sum_deviation = get_sum_deviation_no_ab(original_time_series_vector, doubly_linked_list);
	//cout << "After OO sum deviation: " << sum_deviation << endl;
	///*####################################################################################################*/

	//int count_same = 0;
	//for (int i = 0; i < initial_right_endpoint_vector.size(); i++) {
	//	if (initial_right_endpoint_vector[i] == doubly_linked_list[i].right_endpoint) {
	//		count_same++;
	//	}
	//}
	//if (count_same == initial_right_endpoint_vector.size()) {
	//	input_argument.is_optimization_effect = false;
	//}
	//else {
	//	input_argument.is_optimization_effect = true;
	//	//assert(0);
	//}
#endif
	/*....................................................................................................................*/
}

//201103 Speed up. After initialization, split&merge operation, begin to optimizaiton of endpoints of segment.
TEMPLATE
template<typename T, typename T1, typename Y, typename U, typename U1>
void APLA::optimization_segments_loop_speed(U& const input_argument, const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument) {
	/*..................................................................................................*/
#ifdef _DEBUG
	assert(doubly_linked_list.size() == input_argument.point_dimension);
	//assert(right_endpoint_segment_max_density_merge == right_endpoint_segment_max_area_difference);
	/*^^^^^^^^^^^^^^^        201217 Find Example      ^^^^^^^^^^^^^^^*/
	vector<int> initial_right_endpoint_vector;
	for (auto&& au : doubly_linked_list) {
		initial_right_endpoint_vector.emplace_back(au.right_endpoint);
	}
	/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
	assert_split_map_area_difference(split_area_difference_map);
	//assert_minmax_value(original_time_series_vector, doubly_linked_list);
	assert_bound(original_time_series_vector, doubly_linked_list);
#endif
	/*....................................................................................................*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!     Initial optimization coefficients   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	//doubly_linked_list.front().optimization_coefficient.finish_decrease_left = doubly_linked_list.back().optimization_coefficient.finish_decrease_right = true;
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	bool continue_optimization = true;
	/*+++++++++++++++++++    Candidate split segment is just the latest merged segments    ++++++++++++++++++++++++++++++*/
	//while (!split_area_difference_map.empty()) {

		/****************************************************************************/
		/*long double area_difference_sum_old = INF;
		long double area_difference_sum_new = -INF;*/
		/****************************************************************************/
	while (continue_optimization && !split_area_difference_map.empty()) {
		//while (!split_area_difference_map.empty()) {
			//area_difference_sum_old = get_whole_area_difference(doubly_linked_list);
			//area_difference_sum_old = get_whole_area_difference_by_map(split_area_difference_map);

			/*..............................................................................................................................*/
#ifdef _DEBUG
			//cout << "Old sum area difference: "<< area_difference_sum_old  <<endl;
			//TOOL::print_each_segment_coefficient(doubly_linked_list);
			//assert_split_map_area_difference(split_area_difference_map);
		assert_bound(original_time_series_vector, doubly_linked_list);
#endif
		/*..............................................................................................................................*/

		/*::::::::::::::::::::::::::::::::::::::::::::::::::             Optimization Operation             ::::::::::::::::::::::::::::::::::::::::::::::::::::*/
		//continue_optimization = optimize_segment_max_area_difference_speed(original_time_series_vector, split_area_difference_map);
		//201213
		//continue_optimization = optimize_segment_max_area_difference_speed1(original_time_series_vector, split_area_difference_map);

		//2120103
		continue_optimization = optimize_segment_max_area_difference_speed3(original_time_series_vector, split_area_difference_map, output_argument);

		//int split_method_option = 0;
		//split_merge_optimization(original_time_series_vector, split_method_option, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
		/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
		/*..............................................................................................................................*/
#ifdef _DEBUG
		assert_bound(original_time_series_vector, doubly_linked_list);
		//assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/

			//area_difference_sum_new = get_whole_area_difference(doubly_linked_list);
			//area_difference_sum_new = get_whole_area_difference_by_map(split_area_difference_map);
			//evaluate_upper_lower_bound(input_argument, original_time_series_vector, doubly_linked_list);
			/*..............................................................................................................................*/
	//#ifdef _DEBUG
			//evaluate right point, min&max point, width. a&b, sum value
			//assertLinkedList(original_time_series_vector, doubly_linked_list);
			//cout << "New sum area difference: " << area_difference_sum_new << endl;
			//TOOL::print_each_segment_coefficient(doubly_linked_list);
			//assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
	//#endif
			/*..............................................................................................................................*/
	}
	//}
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*..............................................................................................................................*/
#ifdef _DEBUG
	//assert_minmax_value(original_time_series_vector, doubly_linked_list);
	assert_bound(original_time_series_vector, doubly_linked_list);

	/*:::::::::::::::::::::::::::         201217 find example           :::::::::::::::::::::::*/
	/*----------------  get a&b of every segment & get sum deviation & get reconstruction time series  --------*/
	//const long double sum_deviation = get_sum_deviation_no_ab(original_time_series_vector, doubly_linked_list);
	//typename TOOL::RESULT_RECORD result_record;
	//get_sum_deviation_no_ab(original_time_series_vector, doubly_linked_list, result_record);
	///*---------------------------------------------------------------------------------------------------------*/
	//int count_same = 0;
	//for (int i = 0; i < initial_right_endpoint_vector.size(); i++) {// 201217
	//	if (initial_right_endpoint_vector[i] == doubly_linked_list[i].right_endpoint) {
	//		count_same++;
	//	}
	//}

	//if (count_same == initial_right_endpoint_vector.size() || result_record.max_deviation_av >= output_argument.max_deviation_av) {
	////if (count_same == initial_right_endpoint_vector.size() || result_record.max_deviation >= output_argument.max_deviation) {
	////if (count_same == initial_right_endpoint_vector.size() || result_record.sum_deviation >= output_argument.sum_deviation || result_record.max_deviation >= output_argument.max_deviation) {
	//	input_argument.is_optimization_effect = false;
	//}
	//else {
	//	input_argument.is_optimization_effect = true;
	//	output_argument.sum_deviation = result_record.sum_deviation;
	//	output_argument.max_deviation = result_record.max_deviation;
	//	output_argument.max_deviation_av = result_record.max_deviation_av;
	//	//assert(0);
	//}

	///*--------------   Print linked list  -------------------*/
	//cout << "----------------------------------------------------------\n13 After Optimization: segment coefficients: \n";
	//TOOL::print_each_segment_coefficient(doubly_linked_list);
	///*-------------------------------------------------------*/

	///*---------    200907 get reconstruct time series   ------------------------*/
	//vector<T> reconstruct_time_series_vector;
	//getAPLAReconstructSeries(doubly_linked_list, reconstruct_time_series_vector);
	//cout << "\n14 After Optimization: Reconstruct time series:";
	//TOOL::print_vector(reconstruct_time_series_vector);
	///*--------------------------------------------------------------------------*/

	///*----------------------------------------------------------------------*/
	//cout << "15 After Optimization: reconstructed endpoint id: 0,";
	//for (auto au : doubly_linked_list) {
	//	if (au.right_endpoint == reconstruct_time_series_vector.size() - 1)
	//		cout << au.right_endpoint;
	//	else
	//		cout << au.right_endpoint << "," << au.right_endpoint + 1 << ",";
	//}
	//cout << "\n15 After Optimization: reconstructed endpoint value:" << reconstruct_time_series_vector[0]<<",";
	///*for (auto au : doubly_linked_list) {
	//	if (au.right_endpoint == reconstruct_time_series_vector.size() - 1)
	//		cout << reconstruct_time_series_vector[au.right_endpoint];
	//	else
	//		cout << reconstruct_time_series_vector[au.right_endpoint] << "," << reconstruct_time_series_vector[au.right_endpoint + 1] << ",";
	//}
	//cout << endl;*/
	///*----------------------------------------------------------------------*/

	//reconstruct_time_series_vector.clear();
	//reconstruct_time_series_vector.shrink_to_fit();

	///*---  get a&b of every segment & get sum deviation & get reconstruction time series  ----*/
	//cout << "\n16 ####After Optimization: sum deviation: " << result_record.sum_deviation << ", max deviation: " << result_record.max_deviation << ", max deviation average: " << result_record.max_deviation_av << ", max deviation width: " << result_record.max_deviation_multiple_width << endl;
	///*----------------------------------------------------------------------------------------*/
	/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

	initial_right_endpoint_vector.clear();
	initial_right_endpoint_vector.shrink_to_fit();
#endif
	/*..............................................................................................................................*/
}

//************************************
// Method:split_merge_optimization_segments_speed
// Qualifier: After initial part, The fastest way. Use split&merge&optimization to get tighter approximation
// linked list size <= N
// date:201030 10:10
// author:
//************************************
TEMPLATE
template<typename T, typename T1, typename Y, typename U, typename U1>
void APLA::split_merge_optimization_segments_speed(U& const input_argument, const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument) {
	/*..................................................................................................................*/
#ifdef _DEBUG
	assert(doubly_linked_list.size() == input_argument.point_dimension);

	/*::::::::::::::::::::     201217 Find Example      ::::::::::::::::::::::::::*/
	/*vector<int> initial_right_endpoint_vector;
	for (auto&& au : doubly_linked_list) {
		initial_right_endpoint_vector.emplace_back(au.right_endpoint);
	}*/
	//DoublyLinkedList<Y> temp_doubly_linked_list = DoublyLinkedList<Y>();
	//temp_doubly_linked_list.copy(doubly_linked_list);
	////multimap<T1, DoublyListNode<Y>&, greater<T1>> temp_merge_segment_density_map;
	////multimap<T1, DoublyListNode<Y>&, greater<T1>> temp_split_area_difference_map;
	/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

#endif
	/*....................................................................................................................*/

	if (split_area_difference_map.empty()) {
		return;
	}
	else {
		/*============================================================================================================================================*/
		//long double area_difference_sum_old = INF;
		//long double area_difference_sum_new = -INF;
		/*============================================================================================================================================*/
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++    Candidate split segment is just the latest merged segments    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		bool should_change = true;

		while (should_change) {

			/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   Split  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/

			/*..................................................................................................*/
#ifdef _DEBUG
			//evaluate right point, min&max point, width. a&b, sum value
			assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..................................................................................................*/

			/*----------------------             Whether MAP Empty      ----------------------*/
			// If MAP is empty, no need to split
			if (split_area_difference_map.empty()) break;
			/*--------------------------------------------------------------------------------*/

			/*#############################################               Original Split Segment               ##################################################*/
			auto& const splited_node_original = split_area_difference_map.begin()->second;
			auto& const splited_node_segment_original = splited_node_original._value;

			auto& const merged_node_original = merge_segment_density_map.begin()->second;
			auto& const merged_node_segment_original = merged_node_original._value;

			/*------------------------       If the splited segment is head segment      ---------------------------*/
			bool is_head_node_split = false;
			if (splited_node_segment_original.right_endpoint + 1 == splited_node_segment_original.rectangle_width)
				is_head_node_split = true;
			/*------------------------------------------------------------------------------------------------------*/

			/*------------------------        If the merged segment is head segment      ---------------------------*/
			bool is_head_node_merge = false;
			if (merged_node_segment_original.right_subsegment->right_endpoint + 1 == merged_node_segment_original.right_subsegment->rectangle_width)
				is_head_node_merge = true;
			/*------------------------------------------------------------------------------------------------------*/

			/*-------------------------       If merged node has next: not tail              -----------------------*/
			double merge_right_original_segment_density = -1;
			if (merged_node_original._next)
				merge_right_original_segment_density = merged_node_original._next->_value.right_subsegment->segment_density;
			/*------------------------------------------------------------------------------------------------------*/

			/*-------------------------       If splited node has next: not tail              -----------------------*/
			long double split_right_original_segment_density = -1;
			if (splited_node_original._next) {//not tail node
				split_right_original_segment_density = splited_node_original._next->_value.right_subsegment->segment_density;
			}
			/*------------------------------------------------------------------------------------------------------*/

			long double original_area_difference_sum = splited_node_segment_original.area_difference;

			/*************************      Split: New sub left, right and long segment         **************************/
			//sub left segemnt
			DoublyListNode<Y>* node_sub_left_new = new DoublyListNode<Y>;
			Y& const sub_left_segment = node_sub_left_new->_value;

			Y sub_right_segment;
			//*sub_right_segment.right_subsegment = splited_node_segment_original;
			sub_right_segment = splited_node_segment_original;
			sub_right_segment.right_subsegment = new Y;

			Y long_right_segment;
			long_right_segment.area_difference = 0;

			//vector<Y> changed_segment_vector;
			/***************************************************************************************************************/

			/****************************         Split Original Splited Difference          *******************************/
			// original long segment area difference
			const double original_split_splited_area_difference = splited_node_segment_original.area_difference;
			// original long segment and previous segment triangle density.
			const auto original_split_splited_segment_density = splited_node_segment_original.right_subsegment->segment_density;

			size_t original_split_left_right_endpoint = 0;
			size_t original_split_left_rectangl_width = 0;
			double original_split_left_area_difference = 0;
			double original_split_right_area_difference = 0;
			double origianl_split_left_segment_density = -1;

			/***************************************************************************************************************/

			/*****************************  Merge: New sub left, right and long segment   **********************************/
			const auto original_merge_left_area_difference = merged_node_original._prev->_value.area_difference;
			const auto& const original_merge_left_segment_density = merged_node_original._prev->_value.right_subsegment->segment_density;
			const auto origial_merge_merged_area_difference = merged_node_segment_original.area_difference;
			const auto origial_merge_merged_segment_density = merged_node_segment_original.right_subsegment->segment_density;
			const auto origial_merge_merged_segment_rectangle_width = merged_node_segment_original.rectangle_width;
			/***************************************************************************************************************/

			/*#############################################################################################################################################################*/

			/*############################################################      Assert  Merge Segment         #############################################################*/
			/*............................................................................................................................*/
#ifdef _DEBUG
			assert(original_merge_left_area_difference != INF && origial_merge_merged_area_difference != INF && splited_node_segment_original.rectangle_width > 3);
			assert(merged_node_segment_original.right_subsegment != nullptr && merged_node_segment_original.apla.a != INF && merged_node_segment_original.apla.b != INF && merged_node_segment_original.right_endpoint != INF && merged_node_segment_original.rectangle_width != INF);

			find_if_in_multimap(original_split_splited_area_difference, split_area_difference_map);
			if (!is_head_node_split) { find_if_in_multimap(original_split_splited_segment_density, merge_segment_density_map); }
			if (splited_node_original._next) { find_if_in_multimap(split_right_original_segment_density, merge_segment_density_map); }
			if (original_merge_left_area_difference > 0 && merged_node_original._prev->_value.rectangle_width > 3) { find_if_in_multimap(original_merge_left_area_difference, split_area_difference_map); }
			if (!is_head_node_merge) { find_if_in_multimap(original_merge_left_segment_density, merge_segment_density_map); }
			if (origial_merge_merged_area_difference > 0 && origial_merge_merged_segment_rectangle_width > 3) { find_if_in_multimap(origial_merge_merged_area_difference, split_area_difference_map); }
			find_if_in_multimap(origial_merge_merged_segment_density, merge_segment_density_map);
			if (merge_right_original_segment_density != -1) { find_if_in_multimap(merge_right_original_segment_density, merge_segment_density_map); }

			assert(original_split_splited_area_difference > 0 && original_split_splited_area_difference != INF && splited_node_segment_original.right_subsegment != nullptr);
			assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
			/*............................................................................................................................*/
			/*############################################################################################################################################################*/

			/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&      Find splited new segemnt right_id      &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
			const int split_method_option = 0;
			*sub_right_segment.right_subsegment = sub_right_segment;
			sub_left_segment.right_endpoint = group_find_split_point_methods(original_time_series_vector, split_method_option, sub_left_segment, sub_right_segment, *sub_right_segment.right_subsegment, output_argument);
			/*........................................................................................*/
#ifdef _DEBUG
			assert(sub_left_segment.right_endpoint > 0 && sub_left_segment.right_endpoint < sub_right_segment.right_endpoint);
			assert(sub_left_segment.rectangle_width + sub_right_segment.rectangle_width == splited_node_segment_original.rectangle_width);
			assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
			/*........................................................................................*/
			/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

			/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Has Spilt Point   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
			// Has split point, begin to split segment
			if (sub_left_segment.right_endpoint != INF) {

				sub_left_segment.right_subsegment = new Y;

				/*###################################################     Compute new candidate Area difference & Triangle Density    ##################################*/
				/*------------------------   210203      get Min&Max point     ------------------------------*/
				//200212 get min&max point of left&right segment by long segment, speed up
				//getSubMinMaxPoint(original_time_series_vector, sub_left_segment, sub_right_segment, *sub_right_segment.right_subsegment);
				/*-------------------------------------------------------------------------------------*/

				/*----------------------        Compute Area Difference    ----------------------------*/
				getAreaDifference(original_time_series_vector, sub_left_segment);
				getAreaDifference(original_time_series_vector, sub_right_segment);
				getAreaDifference(original_time_series_vector, *sub_right_segment.right_subsegment);
				/*-------------------------------------------------------------------------------------*/

				/*:::::::::::::::::::::::::::::    201217 Find Example    ::::::::::::::::::::::::::::::::::::::::::::::*/
				//auto& temp_splited_node_copy = temp_doubly_linked_list.getNode(2);
				//temp_doubly_linked_list.insertValueBeforeNode(sub_left_segment, temp_splited_node_copy);
				//temp_doubly_linked_list.insertValueBeforeNode(sub_right_segment, temp_splited_node_copy);
				//temp_doubly_linked_list.removeNode(temp_splited_node_copy);

				///*###################################           Print linked list          ###########################*/
				//cout << "After Split segment coefficients: \n";
				//TOOL::print_each_segment_coefficient(temp_doubly_linked_list);
				///*####################################################################################################*/

				///*#############################    200907 get reconstruct time series      ###########################*/
				//vector<T> reconstruct_time_series_vector;
				//getAPLAReconstructSeries(temp_doubly_linked_list, reconstruct_time_series_vector);
				//cout << "Reconstruct time series:";
				//TOOL::print_vector(reconstruct_time_series_vector);
				//reconstruct_time_series_vector.clear();
				//reconstruct_time_series_vector.shrink_to_fit();
				///*####################################################################################################*/
				//assert(0);
				/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

				multimap<T1, Y&, greater<T1>> temp_new_merge_segment_density_3_map;

				/*-------------------------       new Triangle Area: (long left segemnt, sub left segemnt)       -----------------------------------------*/
				if (!is_head_node_split) {//middle node
					original_split_left_right_endpoint = splited_node_original._prev->_value.right_endpoint;
					original_split_left_rectangl_width = splited_node_original._prev->_value.rectangle_width;
					original_split_left_area_difference = splited_node_original._prev->_value.area_difference;
					original_area_difference_sum += original_split_left_area_difference;
#ifdef _DEBUG
					if (original_split_left_area_difference > 0 && splited_node_original._prev->_value.rectangle_width > 3)
						find_if_in_multimap(original_split_left_area_difference, split_area_difference_map);
#endif
					/*--------------------------             Density: long left segment & sub left segment                 -------------------------------*/
					getMergedSubSegmentInformation(original_time_series_vector, splited_node_original._prev->_value, sub_left_segment, *sub_left_segment.right_subsegment);//200109 For area difference
					/*------------------------------------------------------------------------------------------------------------------------------------*/
					temp_new_merge_segment_density_3_map.emplace(sub_left_segment.right_subsegment->segment_density, sub_left_segment);
					//changed_segment_vector.emplace_back(sub_left_segment);
					const auto& left_segment = splited_node_original._prev->_value;
					if (splited_node_original._prev->_value.rectangle_width != original_split_left_right_endpoint + 1) {
						origianl_split_left_segment_density = splited_node_original._prev->_value.right_subsegment->segment_density;
#ifdef _DEBUG
						find_if_in_multimap(origianl_split_left_segment_density, merge_segment_density_map);
#endif
					}
				}
				/*------------------------------------------------------------------------------------------------------------------------------------------*/

				temp_new_merge_segment_density_3_map.emplace(sub_right_segment.right_subsegment->segment_density, sub_right_segment);
				//changed_segment_vector.emplace_back(sub_right_segment);

				/*-------------------------       new Triangle Area: (sub right segemnt, long right segemnt)    ----------------------------------------------*/
				if (splited_node_original._next) {
					long_right_segment = splited_node_original._next->_value;
					long_right_segment.right_subsegment = new Y;
					original_split_right_area_difference = long_right_segment.area_difference;
#ifdef _DEBUG
					if (original_split_right_area_difference > 0 && splited_node_original._next->_value.rectangle_width > 3)
						find_if_in_multimap(original_split_right_area_difference, split_area_difference_map);
#endif
					original_area_difference_sum += long_right_segment.area_difference;
					getMergedSubSegmentInformation(original_time_series_vector, sub_right_segment, long_right_segment, *long_right_segment.right_subsegment);//200109 For area difference
					temp_new_merge_segment_density_3_map.emplace(long_right_segment.right_subsegment->segment_density, long_right_segment);
					//changed_segment_vector.emplace_back(long_right_segment);
				}
				/*------------------------------------------------------------------------------------------------------------------------------------------*/

				/*...........................................................................................................................................................*/
#ifdef _DEBUG
				if (doubly_linked_list.size() > 1) {
					assert(!merge_segment_density_map.empty());
				}
				else if (doubly_linked_list.size() == 1) {
					assert(merge_segment_density_map.empty());
					break;
				}
#endif
				/*............................................................................................................................................................*/
				/*###############################################################################################################################################################*/

				long double new_merge_area_difference_sum = 0;
				/*Begin to Merge*/
				if (temp_new_merge_segment_density_3_map.begin()->first >= merge_segment_density_map.begin()->first || merged_node_segment_original.right_endpoint == sub_right_segment.right_endpoint || merged_node_segment_original.right_endpoint == long_right_segment.right_endpoint) {
#ifdef _DEBUG
					assert_split_map_area_difference(split_area_difference_map);
#endif
					//auto& const merged_node = temp_split_3_area_difference_map.begin()->second;
					auto& const merged_segment_candidate = temp_new_merge_segment_density_3_map.begin()->second;

					/*++++++++++++++++++++++++++++++++++++++++           candidate merge segment: sub left segment          ++++++++++++++++++++++++++++++++++++++++++*/
					if (merged_segment_candidate.right_endpoint == sub_left_segment.right_endpoint) {//Make sure has left node, not head node.

						assert(!is_head_node_split);

						/*||||||||||||||||||||||   Candidate merge long left, sub left   |||||||||||||||||||*/
						new_merge_area_difference_sum += sub_left_segment.right_subsegment->area_difference;
						new_merge_area_difference_sum += sub_right_segment.area_difference;
						new_merge_area_difference_sum += long_right_segment.area_difference;
						/*||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||*/

						if (original_area_difference_sum >= new_merge_area_difference_sum) {// Should Merge
							should_change = true;

							/*----------------------------------------       Merge long left and sub left segment         -------------------------------------------*/
							sub_left_segment.right_subsegment->right_subsegment = sub_left_segment.right_subsegment;
							sub_left_segment = *sub_left_segment.right_subsegment;
							/*----------------------------------------------------------------------------------------------------------------------------------------*/

							splited_node_original._prev->_value = sub_left_segment;
							splited_node_segment_original = sub_right_segment;

							/*----------------------------------------------  Split MAP: splited => sub right segment    ---------------------------------------------*/
							if (sub_right_segment.area_difference > 0 && sub_right_segment.rectangle_width > 3) {
#ifdef _DEBUG
								if (original_split_splited_area_difference > 0)
									find_if_in_multimap(original_split_splited_area_difference, split_area_difference_map);
#endif
								updateMapByKey(split_area_difference_map, sub_right_segment.right_endpoint, original_split_splited_area_difference, sub_right_segment.area_difference);
#ifdef _DEBUG
								find_if_in_multimap(sub_right_segment.area_difference, split_area_difference_map);
#endif
							}
							else {
#ifdef _DEBUG
								if (original_split_splited_area_difference > 0)
									find_if_in_multimap(original_split_splited_area_difference, split_area_difference_map);
#endif
								eraseMapByKey(split_area_difference_map, sub_right_segment.right_endpoint, original_split_splited_area_difference);

							}
							/*------------------------------------------------------------------------------------------------------------------------------------------*/
							/*--- Split MAP: long left => Merged(long left, sub left segment) / Merge MAP: (long left, splited node) => (merged sub left, sub right) ---*/
							if (!is_head_node_split) {//middle node
								if (original_split_left_area_difference > 0 && sub_left_segment.area_difference > 0 && original_split_left_rectangl_width > 3) {
#ifdef _DEBUG
									assert(sub_left_segment.rectangle_width > 3);
									find_if_in_multimap(original_split_left_area_difference, split_area_difference_map);
#endif
									updateMapByKey(split_area_difference_map, sub_left_segment.right_endpoint, original_split_left_area_difference, sub_left_segment.area_difference);//200109 For area difference
#ifdef _DEBUG
									find_if_in_multimap(sub_left_segment.area_difference, split_area_difference_map);
#endif
								}
								else if (sub_left_segment.area_difference > 0 && sub_left_segment.rectangle_width > 3) {
									split_area_difference_map.emplace(sub_left_segment.area_difference, *splited_node_original._prev);
								}
								updateMapByKey(merge_segment_density_map, sub_right_segment.right_endpoint, original_split_splited_segment_density, getMergedSubSegmentInformation(original_time_series_vector, splited_node_original));//200109 For area difference

							}
							else {//head node
								assert(0);
							}
							/*------------------------------------------------------------------------------------------------------------------------------------------*/
							/*-------------------    Merge MAP: (splited node, long right node) => (sub right node, long right node)        ----------------------------*/
							if (splited_node_original._next) {
								*splited_node_original._next->_value.right_subsegment = *long_right_segment.right_subsegment;
#ifdef _DEBUG
								assert(splited_node_original._next->_value.right_subsegment->segment_density == long_right_segment.right_subsegment->segment_density);
#endif
								updateMapByKey(merge_segment_density_map, long_right_segment.right_endpoint, split_right_original_segment_density, long_right_segment.right_subsegment->segment_density);//200109 For area difference

							}
							/*-------------------------------------------------------------------------------------------------------------------------------------------*/
							/*----------------       Merge MAP: (long left left, long left) => (long left left, (long left , sub left))       -----------------------------*/
							if (sub_left_segment.rectangle_width != sub_left_segment.right_endpoint + 1) {//After merge, (long left, sub left) is not head
								updateMapByKey(merge_segment_density_map, original_split_left_right_endpoint, origianl_split_left_segment_density, getMergedSubSegmentInformation(original_time_series_vector, *splited_node_original._prev));//200109 For area di
							}
							/*------------------------------------------------------------------------------------------------------------------------------------------*/
							/*..............................................................................................................................*/
#ifdef _DEBUG
							assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
							assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
							assert_split_map_area_difference(split_area_difference_map);
#endif
							/*..............................................................................................................................*/
						}
						else {
							should_change = false;
							break;
						}
					}
					/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
					else if (merged_segment_candidate.right_endpoint == sub_right_segment.right_endpoint) {
#ifdef _DEBUG
						assert_split_map_area_difference(split_area_difference_map);
#endif
						should_change = false;
						break;
					}
					else if (merged_segment_candidate.right_endpoint == long_right_segment.right_endpoint) {
#ifdef _DEBUG
						assert_split_map_area_difference(split_area_difference_map);
#endif
						new_merge_area_difference_sum += original_split_left_area_difference;
						new_merge_area_difference_sum += sub_left_segment.area_difference;
						new_merge_area_difference_sum += long_right_segment.right_subsegment->area_difference;

						if (original_area_difference_sum >= new_merge_area_difference_sum) {// Must have next node
#ifdef _DEBUG
							assert_split_map_area_difference(split_area_difference_map);
#endif
							should_change = true;

							const size_t original_split_right_rectangle_width = long_right_segment.rectangle_width;

							/*----------------------------------------------       Merge (sub right, long right)         ---------------------------------------------*/
							long_right_segment.right_subsegment->right_subsegment = long_right_segment.right_subsegment;
							long_right_segment = *long_right_segment.right_subsegment;
							/*----------------------------------------------------------------------------------------------------------------------------------------*/

							splited_node_segment_original = sub_left_segment;
							splited_node_original._next->_value = long_right_segment;

							/*----------------------------------------------  Split MAP: splited => sub left segment    ------------------------------------------------*/
							if (sub_left_segment.area_difference > 0 && sub_left_segment.rectangle_width > 3) {
								updateMapByKey(split_area_difference_map, sub_right_segment.right_endpoint, original_split_splited_area_difference, sub_left_segment.area_difference);
							}
							else {
								eraseMapByKey(split_area_difference_map, sub_right_segment.right_endpoint, original_split_splited_area_difference);
							}
							/*------------------------------------------------------------------------------------------------------------------------------------------*/
							/*-----------------------------------    Merge MAP: (long left, splited node) => (long left, sub left)     ---------------------------------*/
							if (!is_head_node_split) {//middle node
								updateMapByKey(merge_segment_density_map, sub_right_segment.right_endpoint, original_split_splited_segment_density, sub_left_segment.right_subsegment->segment_density);//200109 For area difference
							}

							/*------------------------------------------------------------------------------------------------------------------------------------------*/
							/*-------------------    Merge MAP: (splited node, long right node) => (sub left node, (sub right, long right))        ----------------------------*/
							if (splited_node_original._next) {

								if (original_split_right_area_difference > 0 && long_right_segment.area_difference > 0 & original_split_right_rectangle_width > 3) {
									updateMapByKey(split_area_difference_map, long_right_segment.right_endpoint, original_split_right_area_difference, long_right_segment.area_difference);//200109 For area difference
								}
								else if (long_right_segment.area_difference > 0) {
									split_area_difference_map.emplace(long_right_segment.area_difference, *splited_node_original._next);
								}

								updateMapByKey(merge_segment_density_map, long_right_segment.right_endpoint, split_right_original_segment_density, getMergedSubSegmentInformation(original_time_series_vector, *splited_node_original._next));//200109 For area difference
							}
							else {
								assert(0);
							}
							/*-------------------------------------------------------------------------------------------------------------------------------------------*/
							/*-----------       Merge MAP: (long right, long right right) => ((sub right,long right), long right right)       ---------------------------*/
							if ((*splited_node_original._next)._next) {//After merge, (long left, sub left) is not head

								auto& const right_node = *splited_node_original._next;
								const auto right_right_segment_density = right_node._next->_value.right_subsegment->segment_density;
								updateMapByKey(merge_segment_density_map, right_node._next->_value.right_endpoint, right_right_segment_density, getMergedSubSegmentInformation(original_time_series_vector, *right_node._next));//200109 For area di
#ifdef _DEBUG
								assert_split_map_area_difference(split_area_difference_map);
#endif
							}
							/*-------------------------------------------------------------------------------------------------------------------------------------------*/

							/*..............................................................................................................................*/
#ifdef _DEBUG
							assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
							assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
							assert_split_map_area_difference(split_area_difference_map);
#endif
							/*..............................................................................................................................*/
						}
						else {
							should_change = false;
							break;
						}
					}
					else {
						assert(0);
					}

				}/*###########################################*/
				else if (merged_node_segment_original.right_endpoint < sub_left_segment.right_endpoint || merged_node_segment_original.right_endpoint > long_right_segment.right_endpoint) {
					original_area_difference_sum = 0;
					original_area_difference_sum += splited_node_segment_original.area_difference;
					original_area_difference_sum += merged_node_original._prev->_value.area_difference;
					original_area_difference_sum += merged_node_segment_original.area_difference;

					new_merge_area_difference_sum = 0;
					new_merge_area_difference_sum += merged_node_segment_original.right_subsegment->area_difference;
					new_merge_area_difference_sum += sub_left_segment.area_difference;
					new_merge_area_difference_sum += sub_right_segment.area_difference;
#ifdef _DEBUG
					assert_split_map_area_difference(split_area_difference_map);
#endif
					if (original_area_difference_sum >= new_merge_area_difference_sum) {
						should_change = true;
						splited_node_segment_original = sub_right_segment;
						/*======================================== Linked list: Insert sub left segment   ======================================*/
						doubly_linked_list.insertNodeBeforeNode(*node_sub_left_new, splited_node_original);
						/*======================================================================================================================*/

						/*########################################################    Split MAP: Update Emplace   #######################################################*/

						/*------------------------   Split MAP: sub left segment    -----------------*/
						if (sub_left_segment.area_difference > 0 && sub_left_segment.rectangle_width > 3) {
							//if (getAreaDifference(left_segment) > 0) {
							split_area_difference_map.emplace(sub_left_segment.area_difference, *splited_node_original._prev);
						}
						/*---------------------------------------------------------------------------*/

						/*...........................................................................*/
#ifdef _DEBUG
						assert(sub_left_segment.area_difference == splited_node_original._prev->_value.area_difference && sub_left_segment.area_difference != INF);
						find_if_in_multimap(original_split_splited_area_difference, split_area_difference_map);
#endif
						/*...........................................................................*/

						/*------------------------Split MAP: sub right segment------------------*/
						if (splited_node_segment_original.area_difference > 0 && splited_node_segment_original.rectangle_width > 3) {
							updateMapByKey(split_area_difference_map, splited_node_segment_original.right_endpoint, original_split_splited_area_difference, splited_node_segment_original.area_difference);
						}
						else {
							eraseMapByKey(split_area_difference_map, splited_node_segment_original.right_endpoint, original_split_splited_area_difference);
						}
						/*-----------------------------------------------------------------------------*/
						/*============================================================================================================================================================================*/

						/*==================================================================   Merge MAP : left, current and right segment     ======================================================*/

						/*..........................................................................................................................*/
#ifdef _DEBUG
						if (!is_head_node_split) { find_if_in_multimap(original_split_splited_segment_density, merge_segment_density_map); }
						if (splited_node_original._next) { find_if_in_multimap(split_right_original_segment_density, merge_segment_density_map); }
#endif
						/*..........................................................................................................................*/

						if (!is_head_node_split) {//middle node
							/*------------------------------------------       Merge MAP: sub left         -------------------------------------------------------*/
							merge_segment_density_map.emplace(sub_left_segment.right_subsegment->segment_density, *splited_node_original._prev);//200109 For area difference
							/*------------------------------------------------------------------------------------------------------------------------------------*/
							/*------------------------------------------       Merge MAP: sub right        -------------------------------------------------------*/
							updateMapByKey(merge_segment_density_map, splited_node_segment_original.right_endpoint, original_split_splited_segment_density, splited_node_segment_original.right_subsegment->segment_density);//200109 For area difference
							/*------------------------------------------------------------------------------------------------------------------------------------*/
						}
						else {//head node
							/*------------------------------------------       Merge MAP: sub right         ------------------------------------------------------*/
							merge_segment_density_map.emplace(splited_node_segment_original.right_subsegment->segment_density, splited_node_original);//200109 for area difference
							/*------------------------------------------------------------------------------------------------------------------------------------*/
						}

						/*----------------------------------------------       Merge MAP: long right        ------------------------------------------------------*/
						if (splited_node_original._next) {
							updateMapByKey(merge_segment_density_map, splited_node_original._next->_value.right_endpoint, split_right_original_segment_density, getMergedSubSegmentInformation(original_time_series_vector, *splited_node_original._next));//200109 For area difference
						}
						/*----------------------------------------------------------------------------------------------------------------------------------------*/
						/*==============================================================================================================================================================================*/
						/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&            For Merge Part             &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
						/*+++++++++++++++++++++++++++++++++++++        1 MAP: Pop Split & Merge sub left node;                      +++++++++++++++++++++++++++++++++*/
						/*----------Pop left node in Split Map--------------*/
						if (original_merge_left_area_difference > 0 && merged_node_original._prev->_value.rectangle_width > 3) {
							eraseMapByKey(split_area_difference_map, merged_node_original._prev->_value.right_endpoint, original_merge_left_area_difference);
						}
						/*--------------------------------------------------*/
						/*---------Pop left node in Merge Map --------------*/
						if (!is_head_node_merge) {
							eraseMapByKey(merge_segment_density_map, merged_node_original._prev->_value.right_endpoint, original_merge_left_segment_density);
						}
						/*-------------------------------------------------*/
						/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

						if (merged_node_original._next)
							merge_right_original_segment_density = merged_node_original._next->_value.right_subsegment->segment_density;

						/*--------- Erase Node in Linked List--------------*/
						doubly_linked_list.removeNode(*merged_node_original._prev);
						/*-------------------------------------------------*/
						/*====================================  LinkedList Merge left and right segment  ======================================*/
						merged_node_segment_original.right_subsegment->right_subsegment = merged_node_segment_original.right_subsegment;
						merged_node_segment_original = *merged_node_segment_original.right_subsegment;
						/*=======================================================================================================================*/
						/*++++++++++++++++++++++++++++++++++++++++              MAP: merge & split. update, erase             +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

						/*---------------------- Current Segment Split MAP update merged segment---------------------------------------------------*/
						if (merged_node_segment_original.area_difference > 0) {
							if (origial_merge_merged_area_difference > 0 && origial_merge_merged_segment_rectangle_width > 3) {
								updateMapByKey(split_area_difference_map, merged_node_segment_original.right_endpoint, origial_merge_merged_area_difference, merged_node_segment_original.area_difference);
							}
							else {
								split_area_difference_map.emplace(merged_node_segment_original.area_difference, merged_node_original);
							}
						}
						else if (origial_merge_merged_area_difference > 0 && origial_merge_merged_segment_rectangle_width > 3) {
							eraseMapByKey(split_area_difference_map, merged_node_segment_original.right_endpoint, origial_merge_merged_area_difference);
						}
						/*----------------------------------------------------------------------------------------------------------------------------*/

						/*-------------------- 1 Current Segment Merged MAP update merged segment, 2 Get merged Information -------------------------*/
						if (!is_head_node_merge) {
							updateMapByKey(merge_segment_density_map, merged_node_segment_original.right_endpoint, origial_merge_merged_segment_density, getMergedSubSegmentInformation(original_time_series_vector, merged_node_original));//200109 For Area DIfference
						}
						else {
							eraseMapByKey(merge_segment_density_map, merged_node_segment_original.right_endpoint, origial_merge_merged_segment_density);
						}
						/*------------------------------------------------------------------------------------------------------------------------------*/

						/*-------------------- 1 Right Segment. Merged MAP update right merged segment, 2 Get right merged Information-----------------*/
						if (merge_right_original_segment_density != -1) {
							updateMapByKey(merge_segment_density_map, merged_node_original._next->_value.right_endpoint, merge_right_original_segment_density, getMergedSubSegmentInformation(original_time_series_vector, *merged_node_original._next));
						}
						/*-------------------------------------------------------------------------------------------------------------------------------*/

						/*..............................................................................................................................*/
#ifdef _DEBUG
						assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
						assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
						assert_split_map_area_difference(split_area_difference_map);
#endif
						/*..............................................................................................................................*/

						/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
					}
					else {
						should_change = false;
						break;
					}
				}
				else {
					assert(0);
				}

			}
			/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/

			/*:::::::::::::::::::::::             Split Merge Operation              :::::::::::::::::::::::::*/
			//splitSegmentBySlope(original_time_series_vector, input_argument.option_split_method, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
			/*..............................................................................................................................*/
#ifdef _DEBUG
			/*&&&&&&&&&&&&&&&&&&&&&&&&    200907 get reconstruct time series      &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
			/*vector<T> reconstruct_time_series_vector;
			getAPLAReconstructSeries(doubly_linked_list, reconstruct_time_series_vector);
			cout << "After Split : Reconstruct time series:";
			TOOL::print_vector(reconstruct_time_series_vector);*/
			/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
#endif
			/*..............................................................................................................................*/
			//mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list);
			/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

			//area_difference_sum_new = get_whole_area_difference(doubly_linked_list);

			/*..............................................................................................................................*/
#ifdef _DEBUG
			/*&&&&&&&&&&&&&&&&&&&&&&&&    200907 get reconstruct time series      &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
			/*getAPLAReconstructSeries(doubly_linked_list, reconstruct_time_series_vector);
			cout << "After Merge: Reconstruct time series:";
			TOOL::print_vector(reconstruct_time_series_vector);*/
			/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

			/*cout << "New sum area difference: " << area_difference_sum_new << endl;
			TOOL::print_each_segment_coefficient(doubly_linked_list);*/
			assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);

			//evaluate right point, min&max point, width. a&b, sum value
			assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);

			assert_split_map_area_difference(split_area_difference_map);
#endif
			/*..............................................................................................................................*/

		}
		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


		/*.................................................................................................................................*/
#ifdef _DEBUG
		//assert(temp_doubly_linked_list.size() == input_argument.point_dimension);
		//assert(right_endpoint_segment_max_density_merge == right_endpoint_segment_max_area_difference);

		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&           Print linked list          &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

		//int count_same = 0;
		//for (int i = 0; i < initial_right_endpoint_vector.size(); i++) {
		//	if (initial_right_endpoint_vector[i] == doubly_linked_list[i].right_endpoint) {
		//		count_same++;
		//	}
		//}
		//if (count_same == initial_right_endpoint_vector.size()) {
		//	input_argument.is_MS_effect = false;
		//}
		//else {
		//	input_argument.is_MS_effect = true;
		//	//assert(0);
		//}

		///*###################################           Print linked list          ###########################*/
		//cout << "After MS segment coefficients: \n";
		//TOOL::print_each_segment_coefficient(doubly_linked_list);
		///*####################################################################################################*/

		///*#############################    200907 get reconstruct time series      ###########################*/
		//vector<T> reconstruct_time_series_vector;
		//getAPLAReconstructSeries(doubly_linked_list, reconstruct_time_series_vector);
		//cout << "Reconstruct time series:";
		//TOOL::print_vector(reconstruct_time_series_vector);
		//reconstruct_time_series_vector.clear();
		//reconstruct_time_series_vector.shrink_to_fit();
		///*####################################################################################################*/

		///*######  get a&b of every segment & get sum deviation & get reconstruction time series  ######*/
	 //   //getAPLA(input_argument, original_time_series, doubly_linked_list);
		//long double sum_deviation = get_sum_deviation_no_ab(original_time_series_vector, doubly_linked_list);
		//cout << "After MS sum deviation: " << sum_deviation << endl;
		///*#############################################################################################*/

		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
#endif
		/*.................................................................................................................................*/

		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   Optimization   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		//optimization_segments_loop(input_argument, original_time_series_vector, split_area_difference_map, doubly_linked_list, output_argument);


		//201111
		optimization_segments_loop_speed(input_argument, original_time_series_vector, split_area_difference_map, doubly_linked_list, output_argument);
		//doubly_linked_list.swap(temp_doubly_linked_list);
		//evaluate_upper_lower_bound(input_argument, original_time_series_vector, doubly_linked_list);
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	}
}

//************************************
// Method:update_list_map_sub_left_is_merge
// Qualifier: When candidate merge segment is splited sub left segment.
// date:201229  14:44
// author:
//************************************
TEMPLATE
template<typename T, typename T1, typename Y, typename U>
inline bool APLA::update_list_map_sub_left_is_merge(const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyListNode<Y>& const node_split_candidate, Y& const temp_segment_splited_sub_left, const Y& const temp_segment_splited_sub_right, const Y& const temp_segment_candidate_split_right, U& const output_argument) {
	auto& const segment_split_candidate = node_split_candidate._value;
	/*...................................................................................................*/
#ifdef _DEBUG
	assert(node_split_candidate._prev);
	if (segment_split_candidate.area_difference > 0) assert(find_endpoint_key_in_map(split_area_difference_map, segment_split_candidate.right_endpoint, segment_split_candidate.area_difference));
	assert_split_map_area_difference(split_area_difference_map);
#endif
	/*...................................................................................................*/

	/*--------------------   Candidate merge long left, sub left   --------------------*/
	/*new_merge_area_difference_sum += sub_left_segment.right_subsegment->area_difference;
	new_merge_area_difference_sum += sub_right_segment.area_difference;
	new_merge_area_difference_sum += long_right_segment.area_difference;*/
	/*--------------------------------------------------------------------------------*/

	// Candidate split node left node + candidate split node <= candidate merge node(original left node + splited sub left node) + splited sub right node 
	/*if (node_split_candidate._prev->_value.area_difference + node_split_candidate._value.area_difference <= temp_segment_splited_sub_left.right_subsegment->area_difference + temp_segment_splited_sub_right.area_difference)
		return false;*/

		/*-----------   Merge candidate split left segment and sub left segment      ---------------------------------*/
	temp_segment_splited_sub_left.right_subsegment->right_subsegment = temp_segment_splited_sub_left.right_subsegment;
	temp_segment_splited_sub_left = *temp_segment_splited_sub_left.right_subsegment;
	/*-------------------------------------------------------------------------------------------------------------*/

	/*==========================  candidate splited segment: Update Split MAP: candidate splited segment => sub right segment    ================================*/
	if (temp_segment_splited_sub_right.area_difference > 0 && temp_segment_splited_sub_right.rectangle_width > 3) {

		updateMapByKey(split_area_difference_map, temp_segment_splited_sub_right.right_endpoint, segment_split_candidate.area_difference, temp_segment_splited_sub_right.area_difference);

		/*...................................................................................................*/
#ifdef _DEBUG
		assert(find_endpoint_key_in_map(split_area_difference_map, segment_split_candidate.right_endpoint, temp_segment_splited_sub_right.area_difference));
#endif
		/*...................................................................................................*/
	}
	else {
		eraseMapByKey(split_area_difference_map, temp_segment_splited_sub_right.right_endpoint, segment_split_candidate.area_difference);
	}
	/*==========================================================================================================================================================*/

	
	const size_t original_split_left_rectangle_width = node_split_candidate._prev->_value.rectangle_width;
	const double original_split_left_segment_area_difference = node_split_candidate._prev->_value.area_difference;
	const double origianl_split_left_segment_density = node_split_candidate._prev->_value.right_subsegment->segment_density;
	const double original_split_splited_segment_density = node_split_candidate._value.right_subsegment->segment_density;

	node_split_candidate._prev->_value = temp_segment_splited_sub_left;
	const size_t original_split_left_right_endpoint = node_split_candidate._prev->_value.right_endpoint;

	node_split_candidate._value = temp_segment_splited_sub_right;

	if (node_split_candidate._prev) {//middle node

		/*======== Sub left Segment: Split MAP: candidate split left segment => Merged(candidate split left segment, splited sub left segment) ===================*/
		if (original_split_left_segment_area_difference > 0 && temp_segment_splited_sub_left.area_difference > 0 && original_split_left_rectangle_width > 3) {
			/*...................................................................................................*/
#ifdef _DEBUG
			assert(temp_segment_splited_sub_left.rectangle_width > 3);
			assert(find_endpoint_key_in_map(split_area_difference_map, temp_segment_splited_sub_left.right_endpoint, original_split_left_segment_area_difference));
#endif
			/*...................................................................................................*/

			updateMapByKey(split_area_difference_map, temp_segment_splited_sub_left.right_endpoint, original_split_left_segment_area_difference, temp_segment_splited_sub_left.area_difference);//200109 For area difference

			/*...................................................................................................*/
#ifdef _DEBUG
			assert(find_endpoint_key_in_map(split_area_difference_map, temp_segment_splited_sub_left.right_endpoint, temp_segment_splited_sub_left.area_difference));
#endif
			/*...................................................................................................*/
		}
		else if (temp_segment_splited_sub_left.area_difference > 0 && temp_segment_splited_sub_left.rectangle_width > 3) {
			split_area_difference_map.emplace(temp_segment_splited_sub_left.area_difference, *node_split_candidate._prev);
		}
		/*=======================================================================================================================================================*/

		/*=== Sub right Segment: Merge MAP: (candidate split left segment, candidate splited segment) => Merged(merged sub left, sub right)   ===================*/
		updateMapByKey(merge_segment_density_map, temp_segment_splited_sub_right.right_endpoint, original_split_splited_segment_density, getMergedSubSegmentInformation(original_time_series_vector, node_split_candidate, output_argument));//200109 For merge density
		/*=======================================================================================================================================================*/
	}
	else {//head node
		assert(0);
	}

	/*==========  Original right Segment: Merge MAP: merge(splited node, original right node) => merge(sub right node, original right node) ================*/
	if (node_split_candidate._next) {
		updateMapByKey(merge_segment_density_map, temp_segment_candidate_split_right.right_endpoint, node_split_candidate._next->_value.right_subsegment->segment_density, temp_segment_candidate_split_right.right_subsegment->segment_density);//200109 For area difference

		*node_split_candidate._next->_value.right_subsegment = *temp_segment_candidate_split_right.right_subsegment;
		/*...................................................................................................*/
#ifdef _DEBUG
		assert(node_split_candidate._next->_value.right_subsegment->segment_density == temp_segment_candidate_split_right.right_subsegment->segment_density);
#endif
		/*...................................................................................................*/
	}
	/*======================================================================================================================================================*/

	/*===================    Original left Segment: Merge MAP: (long left left, long left) => (long left left, (long left , sub left))   ===================*/
	if (temp_segment_splited_sub_left.rectangle_width != temp_segment_splited_sub_left.right_endpoint + 1) {//After merge, (long left, sub left) is not head
		updateMapByKey(merge_segment_density_map, original_split_left_right_endpoint, origianl_split_left_segment_density, getMergedSubSegmentInformation(original_time_series_vector, *node_split_candidate._prev, output_argument));//200109 For area di
	}
	/*======================================================================================================================================================*/

	/*...............................................................*/
#ifdef _DEBUG
	assert_split_map_area_difference(split_area_difference_map);
#endif
	/*...............................................................*/

	return true;
}

//************************************
// Method: update_list_map_original_right_is_merge
// Qualifier: When candidate merge segment is splited original right segment.
// date:201229  21:19
// author:
//************************************
TEMPLATE
template<typename T, typename T1, typename Y, typename U>
inline bool APLA::update_list_map_original_right_is_merge(const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyListNode<Y>& const node_split_candidate, const Y& const temp_segment_splited_sub_left, const Y& const temp_segment_splited_sub_right, Y& const temp_segment_candidate_split_right, U& const output_argument) {

	/*new_merge_area_difference_sum += original_split_left_area_difference;
	new_merge_area_difference_sum += temp_segment_splited_sub_left.area_difference;
	new_merge_area_difference_sum += temp_segment_candidate_split_right.right_subsegment->area_difference;*/

	/*if (node_split_candidate._value.area_difference + node_split_candidate._next->_value.area_difference <= temp_segment_splited_sub_left.area_difference + temp_segment_candidate_split_right.right_subsegment->area_difference)
		return false;*/

	// Must have next node
	/*..........................................................*/
#ifdef _DEBUG
	assert_split_map_area_difference(split_area_difference_map);
#endif
	/*..........................................................*/

	const double original_split_splited_segment_area_difference = node_split_candidate._value.area_difference;
	const double original_split_splited_segment_density = node_split_candidate._value.right_subsegment->segment_density;

	const size_t original_split_right_rectangle_width = temp_segment_candidate_split_right.rectangle_width;
	const double original_split_right_area_difference = node_split_candidate._next->_value.area_difference;
	const double original_split_right_segment_density = node_split_candidate._next->_value.right_subsegment->segment_density;

	/*-----------------       Merge original right: (sub right, original right)         ----------------------------------------*/
	temp_segment_candidate_split_right.right_subsegment->right_subsegment = temp_segment_candidate_split_right.right_subsegment;
	temp_segment_candidate_split_right = *temp_segment_candidate_split_right.right_subsegment;
	/*--------------------------------------------------------------------------------------------------------------------------*/

	/*===========================    Candidate Splited Segment: Split MAP: splited segment => sub left segment    ===============================*/
	if (temp_segment_splited_sub_left.area_difference > 0 && temp_segment_splited_sub_left.rectangle_width > 3) {
		updateMapByKey(split_area_difference_map, temp_segment_splited_sub_right.right_endpoint, original_split_splited_segment_area_difference, temp_segment_splited_sub_left.area_difference);
	}
	else {
		eraseMapByKey(split_area_difference_map, temp_segment_splited_sub_right.right_endpoint, original_split_splited_segment_area_difference);
	}
	/*===========================================================================================================================================*/

	/*==================    Candidate Splited Segment: Merge MAP: (original left, splited node) => (original left, sub left)   ==================*/
	if (node_split_candidate._prev) {//middle node
		updateMapByKey(merge_segment_density_map, temp_segment_splited_sub_right.right_endpoint, original_split_splited_segment_density, temp_segment_splited_sub_left.right_subsegment->segment_density);//200109 For area difference
	}
	/*===========================================================================================================================================*/

	node_split_candidate._value = temp_segment_splited_sub_left;
	node_split_candidate._next->_value = temp_segment_candidate_split_right;

	if (node_split_candidate._next) {

		/*=========    Original right Segment: Split MAP: Original right Segment => Merged(split sub right segment, Original right Segment)   ====================*/
		if (original_split_right_area_difference > 0 && temp_segment_candidate_split_right.area_difference > 0 && original_split_right_rectangle_width > 3) {
			updateMapByKey(split_area_difference_map, temp_segment_candidate_split_right.right_endpoint, original_split_right_area_difference, temp_segment_candidate_split_right.area_difference);//200109 For area difference
		}
		else if (temp_segment_candidate_split_right.area_difference > 0) {
			split_area_difference_map.emplace(temp_segment_candidate_split_right.area_difference, *node_split_candidate._next);
		}
		/*========================================================================================================================================================*/

		/*=================    Original right segment: Merge MAP: (splited node, original right node) => (sub left node, (sub right, original right))    ==========================*/
		updateMapByKey(merge_segment_density_map, temp_segment_candidate_split_right.right_endpoint, original_split_right_segment_density, getMergedSubSegmentInformation(original_time_series_vector, *node_split_candidate._next, output_argument));//200109 For area difference
		/*=========================================================================================================================================================================*/
	}
	else {
		assert(0);
	}

	/*======= Original right right segment Merge MAP: (original right, original right right) => ((sub right, original right), original right right)  ==================*/
	if ((*node_split_candidate._next)._next) {//After merge, (long left, sub left) is not head

		auto& const right_node = *node_split_candidate._next;
		const auto right_right_segment_density = right_node._next->_value.right_subsegment->segment_density;
		updateMapByKey(merge_segment_density_map, right_node._next->_value.right_endpoint, right_right_segment_density, getMergedSubSegmentInformation(original_time_series_vector, *right_node._next, output_argument));//200109 For area di
	}
	/*=================================================================================================================================================================*/

	/*..............................................................................................................................*/
#ifdef _DEBUG
	assert_split_map_area_difference(split_area_difference_map);
#endif
	/*..............................................................................................................................*/

	return true;
}

//************************************
// Method: update_list_map_split_is_not_merge
// Qualifier: When candidate merge segment is splited original right segment.
// date:201231  14:30
// author:
//************************************
TEMPLATE
template<typename T, typename T1, typename Y, typename U>
inline bool APLA::update_list_map_split_is_not_merge(const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, DoublyListNode<Y>& const node_split_candidate, DoublyListNode<Y>& const node_merge_candidate, DoublyListNode<Y>& const node_sub_left_new, const Y& const temp_segment_splited_sub_right, U& const output_argument) {

	/*..........................................................*/
#ifdef _DEBUG
	assert_split_map_area_difference(split_area_difference_map);
	assert(node_split_candidate._value.right_endpoint != node_merge_candidate._prev->_value.right_endpoint && node_split_candidate._value.right_endpoint != node_merge_candidate._value.right_endpoint && node_sub_left_new._value.right_endpoint != INF);
#endif
	/*..........................................................*/


	Y& const merged_node_segment_original = node_merge_candidate._value;
	//Y& const temp_segment_splited_sub_left = node_sub_left_new._value;
	/*original_area_difference_sum = 0;
	original_area_difference_sum += node_split_candidate._value.area_difference;
	original_area_difference_sum += node_merge_candidate._prev->_value.area_difference;
	original_area_difference_sum += merged_node_segment_original.area_difference;

	new_merge_area_difference_sum = 0;
	new_merge_area_difference_sum += merged_node_segment_original.right_subsegment->area_difference;
	new_merge_area_difference_sum += node_sub_left_new._value.area_difference;
	new_merge_area_difference_sum += temp_segment_splited_sub_right.area_difference;*/

	//if (node_split_candidate._value.area_difference + node_merge_candidate._prev->_value.area_difference + merged_node_segment_original.area_difference <= node_sub_left_new._value.area_difference + temp_segment_splited_sub_right.area_difference + merged_node_segment_original.right_subsegment->area_difference) return false;

	/*=======================================       Original Node Coefficients     ==================================================*/

	/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    Split Coefficients   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
	/*------------------------------------- split candidate node --------------------------------------*/
	const double original_split_splited_segment_area_difference = node_split_candidate._value.area_difference;
	const double original_split_splited_segment_density = node_split_candidate._value.right_subsegment->segment_density;
	/*-------------------------------------------------------------------------------------------------*/

	/*----------------------------------- split original right node   ---------------------------------*/
	//const size_t original_split_right_rectangle_width = temp_segment_candidate_split_right.rectangle_width;
	//const double original_split_right_area_difference = node_split_candidate._next->_value.area_difference;
	double original_split_right_segment_density = INF;
	if (node_split_candidate._next) original_split_right_segment_density = node_split_candidate._next->_value.right_subsegment->segment_density;
	/*-------------------------------------------------------------------------------------------------*/
	/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

	/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    Merge Coefficients   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
	/*-----------------------------------  merge original left node   ----------------------------------*/
	const double original_merge_left_area_difference = node_merge_candidate._prev->_value.area_difference;
	const double& const original_merge_left_segment_density = node_merge_candidate._prev->_value.right_subsegment->segment_density;
	/*--------------------------------------------------------------------------------------------------*/

	/*-----------------------------------     merge candidate node    ----------------------------------*/
	const size_t origial_merge_merged_segment_rectangle_width = node_merge_candidate._value.rectangle_width;
	const double origial_merge_merged_area_difference = node_merge_candidate._value.area_difference;
	const double origial_merge_merged_segment_density = node_merge_candidate._value.right_subsegment->segment_density;
	/*--------------------------------------------------------------------------------------------------*/

	/*------   merge original right node   ----------*/
	double merge_right_original_segment_density = -1;
	/*-----------------------------------------------*/
	/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

	/*==============================================================================================================================*/

	/*..........................................................................................................................*/
#ifdef _DEBUG
	if (node_split_candidate._prev) { find_if_in_multimap(original_split_splited_segment_density, merge_segment_density_map); }
	if (node_split_candidate._next) { find_if_in_multimap(original_split_right_segment_density, merge_segment_density_map); }
#endif
	/*..........................................................................................................................*/

	node_split_candidate._value = temp_segment_splited_sub_right;

	/*--------210922-------*/
	node_sub_left_new._value.is_split = true;
	node_split_candidate._value.is_split = true;
	/*---------------------*/

	/*-------------     Linked list: Insert sub left segment      -------------------*/
	doubly_linked_list.insertNodeBeforeNode(node_sub_left_new, node_split_candidate);
	/*-------------------------------------------------------------------------------*/

	/*-------------------------      Sub Left Segment: Split MAP: Empalce     ---------------------------------------*/
	if (node_sub_left_new._value.area_difference > 0 && node_sub_left_new._value.rectangle_width > 3) {
		split_area_difference_map.emplace(node_sub_left_new._value.area_difference, *node_split_candidate._prev);
	}
	/*---------------------------------------------------------------------------------------------------------------*/

	/*........................................................................................................................................................*/
#ifdef _DEBUG
	assert(node_sub_left_new._value.area_difference == node_split_candidate._prev->_value.area_difference && node_sub_left_new._value.area_difference != INF);
	assert(find_endpoint_key_in_map(split_area_difference_map, node_split_candidate._value.right_endpoint, original_split_splited_segment_area_difference));
#endif
	/*.........................................................................................................................................................*/

	/*--------------------------      Sub Right Segment: Split MAP: Update    ---------------------------------------*/
	if (node_split_candidate._value.area_difference > 0 && node_split_candidate._value.rectangle_width > 3) {
		updateMapByKey(split_area_difference_map, node_split_candidate._value.right_endpoint, original_split_splited_segment_area_difference, node_split_candidate._value.area_difference);
	}
	else {
		eraseMapByKey(split_area_difference_map, node_split_candidate._value.right_endpoint, original_split_splited_segment_area_difference);
	}
	/*---------------------------------------------------------------------------------------------------------------*/

	/*========================================     Split Sub left & right, split original right node: Merge MAP    =====================================================*/

	if (node_split_candidate._prev->_prev) {//middle node
		/*------------------------------------------     Merge MAP: splited sub left new node     --------------------------------------------*/
		merge_segment_density_map.emplace(node_sub_left_new._value.right_subsegment->segment_density, *node_split_candidate._prev);//200109 For area difference
		/*------------------------------------------------------------------------------------------------------------------------------------*/
		/*------------------------------------------       Merge MAP: splited candidate node       -------------------------------------------*/
		updateMapByKey(merge_segment_density_map, node_split_candidate._value.right_endpoint, original_split_splited_segment_density, node_split_candidate._value.right_subsegment->segment_density);//200109 For area difference
		/*------------------------------------------------------------------------------------------------------------------------------------*/
	}
	else {//head node
		/*------------------------------------------       Merge MAP: splited candidate node       -------------------------------------------*/
		merge_segment_density_map.emplace(node_split_candidate._value.right_subsegment->segment_density, node_split_candidate);//200109 for area difference
		/*------------------------------------------------------------------------------------------------------------------------------------*/
	}

	/*----------------------------------------------     Merge MAP: split original right node    ----------------------------------------------*/
	if (node_split_candidate._next) {
		updateMapByKey(merge_segment_density_map, node_split_candidate._next->_value.right_endpoint, original_split_right_segment_density, getMergedSubSegmentInformation(original_time_series_vector, *node_split_candidate._next, output_argument));//200109 For area difference
	}
	/*-----------------------------------------------------------------------------------------------------------------------------------------*/

	/*===================================================================================================================================================================*/

	/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^      merge original left node: Erase Split&Merge MAP:      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
	/*------------------------------ Erase merge original left node in Split Map ---------------------------*/
	if (original_merge_left_area_difference > 0 && node_merge_candidate._prev->_value.rectangle_width > 3) {
		eraseMapByKey(split_area_difference_map, node_merge_candidate._prev->_value.right_endpoint, original_merge_left_area_difference);
	}
	/*------------------------------------------------------------------------------------------------------*/
	/*-------------------------------Erase merge original left node in Merge Map ---------------------------*/
	if (node_merge_candidate._prev->_prev) {
		if (node_merge_candidate._prev != node_split_candidate._next) {
			eraseMapByKey(merge_segment_density_map, node_merge_candidate._prev->_value.right_endpoint, original_merge_left_segment_density);
		}
		else {// if split original right node == merge original left node
			eraseMapByKey(merge_segment_density_map, node_merge_candidate._prev->_value.right_endpoint, node_merge_candidate._prev->_value.right_subsegment->segment_density);
		}
	}
	/*------------------------------------------------------------------------------------------------------*/
	/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
	node_merge_candidate._value.is_merge = true;

	/*--- Erase merge original left Node in Linked List -------*/
	doubly_linked_list.removeNode(*node_merge_candidate._prev);
	/*---------------------------------------------------------*/

	if (node_merge_candidate._next)
		merge_right_original_segment_density = node_merge_candidate._next->_value.right_subsegment->segment_density;

	/*========================  LinkedList : Merge (original left ndoe , Merged candidate node)   ===================*/
	merged_node_segment_original.right_subsegment->right_subsegment = merged_node_segment_original.right_subsegment;
	merged_node_segment_original = *merged_node_segment_original.right_subsegment;
	/*===============================================================================================================*/

	/*------------------------------------    Merged Candidate Node: Split MAP: update  ---------------------------------------------*/
	if (merged_node_segment_original.area_difference > 0) {
		if (origial_merge_merged_area_difference > 0 && origial_merge_merged_segment_rectangle_width > 3) {
			updateMapByKey(split_area_difference_map, merged_node_segment_original.right_endpoint, origial_merge_merged_area_difference, merged_node_segment_original.area_difference);
		}
		else {
			split_area_difference_map.emplace(merged_node_segment_original.area_difference, node_merge_candidate);
		}
	}
	else if (origial_merge_merged_area_difference > 0 && origial_merge_merged_segment_rectangle_width > 3) {
		eraseMapByKey(split_area_difference_map, merged_node_segment_original.right_endpoint, origial_merge_merged_area_difference);
	}
	/*------------------------------------------------------------------------------------------------------------------------------*/

	/*-------------------------------------   Merged Candidate Node: Merge MAP: update  --------------------------------------------*/
	if (node_merge_candidate._prev) {
		updateMapByKey(merge_segment_density_map, merged_node_segment_original.right_endpoint, origial_merge_merged_segment_density, getMergedSubSegmentInformation(original_time_series_vector, node_merge_candidate, output_argument));//200109 For Area DIfference
	}
	else {
		eraseMapByKey(merge_segment_density_map, merged_node_segment_original.right_endpoint, origial_merge_merged_segment_density);
	}
	/*------------------------------------------------------------------------------------------------------------------------------*/

	/*------------------------------        Merge Original right Node: Merged MAPupdate     ---------------------------------------*/
	if (merge_right_original_segment_density != -1) {
		updateMapByKey(merge_segment_density_map, node_merge_candidate._next->_value.right_endpoint, merge_right_original_segment_density, getMergedSubSegmentInformation(original_time_series_vector, *node_merge_candidate._next, output_argument));
	}
	/*-------------------------------------------------------------------------------------------------------------------------------*/

	/*....................................................................................................................*/
#ifdef _DEBUG
	assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
	assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
	assert_split_map_area_difference(split_area_difference_map);
#endif
	/*....................................................................................................................*/

	return true;
}

//************************************
// Method: update_list_map_merge_split_same
// Qualifier: When candidate split segment is candiate merge segment
// date:210301  21:25
// author:
//************************************
TEMPLATE
template<typename T, typename T1, typename Y, typename U>
inline bool APLA::update_list_map_merge_split_same(const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyListNode<Y>& const node_split_candidate, Y& const temp_segment_splited_sub_left, const Y& const temp_segment_splited_sub_right, U& const output_argument) {
	/*..........................................................*/
#ifdef _DEBUG
	assert_split_map_area_difference(split_area_difference_map);
	assert(node_split_candidate._prev && temp_segment_splited_sub_right.right_endpoint == node_split_candidate._value.right_endpoint);
#endif
	/*..........................................................*/

	/*------------------- split left candidate node ---------------------------*/
	const int original_right_endpoint_left = node_split_candidate._prev->_value.right_endpoint;
	double original_segment_density_left = INF;
	if (node_split_candidate._prev->_prev) original_segment_density_left = node_split_candidate._prev->_value.right_subsegment->segment_density;
	/*-------------------------------------------------------------------------*/
	/*------------------   split original right node    -----------------------*/
	double original_segment_density_long_right = INF;
	if (node_split_candidate._next)
		original_segment_density_long_right = node_split_candidate._next->_value.right_subsegment->segment_density;
	/*-------------------------------------------------------------------------*/

	/*..........................................................................................................................*/
#ifdef _DEBUG
	if (node_split_candidate._prev->_prev) { find_if_in_multimap(node_split_candidate._prev->_value.right_subsegment->segment_density, merge_segment_density_map); }
	if (node_split_candidate._prev) { find_if_in_multimap(node_split_candidate._value.right_subsegment->segment_density, merge_segment_density_map); }
	if (node_split_candidate._next) { find_if_in_multimap(node_split_candidate._next->_value.right_subsegment->segment_density, merge_segment_density_map); }
	if (node_split_candidate._value.area_difference > 0 && node_split_candidate._value.rectangle_width > 3)
		assert(find_endpoint_key_in_map(split_area_difference_map, node_split_candidate._value.right_endpoint, node_split_candidate._value.area_difference));
	if (node_split_candidate._prev->_value.area_difference > 0 && node_split_candidate._prev->_value.rectangle_width > 3)
		assert(find_endpoint_key_in_map(split_area_difference_map, node_split_candidate._prev->_value.right_endpoint, node_split_candidate._prev->_value.area_difference));
#endif
	/*..........................................................................................................................*/

	/*---------------------------  Split MAP  Split Sub Left Candidate Node.   ---------------------------------------------*/
	if (temp_segment_splited_sub_left.area_difference > 0 && temp_segment_splited_sub_left.rectangle_width > 3) {
		if (node_split_candidate._prev->_value.area_difference > 0 && node_split_candidate._prev->_value.rectangle_width > 3) {
			updateMapByKey(split_area_difference_map, node_split_candidate._prev->_value.right_endpoint, node_split_candidate._prev->_value.area_difference, temp_segment_splited_sub_left.area_difference);
		}
		else {
			split_area_difference_map.emplace(temp_segment_splited_sub_left.area_difference, *node_split_candidate._prev);
		}
	}
	else if (node_split_candidate._prev->_value.area_difference > 0 && node_split_candidate._prev->_value.rectangle_width > 3) {
		eraseMapByKey(split_area_difference_map, node_split_candidate._prev->_value.right_endpoint, node_split_candidate._prev->_value.area_difference);
	}
	/*------------------------------------------------------------------------------------------------------------------------------*/

	/*---------------------------   Split MAP: Split Sub Right Candidate Node.   ---------------------------------------------*/
	if (temp_segment_splited_sub_right.area_difference > 0 && temp_segment_splited_sub_right.rectangle_width > 3) {
		if (node_split_candidate._value.area_difference > 0 && node_split_candidate._value.rectangle_width > 3) {
			updateMapByKey(split_area_difference_map, node_split_candidate._value.right_endpoint, node_split_candidate._value.area_difference, temp_segment_splited_sub_right.area_difference);
		}
		else {
			split_area_difference_map.emplace(temp_segment_splited_sub_right.area_difference, node_split_candidate);
		}
	}
	else if (node_split_candidate._value.area_difference > 0 && node_split_candidate._value.rectangle_width > 3) {
		eraseMapByKey(split_area_difference_map, node_split_candidate._value.right_endpoint, node_split_candidate._value.area_difference);
	}
	/*------------------------------------------------------------------------------------------------------------------------------*/

	/*========================================     Split Sub left left; split original right node: Merge MAP    =====================================================*/
	/*------------------------------------------       Merge MAP: splited candidate node       -------------------------------------------*/
	updateMapByKey(merge_segment_density_map, node_split_candidate._value.right_endpoint, node_split_candidate._value.right_subsegment->segment_density, temp_segment_splited_sub_right.right_subsegment->segment_density);//200109 For area difference
	/*------------------------------------------------------------------------------------------------------------------------------------*/
	temp_segment_splited_sub_left.right_subsegment = new Y;
	node_split_candidate._prev->_value = temp_segment_splited_sub_left;

	if (node_split_candidate._prev->_prev) {//middle node
		/*------------------------------------------       Merge MAP: splited left candidate node       ---------------*/
		updateMapByKey(merge_segment_density_map, original_right_endpoint_left, original_segment_density_left, getMergedSubSegmentInformation(original_time_series_vector, *node_split_candidate._prev, output_argument));//200109 For area difference
		/*-------------------------------------------------------------------------------------------------------------*/
	}

	node_split_candidate._value = temp_segment_splited_sub_right;
	/*----------------------------------------------     Merge MAP: split original right node    ----------------------------------------------*/
	if (node_split_candidate._next) {
		updateMapByKey(merge_segment_density_map, node_split_candidate._next->_value.right_endpoint, original_segment_density_long_right, getMergedSubSegmentInformation(original_time_series_vector, *node_split_candidate._next, output_argument));//200109 For area difference
	}
	/*-----------------------------------------------------------------------------------------------------------------------------------------*/

	/*===================================================================================================================================================================*/
	/*...........................................................*/
#ifdef _DEBUG
	assert_split_map_area_difference(split_area_difference_map);
#endif
	/*............................................................*/
	return true;
}

//************************************
	// Method:split_merge_optimization_segments_speed3
	// Qualifier: After initial part, The fastest way. Use split&merge&optimization to get tighter approximation
	// date:201228  14:44
	// author:
	//************************************
TEMPLATE
template<typename T, typename T1, typename Y, typename U, typename U1>
void APLA::split_merge_optimization_segments_speed0(U& const input_argument, const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument) {
	/*..................................................................................................................*/
#ifdef _DEBUG
	assert(doubly_linked_list.size() == input_argument.point_dimension);
	//assert_minmax_value(original_time_series_vector, doubly_linked_list);
	assert_bound(original_time_series_vector, doubly_linked_list);
	assert_merge_map_triangle_density(merge_segment_density_map);
	/*::::::::::::::::::::     201217 Find Example      ::::::::::::::::::::::::::*/
	vector<T> reconstruct_time_series_vector;
	vector<int> initial_right_endpoint_vector;
	for (auto&& au : doubly_linked_list) {
		initial_right_endpoint_vector.emplace_back(au.right_endpoint);
	}
	DoublyLinkedList<Y> temp_doubly_linked_list = DoublyLinkedList<Y>();
	temp_doubly_linked_list.copy(doubly_linked_list);
	multimap<T1, DoublyListNode<Y>&, greater<T1>> temp_merge_segment_density_map;
	multimap<T1, DoublyListNode<Y>&, greater<T1>> temp_split_area_difference_map;
	/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
#endif
	/*....................................................................................................................*/


	if (split_area_difference_map.empty()) return;
	bool should_change = true;

	while (should_change) {

		/*..................................................................................................*/
#ifdef _DEBUG
		//evaluate right point, min&max point, width. a&b, sum value
		assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
		assert_split_map_area_difference(split_area_difference_map);

		/*::::::::::::::::::::     201217 Find Example      ::::::::::::::::::::::::::*/
		getAPLAReconstructSeries(doubly_linked_list, reconstruct_time_series_vector);
		cout << "\n8 After Merge: Reconstruct time series:";
		TOOL::print_vector(reconstruct_time_series_vector);
		reconstruct_time_series_vector.clear();
		reconstruct_time_series_vector.shrink_to_fit();
		/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
#endif
		/*..................................................................................................*/

		/*----------------------       Whether MAP Empty      ----------------------*/
		// If MAP is empty, no need to split
		if (split_area_difference_map.empty()) break;
		/*---------------------------------------------------------------------------*/

		/*=====================      Split Node, Merge Node         ======================*/
		auto& const splited_node_original = split_area_difference_map.begin()->second;
		auto& const splited_node_segment_original = splited_node_original._value;

		auto& const merged_node_original = merge_segment_density_map.begin()->second;
		auto& const merged_node_segment_original = merged_node_original._value;
		/*================================================================================*/

		/*............................................................................................................................*/
#ifdef _DEBUG
		assert(merged_node_original._prev->_value.area_difference != INF && merged_node_segment_original.area_difference != INF && splited_node_segment_original.rectangle_width > 3);
		assert(merged_node_segment_original.right_subsegment != nullptr && merged_node_segment_original.apla.a != INF && merged_node_segment_original.apla.b != INF && merged_node_segment_original.right_endpoint != INF && merged_node_segment_original.rectangle_width != INF);

		find_if_in_multimap(splited_node_segment_original.area_difference, split_area_difference_map);
		if (splited_node_original._prev) { find_if_in_multimap(splited_node_segment_original.right_subsegment->segment_density, merge_segment_density_map); }
		if (splited_node_original._next) { find_if_in_multimap(splited_node_original._next->_value.right_subsegment->segment_density, merge_segment_density_map); }
		if (merged_node_original._prev->_value.area_difference > 0 && merged_node_original._prev->_value.rectangle_width > 3) { find_if_in_multimap(merged_node_original._prev->_value.area_difference, split_area_difference_map); }
		if (merged_node_original._prev->_prev) { find_if_in_multimap(merged_node_original._prev->_value.right_subsegment->segment_density, merge_segment_density_map); }
		if (merged_node_segment_original.area_difference > 0 && merged_node_segment_original.rectangle_width > 3) { find_if_in_multimap(merged_node_segment_original.area_difference, split_area_difference_map); }
		find_if_in_multimap(merged_node_segment_original.right_subsegment->segment_density, merge_segment_density_map);
		if (merged_node_original._next) { find_if_in_multimap(merged_node_original._next->_value.right_subsegment->segment_density, merge_segment_density_map); }

		assert(splited_node_segment_original.area_difference > 0 && splited_node_segment_original.area_difference != INF && splited_node_segment_original.right_subsegment != nullptr);
		assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
		/*............................................................................................................................*/

		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&       Find Split point in Candidate Node      &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
		//sub left segemnt
		DoublyListNode<Y>* node_sub_left_new = new DoublyListNode<Y>;
		Y& const sub_left_segment = node_sub_left_new->_value;

		Y sub_right_segment;
		//*sub_right_segment.right_subsegment = splited_node_segment_original;
		sub_right_segment = splited_node_segment_original;
		sub_right_segment.right_subsegment = new Y;
		*sub_right_segment.right_subsegment = sub_right_segment;

		const int split_method_option = 0;
		sub_left_segment.right_endpoint = group_find_split_point_methods(original_time_series_vector, split_method_option, sub_left_segment, sub_right_segment, *sub_right_segment.right_subsegment, output_argument);

		/*........................................................................................*/
#ifdef _DEBUG
		assert(sub_left_segment.right_endpoint > 0 && sub_left_segment.right_endpoint < sub_right_segment.right_endpoint);
		assert(sub_left_segment.rectangle_width + sub_right_segment.rectangle_width == splited_node_segment_original.rectangle_width);
		assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
		/*........................................................................................*/

		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

		// Has split point, begin to split segment
		if (sub_left_segment.right_endpoint == INF) break;

		/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Has Spilt Point    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

		/*&&&&&&&&&&&&&&&&&&&&&&&    After Split. Coefficients of  1 sub left node, 2 sub right node, 3 split original right node    &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

		/*+++++++++++++++++++++++++++++++++++++++   compute min&max, area difference of splited segments   ++++++++++++++++++++++++++++++++++++++*/
		sub_left_segment.right_subsegment = new Y;
		/*--------------------210203       After Split. Area Min&Max Point of 1 sub left node, 2 sub right node      ------------------------*/
		//200212 get min&max point of left&right segment by long segment, speed up
		//getSubMinMaxPoint(original_time_series_vector, sub_left_segment, sub_right_segment, *sub_right_segment.right_subsegment);
		/*-----------------------------------------------------------------------------------------------------------------------------*/
		/*----------  210203 After Split. Area Difference of  1 sub left node,  2 sub right node,  3 split original right node    -----------*/
		/*getAreaDifference(original_time_series_vector, sub_left_segment);
		getAreaDifference(original_time_series_vector, sub_right_segment);
		getAreaDifference(original_time_series_vector, *sub_right_segment.right_subsegment);*/
		/*-----------------------------------------------------------------------------------------------------------------------------*/

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*++++++++++++++++++++++      After Split. Density of  1 sub left node,  2 sub right node,  3 split original right node      +++++++++++++++++++++++++++*/
		multimap<T1, Y&, greater<T1>> temp_new_merge_segment_density_3_map;

		/*==========================================            Split Sub Left Node: Density          =============================================*/
		if (splited_node_original._prev) {//middle node
			/*--------------------------             Density: long left segment & sub left segment                 -------------------------------*/
			getMergedSubSegmentInformation(original_time_series_vector, splited_node_original._prev->_value, sub_left_segment, *sub_left_segment.right_subsegment, output_argument);//200109 For area difference
			/*------------------------------------------------------------------------------------------------------------------------------------*/
			temp_new_merge_segment_density_3_map.emplace(sub_left_segment.right_subsegment->segment_density, sub_left_segment);
		}
		/*==========================================================================================================================================*/
		/*-----------------------------------------------      Split Sub Right Node: Density      ------------------------------------*/
		temp_new_merge_segment_density_3_map.emplace(sub_right_segment.right_subsegment->segment_density, sub_right_segment);
		/*----------------------------------------------------------------------------------------------------------------------------*/
		/*==========================================       new Split Original Right Node: Density      =============================================*/
		/*------ split original right node ---*/
		Y long_right_segment;
		/*------------------------------------*/
		if (splited_node_original._next) {//middle node
			long_right_segment = splited_node_original._next->_value;
			long_right_segment.right_subsegment = new Y;
			getMergedSubSegmentInformation(original_time_series_vector, sub_right_segment, long_right_segment, *long_right_segment.right_subsegment, output_argument);//200109 For area difference
			temp_new_merge_segment_density_3_map.emplace(long_right_segment.right_subsegment->segment_density, long_right_segment);
		}
		/*==========================================================================================================================================*/

		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*.........................................................*/
#ifdef _DEBUG
		if (doubly_linked_list.size() > 1) {
			assert(!merge_segment_density_map.empty());
		}
		else if (doubly_linked_list.size() == 1) {
			assert(merge_segment_density_map.empty());
			break;
		}
		assert_split_map_area_difference(split_area_difference_map);
#endif
		/*.........................................................*/

		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

		/*:::::::::::::::::::::::::::::::::::::::::::::::           201217 Find Example           ::::::::::::::::::::::::::::::::::::::::::::::*/
		//int order_node = 0;
		//for (order_node = 0; temp_doubly_linked_list[order_node].right_endpoint < splited_node_segment_original.right_endpoint; order_node++) {}
		//auto& temp_splited_node_copy = temp_doubly_linked_list.getNode(order_node);
		//temp_doubly_linked_list.insertValueBeforeNode(sub_left_segment, temp_splited_node_copy);
		//temp_doubly_linked_list.insertValueBeforeNode(sub_right_segment, temp_splited_node_copy);
		//temp_doubly_linked_list.removeNode(temp_splited_node_copy);
		///*-------------    Print linked list    -----------------------*/
		//cout << "After Split segment coefficients: \n";
		//TOOL::print_each_segment_coefficient(temp_doubly_linked_list);
		///*-------------------------------------------------------------*/
		///*-------------    200907 get reconstruct time series      ---------------------*/
		////vector<T> reconstruct_time_series_vector;
		//getAPLAReconstructSeries(temp_doubly_linked_list, reconstruct_time_series_vector);
		//cout << "Reconstruct time series:";
		//TOOL::print_vector(reconstruct_time_series_vector);
		//reconstruct_time_series_vector.clear();
		//reconstruct_time_series_vector.shrink_to_fit();
		///*-----------------------------------------------------------------------------*/
		//assert(0);
		/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

		/*Begin to Merge, when splited segment density > original max density in map. original merged segment is splited segment or split original right segment*/
		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&        candidate merge segment overlap with candidate splited segments      &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
		if (temp_new_merge_segment_density_3_map.begin()->first >= merge_segment_density_map.begin()->first || merged_node_segment_original.right_endpoint == sub_right_segment.right_endpoint || merged_node_segment_original.right_endpoint == long_right_segment.right_endpoint) {

			//auto& const merged_node = temp_split_3_area_difference_map.begin()->second;
			auto& const merged_segment_candidate = temp_new_merge_segment_density_3_map.begin()->second;

			/*++++++++++++++++++++++++++++++++++++++++           candidate merge segment == sub left segment          ++++++++++++++++++++++++++++++++++++++++*/
			if (merged_segment_candidate.right_endpoint == sub_left_segment.right_endpoint) {//Make sure has left node, not head node.
				if (splited_node_original._prev->_value.area_difference + splited_node_original._value.area_difference <= sub_left_segment.right_subsegment->area_difference + sub_right_segment.area_difference) {
					should_change = false;
					break;
				}

				should_change = update_list_map_sub_left_is_merge(original_time_series_vector, merge_segment_density_map, split_area_difference_map, splited_node_original, sub_left_segment, sub_right_segment, long_right_segment, output_argument);
#ifdef _DEBUG
				assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
				assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
				continue;
			}
			/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			/*+++++++++++++++++++++++++++++++++++  candidate merge segment == sub right segment, split & merge on same node  +++++++++++++++++++++++++++++++++*/
			else if (merged_segment_candidate.right_endpoint == sub_right_segment.right_endpoint) {
				should_change = false;
				break;
			}
			/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			/*+++++++++++++++++++++++++++++++++++            candidate merge segment == Original right segment          ++++++++++++++++++++++++++++++++++++++*/
			else if (merged_segment_candidate.right_endpoint == long_right_segment.right_endpoint) {

				if (splited_node_original._value.area_difference + splited_node_original._next->_value.area_difference <= sub_left_segment.area_difference + long_right_segment.right_subsegment->area_difference) {
					should_change = false;
					break;
				}

				should_change = update_list_map_original_right_is_merge(original_time_series_vector, merge_segment_density_map, split_area_difference_map, splited_node_original, sub_left_segment, sub_right_segment, long_right_segment, output_argument);

				/*..............................................................................................................................*/
#ifdef _DEBUG
				assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
				assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
				/*..............................................................................................................................*/
				continue;
			}
			/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			else {
				assert(0);
			}
		}
		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&   Candidate merge segments not related with candidate split segments   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
		else if (merged_node_segment_original.right_endpoint < sub_left_segment.right_endpoint || merged_node_segment_original.right_endpoint > long_right_segment.right_endpoint) {
			if (splited_node_original._value.area_difference + merged_node_original._prev->_value.area_difference + merged_node_original._value.area_difference <= node_sub_left_new->_value.area_difference + sub_right_segment.area_difference + merged_node_original._value.right_subsegment->area_difference) {
				should_change = false;
				break;
			}

			should_change = update_list_map_split_is_not_merge(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, splited_node_original, merged_node_original, *node_sub_left_new, sub_right_segment, output_argument);
			continue;
		}
		else {
			assert(0);
		}
		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	}


	/*:::::::::::::::::::::::             Split Merge Operation              :::::::::::::::::::::::::*/
	//splitSegmentBySlope(original_time_series_vector, input_argument.option_split_method, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
	//mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list);
	/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
	//area_difference_sum_new = get_whole_area_difference(doubly_linked_list);
	/*..............................................................................................................................*/
#ifdef _DEBUG
	/*cout << "New sum area difference: " << area_difference_sum_new << endl;
	TOOL::print_each_segment_coefficient(doubly_linked_list);*/
	assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
	//evaluate right point, min&max point, width. a&b, sum value
	assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
	assert_split_map_area_difference(split_area_difference_map);
	//assert_minmax_value(original_time_series_vector, doubly_linked_list);
	assert_bound(original_time_series_vector, doubly_linked_list);
	assert_merge_map_triangle_density(merge_segment_density_map);
#endif
	/*..............................................................................................................................*/

	/*.................................................................................................................................*/
#ifdef _DEBUG
	//assert(temp_doubly_linked_list.size() == input_argument.point_dimension);
	//assert(right_endpoint_segment_max_density_merge == right_endpoint_segment_max_area_difference);

	/*:::::::::::::::::::::::    201217     Print linked list          ::::::::::::::::::::::::::::::*/

	/*----------  get a&b of every segment & get sum deviation & get reconstruction time series  -------*/
	const long double sum_deviation = get_sum_deviation_no_ab(original_time_series_vector, doubly_linked_list);
	/*--------------------------------------------------------------------------------------------------*/

	int count_same = 0;
	for (int i = 0; i < initial_right_endpoint_vector.size(); i++) {
		if (initial_right_endpoint_vector[i] == doubly_linked_list[i].right_endpoint)
			count_same++;
	}

	if (count_same == initial_right_endpoint_vector.size() || sum_deviation >= output_argument.sum_deviation) {
		input_argument.is_MS_effect = false;
	}
	else {
		input_argument.is_MS_effect = true;
		output_argument.sum_deviation = sum_deviation;
		//assert(0);
	}

	/*--------------   Print linked list  -------------------*/
	cout << "-------------------------------------------------------- \n9 After M&S: segment coefficients: \n";
	TOOL::print_each_segment_coefficient(doubly_linked_list);
	/*-------------------------------------------------------*/

	/*--------- 201217    200907 get reconstruct time series     ----------------*/
	getAPLAReconstructSeries(doubly_linked_list, reconstruct_time_series_vector);
	cout << "\n10 After M&S: Reconstruct time series:";
	TOOL::print_vector(reconstruct_time_series_vector);
	/*-----------------------------------------------------------------------------*/

	/*----------------------------------------------------------------------*/
	cout << "11 After M&S: reconstructed endpoint id: 0,";
	for (auto au : doubly_linked_list) {
		if (au.right_endpoint == reconstruct_time_series_vector.size() - 1)
			cout << au.right_endpoint;
		else
			cout << au.right_endpoint << "," << au.right_endpoint + 1 << ",";
	}
	cout << "\n11 After M&S: reconstructed endpoint value:" << reconstruct_time_series_vector[0] << ",";
	for (auto au : doubly_linked_list) {
		if (au.right_endpoint == reconstruct_time_series_vector.size() - 1)
			cout << reconstruct_time_series_vector[au.right_endpoint];
		else
			cout << reconstruct_time_series_vector[au.right_endpoint] << "," << reconstruct_time_series_vector[au.right_endpoint + 1] << ",";
	}
	cout << endl;
	/*----------------------------------------------------------------------*/

	reconstruct_time_series_vector.clear();
	reconstruct_time_series_vector.shrink_to_fit();

	cout << "\n12 After M&S: sum deviation: " << sum_deviation << endl;
	/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
#endif
	/*.................................................................................................................................*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   Optimization   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	//optimization_segments_loop(input_argument, original_time_series_vector, split_area_difference_map, doubly_linked_list, output_argument);

	//201111
	optimization_segments_loop_speed(input_argument, original_time_series_vector, split_area_difference_map, doubly_linked_list, output_argument);

	//doubly_linked_list.swap(temp_doubly_linked_list);
	//evaluate_upper_lower_bound(input_argument, original_time_series_vector, doubly_linked_list);
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
}


//************************************
// Method:split_merge_optimization_segments_speed1
// Qualifier: After initial part, The fastest way. Use split&merge&optimization to get tighter approximation
// date:201228  14:44
// author:
//************************************
TEMPLATE
template<typename T, typename T1, typename Y, typename U, typename U1>
void APLA::split_merge_optimization_segments_speed1(U& const input_argument, const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument) {

	/*..................................................................................................................*/
#ifdef _DEBUG
	assert(doubly_linked_list.size() == input_argument.point_dimension);
	//assert_minmax_value(original_time_series_vector, doubly_linked_list);
	assert_bound(original_time_series_vector, doubly_linked_list);
	assert_merge_map_triangle_density(merge_segment_density_map);
	/*::::::::::::::::::::     201217 Find Example      ::::::::::::::::::::::::::*/
	//vector<T> reconstruct_time_series_vector;
	//vector<int> initial_right_endpoint_vector;
	//for (auto&& au : doubly_linked_list) {
	//	initial_right_endpoint_vector.emplace_back(au.right_endpoint);
	//}
	//DoublyLinkedList<Y> temp_doubly_linked_list = DoublyLinkedList<Y>();
	//temp_doubly_linked_list.copy(doubly_linked_list);
	//multimap<T1, DoublyListNode<Y>&, greater<T1>> temp_merge_segment_density_map;
	//multimap<T1, DoublyListNode<Y>&, greater<T1>> temp_split_area_difference_map;
	/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
#endif
	/*....................................................................................................................*/


	if (split_area_difference_map.empty()) return;
	bool should_change = true;

	//DoublyListNode<Y>* node_sub_left_new = new DoublyListNode<Y>;
	//Y& const sub_left_segment = node_sub_left_new->_value;
	//sub_left_segment.right_subsegment = new Y;
	//Y sub_right_segment;
	//sub_right_segment.right_subsegment = new Y;

	//Y long_right_segment;
	//long_right_segment.right_subsegment = new Y;

	while (should_change) {

		/*..................................................................................................*/
#ifdef _DEBUG
		//evaluate right point, min&max point, width. a&b, sum value
		assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
		assert_split_map_area_difference(split_area_difference_map);

		/*::::::::::::::::::::     201217 Find Example      ::::::::::::::::::::::::::*/
		/*getAPLAReconstructSeries(doubly_linked_list, reconstruct_time_series_vector);
		cout << "\n8 After Merge: Reconstruct time series:";
		TOOL::print_vector(reconstruct_time_series_vector);
		reconstruct_time_series_vector.clear();
		reconstruct_time_series_vector.shrink_to_fit();*/
		/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
#endif
		/*..................................................................................................*/

		/*----------------------       Whether MAP Empty      ----------------------*/
		// If MAP is empty, no need to split
		if (split_area_difference_map.empty()) break;
		/*---------------------------------------------------------------------------*/

		/*=====================      Split Node, Merge Node         ======================*/
		auto& const splited_node_original = split_area_difference_map.begin()->second;
		auto& const splited_node_segment_original = splited_node_original._value;

		auto& const merged_node_original = merge_segment_density_map.begin()->second;
		auto& const merged_node_segment_original = merged_node_original._value;
		/*================================================================================*/

		/*............................................................................................................................*/
#ifdef _DEBUG
		assert_adjacent_nodes(merged_node_original);
		assert(merged_node_original._prev->_value.area_difference != INF && merged_node_segment_original.area_difference != INF && splited_node_segment_original.rectangle_width > 3);
		assert(merged_node_segment_original.right_subsegment != nullptr && merged_node_segment_original.apla.a != INF && merged_node_segment_original.apla.b != INF && merged_node_segment_original.right_endpoint != INF && merged_node_segment_original.rectangle_width != INF);

		find_if_in_multimap(splited_node_segment_original.area_difference, split_area_difference_map);
		if (splited_node_original._prev) {
			assert_adjacent_nodes(splited_node_original);
			find_if_in_multimap(splited_node_segment_original.right_subsegment->segment_density, merge_segment_density_map);
		}
		if (splited_node_original._next) { find_if_in_multimap(splited_node_original._next->_value.right_subsegment->segment_density, merge_segment_density_map); }
		if (merged_node_original._prev->_value.area_difference > 0 && merged_node_original._prev->_value.rectangle_width > 3) { find_if_in_multimap(merged_node_original._prev->_value.area_difference, split_area_difference_map); }
		if (merged_node_original._prev->_prev) { find_if_in_multimap(merged_node_original._prev->_value.right_subsegment->segment_density, merge_segment_density_map); }
		if (merged_node_segment_original.area_difference > 0 && merged_node_segment_original.rectangle_width > 3) { find_if_in_multimap(merged_node_segment_original.area_difference, split_area_difference_map); }
		find_if_in_multimap(merged_node_segment_original.right_subsegment->segment_density, merge_segment_density_map);
		if (merged_node_original._next) { find_if_in_multimap(merged_node_original._next->_value.right_subsegment->segment_density, merge_segment_density_map); }

		assert(splited_node_segment_original.area_difference > 0 && splited_node_segment_original.area_difference != INF && splited_node_segment_original.right_subsegment != nullptr);
		assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
		/*............................................................................................................................*/

		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&       Find Split point in Candidate Node      &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
		//sub left segemnt
		DoublyListNode<Y>* node_sub_left_new = new DoublyListNode<Y>;
		Y& const sub_left_segment = node_sub_left_new->_value;

		Y sub_right_segment;
		//*sub_right_segment.right_subsegment = splited_node_segment_original;
		sub_right_segment = splited_node_segment_original;
		sub_right_segment.right_subsegment = new Y;
		*sub_right_segment.right_subsegment = sub_right_segment;

		const int split_method_option = 0;
		sub_left_segment.right_endpoint = group_find_split_point_methods(original_time_series_vector, split_method_option, sub_left_segment, sub_right_segment, *sub_right_segment.right_subsegment, output_argument);

		/*........................................................................................*/
#ifdef _DEBUG
		assert(sub_left_segment.right_endpoint > 0 && sub_left_segment.right_endpoint < sub_right_segment.right_endpoint);
		assert(sub_left_segment.rectangle_width + sub_right_segment.rectangle_width == splited_node_segment_original.rectangle_width);
		assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
		/*........................................................................................*/

		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

		// Has split point, begin to split segment
		if (sub_left_segment.right_endpoint == INF) break;

		/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Has Spilt Point    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

		/*&&&&&&&&&&&&&&&&&&&&&&&    After Split. Coefficients of  1 sub left node, 2 sub right node, 3 split original right node    &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

		/*+++++++++++++++++++++++++++++++++++++++   compute min&max, area difference of splited segments   ++++++++++++++++++++++++++++++++++++++*/
		sub_left_segment.right_subsegment = new Y;
		/*--------------------210203       After Split. Area Min&Max Point of 1 sub left node, 2 sub right node      ------------------------*/
		//200212 get min&max point of left&right segment by long segment, speed up
		//getSubMinMaxPoint(original_time_series_vector, sub_left_segment, sub_right_segment, *sub_right_segment.right_subsegment);
		/*-----------------------------------------------------------------------------------------------------------------------------*/
		/*----------  210203 After Split. Area Difference of  1 sub left node,  2 sub right node,  3 split original right node    -----------*/
		/*getAreaDifference(original_time_series_vector, sub_left_segment);
		getAreaDifference(original_time_series_vector, sub_right_segment);
		getAreaDifference(original_time_series_vector, *sub_right_segment.right_subsegment);*/
		/*-----------------------------------------------------------------------------------------------------------------------------*/

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*++++++++++++++++++++++      After Split. Density of  1 sub left node,  2 sub right node,  3 split original right node      +++++++++++++++++++++++++++*/
		multimap<T1, Y&, greater<T1>> temp_new_merge_segment_density_3_map;

		/*==========================================            Split Sub Left Node: Density          =============================================*/
		if (splited_node_original._prev) {//middle node
			/*--------------------------             Density: long left segment & sub left segment                 -------------------------------*/
			getMergedSubSegmentInformation(original_time_series_vector, splited_node_original._prev->_value, sub_left_segment, *sub_left_segment.right_subsegment, output_argument);//200109 For area difference
			/*------------------------------------------------------------------------------------------------------------------------------------*/
			temp_new_merge_segment_density_3_map.emplace(sub_left_segment.right_subsegment->segment_density, sub_left_segment);
		}
		/*==========================================================================================================================================*/
		/*-----------------------------------------------      Split Sub Right Node: Density      ------------------------------------*/
		temp_new_merge_segment_density_3_map.emplace(sub_right_segment.right_subsegment->segment_density, sub_right_segment);
		/*----------------------------------------------------------------------------------------------------------------------------*/
		/*==========================================       new Split Original Right Node: Density      =============================================*/
		/*------ split original right node ---*/
		Y long_right_segment;
		/*------------------------------------*/
		if (splited_node_original._next) {//middle node
			long_right_segment = splited_node_original._next->_value;
			long_right_segment.right_subsegment = new Y;
			getMergedSubSegmentInformation(original_time_series_vector, sub_right_segment, long_right_segment, *long_right_segment.right_subsegment, output_argument);//200109 For area difference
			temp_new_merge_segment_density_3_map.emplace(long_right_segment.right_subsegment->segment_density, long_right_segment);
		}
		/*==========================================================================================================================================*/

		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*.........................................................*/
#ifdef _DEBUG
		if (doubly_linked_list.size() > 1) {
			assert(!merge_segment_density_map.empty());
		}
		else if (doubly_linked_list.size() == 1) {
			assert(merge_segment_density_map.empty());
			break;
		}
		assert_split_map_area_difference(split_area_difference_map);
#endif
		/*.........................................................*/

		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

		/*:::::::::::::::::::::::::::::::::::::::::::::::           201217 Find Example           ::::::::::::::::::::::::::::::::::::::::::::::*/
		//int order_node = 0;
		//for (order_node = 0; temp_doubly_linked_list[order_node].right_endpoint < splited_node_segment_original.right_endpoint; order_node++) {}
		//auto& temp_splited_node_copy = temp_doubly_linked_list.getNode(order_node);
		//temp_doubly_linked_list.insertValueBeforeNode(sub_left_segment, temp_splited_node_copy);
		//temp_doubly_linked_list.insertValueBeforeNode(sub_right_segment, temp_splited_node_copy);
		//temp_doubly_linked_list.removeNode(temp_splited_node_copy);
		///*-------------    Print linked list    -----------------------*/
		//cout << "After Split segment coefficients: \n";
		//TOOL::print_each_segment_coefficient(temp_doubly_linked_list);
		///*-------------------------------------------------------------*/
		///*-------------    200907 get reconstruct time series      ---------------------*/
		////vector<T> reconstruct_time_series_vector;
		//getAPLAReconstructSeries(temp_doubly_linked_list, reconstruct_time_series_vector);
		//cout << "Reconstruct time series:";
		//TOOL::print_vector(reconstruct_time_series_vector);
		//reconstruct_time_series_vector.clear();
		//reconstruct_time_series_vector.shrink_to_fit();
		///*-----------------------------------------------------------------------------*/
		//assert(0);
		/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

		/*Begin to Merge, when splited segment density > original max density in map. original merged segment is splited segment or split original right segment*/
		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&        candidate merge segment overlap with candidate splited segments      &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
		if (temp_new_merge_segment_density_3_map.begin()->first >= merge_segment_density_map.begin()->first || merged_node_segment_original.right_endpoint == sub_right_segment.right_endpoint || merged_node_segment_original.right_endpoint == long_right_segment.right_endpoint) {

			//auto& const merged_node = temp_split_3_area_difference_map.begin()->second;
			auto& const merged_segment_candidate = temp_new_merge_segment_density_3_map.begin()->second;

			/*++++++++++++++++++++++++++++++++++++++++           candidate merge segment == sub left segment          ++++++++++++++++++++++++++++++++++++++++*/
			if (merged_segment_candidate.right_endpoint == sub_left_segment.right_endpoint) {//Make sure has left node, not head node.
				if (splited_node_original._prev->_value.area_difference + splited_node_original._value.area_difference <= sub_left_segment.right_subsegment->area_difference + sub_right_segment.area_difference) {
					should_change = false;
					break;
				}

				should_change = update_list_map_sub_left_is_merge(original_time_series_vector, merge_segment_density_map, split_area_difference_map, splited_node_original, sub_left_segment, sub_right_segment, long_right_segment, output_argument);
#ifdef _DEBUG
				assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
				assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
				continue;
			}
			/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			/*+++++++++++++++++++++++++++++++++++  candidate merge segment == sub right segment, split & merge on same node  +++++++++++++++++++++++++++++++++*/
			else if (merged_segment_candidate.right_endpoint == sub_right_segment.right_endpoint) {
				/*..............................................................................................................................*/
#ifdef _DEBUG
				assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
				assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
				/*..............................................................................................................................*/
				should_change = false;
				break;
			}
			/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			/*+++++++++++++++++++++++++++++++++++            candidate merge segment == Original right segment          ++++++++++++++++++++++++++++++++++++++*/
			else if (merged_segment_candidate.right_endpoint == long_right_segment.right_endpoint) {

				if (splited_node_original._value.area_difference + splited_node_original._next->_value.area_difference <= sub_left_segment.area_difference + long_right_segment.right_subsegment->area_difference) {
					should_change = false;
					break;
				}

				should_change = update_list_map_original_right_is_merge(original_time_series_vector, merge_segment_density_map, split_area_difference_map, splited_node_original, sub_left_segment, sub_right_segment, long_right_segment, output_argument);

				/*..............................................................................................................................*/
#ifdef _DEBUG
				assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
				assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
				/*..............................................................................................................................*/
				continue;
			}
			/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			else {
				assert(0);
			}
		}
		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&   Candidate merge segments not related with candidate split segments   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
		else if (merged_node_segment_original.right_endpoint < sub_left_segment.right_endpoint || merged_node_segment_original.right_endpoint > long_right_segment.right_endpoint) {

			if (splited_node_original._value.area_difference + merged_node_original._prev->_value.area_difference + merged_node_original._value.area_difference <= node_sub_left_new->_value.area_difference + sub_right_segment.area_difference + merged_node_original._value.right_subsegment->area_difference) {
				should_change = false;
				break;
			}

			should_change = update_list_map_split_is_not_merge(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, splited_node_original, merged_node_original, *node_sub_left_new, sub_right_segment, output_argument);
			/*..............................................................................................................................*/
#ifdef _DEBUG
			assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
			assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
			/*..............................................................................................................................*/
			continue;
		}
		else {
			assert(0);
		}
		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	}


	/*:::::::::::::::::::::::             Split Merge Operation              :::::::::::::::::::::::::*/
	//splitSegmentBySlope(original_time_series_vector, input_argument.option_split_method, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
	//mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list);
	/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
	//area_difference_sum_new = get_whole_area_difference(doubly_linked_list);
	/*..............................................................................................................................*/
#ifdef _DEBUG
	assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
	/*cout << "New sum area difference: " << area_difference_sum_new << endl;
	TOOL::print_each_segment_coefficient(doubly_linked_list);*/
	assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
	//evaluate right point, min&max point, width. a&b, sum value
	assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
	assert_split_map_area_difference(split_area_difference_map);
	//assert_minmax_value(original_time_series_vector, doubly_linked_list);
	assert_bound(original_time_series_vector, doubly_linked_list);
	assert_merge_map_triangle_density(merge_segment_density_map);
	//assert(temp_doubly_linked_list.size() == input_argument.point_dimension);
	//assert(right_endpoint_segment_max_density_merge == right_endpoint_segment_max_area_difference);

	/*:::::::::::::::::::::::    201217     Print linked list          ::::::::::::::::::::::::::::::*/

	///*----------  get a&b of every segment & get sum deviation & get reconstruction time series  -------*/
	//const long double sum_deviation = get_sum_deviation_no_ab(original_time_series_vector, doubly_linked_list);
	///*--------------------------------------------------------------------------------------------------*/

	//int count_same = 0;
	//for (int i = 0; i < initial_right_endpoint_vector.size(); i++) {
	//	if (initial_right_endpoint_vector[i] == doubly_linked_list[i].right_endpoint)
	//		count_same++;
	//}

	//if (count_same == initial_right_endpoint_vector.size() || sum_deviation >= output_argument.sum_deviation) {
	//	input_argument.is_MS_effect = false;
	//}
	//else {
	//	input_argument.is_MS_effect = true;
	//	output_argument.sum_deviation = sum_deviation;
	//	//assert(0);
	//}

	///*--------------   Print linked list  -------------------*/
	//cout << "-------------------------------------------------------- \n9 After M&S: segment coefficients: \n";
	//TOOL::print_each_segment_coefficient(doubly_linked_list);
	///*-------------------------------------------------------*/

	///*--------- 201217    200907 get reconstruct time series     ----------------*/
	//getAPLAReconstructSeries(doubly_linked_list, reconstruct_time_series_vector);
	//cout << "\n10 After M&S: Reconstruct time series:";
	//TOOL::print_vector(reconstruct_time_series_vector);
	///*-----------------------------------------------------------------------------*/

	///*----------------------------------------------------------------------*/
	//cout << "11 After M&S: reconstructed endpoint id: 0,";
	//for (auto au : doubly_linked_list) {
	//	if (au.right_endpoint == reconstruct_time_series_vector.size() - 1)
	//		cout << au.right_endpoint;
	//	else
	//		cout << au.right_endpoint << "," << au.right_endpoint + 1 << ",";
	//}
	//cout << "\n11 After M&S: reconstructed endpoint value:" << reconstruct_time_series_vector[0] <<",";
	//for (auto au : doubly_linked_list) {
	//	if (au.right_endpoint == reconstruct_time_series_vector.size() - 1)
	//		cout << reconstruct_time_series_vector[au.right_endpoint];
	//	else
	//		cout << reconstruct_time_series_vector[au.right_endpoint] << "," << reconstruct_time_series_vector[au.right_endpoint + 1] << ",";
	//}
	//cout << endl;
	///*----------------------------------------------------------------------*/

	//reconstruct_time_series_vector.clear();
	//reconstruct_time_series_vector.shrink_to_fit();

	//cout << "\n12 After M&S: sum deviation: " << sum_deviation << endl;
	/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
#endif
	/*.................................................................................................................................*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   Optimization   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	//optimization_segments_loop(input_argument, original_time_series_vector, split_area_difference_map, doubly_linked_list, output_argument);

	//201111
	optimization_segments_loop_speed(input_argument, original_time_series_vector, split_area_difference_map, doubly_linked_list, output_argument);

	//doubly_linked_list.swap(temp_doubly_linked_list);
	//evaluate_upper_lower_bound(input_argument, original_time_series_vector, doubly_linked_list);
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
}

//************************************
// Method:split_merge_optimization_segments_speed2
// Qualifier: After initial part, The fastest way. Use split&merge&optimization to get tighter approximation
// date:210301  14:44
// author:
//************************************
TEMPLATE
template<typename T, typename T1, typename Y, typename U, typename U1>
void APLA::split_merge_optimization_segments_speed2(U& const input_argument, const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument) {
	/*############################################################# Split & Merge Operation #############################################################################################*/
	bool temp_is_burst = false;
	while (doubly_linked_list.size() < input_argument.point_dimension) {

		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!     191124 for burst time series   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		if (split_area_difference_map.size() == 0) {
			assert(0);
			temp_is_burst = true;

			/*............................................*/
#ifdef _DEBUG
			assert(input_argument.point_dimension != INF);
#endif
			/*............................................*/

			/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			split_burst_segment(original_time_series_vector, input_argument.point_dimension, doubly_linked_list);
			/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			break;

		}
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		splitSegmentBySlope(original_time_series_vector, input_argument.option_split_method, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	}
	/*..................................................................................................................*/
#ifdef _DEBUG
	if (temp_is_burst == false)
		assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
#endif
	/*..................................................................................................................*/
	while (doubly_linked_list.size() > input_argument.point_dimension) {
		mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
	}
	/*##############################################################################################################################################################################*/

	/*..................................................................................................................*/
#ifdef _DEBUG
	assert(doubly_linked_list.size() == input_argument.point_dimension);
	//assert_minmax_value(original_time_series_vector, doubly_linked_list);
	assert_bound(original_time_series_vector, doubly_linked_list);
	assert_merge_map_triangle_density(merge_segment_density_map);
	/*::::::::::::::::::::     201217 Find Example      ::::::::::::::::::::::::::*/
	/*vector<T> reconstruct_time_series_vector;
	vector<int> initial_right_endpoint_vector;
	for (auto&& au : doubly_linked_list) {
		initial_right_endpoint_vector.emplace_back(au.right_endpoint);
	}
	DoublyLinkedList<Y> temp_doubly_linked_list = DoublyLinkedList<Y>();
	temp_doubly_linked_list.copy(doubly_linked_list);
	multimap<T1, DoublyListNode<Y>&, greater<T1>> temp_merge_segment_density_map;
	multimap<T1, DoublyListNode<Y>&, greater<T1>> temp_split_area_difference_map;*/
	/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
#endif
	/*....................................................................................................................*/
	if (split_area_difference_map.empty()) return;
	bool should_change = true;

	while (should_change) {

		/*..................................................................................................*/
#ifdef _DEBUG
		//evaluate right point, min&max point, width. a&b, sum value
		assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
		assert_split_map_area_difference(split_area_difference_map);
		/*::::::::::::::::::::     201217 Find Example      ::::::::::::::::::::::::::*/
		/*getAPLAReconstructSeries(doubly_linked_list, reconstruct_time_series_vector);
		cout << "\n8 After Merge: Reconstruct time series:";
		TOOL::print_vector(reconstruct_time_series_vector);
		reconstruct_time_series_vector.clear();
		reconstruct_time_series_vector.shrink_to_fit();*/
		/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
#endif
		/*..................................................................................................*/

		/*----------------------       Whether MAP Empty      ----------------------*/
		// If MAP is empty, no need to split
		if (split_area_difference_map.empty()) break;
		/*---------------------------------------------------------------------------*/
		/*=====================      Split Node, Merge Node         ======================*/
		auto& const splited_node_original = split_area_difference_map.begin()->second;
		auto& const splited_node_segment_original = splited_node_original._value;

		auto& const merged_node_original = merge_segment_density_map.begin()->second;
		auto& const merged_node_segment_original = merged_node_original._value;
		/*================================================================================*/

		/*............................................................................................................................*/
#ifdef _DEBUG
		assert(merged_node_original._prev->_value.area_difference != INF && merged_node_segment_original.area_difference != INF && splited_node_segment_original.rectangle_width > 3);
		assert(merged_node_segment_original.right_subsegment != nullptr && merged_node_segment_original.apla.a != INF && merged_node_segment_original.apla.b != INF && merged_node_segment_original.right_endpoint != INF && merged_node_segment_original.rectangle_width != INF);

		find_if_in_multimap(splited_node_segment_original.area_difference, split_area_difference_map);
		if (splited_node_original._prev) { find_if_in_multimap(splited_node_segment_original.right_subsegment->segment_density, merge_segment_density_map); }
		if (splited_node_original._next) { find_if_in_multimap(splited_node_original._next->_value.right_subsegment->segment_density, merge_segment_density_map); }
		if (merged_node_original._prev->_value.area_difference > 0 && merged_node_original._prev->_value.rectangle_width > 3) { find_if_in_multimap(merged_node_original._prev->_value.area_difference, split_area_difference_map); }
		if (merged_node_original._prev->_prev) { find_if_in_multimap(merged_node_original._prev->_value.right_subsegment->segment_density, merge_segment_density_map); }
		if (merged_node_segment_original.area_difference > 0 && merged_node_segment_original.rectangle_width > 3) { find_if_in_multimap(merged_node_segment_original.area_difference, split_area_difference_map); }
		find_if_in_multimap(merged_node_segment_original.right_subsegment->segment_density, merge_segment_density_map);
		if (merged_node_original._next) { find_if_in_multimap(merged_node_original._next->_value.right_subsegment->segment_density, merge_segment_density_map); }

		assert(splited_node_segment_original.area_difference > 0 && splited_node_segment_original.area_difference != INF && splited_node_segment_original.right_subsegment != nullptr);
		assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
		/*............................................................................................................................*/

		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&   For Split & Merge,  Find Split point in Candidate Node   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
		//sub left segemnt
		DoublyListNode<Y>* node_sub_left_new = new DoublyListNode<Y>;
		Y& const sub_left_segment = node_sub_left_new->_value;

		Y sub_right_segment;
		//*sub_right_segment.right_subsegment = splited_node_segment_original;
		sub_right_segment = splited_node_segment_original;
		sub_right_segment.right_subsegment = new Y;
		*sub_right_segment.right_subsegment = sub_right_segment;

		const int split_method_option = 0;
		sub_left_segment.right_endpoint = group_find_split_point_methods(original_time_series_vector, split_method_option, sub_left_segment, sub_right_segment, *sub_right_segment.right_subsegment, output_argument);
		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
		/*........................................................................................*/
#ifdef _DEBUG
		assert(sub_left_segment.right_endpoint > 0 && sub_left_segment.right_endpoint < sub_right_segment.right_endpoint);
		assert(sub_left_segment.rectangle_width + sub_right_segment.rectangle_width == splited_node_segment_original.rectangle_width);
		assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
		/*........................................................................................*/
		// Has split point, begin to split segment
		if (sub_left_segment.right_endpoint == INF) break;


		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&  210301 For Merge & Split,  Find Split point in Candidate Node   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
		long double area_difference_original_ms = INF;
		long double area_difference_upper_bound_ms = INF;
		long double differece_merge_split = INF;
		long double difference_split_merge = INF;
		Y sub_left_segment_ms;
		Y sub_right_segment_ms;
		size_t merge_split_type = 0;
		if (merged_node_segment_original.right_subsegment->area_difference <= splited_node_segment_original.area_difference && splited_node_segment_original.right_endpoint != merged_node_original._prev->_value.right_endpoint && splited_node_segment_original.right_endpoint != merged_node_segment_original.right_endpoint) {// merged node is not split node
			merge_split_type = 1;
			area_difference_original_ms = merged_node_original._prev->_value.area_difference + merged_node_segment_original.area_difference + splited_node_segment_original.area_difference;
			area_difference_upper_bound_ms = merged_node_segment_original.right_subsegment->area_difference + sub_left_segment.area_difference + sub_right_segment.area_difference;
			differece_merge_split = area_difference_original_ms - area_difference_upper_bound_ms;
		}
		else {//merged node is split node
			merge_split_type = 2;
			sub_right_segment_ms.right_subsegment = new Y;
			*sub_right_segment_ms.right_subsegment = *merged_node_segment_original.right_subsegment;
			sub_left_segment_ms.right_endpoint = group_find_split_point_methods(original_time_series_vector, split_method_option, sub_left_segment_ms, sub_right_segment_ms, *sub_right_segment_ms.right_subsegment, output_argument);
			area_difference_original_ms = merged_node_original._prev->_value.area_difference + merged_node_segment_original.area_difference;
			area_difference_upper_bound_ms = sub_left_segment_ms.area_difference + sub_right_segment_ms.area_difference;
			differece_merge_split = area_difference_original_ms - area_difference_upper_bound_ms;
		}
		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

		/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Has Spilt Point    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

		/*&&&&&&&&&&&&&&&&&&&&&&&    After Split. Coefficients of  1 sub left node, 2 sub right node, 3 split original right node    &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
		sub_left_segment.right_subsegment = new Y;
		/*++++++++++++++++++++++      After Split. Density of  1 sub left node,  2 sub right node,  3 split original right node      +++++++++++++++++++++++++++*/
		multimap<T1, Y&, greater<T1>> temp_new_merge_segment_density_3_map;
		/*==========================================            Split Sub Left Node: Density          =============================================*/
		if (splited_node_original._prev) {//middle node
			/*--------------------------             Density: long left segment & sub left segment                 -------------------------------*/
			getMergedSubSegmentInformation(original_time_series_vector, splited_node_original._prev->_value, sub_left_segment, *sub_left_segment.right_subsegment, output_argument);//200109 For area difference
			/*------------------------------------------------------------------------------------------------------------------------------------*/
			temp_new_merge_segment_density_3_map.emplace(sub_left_segment.right_subsegment->segment_density, sub_left_segment);
		}
		/*==========================================================================================================================================*/
		/*-----------------------------------------------      Split Sub Right Node: Density      ------------------------------------*/
		temp_new_merge_segment_density_3_map.emplace(sub_right_segment.right_subsegment->segment_density, sub_right_segment);
		/*----------------------------------------------------------------------------------------------------------------------------*/
		/*==========================================       new Split Original Right Node: Density      =============================================*/
		/*------ split original right node ---*/
		Y long_right_segment;
		/*------------------------------------*/
		if (splited_node_original._next) {//middle node
			long_right_segment = splited_node_original._next->_value;
			long_right_segment.right_subsegment = new Y;
			getMergedSubSegmentInformation(original_time_series_vector, sub_right_segment, long_right_segment, *long_right_segment.right_subsegment, output_argument);//200109 For area difference
			temp_new_merge_segment_density_3_map.emplace(long_right_segment.right_subsegment->segment_density, long_right_segment);
		}
		/*==========================================================================================================================================*/
		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*.........................................................*/
#ifdef _DEBUG
		if (doubly_linked_list.size() > 1) {
			assert(!merge_segment_density_map.empty());
		}
		else if (doubly_linked_list.size() == 1) {
			assert(merge_segment_density_map.empty());
			break;
		}
		assert_split_map_area_difference(split_area_difference_map);
#endif
		/*.........................................................*/

		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

		/*Begin to Merge, when splited segment density > original max density in map. original merged segment is splited segment or split original right segment*/
		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&        candidate merge segment overlap with candidate splited segments      &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
		if (temp_new_merge_segment_density_3_map.begin()->first >= merge_segment_density_map.begin()->first || merged_node_segment_original.right_endpoint == sub_right_segment.right_endpoint || merged_node_segment_original.right_endpoint == long_right_segment.right_endpoint) {

			//auto& const merged_node = temp_split_3_area_difference_map.begin()->second;
			auto& const merged_segment_candidate = temp_new_merge_segment_density_3_map.begin()->second;

			/*++++++++++++++++++++++++++++++++++++++++           candidate merge segment == sub left segment          ++++++++++++++++++++++++++++++++++++++++*/
			if (merged_segment_candidate.right_endpoint == sub_left_segment.right_endpoint) {//Make sure has left node, not head node.

				//if (splited_node_original._prev->_value.area_difference + splited_node_original._value.area_difference <= sub_left_segment.right_subsegment->area_difference + sub_right_segment.area_difference) should_change = false;
				difference_split_merge = splited_node_original._prev->_value.area_difference + splited_node_original._value.area_difference - sub_left_segment.right_subsegment->area_difference - sub_right_segment.area_difference;
				/*======================= Compare sm or ms=========================*/
				if (difference_split_merge <= 0 && differece_merge_split <= 0) {
					should_change = false;
					break;
				}
				else if (difference_split_merge > differece_merge_split) {// first split, second merge
					should_change = update_list_map_sub_left_is_merge(original_time_series_vector, merge_segment_density_map, split_area_difference_map, splited_node_original, sub_left_segment, sub_right_segment, long_right_segment, output_argument);
				}
				else if (difference_split_merge <= differece_merge_split) {
					if (merge_split_type == 1) {// merged node is not split node.
						should_change = update_list_map_split_is_not_merge(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, splited_node_original, merged_node_original, *node_sub_left_new, sub_right_segment, output_argument);
					}
					else {//merged node is split nodes
						should_change = update_list_map_merge_split_same(original_time_series_vector, merge_segment_density_map, split_area_difference_map, merged_node_original, sub_left_segment_ms, sub_right_segment_ms, output_argument);
					}
				}
				else {
					assert(0);
				}
				/*==============================================================*/
#ifdef _DEBUG
				assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
				assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
				continue;
				/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			}
			else if (merged_segment_candidate.right_endpoint == sub_right_segment.right_endpoint) {//candidate merge segment == sub right segment, split & merge on same node
				if (differece_merge_split <= 0) {
					should_change = false;
					break;
				}
				else if (merge_split_type == 1) {// merged node is not split node.
					should_change = update_list_map_split_is_not_merge(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, splited_node_original, merged_node_original, *node_sub_left_new, sub_right_segment, output_argument);
				}
				else {//merged node is split nodes
					should_change = update_list_map_merge_split_same(original_time_series_vector, merge_segment_density_map, split_area_difference_map, merged_node_original, sub_left_segment_ms, sub_right_segment_ms, output_argument);
				}
				continue;
			}
			else if (merged_segment_candidate.right_endpoint == long_right_segment.right_endpoint) {
				/*+++++++++++++++++++++++++++++++++++            candidate merge segment == Original right segment          ++++++++++++++++++++++++++++++++++++++*/
				/*if (splited_node_original._value.area_difference + splited_node_original._next->_value.area_difference <= sub_left_segment.area_difference + long_right_segment.right_subsegment->area_difference){
					should_change = false;
					break;
				}*/

				difference_split_merge = splited_node_original._value.area_difference + splited_node_original._next->_value.area_difference - sub_left_segment.area_difference - long_right_segment.right_subsegment->area_difference;

				/*======================= Compare sm or ms=========================*/
				if (difference_split_merge <= 0 && differece_merge_split <= 0) {
					should_change = false;
					break;
				}
				else if (difference_split_merge > differece_merge_split) {// first split, second merge
					should_change = update_list_map_original_right_is_merge(original_time_series_vector, merge_segment_density_map, split_area_difference_map, splited_node_original, sub_left_segment, sub_right_segment, long_right_segment, output_argument);
				}
				else if (difference_split_merge <= differece_merge_split) {
					if (merge_split_type == 1) {// merged node is not split node.
						should_change = update_list_map_split_is_not_merge(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, splited_node_original, merged_node_original, *node_sub_left_new, sub_right_segment, output_argument);
					}
					else {//merged node is split nodes
						should_change = update_list_map_merge_split_same(original_time_series_vector, merge_segment_density_map, split_area_difference_map, merged_node_original, sub_left_segment_ms, sub_right_segment_ms, output_argument);
					}
				}
				else {
					assert(0);
				}
				/*==============================================================*/

				/*..............................................................................................................................*/
#ifdef _DEBUG
				assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
				assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
				/*..............................................................................................................................*/
				continue;
				/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			}
			else {
				assert(0);
			}
		}
		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
		else if (merged_node_segment_original.right_endpoint < sub_left_segment.right_endpoint || merged_node_segment_original.right_endpoint > long_right_segment.right_endpoint) {
			/*+++++++++++++++++++++++++++++++++++++++   Candidate merge segments not related with candidate split segments   +++++++++++++++++++++++++++++++++++++++*/
			/*if (splited_node_original._value.area_difference + merged_node_original._prev->_value.area_difference + merged_node_original._value.area_difference <= node_sub_left_new->_value.area_difference + sub_right_segment.area_difference + merged_node_original._value.right_subsegment->area_difference){
				should_change = false;
				break;
			}*/

			difference_split_merge = splited_node_original._value.area_difference + merged_node_original._prev->_value.area_difference + merged_node_original._value.area_difference - node_sub_left_new->_value.area_difference - sub_right_segment.area_difference - merged_node_original._value.right_subsegment->area_difference;

			/*======================= Compare sm or ms=========================*/
			if (difference_split_merge <= 0 && differece_merge_split <= 0) {
				should_change = false;
				break;
			}
			else if (difference_split_merge > differece_merge_split) {// first split, second merge
				should_change = update_list_map_split_is_not_merge(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, splited_node_original, merged_node_original, *node_sub_left_new, sub_right_segment, output_argument);
			}
			else if (difference_split_merge <= differece_merge_split) {
				if (merge_split_type == 1) {// merged node is not split node.
					should_change = update_list_map_split_is_not_merge(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, splited_node_original, merged_node_original, *node_sub_left_new, sub_right_segment, output_argument);
				}
				else {//merged node is split nodes
					should_change = update_list_map_merge_split_same(original_time_series_vector, merge_segment_density_map, split_area_difference_map, merged_node_original, sub_left_segment_ms, sub_right_segment_ms, output_argument);
				}
			}
			else {
				assert(0);
			}
			/*==============================================================*/
			continue;
		}
		else {
			assert(0);
		}

	}

	/*:::::::::::::::::::::::             Split Merge Operation              :::::::::::::::::::::::::*/
	//splitSegmentBySlope(original_time_series_vector, input_argument.option_split_method, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
	//mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list);
	/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
	//area_difference_sum_new = get_whole_area_difference(doubly_linked_list);
	/*..............................................................................................................................*/
#ifdef _DEBUG
	/*cout << "New sum area difference: " << area_difference_sum_new << endl;
	TOOL::print_each_segment_coefficient(doubly_linked_list);*/
	assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
	//evaluate right point, min&max point, width. a&b, sum value
	assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
	assert_split_map_area_difference(split_area_difference_map);
	//assert_minmax_value(original_time_series_vector, doubly_linked_list);
	assert_bound(original_time_series_vector, doubly_linked_list);
	assert_merge_map_triangle_density(merge_segment_density_map);
#endif
	/*..............................................................................................................................*/

	/*.................................................................................................................................*/
#ifdef _DEBUG
	//assert(temp_doubly_linked_list.size() == input_argument.point_dimension);
	//assert(right_endpoint_segment_max_density_merge == right_endpoint_segment_max_area_difference);

	/*:::::::::::::::::::::::    201217     Print linked list          ::::::::::::::::::::::::::::::*/
	///*----------  get a&b of every segment & get sum deviation & get reconstruction time series  -------*/
	//const long double sum_deviation = get_sum_deviation_no_ab(original_time_series_vector, doubly_linked_list);
	///*--------------------------------------------------------------------------------------------------*/

	//int count_same = 0;
	//for (int i = 0; i < initial_right_endpoint_vector.size(); i++) {
	//	if (initial_right_endpoint_vector[i] == doubly_linked_list[i].right_endpoint)
	//		count_same++;
	//}

	//if (count_same == initial_right_endpoint_vector.size() || sum_deviation >= output_argument.sum_deviation) {
	//	input_argument.is_MS_effect = false;
	//}
	//else {
	//	input_argument.is_MS_effect = true;
	//	output_argument.sum_deviation = sum_deviation;
	//	//assert(0);
	//}

	///*--------------   Print linked list  -------------------*/
	//cout << "-------------------------------------------------------- \n9 After M&S: segment coefficients: \n";
	//TOOL::print_each_segment_coefficient(doubly_linked_list);
	///*-------------------------------------------------------*/

	///*--------- 201217    200907 get reconstruct time series     ----------------*/
	//getAPLAReconstructSeries(doubly_linked_list, reconstruct_time_series_vector);
	//cout << "\n10 After M&S: Reconstruct time series:";
	//TOOL::print_vector(reconstruct_time_series_vector);
	///*-----------------------------------------------------------------------------*/

	///*----------------------------------------------------------------------*/
	//cout << "11 After M&S: reconstructed endpoint id: 0,";
	//for (auto au : doubly_linked_list) {
	//	if (au.right_endpoint == reconstruct_time_series_vector.size() - 1)
	//		cout << au.right_endpoint;
	//	else
	//		cout << au.right_endpoint << "," << au.right_endpoint + 1 << ",";
	//}
	//cout << "\n11 After M&S: reconstructed endpoint value:" << reconstruct_time_series_vector[0] << ",";
	//for (auto au : doubly_linked_list) {
	//	if (au.right_endpoint == reconstruct_time_series_vector.size() - 1)
	//		cout << reconstruct_time_series_vector[au.right_endpoint];
	//	else
	//		cout << reconstruct_time_series_vector[au.right_endpoint] << "," << reconstruct_time_series_vector[au.right_endpoint + 1] << ",";
	//}
	//cout << endl;
	///*----------------------------------------------------------------------*/

	//reconstruct_time_series_vector.clear();
	//reconstruct_time_series_vector.shrink_to_fit();

	//cout << "\n12 After M&S: sum deviation: " << sum_deviation << endl;
	/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
#endif
	/*.................................................................................................................................*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   Optimization   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	//optimization_segments_loop(input_argument, original_time_series_vector, split_area_difference_map, doubly_linked_list, output_argument);

	//201111
	optimization_segments_loop_speed(input_argument, original_time_series_vector, split_area_difference_map, doubly_linked_list, output_argument);

	//doubly_linked_list.swap(temp_doubly_linked_list);
	//evaluate_upper_lower_bound(input_argument, original_time_series_vector, doubly_linked_list);
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
}

//************************************
// Method:split_merge_optimization_segments_speed3
// Qualifier: After initial part, add speeded ms part, not only sm part.
// date:210303  09:27
// author:
//************************************
TEMPLATE
template<typename T, typename T1, typename Y, typename U, typename U1>
void APLA::split_merge_optimization_segments_speed3(U& const input_argument, const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument) {

	/*...................    210304    .........................*/
#ifdef _DEBUG
	typename TOOL::RESULT_RECORD result_record;
	get_sum_deviation_no_ab(original_time_series_vector, doubly_linked_list, result_record);
	assert_endpoint_a_b(original_time_series_vector, doubly_linked_list);
	//cout << "After Initialization: <Sum deviation: " << result_record.sum_deviation << ">. max deviation: "<< result_record.max_deviation << "max deviation width: "<< result_record.max_deviation_multiple_width << "  <Sum upper bound: " << get_sum_upper_bound(doubly_linked_list) << endl;
	long double min_sum_dev = INF;
#endif
	/*..........................................................*/

	/*############################################################# Split & Merge Operation == N ########################################################*/
	/*===========================================  Split Iteration  =====================================*/
	while (doubly_linked_list.size() < input_argument.point_dimension) {
		/*................................................................................................................*/

		/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     191124 for burst time series   ^^^^^^^^^^^^^^^^^^^^^^^^*/
		if (split_area_difference_map.size() == 0) {
			//assert(0);
			assert(input_argument.point_dimension != INF);
			/*--------- split burst ----------*/
			split_burst_segment(original_time_series_vector, input_argument.point_dimension, doubly_linked_list);
			/*--------------------------------*/
			/*...................    210304    .........................*/
#ifdef _DEBUG
			assert_endpoint_a_b(original_time_series_vector, doubly_linked_list);
#endif
			/*..........................................................*/

			break;
		}
		/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

		/*................................................................................................................*/

		/*---------------------------------------               Split Operation         ---------------------------------------*/
		splitSegmentBySlope(original_time_series_vector, input_argument.option_split_method, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
		/*---------------------------------------------------------------------------------------------------------------------*/

		/*...................    210304    .........................*/
#ifdef _DEBUG
		//min_sum_dev = get_sum_deviation_no_ab(original_time_series_vector, doubly_linked_list);
		//cout << "After Split: <Sum deviation: " << min_sum_dev << ">.    <Sum upper bound: " << get_sum_upper_bound(doubly_linked_list) << endl;
#endif
		/*..........................................................*/
	}
	/*===================================================================================================*/
	/*===========================================  Merge Iteration  =====================================*/
	while (doubly_linked_list.size() > input_argument.point_dimension) {
		mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
		/*...................210304.........................*/
#ifdef _DEBUG
		//min_sum_dev = get_sum_deviation_no_ab(original_time_series_vector, doubly_linked_list);
		//cout << "After Merge: <Sum deviation: " << min_sum_dev << ">.    <Sum upper bound: " << get_sum_upper_bound(doubly_linked_list) << endl;
#endif
		/*..................................................*/
	}
	/*===================================================================================================*/
	/*###################################################################################################################################################*/

	/*..................................................................................................................*/
#ifdef _DEBUG
	size_t ms_count = 0;
	std::priority_queue<long double, std::vector<long double>, std::greater<long double>> q_sum_small;
	q_sum_small.emplace(min_sum_dev);
	assert(doubly_linked_list.size() == input_argument.point_dimension);
	//assert_minmax_value(original_time_series_vector, doubly_linked_list);
	assert_bound(original_time_series_vector, doubly_linked_list);
	assert_merge_map_triangle_density(merge_segment_density_map);

	/*::::::::::::::::::::::::::::::     201217 Find Example      :::::::::::::::::::::::::::::::::::::*/
	//vector<T> reconstruct_time_series_vector;
	//vector<int> initial_right_endpoint_vector;
	//for (auto&& au : doubly_linked_list) {
	//	initial_right_endpoint_vector.emplace_back(au.right_endpoint);
	//}
	//DoublyLinkedList<Y> temp_doubly_linked_list = DoublyLinkedList<Y>();
	//temp_doubly_linked_list.copy(doubly_linked_list);
	//multimap<T1, DoublyListNode<Y>&, greater<T1>> temp_merge_segment_density_map;
	//multimap<T1, DoublyListNode<Y>&, greater<T1>> temp_split_area_difference_map;
	//
	///*----------------     Print linked list  ----------------*/
	//cout << "-------------------------------------------------------- \n 4 After Initialization:  segment coefficients: \n";
	//TOOL::print_each_segment_coefficient(doubly_linked_list);
	///*--------------------------------------------------------*/

	///*---------    200907 get reconstruct time series   ------------------------*/
	//getAPLAReconstructSeries(doubly_linked_list, reconstruct_time_series_vector);
	//cout << "\n5 After Initialization: Reconstruct time series:";
	//TOOL::print_vector(reconstruct_time_series_vector);
	///*--------------------------------------------------------------------------*/

	///*----------------------------------------------------------------------*/
	//cout << "6 After Initialization: reconstructed endpoint id: 0,";
	//for (auto au : doubly_linked_list) {
	//	if (au.right_endpoint == reconstruct_time_series_vector.size() - 1)
	//		cout << au.right_endpoint;
	//	else
	//		cout << au.right_endpoint << "," << au.right_endpoint + 1 << ",";
	//}
	//cout << "\n6 After Initialization: reconstructed endpoint value:" << reconstruct_time_series_vector[0] << ",";
	//for (auto au : doubly_linked_list) {
	//	if (au.right_endpoint == reconstruct_time_series_vector.size() - 1)
	//		cout << reconstruct_time_series_vector[au.right_endpoint];
	//	else
	//		cout << reconstruct_time_series_vector[au.right_endpoint] << "," << reconstruct_time_series_vector[au.right_endpoint + 1] << ",";
	//}
	//cout << endl;
	///*----------------------------------------------------------------------*/

	///*---------  get a&b of every segment & get sum deviation & get reconstruction time series  ------*/
	////getAPLA(input_argument, original_time_series, doubly_linked_list);
	///*long double sum_deviation = get_sum_deviation_no_ab(original_time_series_vector, doubly_linked_list);
	//output_argument.sum_deviation = sum_deviation;*/
	//output_argument.sum_deviation = get_sum_deviation_no_ab(original_time_series_vector, doubly_linked_list, result_record);
	//cout << "\n7### After Initialization: sum deviation: " << result_record.sum_deviation << endl;
	//cout << "7 After Initialization: max deviation: " << result_record.max_deviation << endl;
	//cout << "7 After Initialization: max deviation av: " << result_record.max_deviation_av << endl;
	//cout << "7 After Initialization: max width deviation: " << result_record.max_deviation_multiple_width << endl;
	///*------------------------------------------------------------------------------------------------*/
	//input_argument.is_MS_effect = false;
	//if ( result_record.max_deviation_av >= output_argument.max_deviation_av_icde07) {
	//	//if (result_record.max_deviation >= output_argument.max_deviation_icde07) {
	////if (result_record.sum_deviation >= output_argument.sum_deviation_icde07 || result_record.max_deviation >= output_argument.max_deviation_icde07) {
	//	input_argument.is_MS_effect = false;
	//}
	//else {
	//	input_argument.is_MS_effect = true;
	//	output_argument.sum_deviation = result_record.sum_deviation;
	//	output_argument.max_deviation = result_record.max_deviation;
	//	output_argument.max_deviation_av = result_record.max_deviation_av;
	//	//assert(0);
	//}

	//reconstruct_time_series_vector.clear();
	//reconstruct_time_series_vector.shrink_to_fit();
	/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
#endif
	/*....................................................................................................................*/

	if (split_area_difference_map.empty()) return;
	bool should_change = true;

	while (should_change) {

		/*..................................................................................................*/
#ifdef _DEBUG
		//evaluate right point, min&max point, width. a&b, sum value
		assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
		assert_split_map_area_difference(split_area_difference_map);
		/*::::::::::::::::::::     201217 Find Example      ::::::::::::::::::::::::::*/
		/*getAPLAReconstructSeries(doubly_linked_list, reconstruct_time_series_vector);
		cout << "\n8 After Merge: Reconstruct time series:";
		TOOL::print_vector(reconstruct_time_series_vector);
		reconstruct_time_series_vector.clear();
		reconstruct_time_series_vector.shrink_to_fit();*/
		/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
#endif
		/*..................................................................................................*/

		/*----------------------       Whether MAP Empty      ----------------------*/
		// If MAP is empty, no need to split
		if (split_area_difference_map.empty()) break;
		/*---------------------------------------------------------------------------*/
		/*=====================      Split Node, Merge Node         ======================*/
		DoublyListNode<Y>* splited_node_original;
		Y* splited_node_segment_original;
		auto& const splited_node_original1 = split_area_difference_map.begin()->second;
		auto& const splited_node_segment_original1 = splited_node_original1._value;

		splited_node_original = &splited_node_original1;
		splited_node_segment_original = &splited_node_segment_original1;

		DoublyListNode<Y>* merged_node_original;
		Y* merged_node_segment_original;
		auto& const merged_node_original1 = merge_segment_density_map.begin()->second;
		auto& const merged_node_segment_original1 = merged_node_original1._value;
		merged_node_original = &merged_node_original1;
		merged_node_segment_original = &merged_node_segment_original1;
		/*================================================================================*/

		/*............................................................................................................................*/
#ifdef _DEBUG
		assert(merged_node_original->_prev->_value.area_difference != INF && merged_node_segment_original->area_difference != INF && splited_node_segment_original->rectangle_width > 3);
		assert(merged_node_segment_original->right_subsegment != nullptr && merged_node_segment_original->apla.a != INF && merged_node_segment_original->apla.b != INF && merged_node_segment_original->right_endpoint != INF && merged_node_segment_original->rectangle_width != INF);

		find_if_in_multimap(splited_node_segment_original->area_difference, split_area_difference_map);
		if (splited_node_original->_prev) { find_if_in_multimap(splited_node_segment_original->right_subsegment->segment_density, merge_segment_density_map); }
		if (splited_node_original->_next) { find_if_in_multimap(splited_node_original->_next->_value.right_subsegment->segment_density, merge_segment_density_map); }
		if (merged_node_original->_prev->_value.area_difference > 0 && merged_node_original->_prev->_value.rectangle_width > 3) { find_if_in_multimap(merged_node_original->_prev->_value.area_difference, split_area_difference_map); }
		if (merged_node_original->_prev->_prev) { find_if_in_multimap(merged_node_original->_prev->_value.right_subsegment->segment_density, merge_segment_density_map); }
		if (merged_node_segment_original->area_difference > 0 && merged_node_segment_original->rectangle_width > 3) { find_if_in_multimap(merged_node_segment_original->area_difference, split_area_difference_map); }
		find_if_in_multimap(merged_node_segment_original->right_subsegment->segment_density, merge_segment_density_map);
		if (merged_node_original->_next) { find_if_in_multimap(merged_node_original->_next->_value.right_subsegment->segment_density, merge_segment_density_map); }

		assert(splited_node_segment_original->area_difference > 0 && splited_node_segment_original->area_difference != INF && splited_node_segment_original->right_subsegment != nullptr);
		assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
		/*............................................................................................................................*/
		if(splited_node_segment_original->is_split)
		for (auto it = split_area_difference_map.begin(); it != split_area_difference_map.end(); it++){
			if (!it->second._value.is_split) {
				auto& const splited_node_original2 = it->second;
				auto& const splited_node_segment_original2 = splited_node_original2._value;
				splited_node_original = &splited_node_original2;
				splited_node_segment_original = &splited_node_segment_original2;
				break;
			}
		}

		if (merged_node_segment_original->is_merge)
			for (auto it = merge_segment_density_map.begin(); it != merge_segment_density_map.end(); it++) {
				if (!it->second._value.is_merge) {
					auto& const merged_node_original2 = it->second;
					auto& const merged_node_segment_original2 = merged_node_original2._value;
					merged_node_original = &merged_node_original2;
					merged_node_segment_original = &merged_node_segment_original2;
					break;
				}
			}

		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&   For Split & Merge,  Find Split point in Candidate Node   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
		//sub left segemnt
		DoublyListNode<Y>* node_sub_left_new = new DoublyListNode<Y>;
		Y& const sub_left_segment = node_sub_left_new->_value;

		Y sub_right_segment;
		//*sub_right_segment.right_subsegment = splited_node_segment_original;
		sub_right_segment = *splited_node_segment_original;
		sub_right_segment.right_subsegment = new Y;
		*sub_right_segment.right_subsegment = sub_right_segment;

		const int split_method_option = 0;
		sub_left_segment.right_endpoint = group_find_split_point_methods(original_time_series_vector, split_method_option, sub_left_segment, sub_right_segment, *sub_right_segment.right_subsegment, output_argument);
		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
		/*........................................................................................*/
#ifdef _DEBUG
		assert(sub_left_segment.right_endpoint > 0 && sub_left_segment.right_endpoint < sub_right_segment.right_endpoint);
		assert(sub_left_segment.rectangle_width + sub_right_segment.rectangle_width == splited_node_segment_original->rectangle_width);
		assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
		/*........................................................................................*/
		// Has split point, begin to split segment
		if (sub_left_segment.right_endpoint == INF) break;

		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&  210301 For Merge & Split,  Find Split point in Candidate Node   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
		//long double area_difference_original_ms = INF;
		//long double area_difference_upper_bound_ms = INF;
		long double differece_merge_split = -INF;
		long double difference_split_merge = -INF;
		//Y sub_left_segment_ms;
		//Y sub_right_segment_ms;
		//size_t merge_split_type = 0;
		//if (merged_node_segment_original.right_subsegment->area_difference <= splited_node_segment_original.area_difference && splited_node_segment_original.right_endpoint != merged_node_original._prev->_value.right_endpoint && splited_node_segment_original.right_endpoint != merged_node_segment_original.right_endpoint) {// merged node is not split node
			//merge_split_type = 1;
			//area_difference_original_ms = merged_node_original._prev->_value.area_difference + merged_node_segment_original.area_difference + splited_node_segment_original.area_difference;
			//area_difference_upper_bound_ms = merged_node_segment_original.right_subsegment->area_difference + sub_left_segment.area_difference + sub_right_segment.area_difference;
			//differece_merge_split = merged_node_original._prev->_value.area_difference + merged_node_segment_original.area_difference + splited_node_segment_original.area_difference - merged_node_segment_original.right_subsegment->area_difference - sub_left_segment.area_difference - sub_right_segment.area_difference;
		//}
		//else {//merged node is split node
		//	merge_split_type = 2;
		//	sub_right_segment_ms.right_subsegment = new Y;
		//	*sub_right_segment_ms.right_subsegment = *merged_node_segment_original.right_subsegment;
		//	sub_left_segment_ms.right_endpoint = group_find_split_point_methods(original_time_series_vector, split_method_option, sub_left_segment_ms, sub_right_segment_ms, *sub_right_segment_ms.right_subsegment, output_argument);
		//	area_difference_original_ms = merged_node_original._prev->_value.area_difference + merged_node_segment_original.area_difference;
		//	area_difference_upper_bound_ms = sub_left_segment_ms.area_difference + sub_right_segment_ms.area_difference;
		//	differece_merge_split = area_difference_original_ms - area_difference_upper_bound_ms;
		//}
		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

		/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Has Spilt Point    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

		/*&&&&&&&&&&&&&&&&&&&&&&&    After Split. Coefficients of  1 sub left node, 2 sub right node, 3 split original right node    &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
		sub_left_segment.right_subsegment = new Y;
		/*++++++++++++++++++++++      After Split. Density of  1 sub left node,  2 sub right node,  3 split original right node      +++++++++++++++++++++++++++*/
		multimap<T1, Y&, greater<T1>> temp_new_merge_segment_density_3_map;
		/*==========================================            Split Sub Left Node: Density          =============================================*/
		if (splited_node_original->_prev) {//middle node
			/*--------------------------             Density: long left segment & sub left segment                 -------------------------------*/
			getMergedSubSegmentInformation(original_time_series_vector, splited_node_original->_prev->_value, sub_left_segment, *sub_left_segment.right_subsegment, output_argument);//200109 For area difference
			/*------------------------------------------------------------------------------------------------------------------------------------*/
			temp_new_merge_segment_density_3_map.emplace(sub_left_segment.right_subsegment->segment_density, sub_left_segment);
		}
		/*==========================================================================================================================================*/
		/*-------------------------------------      Split Sub Right Node: Density      -----------------------------------*/
		temp_new_merge_segment_density_3_map.emplace(sub_right_segment.right_subsegment->segment_density, sub_right_segment);
		/*-----------------------------------------------------------------------------------------------------------------*/
		/*==========================================       new Split Original Right Node: Density      =============================================*/
		/*------ split original right node ---*/
		Y long_right_segment;
		/*------------------------------------*/
		if (splited_node_original->_next) {//middle node
			long_right_segment = splited_node_original->_next->_value;
			long_right_segment.right_subsegment = new Y;
			getMergedSubSegmentInformation(original_time_series_vector, sub_right_segment, long_right_segment, *long_right_segment.right_subsegment, output_argument);//200109 For area difference
			temp_new_merge_segment_density_3_map.emplace(long_right_segment.right_subsegment->segment_density, long_right_segment);
		}
		/*==========================================================================================================================================*/
		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*.........................................................*/
#ifdef _DEBUG
		if (doubly_linked_list.size() > 1) {
			assert(!merge_segment_density_map.empty());
		}
		else if (doubly_linked_list.size() == 1) {
			assert(merge_segment_density_map.empty());
			break;
		}
		assert_split_map_area_difference(split_area_difference_map);
#endif
		/*.........................................................*/

		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

		/*Begin to Merge, when splited segment density > original max density in map. original merged segment is splited segment or split original right segment*/
		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&        candidate merge segment overlap with candidate splited segments      &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
		if (temp_new_merge_segment_density_3_map.begin()->first >= merge_segment_density_map.begin()->first || merged_node_segment_original->right_endpoint == sub_right_segment.right_endpoint || merged_node_segment_original->right_endpoint == long_right_segment.right_endpoint) {

			//auto& const merged_node = temp_split_3_area_difference_map.begin()->second;
			auto& const merged_segment_candidate = temp_new_merge_segment_density_3_map.begin()->second;

			/*++++++++++++++++++++++++++++++++++++++++           candidate merge segment == sub left segment          ++++++++++++++++++++++++++++++++++++++++*/
			if (merged_segment_candidate.right_endpoint == sub_left_segment.right_endpoint) {//Make sure has left node, not head node.

				//if (splited_node_original._prev->_value.area_difference + splited_node_original._value.area_difference <= sub_left_segment.right_subsegment->area_difference + sub_right_segment.area_difference) should_change = false;
				difference_split_merge = splited_node_original->_prev->_value.area_difference + splited_node_original->_value.area_difference - sub_left_segment.right_subsegment->area_difference - sub_right_segment.area_difference;
				differece_merge_split = -INF;
				if (merged_node_segment_original->right_subsegment->area_difference <= splited_node_segment_original->area_difference && splited_node_segment_original->right_endpoint != merged_node_original->_prev->_value.right_endpoint && splited_node_segment_original->right_endpoint != merged_node_segment_original->right_endpoint) {// merged node is not split node
					differece_merge_split = merged_node_original->_prev->_value.area_difference + merged_node_segment_original->area_difference + splited_node_segment_original->area_difference - merged_node_segment_original->right_subsegment->area_difference - sub_left_segment.area_difference - sub_right_segment.area_difference;
				}

				/*======================= Compare sm or ms=========================*/
				if (difference_split_merge <= 0 && differece_merge_split <= 0) {
					should_change = false;
					break;
				}
				else if (difference_split_merge > differece_merge_split) {// first split, second merge
					should_change = update_list_map_sub_left_is_merge(original_time_series_vector, merge_segment_density_map, split_area_difference_map, *splited_node_original, sub_left_segment, sub_right_segment, long_right_segment, output_argument);
					/*...................210304.........................*/
#ifdef _DEBUG
					/*min_sum_dev = get_sum_deviation_no_ab(original_time_series_vector, doubly_linked_list);
					cout << "After Split & Merge: <Sum deviation: " << min_sum_dev << ">.    <Sum upper bound: " << get_sum_upper_bound(doubly_linked_list) << endl;
					if (q_sum_small.top() > min_sum_dev) {
						ms_count++;
						q_sum_small.emplace(min_sum_dev);
						if (ms_count == 4) assert(0);
					}*/
#endif
					/*..................................................*/
				}
				else if (difference_split_merge <= differece_merge_split) {// first merge, second split. merged node is not split node.
#ifdef _DEBUG
					assert(merged_node_segment_original->right_subsegment->area_difference <= splited_node_segment_original->area_difference && splited_node_segment_original->right_endpoint != merged_node_original->_prev->_value.right_endpoint && splited_node_segment_original->right_endpoint != merged_node_segment_original->right_endpoint);
#endif
					should_change = update_list_map_split_is_not_merge(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, *splited_node_original, *merged_node_original, *node_sub_left_new, sub_right_segment, output_argument);
					/*...................210304.........................*/
#ifdef _DEBUG
					/*min_sum_dev = get_sum_deviation_no_ab(original_time_series_vector, doubly_linked_list);
					cout << "After Merge & Split: <Sum deviation: " << min_sum_dev << ">.    <Sum upper bound: " << get_sum_upper_bound(doubly_linked_list) << endl;
					if (q_sum_small.top() > min_sum_dev) {
						ms_count++;
						q_sum_small.emplace(min_sum_dev);
						if (ms_count == 4) assert(0);
					}*/
#endif
					/*..................................................*/
				}
				else {
					assert(0);
				}
				/*================================================================*/

				/*..................................................*/
#ifdef _DEBUG
				assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
				assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
				/*..................................................*/

				continue;
				/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			}
			else if (merged_segment_candidate.right_endpoint == sub_right_segment.right_endpoint) {//candidate merge segment == sub right segment, split & merge on same node
				should_change = false;
				break;
			}
			else if (merged_segment_candidate.right_endpoint == long_right_segment.right_endpoint) {
				/*+++++++++++++++++++++++++++++++++++            candidate merge segment == Original right segment          ++++++++++++++++++++++++++++++++++++++*/
				/*if (splited_node_original._value.area_difference + splited_node_original._next->_value.area_difference <= sub_left_segment.area_difference + long_right_segment.right_subsegment->area_difference){
					should_change = false;
					break;
				}*/

				difference_split_merge = splited_node_original->_value.area_difference + splited_node_original->_next->_value.area_difference - sub_left_segment.area_difference - long_right_segment.right_subsegment->area_difference;

				differece_merge_split = -INF;
				if (merged_node_segment_original->right_subsegment->area_difference <= splited_node_segment_original->area_difference && splited_node_segment_original->right_endpoint != merged_node_original->_prev->_value.right_endpoint && splited_node_segment_original->right_endpoint != merged_node_segment_original->right_endpoint) {// merged node is not split node
					differece_merge_split = merged_node_original->_prev->_value.area_difference + merged_node_segment_original->area_difference + splited_node_segment_original->area_difference - merged_node_segment_original->right_subsegment->area_difference - sub_left_segment.area_difference - sub_right_segment.area_difference;
				}

				/*======================= Compare sm or ms=========================*/
				if (difference_split_merge <= 0 && differece_merge_split <= 0) {
					should_change = false;
					break;
				}
				else if (difference_split_merge > differece_merge_split) {// first split, second merge
					should_change = update_list_map_original_right_is_merge(original_time_series_vector, merge_segment_density_map, split_area_difference_map, *splited_node_original, sub_left_segment, sub_right_segment, long_right_segment, output_argument);

					/*...................210304.........................*/
#ifdef _DEBUG
					/*min_sum_dev = get_sum_deviation_no_ab(original_time_series_vector, doubly_linked_list);
					cout << "After Split & Merge: <Sum deviation: " << min_sum_dev << ">.    <Sum upper bound: " << get_sum_upper_bound(doubly_linked_list) << endl;
					if (q_sum_small.top() > min_sum_dev) {
						ms_count++;
						q_sum_small.emplace(min_sum_dev);
						if (ms_count == 4) assert(0);
					}*/
#endif
					/*..................................................*/
				}
				else if (difference_split_merge <= differece_merge_split) {// first merge, second split
					/*..................................................*/
#ifdef _DEBUG
					assert(merged_node_segment_original->right_subsegment->area_difference <= splited_node_segment_original->area_difference && splited_node_segment_original->right_endpoint != merged_node_original->_prev->_value.right_endpoint && splited_node_segment_original->right_endpoint != merged_node_segment_original->right_endpoint);
#endif
					/*..................................................*/

					should_change = update_list_map_split_is_not_merge(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, *splited_node_original, *merged_node_original, *node_sub_left_new, sub_right_segment, output_argument);

					/*...................210304.........................*/
#ifdef _DEBUG
					//cout << "After Merge & Split: <Sum deviation: " << min_sum_dev = get_sum_deviation_no_ab(original_time_series_vector, doubly_linked_list) << ">.    <Sum upper bound: " << get_sum_upper_bound(doubly_linked_list) << endl;
					//if (q_sum_small.top() > min_sum_dev) {
					//	ms_count++;
					//	q_sum_small.emplace(min_sum_dev);
					//	if (ms_count == 4) assert(0);
					//}
#endif
					/*..................................................*/
				}
				else {
					assert(0);
				}
				/*==============================================================*/

				/*....................................................................................................................*/
#ifdef _DEBUG
				assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
				assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
				/*....................................................................................................................*/
				continue;
				/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			}
			else {
				assert(0);
			}
		}
		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
		else if (merged_node_segment_original->right_endpoint < sub_left_segment.right_endpoint || merged_node_segment_original->right_endpoint > long_right_segment.right_endpoint) {
			/*+++++++++++++++++++++++++++++++++++++++   Candidate merge segments not related with candidate split segments   +++++++++++++++++++++++++++++++++++++++*/
			/*if (splited_node_original._value.area_difference + merged_node_original._prev->_value.area_difference + merged_node_original._value.area_difference <= node_sub_left_new->_value.area_difference + sub_right_segment.area_difference + merged_node_original._value.right_subsegment->area_difference){
				should_change = false;
				break;
			}*/

			difference_split_merge = splited_node_original->_value.area_difference + merged_node_original->_prev->_value.area_difference + merged_node_original->_value.area_difference - node_sub_left_new->_value.area_difference - sub_right_segment.area_difference - merged_node_original->_value.right_subsegment->area_difference;

			/*======================= Compare sm or ms=========================*/
			if (difference_split_merge <= 0) {
				should_change = false;
				break;
			}
			else {// first split, second merge
				should_change = update_list_map_split_is_not_merge(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, *splited_node_original, *merged_node_original, *node_sub_left_new, sub_right_segment, output_argument);
			}
			/*==============================================================*/
			continue;
		}
		else {
			assert(0);
		}

	}

	/*:::::::::::::::::::::::             Split Merge Operation              :::::::::::::::::::::::::*/
	//splitSegmentBySlope(original_time_series_vector, input_argument.option_split_method, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
	//mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list);
	/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
	//area_difference_sum_new = get_whole_area_difference(doubly_linked_list);
	/*..............................................................................................................................*/
#ifdef _DEBUG
	/*cout << "New sum area difference: " << area_difference_sum_new << endl;
	TOOL::print_each_segment_coefficient(doubly_linked_list);*/
	assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
	//evaluate right point, min&max point, width. a&b, sum value
	assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
	assert_split_map_area_difference(split_area_difference_map);
	//assert_minmax_value(original_time_series_vector, doubly_linked_list);
	assert_bound(original_time_series_vector, doubly_linked_list);
	assert_merge_map_triangle_density(merge_segment_density_map);
	//assert(temp_doubly_linked_list.size() == input_argument.point_dimension);
	//assert(right_endpoint_segment_max_density_merge == right_endpoint_segment_max_area_difference);

	/*:::::::::::::::::::::::    201217     Print linked list          ::::::::::::::::::::::::::::::*/
	///*----------  get a&b of every segment & get sum deviation & get reconstruction time series  -------*/
	//const long double sum_deviation = get_sum_deviation_no_ab(original_time_series_vector, doubly_linked_list);
	//get_sum_deviation_no_ab(original_time_series_vector, doubly_linked_list, result_record);
	///*--------------------------------------------------------------------------------------------------*/

	//int count_same = 0;
	//for (int i = 0; i < initial_right_endpoint_vector.size(); i++) {
	//	if (initial_right_endpoint_vector[i] == doubly_linked_list[i].right_endpoint)
	//		count_same++;
	//}

	//if (!input_argument.is_MS_effect || count_same == initial_right_endpoint_vector.size() || result_record.max_deviation_av >= output_argument.max_deviation_av) {
	////if (!input_argument.is_MS_effect || count_same == initial_right_endpoint_vector.size() || result_record.max_deviation >= output_argument.max_deviation) {
	////if (!input_argument.is_MS_effect || count_same == initial_right_endpoint_vector.size() || result_record.sum_deviation >= output_argument.sum_deviation || result_record.max_deviation >= output_argument.max_deviation) {
	//	input_argument.is_MS_effect = false;
	//}
	//else {
	//	input_argument.is_MS_effect = true;
	//	output_argument.sum_deviation = result_record.sum_deviation;
	//	output_argument.max_deviation = result_record.max_deviation;
	//	output_argument.max_deviation_av = result_record.max_deviation_av;
	//	//assert(0);
	//}

	///*--------------   Print linked list  -------------------*/
	//cout << "---------------------- \n9 After Iteration: segment coefficients: \n";
	//TOOL::print_each_segment_coefficient(doubly_linked_list);
	///*-------------------------------------------------------*/

	///*--------- 201217    200907 get reconstruct time series     ----------------*/
	//getAPLAReconstructSeries(doubly_linked_list, reconstruct_time_series_vector);
	//cout << "\n10 After SM/MS Iteration: Reconstruct time series:";
	//TOOL::print_vector(reconstruct_time_series_vector);
	///*-----------------------------------------------------------------------------*/

	///*----------------------------------------------------------------------*/
	//cout << "11 After  SM/MS Iteration: reconstructed endpoint id: 0,";
	//for (auto au : doubly_linked_list) {
	//	if (au.right_endpoint == reconstruct_time_series_vector.size() - 1)
	//		cout << au.right_endpoint;
	//	else
	//		cout << au.right_endpoint << "," << au.right_endpoint + 1 << ",";
	//}
	//cout << "\n11 After M&S: reconstructed endpoint value:" << reconstruct_time_series_vector[0] << ",";
	//for (auto au : doubly_linked_list) {
	//	if (au.right_endpoint == reconstruct_time_series_vector.size() - 1)
	//		cout << reconstruct_time_series_vector[au.right_endpoint];
	//	else
	//		cout << reconstruct_time_series_vector[au.right_endpoint] << "," << reconstruct_time_series_vector[au.right_endpoint + 1] << ",";
	//}
	//cout << endl;
	///*----------------------------------------------------------------------*/

	//reconstruct_time_series_vector.clear();
	//reconstruct_time_series_vector.shrink_to_fit();

	//cout << "\n12### After  SM/MS Iteration: Sum deviation: " << result_record.sum_deviation << ". max deviation: " << result_record.max_deviation << ". max deviation average: " << result_record.max_deviation_av << ". max deviation width: " << result_record.max_deviation_multiple_width << ".    Sum upper bound: " << get_sum_upper_bound(doubly_linked_list) << endl;
	/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
#endif
	/*.................................................................................................................................*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   Optimization   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	//optimization_segments_loop(input_argument, original_time_series_vector, split_area_difference_map, doubly_linked_list, output_argument);

	//***************201111
	optimization_segments_loop_speed(input_argument, original_time_series_vector, split_area_difference_map, doubly_linked_list, output_argument);

	//doubly_linked_list.swap(temp_doubly_linked_list);
	//evaluate_upper_lower_bound(input_argument, original_time_series_vector, doubly_linked_list);
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
}

//************************************
// Method:split_merge_optimization_segments
// Qualifier: After initial part, Use split&merge&optimization to get tighter approximation
// linked list size <= N
// date:200915 09:56
// author:
//************************************
TEMPLATE
template<typename T, typename T1, typename Y, typename U, typename U1, typename U2>
void APLA::split_merge_optimization_segments(U& const input_argument, const vector<T>& const original_time_series_vector, const U2& const optimization_coefficients, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument) {

	/*..................................................................................................................*/
#ifdef _DEBUG
	assert(doubly_linked_list.size() == input_argument.point_dimension);

	/*++++++++++++++++++++++++   Before MS, the right endpoint of linked list +++++++++++++++++++++++++++*/
	/*vector<int> initial_right_endpoint_vector;
	for (auto&& au : doubly_linked_list) {
		initial_right_endpoint_vector.emplace_back(au.right_endpoint);
	}*/
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
#endif
	/*....................................................................................................................*/

	if (split_area_difference_map.empty()) {
		return;
	}
	else {

		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		long double area_difference_sum_old = INF;
		long double area_difference_sum_new = -INF;
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

		/*+++++++++++++++++++    Candidate split segment is just the latest merged segments    ++++++++++++++++++++++++++++++*/
		DoublyLinkedList<Y> temp_doubly_linked_list = DoublyLinkedList<Y>();
		//multimap<T1, DoublyListNode<Y>&, greater<T1>> temp_merge_segment_density_map;
		multimap<T1, DoublyListNode<Y>&, greater<T1>> temp_split_area_difference_map;


		while (area_difference_sum_old > area_difference_sum_new) {

			area_difference_sum_old = get_whole_area_difference(doubly_linked_list);

			/*..............................................................................................................................*/
#ifdef _DEBUG
			/*cout << "Old sum area difference: "<< area_difference_sum_old  <<endl;
			TOOL::print_each_segment_coefficient(doubly_linked_list);*/
#endif
			/*..............................................................................................................................*/

			/*:::::::::::::::::::::::::::::::::::::::::::::::                  copy of linked list                ::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
			temp_doubly_linked_list.copy(doubly_linked_list);
			//temp_merge_segment_density_map.clear();
			temp_split_area_difference_map.clear();
			//temp_merge_segment_density_map = merge_segment_density_map;
			//temp_split_area_difference_map = split_area_difference_map;

			/*==========================================         Update Temp MAP: Split & Merge      ==========================================*/
			for (int id_node = 0; id_node < temp_doubly_linked_list.size(); id_node++) {

				/**************************    reference node and value in linkedlist    ******************************/
				auto& const node_segment_current = temp_doubly_linked_list.getNode(id_node);
				auto& const value_segment_current = node_segment_current._value;
				/******************************************************************************************************/

				/*.................................................................................................................................*/
#ifdef _DEBUG
				Y test_splitted_segment = value_segment_current;
				get_ab_segment(original_time_series_vector, test_splitted_segment);
				assert_two_segments_a_b(test_splitted_segment, value_segment_current);
				assert_segment_a_b(value_segment_current);
				assert_segment_a_b_minmax(original_time_series_vector, value_segment_current);
				assert(value_segment_current.area_difference != INF);
				assert(value_segment_current.right_subsegment != nullptr && value_segment_current.apla.a != INF && value_segment_current.apla.b != INF && value_segment_current.right_endpoint != INF && value_segment_current.rectangle_width != INF);
#endif
				/*.....................................................................................................................................................*/

				/******************************           Get Area difference           *******************************************/
				//if (value_segment_current.rectangle_width > 2) {
				temp_split_area_difference_map.emplace(getAreaDifference(original_time_series_vector, value_segment_current), node_segment_current);
				//}

				//temp_merge_segment_density_map.emplace(value_segment_current.right_subsegment->segment_density, node_segment_current);
				/******************************************************************************************************************/
			}
			/*======================================================================================================================*/
			/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

			/*:::::::::::::::::::::::             Split Merge Operation              :::::::::::::::::::::::::*/
			splitSegmentBySlope(original_time_series_vector, input_argument.option_split_method, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);

			/*..............................................................................................................................*/
#ifdef _DEBUG
			/*&&&&&&&&&&&&&&&&&&&&&&&&    200907 get reconstruct time series      &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
			/*vector<T> reconstruct_time_series_vector;
			getAPLAReconstructSeries(doubly_linked_list, reconstruct_time_series_vector);
			cout << "After Split : Reconstruct time series:";
			TOOL::print_vector(reconstruct_time_series_vector);*/
			/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
#endif
			/*..............................................................................................................................*/

			mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list);

			/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

			area_difference_sum_new = get_whole_area_difference(doubly_linked_list);

			/*..............................................................................................................................*/
#ifdef _DEBUG
			/*&&&&&&&&&&&&&&&&&&&&&&&&    200907 get reconstruct time series      &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
			/*getAPLAReconstructSeries(doubly_linked_list, reconstruct_time_series_vector);
			cout << "After Merge: Reconstruct time series:";
			TOOL::print_vector(reconstruct_time_series_vector);*/
			/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

			/*cout << "New sum area difference: " << area_difference_sum_new << endl;
			TOOL::print_each_segment_coefficient(doubly_linked_list);*/
			assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
#endif
			/*..............................................................................................................................*/

		}
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

		/*.................................................................................................................................*/
#ifdef _DEBUG
		assert(temp_doubly_linked_list.size() == input_argument.point_dimension);
		//assert(right_endpoint_segment_max_density_merge == right_endpoint_segment_max_area_difference);

		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&           Print linked list          &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

		//cout << "After MS segment coefficients: \n";
		//TOOL::print_each_segment_coefficient(temp_doubly_linked_list);
		//int count_same = 0;
		//for (int i = 0; i < initial_right_endpoint_vector.size(); i++) {
		//	if (initial_right_endpoint_vector[i] == temp_doubly_linked_list[i].right_endpoint) {
		//		count_same++;
		//	}
		//}
		//if (count_same == initial_right_endpoint_vector.size()) {
		//	input_argument.is_MS_effect = false;
		//}
		//else {
		//	input_argument.is_MS_effect = true;
		//	//assert(0);
		//}

		//vector<T> reconstruct_time_series_vector;

		///*###################################           Print linked list          ###########################*/
		//cout << "After MS segment coefficients: \n";
		//TOOL::print_each_segment_coefficient(temp_doubly_linked_list);
		///*####################################################################################################*/

		///*#############################    200907 get reconstruct time series      ###########################*/
		//getAPLAReconstructSeries(temp_doubly_linked_list, reconstruct_time_series_vector);
		//cout << "Reconstruct time series:";
		//TOOL::print_vector(reconstruct_time_series_vector);
		//reconstruct_time_series_vector.clear();
		//reconstruct_time_series_vector.shrink_to_fit()
		///*####################################################################################################*/

		///*######  get a&b of every segment & get sum deviation & get reconstruction time series  ######*/
	 //   //getAPLA(input_argument, original_time_series, doubly_linked_list);
		//long double sum_deviation = get_sum_deviation_no_ab(original_time_series_vector, temp_doubly_linked_list);
		//cout << "After MS sum deviation: " << sum_deviation << endl;
		///*#############################################################################################*/

		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
#endif
		/*.................................................................................................................................*/

		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   Optimization   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		optimization_segments_loop(input_argument, original_time_series_vector, temp_split_area_difference_map, temp_doubly_linked_list, output_argument);
		doubly_linked_list.swap(temp_doubly_linked_list);
		//evaluate_upper_lower_bound(input_argument, original_time_series_vector, doubly_linked_list);
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	}
}

//************************************
// Method:get_SAPLA_by_one_line_or_two_points
// Qualifier: After initial part, add speeded ms part, not only sm part.
// date:210307  16:03
// author:
//************************************
TEMPLATE
template <typename T, typename T1, typename Y, typename U, typename U1>
void APLA::get_SAPLA_by_one_line_or_two_points(U& const input_argument, const vector<T>& const original_time_series_vector, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument) {

	size_t approximation_type = 0;// 0 one line, 1 two points
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   Create initial elements  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	Y current_segment, accumulate_segment;
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	current_segment.right_endpoint = 1;
	current_segment.rectangle_width = accumulate_segment.right_endpoint = 2;
	getAandBSlopInterceptTwoPoint(original_time_series_vector.front(), original_time_series_vector[1], current_segment);
	accumulate_segment.rectangle_width = accumulate_segment.right_endpoint + 1;
	/*------------   210113 upper bound   -----------------*/
	current_segment.area_difference = current_segment.bound.upper_bound_diff = current_segment.bound.upper_bound_area = 0;
	/*-----------------------------------------------------*/
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	switch (approximation_type) {//0 one line, 1 two points
	case 0: {// one line
		while (current_segment.right_endpoint < original_time_series_vector.size() - 1) {
			/*========================================   compute a&b, upper bound of segment    ======================================================*/
			/*-------------------------------------------------------------------------------------------------------------*/
			get_ab_minmax_segment_by_accumulation(original_time_series_vector[accumulate_segment.right_endpoint], current_segment, accumulate_segment);
			/*-------------------------------------------------------------------------------------------------------------*/
			/*------------ 210113 compute upper bound -------------*/
			get_line_segment_height_diference_from_accumulate(original_time_series_vector, current_segment, accumulate_segment, output_argument);
			/*-----------------------------------------------------*/
			/*..................................................*/
#ifdef _DEBUG
			/*cout << "current segment coefficients: \n";
			print_segment_coefficients(current_segment);
			cout << "Increment segment coefficients: \n";
			print_segment_coefficients(accumulate_segment);*/
			assert_segment_bound(original_time_series_vector, current_segment);
			assert_segment_bound(original_time_series_vector, accumulate_segment);
#endif
			/*..................................................*/
			/*=====================================================================================================================================*/

			current_segment = accumulate_segment;
			accumulate_segment.right_endpoint = current_segment.right_endpoint + 1;
			accumulate_segment.rectangle_width = current_segment.rectangle_width + 1;
		}

		/****************    when accumulate segment right_endpiont is the last point in time series     *************************/
		/*..................................................*/
#ifdef _DEBUG
		assert(accumulate_segment.right_endpoint == original_time_series_vector.size());
#endif
		/*..................................................*/
		//current_segment = accumulate_segment;
		insert_last_segment_compute_merge_split_coefficients(original_time_series_vector, current_segment, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
		/************************************************************************************************************************/

		/*===========================================  Split Iteration  =====================================*/
		while (doubly_linked_list.size() < input_argument.point_dimension) {
			/*................................................................................................................*/
#ifdef _DEBUG
			/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     191124 for burst time series   ^^^^^^^^^^^^^^^^^^^^^^^^*/
			if (split_area_difference_map.size() == 0) {
				assert(0);
				assert(input_argument.point_dimension != INF);
				/*------------------------------------ split burst ------------------------------------*/
				split_burst_segment(original_time_series_vector, input_argument.point_dimension, doubly_linked_list);
				/*-------------------------------------------------------------------------------------*/
				break;
			}
			/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#endif
		/*................................................................................................................*/

			/*---------------------------------------               Split Operation         ---------------------------------------*/
			splitSegmentBySlope(original_time_series_vector, input_argument.option_split_method, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
			/*---------------------------------------------------------------------------------------------------------------------*/

			/*...................    210304    .........................*/
#ifdef _DEBUG
			cout << "After Split: <Sum deviation: " << get_sum_deviation_no_ab(original_time_series_vector, doubly_linked_list) << ">.    <Sum upper bound: " << get_sum_upper_bound(doubly_linked_list) << endl;
#endif
			/*..........................................................*/
		}
		/*===================================================================================================*/

		break;
	}
	case 1: {// two points

		while (current_segment.right_endpoint < original_time_series_vector.size()) {
			/*========================================   compute a&b, upper bound of segment    ======================================================*/
			/*..................................................*/
#ifdef _DEBUG
			/*cout << "current segment coefficients: \n";
			print_segment_coefficients(current_segment);
			cout << "Increment segment coefficients: \n";
			print_segment_coefficients(accumulate_segment);*/
			assert_segment_bound(original_time_series_vector, current_segment);
#endif
			/*..................................................*/
			/*=====================================================================================================================================*/

			insert_last_segment_compute_merge_split_coefficients(original_time_series_vector, current_segment, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);

			/********************************************** new twe points segment *********************************************************************/
			current_segment.right_endpoint += 2;
			current_segment.rectangle_width = 2;
			//current_segment.segment_right_height_difference = 0;
			current_segment.area_difference = current_segment.bound.upper_bound_diff = current_segment.bound.upper_bound_area = 0;
			//get_segment_two_points_ab_minmax(original_time_series_vector[current_segment.right_endpoint - 1], original_time_series_vector[current_segment.right_endpoint], current_segment);
			getAandBSlopInterceptTwoPoint(original_time_series_vector[current_segment.right_endpoint - 1], original_time_series_vector[current_segment.right_endpoint], current_segment);
			/*******************************************************************************************************************************************/
		}
		/*................................................................................*/
#ifdef _DEBUG
		assert(doubly_linked_list.back().right_endpoint == original_time_series_vector.size() - 1);
#endif
		/*................................................................................*/

		/*===========================================  Merge Iteration  =====================================*/
		while (doubly_linked_list.size() > input_argument.point_dimension) {
			mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
			/*...................210304.........................*/
#ifdef _DEBUG
			cout << "After Merge: <Sum deviation: " << get_sum_deviation_no_ab(original_time_series_vector, doubly_linked_list) << ">.    <Sum upper bound: " << get_sum_upper_bound(doubly_linked_list) << endl;
#endif
			/*..................................................*/
		}
		/*===================================================================================================*/

		break;
	}
	default:
		assert(0);
	}

	/*.........................................................................................*/
#ifdef _DEBUG
	assert(doubly_linked_list.back().right_endpoint == original_time_series_vector.size() - 1);//&& doubly_linked_list.size() == input_argument.point_dimension);
	//assert_minmax_value(original_time_series_vector, doubly_linked_list);
	assert_bound(original_time_series_vector, doubly_linked_list);
	assert_split_map_area_difference(split_area_difference_map);
#endif
	/*........................................................................................*/
}

//*****************************************************
// Method:initial_SAPLA_200706
// Qualifier: initial represent original time series
// 190918 Use Linded list
// compute right endpoint, width, a&b and minmax point
// date:200707 07:39
// author:
//*****************************************************
TEMPLATE
template<typename T, typename Y, typename U, typename U1>
void APLA::initial_SAPLA_200706(U& const input_argument, const vector<T>& const original_time_series_vector, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument) {

	/*................................................................................*/
#ifdef _DEBUG
	assert(input_argument.time_series_length == original_time_series_vector.size());
	//assert(output_argument.coefficents_split_id.local_split_time != INF && output_argument.coefficents_split_id.local_split_sum_deviation != INF && output_argument.coefficents_split_id.local_split_shift_abs != INF);
#endif
	/*................................................................................*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!    compute segment length and last remainder   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	multimap<long double, DoublyListNode<Y>& const, greater<long double>> split_area_difference_map;// area difference, node*
	multimap<long double, DoublyListNode<Y>&, greater<long double>> merge_segment_density_map;// long segment merged information, node*
	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/*div_t div_result = div(input_argument.time_series_length, input_argument.point_dimension);
	const auto& const segment_length_average = div_result.quot;
	const auto& const remainder = div_result.rem;*/
	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/*++++++++++++++++++++++++++++++++++++++*/
	//Y current_segment, accumulate_segment;
	/*++++++++++++++++++++++++++++++++++++++*/
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!              Initial Part              !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	//current_segment.right_endpoint = 1;
	//current_segment.rectangle_width = accumulate_segment.right_endpoint = 2;
	//getAandBSlopInterceptTwoPoint(original_time_series_vector.front(), original_time_series_vector[1], current_segment);
	//get_segment_two_point_minmax(original_time_series_vector.front(), original_time_series_vector[1], current_segment);
	//get_segment_two_points_ab_minmax(original_time_series_vector.front(), original_time_series_vector[1], current_segment);
	//accumulate_segment.rectangle_width = accumulate_segment.right_endpoint + 1;
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!              Loop Part                !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	//loop_to_get_split_point(original_time_series_vector, current_segment, accumulate_segment, next_two_points_segment, doubly_linked_list);
	/*+++++++++++++++++++++++++++++++++++++++++++++        accumulate loop: increment area          +++++++++++++++++++++++++++++++++++++*/
	//get_right_endpoint_by_accumulation_area(input_argument, original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);

	//210301
	/***********************************************/
	get_right_endpoint_by_accumulation_area_no_split_merge(input_argument, original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
	/***********************************************/

	/*############################################################                one line time series         #####################################################################*/
	if (doubly_linked_list.size() == 1) {
		//assert(0);
		//return;
		/*..................................................................................................................*/
#ifdef _DEBUG
		assert(merge_segment_density_map.empty());
#endif
		/*..................................................................................................................*/

		y_projection_merge_line(input_argument, original_time_series_vector, doubly_linked_list);

		return;
	}
	/*##############################################################################################################################################################################*/

	//210308 one line or two points
	//get_SAPLA_by_one_line_or_two_points(input_argument, original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
	//210301
	//get_right_endpoint_by_accumulation_area_no_split_merge_threshold(input_argument, original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
	//cout << "Latest merged right endpoint : " << optimization_coefficients.right_endpoint_last_merged_segment << endl;
	//evaluate_upper_lower_bound(input_argument, original_time_series_vector, doubly_linked_list);
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*.........................................................................................*/
#ifdef _DEBUG
	assert(doubly_linked_list.back().right_endpoint == original_time_series_vector.size() - 1);//&& doubly_linked_list.size() == input_argument.point_dimension);
	//assert_minmax_value(original_time_series_vector, doubly_linked_list);
	assert_bound(original_time_series_vector, doubly_linked_list);
	assert_endpoint_a_b(original_time_series_vector, doubly_linked_list);
	//get_apla_coefficients_segment(temp_segemnt);
	/*:::::::::::::::::::::::::::::::: 201217 Find Example ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
	//vector<T> reconstruct_time_series_vector;
	///*----------------     Print linked list  ----------------*/
	//cout << "-------------------------------------------------------- \n 4 After Initialization:  segment coefficients: \n";
	//TOOL::print_each_segment_coefficient(doubly_linked_list);
	///*--------------------------------------------------------*/

	///*---------    200907 get reconstruct time series   ------------------------*/
	//getAPLAReconstructSeries(doubly_linked_list, reconstruct_time_series_vector);
	//cout << "\n5 After Initialization: Reconstruct time series:";
	//TOOL::print_vector(reconstruct_time_series_vector);
	//
	///*--------------------------------------------------------------------------*/

	///*----------------------------------------------------------------------*/
	//cout << "6 After Initialization: reconstructed endpoint id: 0,";
	//for (auto au : doubly_linked_list) {
	//	if (au.right_endpoint == reconstruct_time_series_vector.size() - 1)
	//		cout << au.right_endpoint;
	//	else
	//		cout << au.right_endpoint << "," << au.right_endpoint + 1 << ",";
	//}
	//cout << "\n6 After Initialization: reconstructed endpoint value:" << reconstruct_time_series_vector[0]<<",";
	//for (auto au : doubly_linked_list) {
	//	if (au.right_endpoint == reconstruct_time_series_vector.size() - 1)
	//		cout << reconstruct_time_series_vector[au.right_endpoint];
	//	else
	//		cout << reconstruct_time_series_vector[au.right_endpoint] << "," << reconstruct_time_series_vector[au.right_endpoint + 1] << ",";
	//}
	//cout << endl;
	///*----------------------------------------------------------------------*/

	///*---------  get a&b of every segment & get sum deviation & get reconstruction time series  ------*/
	////getAPLA(input_argument, original_time_series, doubly_linked_list);
	///*long double sum_deviation = get_sum_deviation_no_ab(original_time_series_vector, doubly_linked_list);
	//output_argument.sum_deviation = sum_deviation;*/
	//typename TOOL::RESULT_RECORD result_record;
	//output_argument.sum_deviation = get_sum_deviation_no_ab(original_time_series_vector, doubly_linked_list, result_record);
	//cout << "\n7 After Initialization: sum deviation: " << result_record.sum_deviation << endl;
	//cout << "\n7 After Initialization: max deviation: " << result_record.max_deviation << endl;
	//cout << "\n7 After Initialization: max width deviation: " << result_record.max_deviation_multiple_width << endl;
	///*------------------------------------------------------------------------------------------------*/
	//reconstruct_time_series_vector.clear();
	//reconstruct_time_series_vector.shrink_to_fit();
	/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
#endif
	/*...................................................................................*/


	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  200915  Splie & Merge & Optimization      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	//200915 After initial part, Use split&merge&optimization to get tighter approximation
	//split_merge_optimization_segments(input_argument, original_time_series_vector, optimization_coefficients, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
	//201111
	//split_merge_optimization_segments_speed(input_argument, original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
	//210203 the same with 1, origianl model
	//split_merge_optimization_segments_speed0(input_argument, original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
	//210102
	//split_merge_optimization_segments_speed1(input_argument, original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
	//210301 add ms, not only sm
	//split_merge_optimization_segments_speed2(input_argument, original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);

	/*******************   210303 add ms, not only sm   ************************/
	split_merge_optimization_segments_speed3(input_argument, original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
	/***************************************************************************/

	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
//	if (!split_area_difference_map.empty()) {
//
//		DoublyLinkedList<Y> temp_doubly_linked_list = DoublyLinkedList<Y>();
//		//multimap<long double, DoublyListNode<Y>&, greater<long double>> temp_merge_segment_density_map;
//		multimap<long double, DoublyListNode<Y>&, greater<long double>> temp_split_area_difference_map;
//		temp_doubly_linked_list.copy(doubly_linked_list);
//		/*==========================================         Update Temp MAP: Split & Merge      ==========================================*/
//		for (int id_node = 0; id_node < temp_doubly_linked_list.size(); id_node++) {
//
//			/**************************    reference node and value in linkedlist    ******************************/
//			auto& const node_segment_current = temp_doubly_linked_list.getNode(id_node);
//			auto& const value_segment_current = node_segment_current._value;
//			/******************************************************************************************************/
//
//			/*.................................................................................................................................*/
//#ifdef _DEBUG
//			Y test_splitted_segment = value_segment_current;
//			get_ab_segment(original_time_series_vector, test_splitted_segment);
//			//assert_two_segments_a_b(test_splitted_segment, value_segment_current);
//			//assert_segment_a_b(value_segment_current);
//			//assert_segment_a_b_minmax(original_time_series_vector, value_segment_current);
//			assert(value_segment_current.area_difference != INF);
//			//assert(value_segment_current.right_subsegment != nullptr && value_segment_current.apla.a != INF && value_segment_current.apla.b != INF && value_segment_current.right_endpoint != INF && value_segment_current.rectangle_width != INF);
//#endif
//		/*.....................................................................................................................................................*/
//
//		/******************************           Get Area difference           *******************************************/
//		//if (value_segment_current.rectangle_width > 2) {
//			temp_split_area_difference_map.emplace(getAreaDifference(value_segment_current), node_segment_current);
//			//}
//
//			//temp_merge_segment_density_map.emplace(value_segment_current.right_subsegment->segment_density, node_segment_current);
//		/******************************************************************************************************************/
//		}
//		/*======================================================================================================================*/
//		optimization_segments_loop(input_argument, original_time_series_vector, temp_split_area_difference_map, temp_doubly_linked_list, output_argument);
//		doubly_linked_list.swap(temp_doubly_linked_list);
//	}
	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
}

//191028 Initial to check Y-projection & APLA
//************************************
// Method:initialAPLAYProjection
// Qualifier: Recursive split and merge segment. Add split merge process. a, b, width, right_endpoint, apla_coefficient, sum_value. Split segment into 3 sub-segment by minmax point
// 190918 Use Linded list
// date:191028 14:03
// author:
//************************************
TEMPLATE
void APLA::initialAPLAYProjection(typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<AREA_COEFFICIENT>& const all_linked_list, DoublyLinkedList<AREA_COEFFICIENT>& const cluster_linked_list, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list) {//191028 Initial to check Y-projection & APLA
#ifdef _DEBUG
	assert(y_projection_argument.initial_N != INF && doubly_linked_list.empty());
#endif
	if (y_projection_argument.initial_N == input_argument.point_dimension && checkIfBurstDataSet(input_argument, original_time_series, y_projection_argument)) {
#ifdef _DEBUG
		cout << "YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY   " << y_projection_argument.is_y_projection << endl;
		assert(y_projection_argument.is_y_projection == true);
#endif
		initialYProjectionAll(input_argument, original_time_series, y_projection_argument, all_linked_list);
		initialYProjectionCluster(input_argument, original_time_series, y_projection_argument, all_linked_list, cluster_linked_list);
	}
	else if (!y_projection_argument.is_y_projection) {
		initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursiveSpeed2(input_argument, original_time_series, doubly_linked_list);//191002 13:20
	}
}

//************************************
// Method:initial_apla_yprojection_knn
// Qualifier: for KNN algorithm. Recursive split and merge segment. Add split merge process. a,b,width,right_endpoint,apla_coefficient, sum_value. Split segment into 3 sub-segment by minmax point
// 190918 Use Linded list
// Initial to check Y-projection & APLA
// date:191115 14:03
// author:
//************************************
TEMPLATE
template<typename T>
void APLA::initial_apla_yprojection_knn(typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<T>& const all_linked_list, DoublyLinkedList<T>& const cluster_linked_list, DoublyLinkedList<T>& const doubly_linked_list) {
#ifdef _DEBUG
	assert(y_projection_argument.initial_N != INF && doubly_linked_list.empty());
	//cout << "inital change file: " << input_argument.change_file <<endl;
#endif
	//if (y_projection_argument.change_file == true) {
		//y_projection_argument.change_file = false;
	//}
	//y_projection_argument.is_y_projection = false;
	if (input_argument.change_file == true && checkIfBurstDataSet(input_argument, original_time_series, y_projection_argument) && y_projection_argument.whole_difference_map.size() > 1) {
		//if (y_projection_argument.initial_N == input_argument.point_dimension && checkIfBurstDataSet(input_argument, original_time_series, y_projection_argument) && y_projection_argument.whole_difference_map.size() > 1) {
		//cout << "Has to initialize!!!!!!!!!!!!!!!!!!!!!\n";
#ifdef _DEBUG
		//cout << "y projection: " << y_projection_argument.is_y_projection << endl;
		assert(y_projection_argument.is_y_projection == true);
#endif
		/* get all segments && clustered segments, below two functions can be merged??? */
		initialYProjectionAll(input_argument, original_time_series, y_projection_argument, all_linked_list);
		initialYProjectionCluster(input_argument, original_time_series, y_projection_argument, all_linked_list, cluster_linked_list);
	}
	else if (!y_projection_argument.is_y_projection) {
		initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursiveSpeed2(input_argument, original_time_series, doubly_linked_list);//191002 13:20
		return;
	}
	else if (y_projection_argument.whole_difference_map.size() == 1) {//191204 only one value, line time series
		return;
	}
	else {// data set not change, already compute all list and cluster list
		//cout << "No need to initialize~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
		return;
	}
	/* y_projection_argument.whole_difference_map.size() == 1, time series is line */
}

//************************************
// Method:initialAPLARightEndpoint3SubNoMerge
// Qualifier: a,b,width,right_endpoint,apla_coefficient, sum_value. Split segment into 3 sub-segment by minmax point
//190627 16:38 Use minmax point split segment into 3 subsegment, when minmax points at endpoint, not merge.
// date:190627 16:45
// author:
//************************************
TEMPLATE
void APLA::initialAPLARightEndpoint3SubNoMerge(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector) {//190627 16:38 Use minmax point split segment into 3 subsegment, when minmax points at endpoint, not merge.
		//int segment_number = input_argument.point_dimension * 2;
	//input_argument.remainder = int(input_argument.time_series_length) % int(segment_number);//For PLA
	//double integerDividend = input_argument.time_series_length - input_argument.remainder;
	//input_argument.segment_length_second = integerDividend / segment_number;
	//input_argument.segment_length_first = input_argument.segment_length_second + 1;

#ifdef _DEBUG
	assert(input_argument.segment_length_first == input_argument.segment_length_second + 1);
	assert(input_argument.segment_length_first > 2);
#endif

	int j = 0;//original id
	int k = 0;
	int original_id = 0;//190617
	int zero_id = NULL;//190617 [0,segment_len-1]

	int sub_id1 = NULL;
	int sub_id2 = NULL;
	int sub_id3 = NULL;
	int segment_id = NULL;
	int whole_width = input_argument.segment_length_second;

	for (int i = 1; i <= input_argument.point_dimension; i++) {//get right endpoint and width
		zero_id = 0;
		if (input_argument.segment_length_first >= 6) {
			sub_id1 = i * 3 - 3;
			sub_id2 = i * 3 - 2;
			sub_id3 = i * 3 - 1;
			segment_id = i * 3 - 1;
			area_vector[segment_id].min_point.id = INF;
			area_vector[segment_id].min_point.value = INF;
			area_vector[segment_id].max_point.id = -INF;
			area_vector[segment_id].max_point.value = -INF;
			area_vector[segment_id].right_subsegment = new AREA_COEFFICIENT;
			area_vector[sub_id2].right_subsegment = new AREA_COEFFICIENT;
			area_vector[sub_id1].right_subsegment = new AREA_COEFFICIENT;
			area_vector[segment_id].sum_value = 0;
			//double min_sum_value = 0;
			//double max_sum_value = 0;
			/*----------190628------------*/
		}
		else {
			if (i <= input_argument.remainder) {
				area_vector[segment_id].right_endpoint = i * input_argument.segment_length_first - 1;
				whole_width++;
			}
			else {
				area_vector[segment_id].right_endpoint = input_argument.remainder + i * input_argument.segment_length_second - 1;
			}
			area_vector[segment_id].min_point.id = INF;
			area_vector[segment_id].min_point.value = INF;
			area_vector[segment_id].max_point.id = -INF;
			area_vector[segment_id].max_point.value = -INF;
			area_vector[segment_id].right_subsegment = new AREA_COEFFICIENT;
			area_vector[segment_id].sum_value = 0;
			if (whole_width == 6) {
				area_vector[segment_id].rectangle_width = 2;
				area_vector[sub_id2].rectangle_width = 2;
				area_vector[sub_id1].rectangle_width = 2;

				area_vector[sub_id2].right_endpoint = area_vector[segment_id].right_endpoint - 2;
				area_vector[sub_id1].right_endpoint = area_vector[sub_id2].right_endpoint - 2;
			}
			else if (whole_width > 3 && whole_width < 6) {
				area_vector[segment_id].rectangle_width = whole_width - 2;
				area_vector[sub_id2].right_endpoint = area_vector[segment_id].right_endpoint - area_vector[segment_id].rectangle_width;
				area_vector[sub_id2].rectangle_width = 2;
				area_vector[sub_id1].right_endpoint = INF;
				area_vector[sub_id1].right_endpoint = INF;
			}
			else if (whole_width < 4) {
				area_vector[segment_id].rectangle_width = whole_width - 2;
				area_vector[sub_id2].right_endpoint = INF;
				area_vector[sub_id2].rectangle_width = INF;
				area_vector[sub_id1].right_endpoint = INF;
				area_vector[sub_id1].right_endpoint = INF;
			}
			continue;
		}

		/*---------------------------------------------------------------Get MinMax Point----------------------------------------------------------------------------------------*/
		if (i <= input_argument.remainder) {//first part
			/*------------------------Right endpoint ---------------------------------*/
			area_vector[segment_id].right_endpoint = i * input_argument.segment_length_first - 1;
			whole_width++;
			/*.........................................................................*/

			for (original_id = int((i - 1) * input_argument.segment_length_first); original_id <= area_vector[segment_id].right_endpoint; original_id++) {
				//cout<<original_id<<": "<< original_time_series[original_id]<<", ";
				/*---------------------------------Get minmax point of every segment----------------------------------------------*/
				if (area_vector[segment_id].min_point.value > original_time_series[original_id]) {
					area_vector[segment_id].min_point.value = original_time_series[original_id];
					area_vector[segment_id].min_point.id = original_id;
				}
				if (area_vector[segment_id].max_point.value < original_time_series[original_id]) {
					area_vector[segment_id].max_point.value = original_time_series[original_id];
					area_vector[segment_id].max_point.id = original_id;
				}
				/*................................................................................................................*/
			}
			//cout << endl;
			/*-----------------------------Segment Coefficient--------------------------------------------------------*/
#ifdef _DEBUG
			assert(original_id == i * input_argument.segment_length_first);//original_id final is equal to right_endpoint
#endif
			/*.......................................................................................................*/
		}
		else {
			/*------------------------Right endpoint ---------------------------------*/
			area_vector[segment_id].right_endpoint = input_argument.remainder + i * input_argument.segment_length_second - 1;

			/*.........................................................................*/

			for (k = i - 1, original_id = int(input_argument.remainder + k * input_argument.segment_length_second); original_id <= area_vector[segment_id].right_endpoint; original_id++) {
				//assert(original_id >= 0);
				//cout<<original_id<<": "<< original_time_series[original_id]<<", ";
				/*---------------------------------Get minmax point of every segment----------------------------------------------*/
				if (area_vector[segment_id].min_point.value > original_time_series[original_id]) {
					area_vector[segment_id].min_point.value = original_time_series[original_id];
					area_vector[segment_id].min_point.id = original_id;
				}
				if (area_vector[segment_id].max_point.value < original_time_series[original_id]) {
					area_vector[segment_id].max_point.value = original_time_series[original_id];
					area_vector[segment_id].max_point.id = original_id;
				}
				/*................................................................................................................*/
			}
			//cout << endl;
			/*-----------------------------Segment Coefficient--------------------------------------------------------*/
#ifdef _DEBUG
			assert(original_id == input_argument.remainder + i * input_argument.segment_length_second);//original_id final is equal to right_endpoint
#endif
			/*.......................................................................................................*/
		}
		/*...................................................................................................................................................................*/

		/*==================================================According to minmax point, Get endpoint & width of 3 sub segments========================================================================================*/
#ifdef _DEBUG
		assert(whole_width > 6);
#endif
		if (whole_width > 6) {
			auto split_endpoint = minmax(area_vector[segment_id].min_point.id, area_vector[segment_id].max_point.id);
			int sub_segment1_endpoint = split_endpoint.first;
			int sub_segment2_endpoint = split_endpoint.second;
			area_vector[sub_id2].right_endpoint = sub_segment2_endpoint;
			area_vector[sub_id1].right_endpoint = sub_segment1_endpoint;
			int sub_segment1_width = INF;
			if (i > 1) {
				sub_segment1_width = area_vector[sub_id1].right_endpoint - area_vector[sub_id1 - 1].right_endpoint;
			}
			else {
				sub_segment1_width = area_vector[sub_id1].right_endpoint + 1;
			}
			int sub_segment2_width = sub_segment2_endpoint - sub_segment1_endpoint;
			int sub_segment3_width = area_vector[segment_id].right_endpoint - sub_segment2_endpoint;

			area_vector[segment_id].rectangle_width = sub_segment3_width;
			area_vector[sub_id2].rectangle_width = sub_segment2_width;
			area_vector[sub_id1].rectangle_width = sub_segment1_width;
#ifdef _DEBUG
			assert(whole_width == sub_segment1_width + sub_segment2_width + sub_segment3_width);//original_id final is equal to right_endpoint
#endif
			if ((sub_segment1_width < 2 && sub_segment3_width < 2) || sub_segment1_endpoint == sub_segment2_endpoint || area_vector[sub_id2].rectangle_width == 1) {
				int average_width = whole_width / 3;
				area_vector[segment_id].rectangle_width = average_width;
				area_vector[sub_id2].rectangle_width = average_width;
				area_vector[sub_id2].right_endpoint = area_vector[segment_id].right_endpoint - average_width;
				area_vector[sub_id1].rectangle_width = whole_width - average_width * 2;
				area_vector[sub_id1].right_endpoint = area_vector[sub_id2].right_endpoint - average_width;
#ifdef _DEBUG
				//assert(area_vector[segment_id].max_point.id != area_vector[segment_id].min_point.id && area_vector[segment_id].max_point.value != area_vector[segment_id].min_point.value);
				assert(area_vector[sub_id1].rectangle_width > 1 && area_vector[sub_id2].rectangle_width > 1 && area_vector[segment_id].rectangle_width > 1);
#endif
			}
			else if (sub_segment1_width < 2 && sub_segment3_width > 1) {
				if (sub_segment2_width > sub_segment3_width) {
					int average = sub_segment2_width / 2;
					area_vector[sub_id1].right_endpoint += average;
					area_vector[sub_id1].rectangle_width += average;
					area_vector[sub_id2].rectangle_width = area_vector[sub_id2].right_endpoint - area_vector[sub_id1].right_endpoint;
#ifdef _DEBUG
					assert(area_vector[sub_id2].rectangle_width == whole_width - area_vector[sub_id1].rectangle_width - area_vector[segment_id].rectangle_width);//original_id final is equal to right_endpoint
#endif
				}
				else {
					int average_width = sub_segment3_width / 2;
					area_vector[segment_id].rectangle_width = average_width;
					area_vector[sub_id1].right_endpoint = area_vector[sub_id2].right_endpoint;
					area_vector[sub_id2].right_endpoint = area_vector[segment_id].right_endpoint - average_width;
					area_vector[sub_id2].rectangle_width = area_vector[sub_id2].right_endpoint - area_vector[sub_id1].right_endpoint;
					area_vector[sub_id1].rectangle_width = whole_width - area_vector[sub_id2].rectangle_width - area_vector[segment_id].rectangle_width;
				}
#ifdef _DEBUG
				//assert(area_vector[segment_id].max_point.id != area_vector[segment_id].min_point.id && area_vector[segment_id].max_point.value != area_vector[segment_id].min_point.value);
				assert(area_vector[sub_id1].rectangle_width > 1 && area_vector[sub_id2].rectangle_width > 1 && area_vector[segment_id].rectangle_width > 1);
#endif
			}
			else if (sub_segment1_width > 1 && sub_segment3_width < 2) {
				if (sub_segment1_width > sub_segment2_width) {
					int average = sub_segment1_width / 2;
					area_vector[sub_id2].right_endpoint = area_vector[sub_id1].right_endpoint;
					area_vector[segment_id].rectangle_width = area_vector[segment_id].right_endpoint - area_vector[sub_id2].right_endpoint;
					area_vector[sub_id1].right_endpoint -= average;
					area_vector[sub_id2].rectangle_width = area_vector[sub_id2].right_endpoint - area_vector[sub_id1].right_endpoint;
					area_vector[sub_id1].rectangle_width = whole_width - area_vector[sub_id2].rectangle_width - area_vector[segment_id].rectangle_width;
#ifdef _DEBUG
					assert(area_vector[sub_id2].rectangle_width == whole_width - area_vector[sub_id1].rectangle_width - area_vector[segment_id].rectangle_width);//original_id final is equal to right_endpoint
#endif
				}
				else {
					auto average_width = sub_segment2_width / 2;
					area_vector[sub_id2].right_endpoint -= average_width;
					area_vector[segment_id].rectangle_width = area_vector[segment_id].right_endpoint - area_vector[sub_id2].right_endpoint;
					area_vector[sub_id2].rectangle_width = area_vector[sub_id2].right_endpoint - area_vector[sub_id1].right_endpoint;
				}
#ifdef _DEBUG
				//assert(area_vector[segment_id].max_point.id != area_vector[segment_id].min_point.id && area_vector[segment_id].max_point.value != area_vector[segment_id].min_point.value);
				assert(area_vector[sub_id1].rectangle_width > 1 && area_vector[sub_id2].rectangle_width > 1 && area_vector[segment_id].rectangle_width > 1);
#endif
			}
		}

#ifdef _DEBUG
		assert(area_vector[sub_id1].rectangle_width > 0 && area_vector[sub_id2].rectangle_width > 0 && area_vector[segment_id].rectangle_width > 0);
		assert(area_vector[segment_id].min_point.id <= area_vector[segment_id].right_endpoint && area_vector[segment_id].max_point.id <= area_vector[segment_id].right_endpoint);
		/*if (i > 1) {
			assert(area_vector[segment_id].min_point.id >= area_vector[segment_id - 1].right_endpoint || area_vector[segment_id].max_point.id >= area_vector[segment_id - 1].right_endpoint);
		}*/
#endif
#ifdef _DEBUG
		//assert(area_vector[segment_id].max_point.id != area_vector[segment_id].min_point.id && area_vector[segment_id].max_point.value != area_vector[segment_id].min_point.value);
		assert(area_vector[sub_id1].rectangle_width > 1 && area_vector[sub_id2].rectangle_width > 1 && area_vector[segment_id].rectangle_width > 1);
#endif
	}

	area_vector.erase(std::remove_if(area_vector.begin(), area_vector.end(), [](AREA_COEFFICIENT& i) { return i.right_endpoint == INF && i.rectangle_width == INF; }), area_vector.end());
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	getPLAByAdaptiveSegment(input_argument, original_time_series, area_vector);//190617 sum_value, a, b, apla_coefficient
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
}

//************************************
// Method:initialRecArea0ForParallelogramArrayVector0
// Qualifier: intial segment for the parallelogramuse vectorand no sub-function to speed up
// date:190605
// author:
//************************************
TEMPLATE
void APLA::initialRecArea0ForParallelogramArrayVector0(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector) {//190605 Use vector to instead Array,
#ifdef _DEBUG
	assert(input_argument.time_series_length % 2 == 0);//n is even
#endif

	int initial_rectangle_num = input_argument.time_series_length / 2;//!!!!!!!!!!!!!!!!! what if time_series_length is  odd???
	//area_vector.resize(initial_rectangle_num, AREA_COEFFICIENT());

	//AREA_COEFFICIENT area_coefficient;
	//AreaIncreasing areaIncreasing;
	//output_argument.min_density_segment.value = INF;
	//output_argument.min_density_segment.id = INF;

	/*--------------------------------------Test-----------------------------------------------*/
	priority_queue<typename GEOMETRY::POINT> min_density_queue;//190604

	typename GEOMETRY::POINT min_density_point;
	/*.........................................................................................*/

	for (int array_id = 0, segment_id = 1, array_end_id = initial_rectangle_num - 1; array_id < array_end_id; array_id++, segment_id++, array_end_id--) {
		/*==================end point=======================*/
		int left_id = array_id * 2;
		int right_id = area_vector[array_id].right_endpoint = left_id + 1;
		/*==================width=======================*/
		area_vector[array_id].rectangle_width = 2.0;
		//sum value 190412
		area_vector[array_id].sum_value = original_time_series[left_id] + original_time_series[right_id];
		//================get a&b=========================
		area_vector[array_id].apla.a = (original_time_series[right_id] - original_time_series[left_id]);
		area_vector[array_id].apla.b = original_time_series[left_id];
		//refreshSegmentCoefficient(original_time_series, area_coefficient);
		//================get deviation==================
		area_vector[array_id].increment_area = fabs(area_vector[array_id].apla.a);
		area_vector[array_id].parallelogram_height = area_vector[array_id].increment_area;
		//area_vector[array_id].rectangle_height = area_vector[array_id].increment_area;
		area_vector[array_id].rec_deviation = 0;
		//output_argument.density_min_value = min(area_coefficient.segment_density, ooutput_argument.min_density_segment.value);
		/*================get Density=======================*/
		area_vector[array_id].getSegmentDensitySpeed();
		/*================get Threshhold====================*/
		if (area_vector[array_id].segment_density < output_argument.min_density_segment.value) {
			output_argument.min_density_segment.value = area_vector[array_id].segment_density;
			//output_argument.min_density_segment.id = array_id;
		}

		/*------------------------------Test------------------------------------------------*/
		/*if (min_density_queue.size()<=5) {
			min_density_point.id = array_id;
			min_density_point.value = area_vector[array_id].segment_density;
			min_density_queue.push(min_density_point);
		}
		else {
		}*/
		/*==================end point=======================*/
		left_id = array_end_id * 2;
		right_id = area_vector[array_end_id].right_endpoint = left_id + 1;
		/*==================width=======================*/
		area_vector[array_end_id].rectangle_width = 2.0;
		//sum value 190412
		area_vector[array_end_id].sum_value = original_time_series[left_id] + original_time_series[right_id];
		//================get a&b=========================
		area_vector[array_end_id].apla.a = (original_time_series[right_id] - original_time_series[left_id]);
		area_vector[array_end_id].apla.b = original_time_series[left_id];
		//refreshSegmentCoefficient(original_time_series, area_coefficient);
		//================get deviation==================
		area_vector[array_end_id].increment_area = fabs(area_vector[array_end_id].apla.a);
		area_vector[array_end_id].parallelogram_height = area_vector[array_end_id].increment_area;
		//area_vector[array_end_id].rectangle_height = area_vector[array_end_id].increment_area;
		area_vector[array_end_id].rec_deviation = 0;
		//output_argument.density_min_value = min(area_coefficient.segment_density, ooutput_argument.min_density_segment.value);
		/*================get Density=======================*/
		area_vector[array_end_id].getSegmentDensitySpeed();
		/*================get Threshhold====================*/
		if (area_vector[array_end_id].segment_density < output_argument.min_density_segment.value) {
			output_argument.min_density_segment.value = area_vector[array_end_id].segment_density;
			//output_argument.min_density_segment.id = array_end_id;
		}
		/*..................................................................................*/

		/*================190516 Test Min&Max Section====================*/
//		int segment_left_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
//		auto[mmin, mmax] = minmax_element(original_time_series + segment_left_id, original_time_series + int(temp_coefficient.right_endpoint + 1));
//		temp_coefficient.min_point.value = *mmin;
//		temp_coefficient.max_point.value = *mmax;
//		temp_coefficient.rectangle_height = temp_coefficient.max_point.value - temp_coefficient.min_point.value;
//
//#ifdef _DEBUG
//		assert(*mmax >= *mmin);
//		assert(temp_coefficient.right_endpoint >= mmin - original_time_series && temp_coefficient.right_endpoint >= mmax - original_time_series);
//		assert(temp_coefficient.rectangle_height >= 0);
//#endif
//		//minimax id
//		temp_coefficient.min_point.id = mmin - original_time_series;
//		temp_coefficient.max_point.id = mmax - original_time_series;
//
		/*---------------------------------------------------MinMax Point------------------------------------------------------------------------------------*/
		//if (original_time_series[int(area_vector[array_id].right_endpoint - 1)] <= original_time_series[int(area_vector[array_id].right_endpoint)]) {
		//	//minmax id
		//	area_vector[array_id].min_point.id = area_vector[array_id].right_endpoint - 1;
		//	area_vector[array_id].max_point.id = area_vector[array_id].right_endpoint;
		//}
		//else {
		//	//minmax id
		//	area_vector[array_id].min_point.id = area_vector[array_id].right_endpoint;
		//	area_vector[array_id].max_point.id = area_vector[array_id].right_endpoint - 1;
		//}
		////minmax value
		//area_vector[array_id].min_point.value = original_time_series[int(area_vector[array_id].min_point.id)];
		//area_vector[array_id].max_point.value = original_time_series[int(area_vector[array_id].max_point.id)];
		/*..........................................................................................................................................*/
		//area_vector[array_id].deviation_point.id = area_vector[array_id].min_point.id;
		/*...............................................................*/
	}
}

//************************************
// Method:initial_y_projection_all_cluster
// Qualifier: Determine whether should use Y-projection method and get all segments and cluster segments
// date:200427 
// author:
//************************************
TEMPLATE
template<typename T, typename T1, typename Y, typename U>
void APLA::initial_y_projection_all_cluster(const U& const input_argument, const vector<T>& const original_time_series_vector, T1& const y_projection_argument, DoublyLinkedList<Y>& const all_segment_linked_list, DoublyLinkedList<Y>& const cluster_linked_list) {
	Y temp_coefficient;
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&            get threshold             &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	/*###########################################            count most points          ###################################################*/
	std::map<int, double, std::greater<int>> number_value_map;// number of y value bigger to small.
	for (auto&& au : y_projection_argument.whole_difference_map) {
		number_value_map.emplace(au.second, au.first);
	}
	// initial threshold
	y_projection_argument.flat_segment_min = number_value_map.begin()->second;//first threshold. min value in flat segment
	y_projection_argument.flat_segment_max = y_projection_argument.flat_segment_min;
	/*#####################################################################################################################################*/

	/*########################################        Special case: time series is a line        #############################################################*/
	if (y_projection_argument.whole_difference_map.size() < 2) {
#ifdef _DEBUG
		cout << "!!!!!!!!!!!!!!!!!!!!!     Whole time series is a line   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n";
		assert(!y_projection_argument.whole_difference_map.empty() && y_projection_argument.flat_segment_min != INF && y_projection_argument.flat_segment_max == y_projection_argument.flat_segment_min);
#endif

		y_projection_argument.is_y_projection = true;
		temp_coefficient.right_endpoint = input_argument.time_series_length - 1;
		temp_coefficient.rectangle_width = input_argument.time_series_length;
		temp_coefficient.is_flat = true;
		temp_coefficient.segment_right_height_difference = 0;

		cluster_linked_list.add(temp_coefficient);
		all_segment_linked_list.add(temp_coefficient);
#ifdef _DEBUG
		assert(cluster_linked_list.back().right_endpoint == input_argument.time_series_length - 1 && cluster_linked_list.size() == all_segment_linked_list.size());
		assert(y_projection_argument.flat_segment_max != INF && y_projection_argument.flat_segment_min != INF && y_projection_argument.flat_segment_min == y_projection_argument.flat_segment_max);
#endif
	}
	/*#########################################################################################################################################################*/
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!            if y value has several y values             !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	else {
		/*+++++++++++++++++++++++++++++++++++++++++++              get  threshold of y projection         +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
#ifdef _DEBUG
		assert(!y_projection_argument.whole_difference_map.empty() && y_projection_argument.flat_segment_min != INF && y_projection_argument.flat_segment_max == y_projection_argument.flat_segment_min);
#endif
		/*=====================================================      get neighber of threshold   ==============================================================================================================*/
		const auto& const second_most_y_pair = next(number_value_map.begin(), 1);//second threshold number
		const auto& const bigger_than_threshold_pair = next(y_projection_argument.whole_difference_map.find(y_projection_argument.flat_segment_min), 1);// bigger than threshold
		const auto& const smaller_than_threshold_pair = prev(y_projection_argument.whole_difference_map.find(y_projection_argument.flat_segment_min), 1);//smaller than threshold
		/*======================================================================================================================================================================================================*/

		/*=====================================================            get threshold         ===============================================================================================================*/
		//no bigger most y value
		if (bigger_than_threshold_pair == y_projection_argument.whole_difference_map.end()) {
			if (second_most_y_pair->second == smaller_than_threshold_pair->first) {
				y_projection_argument.flat_segment_max = y_projection_argument.flat_segment_min;//threshold
				y_projection_argument.flat_segment_min = second_most_y_pair->second;
			}
		}//no smaller y value
		else if (smaller_than_threshold_pair == y_projection_argument.whole_difference_map.end()) {
			if (second_most_y_pair->second == bigger_than_threshold_pair->first) {
				y_projection_argument.flat_segment_max = second_most_y_pair->second;//threshold
			}
		}
		else {
			if (second_most_y_pair->second == smaller_than_threshold_pair->first) {
#ifdef _DEBUG
				assert(second_most_y_pair->second != bigger_than_threshold_pair->first);
#endif
				//y_projection_argument.flat_segment_max = y_projection_argument.flat_segment_min;//threshold
				y_projection_argument.flat_segment_min = second_most_y_pair->second;
			}
			else if (second_most_y_pair->second == bigger_than_threshold_pair->first) {
#ifdef _DEBUG
				assert(second_most_y_pair->second != smaller_than_threshold_pair->first);
#endif
				y_projection_argument.flat_segment_max = second_most_y_pair->second;//threshold
			}
		}
		/*====================================================================================================================================================================================*/

		//if (number_value_map.begin()->first / second_y_number->first > 2) {
		//	y_projection_argument.flat_segment_max = y_projection_argument.flat_segment_min;//threshold
		//}
		//else {
		//	y_projection_argument.flat_segment_max = max(second_y_number->second, y_projection_argument.flat_segment_min);//threshold
		//	y_projection_argument.flat_segment_min = min(second_y_number->second, y_projection_argument.flat_segment_min);
		//}

#ifdef _DEBUG
		assert(y_projection_argument.flat_segment_max != INF && y_projection_argument.flat_segment_min != INF && y_projection_argument.flat_segment_min <= y_projection_argument.flat_segment_max);
#endif
		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*++++++++++++++++++++++++++++++++++++          get all & cluster linked list         +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		//get_y_all_cluster_segment(input_argument, original_time_series_vector, y_projection_argument, all_segment_linked_list, cluster_linked_list);
		get_y_all_cluster_segment_200213(input_argument, original_time_series_vector, y_projection_argument, all_segment_linked_list, cluster_linked_list);
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		//if (flat_segment_number / double(all_segment_linked_list.size()) < 0.5) {
		//if (input_argument.total_flat_segment_length / double(input_argument.time_series_length) > 0.5) {

		/*++++++++++++++++++++++++++++++++++++          Final determine it is Y projection         ++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		if (cluster_linked_list.size() <= double(input_argument.time_series_length) / 10 && number_value_map.begin()->first > double(input_argument.time_series_length) / 10 && y_projection_argument.total_flat_segment_length > double(input_argument.time_series_length) / 2) {
#ifdef _DEBUG
			cout << "It is a Burst TIme Siers YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY\n";
			cout << "After initial, All segment size: " << all_segment_linked_list.size() << "  Burst size " << cluster_linked_list.size() << endl;
			cout << "Total flat length: " << y_projection_argument.total_flat_segment_length << "  total flat number:  " << y_projection_argument.flat_segment_number << ",   " << y_projection_argument.flat_segment_number / y_projection_argument.total_flat_segment_length << endl;
			cout << "Y size: " << y_projection_argument.whole_difference_map.size() << endl;
			cout << "most frequent point number : " << number_value_map.begin()->first << endl;
#endif
			y_projection_argument.is_y_projection = true;
		}
		else {
#ifdef _DEBUG
			cout << "NNNNNNNNNNNNNN     This is not a burst time series !          NNNNNNNNNNNNN                        NNNNNNNNNNNNNNNNNNNNNNNNNNN NNNNNNNNNNNNNNNN          NNNNNNNNNNNNNNNNNNNNNNNN\n";
			cout << "After initial, All segment size: " << all_segment_linked_list.size() << "  Burst size " << cluster_linked_list.size() << endl;
			cout << "Total flat length: " << y_projection_argument.total_flat_segment_length << "  total flat number:  " << y_projection_argument.flat_segment_number << ",   " << y_projection_argument.flat_segment_number / y_projection_argument.total_flat_segment_length << endl;
			cout << "Y size: " << y_projection_argument.whole_difference_map.size() << endl;
			cout << "most frequent point number : " << number_value_map.begin()->first << endl;
#endif
			y_projection_argument.is_y_projection = false;
		}
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	}
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	/*#####################################################################################################################################################*/
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
}

//************************************
// Method:getRecWidth
// Qualifier: get width of rec_num segments
// date:190115
// author:
//************************************
TEMPLATE
inline double& APLA::getRecWidth(const vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, const int& const rec_num, AREA_COEFFICIENT& const temp_coefficient) {//190115
#ifdef _DEBUG
	assert(vector_id <= area_vector.size() && vector_id >= 0 && rec_num > 0);
#endif

	if (vector_id - rec_num < 0) {
		temp_coefficient.rectangle_width = area_vector[vector_id].right_endpoint + 1;
	}
	else {
#ifdef _DEBUG
		assert(area_vector[vector_id].right_endpoint > 0 && area_vector[vector_id - rec_num].right_endpoint > 0);
#endif
		temp_coefficient.rectangle_width = area_vector[vector_id].right_endpoint - area_vector[vector_id - rec_num].right_endpoint;
	}

#ifdef _DEBUG
	if (rec_num == 1)//190319
		assert(area_vector[vector_id].rectangle_width == temp_coefficient.rectangle_width);
#endif

	return temp_coefficient.rectangle_width;
}

//************************************
// Method:getRecWidth
// Qualifier: get width of rec_num segments
// date:190319
// author:
//************************************
TEMPLATE
double& APLA::getRecWidth(vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, const int& const rec_num) {//190319
#ifdef _DEBUG
	assert(vector_id <= area_vector.size() && vector_id >= 0 && rec_num > 0);
#endif

	if (vector_id - rec_num < 0) {
		area_vector[vector_id].rectangle_width = area_vector[vector_id].right_endpoint + 1;
	}
	else {
#ifdef _DEBUG
		assert(area_vector[vector_id].right_endpoint > 0 && area_vector[vector_id - rec_num].right_endpoint > 0);
#endif
		area_vector[vector_id].rectangle_width = area_vector[vector_id].right_endpoint - area_vector[vector_id - rec_num].right_endpoint;
	}

	return area_vector[vector_id].rectangle_width;
}

//************************************
// Method:getRecWidth
// Qualifier: get width of segments, use array to instead vector
// date:190419
// author:
//************************************
TEMPLATE
inline double& APLA::getRecWidth(SEGMENT_COEFFICIENT*& area_vector, const int& const vector_id, SEGMENT_COEFFICIENT& const temp_coefficient) {//190418
#ifdef _DEBUG
	assert(vector_id >= 0);
#endif

	if (vector_id < 2) {
		temp_coefficient.rectangle_width = area_vector[vector_id].right_endpoint + 1;
	}
	else {
#ifdef _DEBUG
		assert(area_vector[vector_id].right_endpoint > 0);
#endif
		temp_coefficient.rectangle_width = area_vector[vector_id].right_endpoint - area_vector[vector_id - 2].right_endpoint;
	}

	return temp_coefficient.rectangle_width;
}

//************************************
// Method:getRecWidthWidth
// Qualifier: get width of segments, use array to instead vector
// date:190605
// author:
//************************************
TEMPLATE
inline double& APLA::getRecWidthWidth(vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient) {//190605
#ifdef _DEBUG
	assert(vector_id > 0 && vector_id < area_vector.size() && area_vector[vector_id - 1].rectangle_width != INF && area_vector[vector_id].rectangle_width != INF);
#endif

	if (vector_id < 2) {
		return temp_coefficient.rectangle_width = area_vector[vector_id].right_endpoint + 1;
	}

	return temp_coefficient.rectangle_width = area_vector[vector_id - 1].rectangle_width + area_vector[vector_id].rectangle_width;
}

//************************************
// Method:getRightEndpointAndWidth
// Qualifier: get right_endpoint & width of segment
// date:190624
// author:
//************************************
TEMPLATE
void APLA::getRightEndpointAndWidth(const vector<int>& const right_endpoint_vector, vector<AREA_COEFFICIENT>& const area_vector) {//190624
#ifdef _DEBUG
	assert(area_vector.size() == right_endpoint_vector.size());
#endif
	int vector_id = 0;

	area_vector[0].right_endpoint = right_endpoint_vector[0];
	area_vector[0].rectangle_width = area_vector[0].right_endpoint + 1;

	for (vector_id = 1; vector_id < right_endpoint_vector.size(); vector_id++) {
		area_vector[vector_id].right_endpoint = right_endpoint_vector[vector_id];
		area_vector[vector_id].rectangle_width = area_vector[vector_id].right_endpoint - area_vector[vector_id - 1].right_endpoint;
	}
}

//************************************
// Method:getAandBSlopInterceptOnePoint
// Qualifier: update adjacent rectangle after merge operation
// date:181205
// author:
//************************************
TEMPLATE
inline long double& APLA::getAandBSlopInterceptOnePoint(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient) {//190115
	assert(0);
#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width == 1);
#endif
	/*-----------sum value-----------*/
	temp_coefficient.sum_value = original_time_series[int(temp_coefficient.right_endpoint)];
	/*--------a&b coefficient--------*/
	temp_coefficient.apla.a_minuend = 0;//(l-1)/2
	temp_coefficient.apla.a_divisor = 0;//l(l-1)(l+1)
	temp_coefficient.apla.b_minuend = 1;//2l-1
	temp_coefficient.apla.b_divisor = 2;//l(l+1)
	/*................................*/
	temp_coefficient.apla.b = original_time_series[int(temp_coefficient.right_endpoint)];
	return temp_coefficient.apla.a = 0;
}

//200212 Use vector of time series to instead pointer. Add template
//************************************
// Method:getAandBSlopInterceptOnePoint
// Qualifier: update adjacent rectangle after merge operation
// date:200212
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline long double& APLA::getAandBSlopInterceptOnePoint(const vector<T>& const original_time_series_vector, Y& const temp_coefficient) {//200212
	//assert(0);
#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width == 1);
#endif
	/*-----------sum value-----------*/
	//200316 sum value
	//temp_coefficient.sum_value = original_time_series_vector[int(temp_coefficient.right_endpoint)];
	/*--------a&b coefficient--------*/
	temp_coefficient.apla.a_minuend = 0;//(l-1)/2
	temp_coefficient.apla.a_divisor = 0;//l(l-1)(l+1)
	temp_coefficient.apla.b_minuend = 1;//2l-1
	temp_coefficient.apla.b_divisor = 2;//l(l+1)
	/*................................*/
	temp_coefficient.apla.b = original_time_series_vector[int(temp_coefficient.right_endpoint)];
	return temp_coefficient.apla.a = 0;
}

//************************************
// Method:getAandBSlopInterceptOnePoint
// Qualifier: update adjacent rectangle after merge operation
// date:191114
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline Y& APLA::getAandBSlopInterceptOnePoint(const T& const point_value, Y& const temp_coefficient) {//191114
#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width == 1);
#endif

	/*######################################     get min&max point     ####################################*/
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   a&b coefficient  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	temp_coefficient.apla.a = temp_coefficient.apla.a_minuend = temp_coefficient.apla.a_divisor = 0;//(l-1)/2 //l(l-1)(l+1)
	temp_coefficient.apla.b_minuend = 1;//2l-1
	temp_coefficient.apla.b_divisor = 2;//l(l+1)
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   a&b coefficient  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	//temp_coefficient.apla.b = temp_coefficient.sum_value = point_value;
	temp_coefficient.apla.b = point_value;
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!/
	/*#####################################################################################################*/

	/*######################################     get min&max point     #####################################*/
	//temp_coefficient.min_point.id = temp_coefficient.max_point.id = int(temp_coefficient.right_endpoint);
	//temp_coefficient.min_point.value = temp_coefficient.max_point.value = point_value;
	/*######################################################################################################*/

	return temp_coefficient;
}

//************************************
// Method:computeRectangleCoefficient
// Qualifier: update adjacent rectangle after merge operation
// Input: right endpoint, width
// Output: a & b, sume value. pla coefficient
// date:181205
// author:
//************************************
TEMPLATE
inline typename APLA::AREA_COEFFICIENT& APLA::getAandBSlopInterceptTwoPoint(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient) {//190929
#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width == 2);
#endif
	temp_coefficient.apla.a_minuend = 0.5;//(l-1)/2
	temp_coefficient.apla.a_divisor = 6.0;//l(l-1)(l+1)
	temp_coefficient.apla.b_minuend = 3.0;//2l-1
	temp_coefficient.apla.b_divisor = 6.0;//l(l+1)

	int segment_left_id = temp_coefficient.right_endpoint - 1;
#ifdef _DEBUG
	assert(temp_coefficient.right_endpoint - segment_left_id == 1);
#endif
	temp_coefficient.apla.a = (original_time_series[int(temp_coefficient.right_endpoint)] - original_time_series[segment_left_id]);
	temp_coefficient.apla.b = original_time_series[segment_left_id];

	temp_coefficient.sum_value = original_time_series[int(temp_coefficient.right_endpoint)] + original_time_series[segment_left_id];
	//temp_a = (original_time_series[int(temp_coefficient.right_endpoint)] - original_time_series[segment_left_id]);
	//temp_b = original_time_series[segment_left_id];
#ifdef _DEBUG
	assert(temp_coefficient.sum_value != INF && temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF && temp_coefficient.apla.a_minuend != INF && temp_coefficient.apla.a_divisor != INF && temp_coefficient.apla.b_minuend != INF && temp_coefficient.apla.b_divisor != INF);
#endif
	return temp_coefficient;
}

//200212 Use vector to instead pointer for time sereis ,add template
//************************************
// Method:getAandBSlopInterceptTwoPoint
// Qualifier: update adjacent rectangle after merge operation
// Input: right endpoint, width
// Output: a & b, sume value. pla coefficient
// date:200212
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline Y& APLA::getAandBSlopInterceptTwoPoint(const vector<T>& const original_time_series_vector, Y& const temp_coefficient) {//200212
#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width == 2 && !original_time_series_vector.empty());
#endif
	temp_coefficient.apla.a_minuend = 0.5;//(l-1)/2
	temp_coefficient.apla.a_divisor = 6.0;//l(l-1)(l+1)
	temp_coefficient.apla.b_minuend = 3.0;//2l-1
	temp_coefficient.apla.b_divisor = 6.0;//l(l+1)

	int segment_left_id = temp_coefficient.right_endpoint - 1;
#ifdef _DEBUG
	assert(temp_coefficient.right_endpoint - segment_left_id == 1);
#endif
	temp_coefficient.apla.a = (original_time_series_vector[int(temp_coefficient.right_endpoint)] - original_time_series_vector[segment_left_id]);
	temp_coefficient.apla.b = original_time_series_vector[segment_left_id];

	//200316 sum value
	//temp_coefficient.sum_value = original_time_series_vector[int(temp_coefficient.right_endpoint)] + original_time_series_vector[segment_left_id];
	//temp_a = (original_time_series[int(temp_coefficient.right_endpoint)] - original_time_series[segment_left_id]);
	//temp_b = original_time_series[segment_left_id];

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!        200421 get min&max point of segment    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	/*if (original_time_series_vector[int(temp_coefficient.right_endpoint - 1)] <= original_time_series_vector[int(temp_coefficient.right_endpoint)]) {
		temp_coefficient.min_point.id = segment_left_id;
		temp_coefficient.max_point.id = temp_coefficient.right_endpoint;
		temp_coefficient.min_point.value = original_time_series_vector[segment_left_id];
		temp_coefficient.max_point.value = original_time_series_vector[int(temp_coefficient.right_endpoint)];
	}
	else {
		temp_coefficient.min_point.id = temp_coefficient.right_endpoint;
		temp_coefficient.max_point.id = segment_left_id;
		temp_coefficient.min_point.value = original_time_series_vector[int(temp_coefficient.right_endpoint)];
		temp_coefficient.max_point.value = original_time_series_vector[segment_left_id];
	}*/
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

#ifdef _DEBUG
	assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF && temp_coefficient.apla.a_minuend != INF && temp_coefficient.apla.a_divisor != INF && temp_coefficient.apla.b_minuend != INF && temp_coefficient.apla.b_divisor != INF);
#endif
	return temp_coefficient;
}

//************************************
// Method:computeRectangleCoefficient
// Qualifier: update adjacent rectangle after merge operation
// Input: right endpoint, width
// Output: a & b, sume value. pla coefficient
// date:181205
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline void APLA::getAandBSlopInterceptTwoPoint(const Y& const left_value, const Y& const right_value, T& const temp_coefficient) {//191114
#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width == 2);
#endif
	temp_coefficient.apla.a_minuend = 0.5;//(l-1)/2
	temp_coefficient.apla.a_divisor = temp_coefficient.apla.b_divisor = 6.0;//l(l-1)(l+1) //l(l+1)
	temp_coefficient.apla.b_minuend = 3.0;//2l-1

	temp_coefficient.apla.a = right_value - left_value;
	temp_coefficient.apla.b = left_value;
	//200316 sum value
	//temp_coefficient.sum_value = left_value + right_value;
	//temp_a = (original_time_series[int(temp_coefficient.right_endpoint)] - original_time_series[segment_left_id]);
	//temp_b = original_time_series[segment_left_id];
#ifdef _DEBUG
	assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF && temp_coefficient.apla.a_minuend != INF && temp_coefficient.apla.a_divisor != INF && temp_coefficient.apla.b_minuend != INF && temp_coefficient.apla.b_divisor != INF);
#endif
}

//************************************
// Method:computeRectangleCoefficient
// Qualifier: update adjacent rectangle after merge operation. Have to know right_point & rectangle_width
// date:181205
// author:
//************************************
TEMPLATE
typename APLA::AREA_COEFFICIENT& APLA::refreshSegmentCoefficient(DataType*& const original_time_series, typename  APLA::AREA_COEFFICIENT& const temp_coefficient) {//190318
//AREA_COEFFICIENT& APLA::refreshSegmentCoefficient(DataType *& const original_time_series, AREA_COEFFICIENT& const temp_coefficient){
#ifdef _DEBUG
	assert(temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF);
	assert(temp_coefficient.rectangle_width > 0);
#endif

	int segment_left_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	auto [mmin, mmax] = minmax_element(original_time_series + segment_left_id, original_time_series + int(temp_coefficient.right_endpoint + 1));

	/*for (int id = segment_left_id; id <= temp_coefficient.right_endpoint;id++) {
		cout << original_time_series[id] << " ";
	}
	cout << endl;*/

	//height
	temp_coefficient.min_point.value = *mmin;
	temp_coefficient.max_point.value = *mmax;
	temp_coefficient.rectangle_height = temp_coefficient.max_point.value - temp_coefficient.min_point.value;

#ifdef _DEBUG
	assert(*mmax >= *mmin);
	assert(temp_coefficient.right_endpoint >= mmin - original_time_series && temp_coefficient.right_endpoint >= mmax - original_time_series);
	assert(temp_coefficient.rectangle_height >= 0);
#endif

	//minimax id
	temp_coefficient.min_point.id = mmin - original_time_series;
	temp_coefficient.max_point.id = mmax - original_time_series;
	//temp_coefficient.minmax_distance = fabs(temp_coefficient.max_point.id - temp_coefficient.min_point.id);
	temp_coefficient.minmax_distance = temp_coefficient.rectangle_height == 0 ? 0 : fabs(temp_coefficient.max_point.id - temp_coefficient.min_point.id);

	/*------------------------------Compute Segment Area----------------------------------------------------------*/
	temp_coefficient.rectangle_area = temp_coefficient.rectangle_height * temp_coefficient.rectangle_width;
	computeParallelogram(original_time_series, temp_coefficient);//get area of parallelogram for every segment
	//getPolygonArea(original_time_series, temp_coefficient);// get area of polygon for every segment
	//getConvexHullArea(original_time_series, temp_coefficient);// get area of convex hull for every segment
	//getCircleArea(original_time_series, temp_coefficient);// get area of circle for every segment
	/*-----------------------------------------------------------------------------------------------------------*/

	/*=================================Get Segment Deviation=======================================================*/
	getSegmentDevByPLA(original_time_series, temp_coefficient);
	/*.............................................................................................................*/
	temp_coefficient.getSegmentDensity();

	return temp_coefficient;
}

//************************************
// Method:refreshSegmentCoefficient
// Qualifier: update adjacent rectangle after merge operation.
// date:190319
// author:
//************************************
TEMPLATE
void APLA::refreshSegmentCoefficient(DataType*& const original_time_series, vector<typename APLA::AREA_COEFFICIENT>& area_vector, const int& const vector_id) {//190319
#ifdef _DEBUG
	assert(area_vector[vector_id].right_endpoint != INF && area_vector[vector_id].rectangle_width != INF);
	assert(area_vector[vector_id].rectangle_width > 0);
#endif

	int left_id = vector_id - 1;
	//int right_id = vector_id + 1;
	int segment_left_id = INF;

	//Width
	getRecWidth(area_vector, vector_id, 1);

	if (vector_id > 0 && vector_id < area_vector.size()) {
		segment_left_id = area_vector[left_id].right_endpoint + 1;
	}
	else if (vector_id == 0) {
		segment_left_id = 0;
	}
	else
		assert(0);

	auto [mmin, mmax] = minmax_element(original_time_series + segment_left_id, original_time_series + int(area_vector[vector_id].right_endpoint + 1));

#ifdef _DEBUG
	assert(*mmax >= *mmin);
	assert(area_vector[vector_id].right_endpoint >= mmin - original_time_series && area_vector[vector_id].right_endpoint >= mmax - original_time_series);
#endif

	//height
	area_vector[vector_id].min_point.value = *mmin;
	area_vector[vector_id].max_point.value = *mmax;
	area_vector[vector_id].rectangle_height = area_vector[vector_id].max_point.value - area_vector[vector_id].min_point.value;

#ifdef _DEBUG
	assert(area_vector[vector_id].rectangle_height >= 0);
#endif

	//minimax id
	area_vector[vector_id].min_point.id = mmin - original_time_series;
	area_vector[vector_id].max_point.id = mmax - original_time_series;
	//area_vector[vector_id].minmax_distance = fabs(area_vector[vector_id].max_point.id - area_vector[vector_id].min_point.id);
	area_vector[vector_id].minmax_distance = area_vector[vector_id].rectangle_height == 0 ? 0 : fabs(area_vector[vector_id].max_point.id - area_vector[vector_id].min_point.id);

	/*------------------------------Compute Segment Area----------------------------------------------------------*/
	area_vector[vector_id].rectangle_area = area_vector[vector_id].rectangle_height * area_vector[vector_id].rectangle_width;
	computeParallelogram(original_time_series, area_vector[vector_id]);//get area of parallelogram for every segment
	//getPolygonArea(original_time_series, area_vector[vector_id]);// get area of polygon for every segment
	//getConvexHullArea(original_time_series, area_vector[vector_id]);// get area of convex hull for every segment
	//getCircleArea(original_time_series, area_vector[vector_id]);// get area of circle for every segment
	/*-----------------------------------------------------------------------------------------------------------*/
	getSegmentDevByPLA(original_time_series, area_vector[vector_id]);
	area_vector[vector_id].getSegmentDensity();

	/*====================Evaluate refreshSegmentCoefficient=========================*/
#ifdef _DEBUG
	AREA_COEFFICIENT test_segment;
	test_segment.right_endpoint = area_vector[vector_id].right_endpoint;
	test_segment.rectangle_width = area_vector[vector_id].rectangle_width;
	test_segment.circle_radius = area_vector[vector_id].circle_radius;
	refreshSegmentCoefficient(original_time_series, test_segment);
	test_segment.compareSegmentCoefficient(area_vector[vector_id]);
#endif
	/*...............................................................................*/
}

//************************************
// Method:refreshSegmentCoefficient0ForParallelogram
// Qualifier: refresh segemnt, especially for the Parallelogram.
// date:190404
// author:
//************************************
TEMPLATE
typename APLA::AREA_COEFFICIENT& APLA::refreshSegmentCoefficient0ForParallelogram(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient) {//190404
#ifdef _DEBUG
	assert(temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF);
	assert(temp_coefficient.rectangle_width > 0);
	//int segment_left_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	//auto[mmin, mmax] = minmax_element(original_time_series + segment_left_id, original_time_series + int(temp_coefficient.right_endpoint + 1));
#endif
	/*====================190516 Test===============================*/

	int segment_left_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	auto [mmin, mmax] = minmax_element(original_time_series + segment_left_id, original_time_series + int(temp_coefficient.right_endpoint + 1));
	temp_coefficient.min_point.value = *mmin;
	temp_coefficient.max_point.value = *mmax;
	temp_coefficient.rectangle_height = temp_coefficient.max_point.value - temp_coefficient.min_point.value;

#ifdef _DEBUG
	assert(*mmax >= *mmin);
	assert(temp_coefficient.right_endpoint >= mmin - original_time_series && temp_coefficient.right_endpoint >= mmax - original_time_series);
	assert(temp_coefficient.rectangle_height >= 0);
#endif
	//minimax id
	temp_coefficient.min_point.id = mmin - original_time_series;
	temp_coefficient.max_point.id = mmax - original_time_series;

	/*...................................................*/

#ifdef _DEBUG
	assert(*mmax >= *mmin);
	assert(temp_coefficient.right_endpoint >= mmin - original_time_series && temp_coefficient.right_endpoint >= mmax - original_time_series);
	assert(temp_coefficient.rectangle_height >= 0);
#endif

	/*------------------------------Compute Segment Area----------------------------------------------------------*/
	//temp_coefficient.rectangle_area = temp_coefficient.rectangle_height * temp_coefficient.rectangle_width;
	//computeParallelogram(original_time_series, temp_coefficient);//get area of parallelogram for every segment
	computeParallelogramNoProjection(original_time_series, temp_coefficient);//190603
	//getPolygonArea(original_time_series, temp_coefficient);// get area of polygon for every segment
	//getConvexHullArea(original_time_series, temp_coefficient);// get area of convex hull for every segment
	//getCircleArea(original_time_series, temp_coefficient);// get area of circle for every segment
	/*-----------------------------------------------------------------------------------------------------------*/
	//temp_coefficient.getSegmentDensitySpeed();
	return temp_coefficient;
}

//************************************
// Method:refreshSegmentCoefficient0ForParallelogram
// Qualifier: refresh segemnt, especially for the Parallelogram.
// date:190404
// author:
//************************************
TEMPLATE
typename APLA::SEGMENT_COEFFICIENT& APLA::refreshSegmentCoefficient0ForParallelogram(DataType*& const original_time_series, SEGMENT_COEFFICIENT& const temp_coefficient) {//190419
#ifdef _DEBUG
	assert(temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF);
	assert(temp_coefficient.rectangle_width > 0);
	int segment_left_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	auto [mmin, mmax] = minmax_element(original_time_series + segment_left_id, original_time_series + int(temp_coefficient.right_endpoint + 1));
#endif

#ifdef _DEBUG
	assert(*mmax >= *mmin);
	assert(temp_coefficient.right_endpoint >= mmin - original_time_series && temp_coefficient.right_endpoint >= mmax - original_time_series);
	assert(temp_coefficient.rectangle_height >= 0);
#endif

	/*------------------------------Compute Segment Area----------------------------------------------------------*/
	//temp_coefficient.rectangle_area = temp_coefficient.rectangle_height * temp_coefficient.rectangle_width;
	//computeParallelogram(original_time_series, temp_coefficient);//get area of parallelogram for every segment
	computeParallelogramNoProjection(original_time_series, temp_coefficient);
	//getPolygonArea(original_time_series, temp_coefficient);// get area of polygon for every segment
	//getConvexHullArea(original_time_series, temp_coefficient);// get area of convex hull for every segment
	//getCircleArea(original_time_series, temp_coefficient);// get area of circle for every segment
	/*-----------------------------------------------------------------------------------------------------------*/
	temp_coefficient.getSegmentDensitySpeed();

	return temp_coefficient;
}

//************************************
// Method:computeRectangleCoefficient
// Qualifier: update adjacent rectangle after merge operation. Old, is replaced.
// date:181205
// author:
//************************************
TEMPLATE
void APLA::computeRectangleCoefficient(vector<AREA_COEFFICIENT>& area_vector, const int& const vector_id, const double& const lowest_id, const double& const lowest_value, const double& const heightest_id, const double& const heightest_value) {
	//
	//cout << "low id: " << lowest_id << "high id: " << heightest_id << endl;
#if _DEBUG
	assert(vector_id >= 0 && vector_id < area_vector.size());
	assert(heightest_value >= lowest_value);
	assert(area_vector.at(vector_id).right_endpoint >= lowest_id && area_vector.at(vector_id).right_endpoint >= heightest_id);
	if (vector_id > 0)
		assert(area_vector.at(vector_id - 1).right_endpoint < lowest_id&& area_vector.at(vector_id - 1).right_endpoint < heightest_id);
#endif

	AREA_COEFFICIENT temp_coefficient;

	//height
	area_vector.at(vector_id).min_point.value = lowest_value;
	area_vector.at(vector_id).max_point.value = heightest_value;
	area_vector.at(vector_id).rectangle_height = area_vector.at(vector_id).max_point.value - area_vector.at(vector_id).min_point.value;

	//area_vector.at(vector_id).lowest_value = area_vector.at(vector_id).min_point.value;
	//area_vector.at(vector_id).heightest_value = area_vector.at(vector_id).max_point.value;

	//width
	if (vector_id == 0)
		area_vector.at(vector_id).rectangle_width = area_vector.at(vector_id).right_endpoint + 1;
	else
		area_vector.at(vector_id).rectangle_width = area_vector.at(vector_id).right_endpoint - area_vector.at(vector_id - 1).right_endpoint;
	getRecWidth(area_vector, vector_id, 1, temp_coefficient);

#if _DEBUG
	assert(temp_coefficient.rectangle_width == area_vector.at(vector_id).rectangle_width);
	assert(area_vector[vector_id].rectangle_width > 0);
#endif
	//area
	area_vector.at(vector_id).rectangle_area = area_vector.at(vector_id).rectangle_height * area_vector.at(vector_id).rectangle_width;

	//temp_vector.merged_percentage = (area_vector.begin() + vector_id)->rectangle_area / temp_vector.rectangle_area;

	//minimax id
	area_vector[vector_id].min_point.id = lowest_id;
	area_vector[vector_id].max_point.id = heightest_id;
	area_vector[vector_id].minmax_distance = fabs(area_vector[vector_id].max_point.id - area_vector[vector_id].min_point.id);
}

//************************************
// Method:computeRectangleCoefficient
// Qualifier: update adjacent rectangle after merge operation. New version
// date:190319
// author:
//************************************
TEMPLATE
void APLA::computeRectangleCoefficient(vector<AREA_COEFFICIENT>& area_vector, const int& const vector_id, const typename GEOMETRY::POINT& const min_point, const typename GEOMETRY::POINT& const max_point) {//190319 Improve input argument of function
	//
	//cout << "low id: " << lowest_id << "high id: " << heightest_id << endl;
#if _DEBUG
	assert(vector_id >= 0 && vector_id < area_vector.size());
	assert(max_point.value >= min_point.value);
	assert(area_vector[vector_id].right_endpoint >= min_point.id && area_vector[vector_id].right_endpoint >= max_point.id);
	if (vector_id > 0)
		assert(area_vector[vector_id - 1].right_endpoint < min_point.id&& area_vector[vector_id - 1].right_endpoint < max_point.id);
#endif

	AREA_COEFFICIENT temp_coefficient;

	//height
	area_vector[vector_id].min_point.value = min_point.value;
	area_vector[vector_id].max_point.value = max_point.value;
	area_vector[vector_id].rectangle_height = area_vector[vector_id].max_point.value - area_vector[vector_id].min_point.value;

	//width
	/*if (vector_id == 0)
		area_vector.at(vector_id).rectangle_width = area_vector.at(vector_id).right_endpoint + 1;
	else
		area_vector.at(vector_id).rectangle_width = area_vector.at(vector_id).right_endpoint - area_vector.at(vector_id - 1).right_endpoint;*/
	getRecWidth(area_vector, vector_id, 1, temp_coefficient);
#if _DEBUG
	assert(temp_coefficient.rectangle_width == area_vector[vector_id].rectangle_width);
	assert(area_vector[vector_id].rectangle_width > 0);
#endif
	//minimax id
	area_vector[vector_id].min_point.id = min_point.id;
	area_vector[vector_id].max_point.id = max_point.id;
	area_vector[vector_id].minmax_distance = fabs(area_vector[vector_id].max_point.id - area_vector[vector_id].min_point.id);

	//area
	area_vector[vector_id].rectangle_area = area_vector[vector_id].rectangle_height * area_vector[vector_id].rectangle_width;
	/*------------------------------Compute Segment Area----------------------------------------------------------*/
	//temp_coefficient.rectangle_area = temp_coefficient.rectangle_height * temp_coefficient.rectangle_width;
	//computeParallelogram(original_time_series, temp_coefficient);//get area of parallelogram for every segment
	//getPolygonArea(original_time_series, temp_coefficient);// get area of polygon for every segment
	//getConvexHullArea(original_time_series, temp_coefficient);// get area of convex hull for every segment
	//getCircleArea(original_time_series, temp_coefficient);// get area of circle for every segment
	/*-----------------------------------------------------------------------------------------------------------*/
	//temp_vector.merged_percentage = (area_vector.begin() + vector_id)->rectangle_area / temp_vector.rectangle_area;
}

//************************************
// Method:updateRectangle
// Qualifier: update adjacent rectangle after merge operation
// date:181205
// author:
//************************************
TEMPLATE
bool APLA::updateRectangle(vector<AREA_COEFFICIENT>& area_vector, const int& const vector_id, DataType*& const original_time_series) {//181205 update adjacent rectangle after merge operation
	int left_id = vector_id - 1;
	//int right_id = vector_id + 1;

	if (vector_id > 0 && vector_id < area_vector.size()) {
		//get min_point & max_point
		//cout << area_vector[left_id].right_endpoint + 1 << " " << area_vector[vector_id].right_endpoint << endl;
		auto minmax = minmax_element(original_time_series + int(area_vector[left_id].right_endpoint + 1), original_time_series + int(area_vector[vector_id].right_endpoint + 1));
		//print result
		/*
		for (int array_id = (area_vector.begin() + left_id)->right_endpoint + 1; array_id <= int((area_vector.begin() + vector_id)->right_endpoint); array_id++) {
			cout << "id: " << array_id << ", value: " << original_time_series[array_id] << " ";
		}

		cout << endl;
		cout << "min is " << *minmax.first;
		cout << ", at position " << (minmax.first - original_time_series) << '\n';
		cout << "max is " << *minmax.second;
		cout << ", at position " << (minmax.second - original_time_series) << '\n';*/

		//Update coefficient
		computeRectangleCoefficient(area_vector, vector_id, minmax.first - original_time_series, *minmax.first, minmax.second - original_time_series, *minmax.second);
		//computeParallelogram(original_time_series, area_vector.at(vector_id));
		refreshSegmentCoefficient(original_time_series, area_vector, vector_id);
		return true;
	}
	else if (vector_id == 0) {
		auto minmax = minmax_element(original_time_series, original_time_series + int((area_vector.begin() + vector_id)->right_endpoint + 1));
		//print result
		/*cout << 0 << " " << int((area_vector.begin() + vector_id)->right_endpoint) << endl;
		for (int array_id = 0; array_id <= int((area_vector.begin() + vector_id)->right_endpoint); array_id++) {
			cout << "id: " << array_id << ", value: " << original_time_series[array_id] << " ";
		}

		cout << endl;
		cout << "min is " << *minmax.first;
		cout << ", at position " << (minmax.first - original_time_series) << '\n';
		cout << "max is " << *minmax.second;
		cout << ", at position " << (minmax.second - original_time_series) << '\n';*/

		//Update coefficient
		computeRectangleCoefficient(area_vector, vector_id, minmax.first - original_time_series, *minmax.first, minmax.second - original_time_series, *minmax.second);
		//computeParallelogram(original_time_series, area_vector.at(vector_id));
		refreshSegmentCoefficient(original_time_series, area_vector, vector_id);
		return true;
	}
	else {
		return false;
		assert(0);
	}

	assert(0);
}

//************************************
// Method:mergeRectangleRange
// Qualifier: MergeRangeRectangle
// date:181210
// author:
//************************************
TEMPLATE
void APLA::mergeRectangleRange(vector<AREA_COEFFICIENT>& area_vector, int& first_id, int& last_id, DataType*& const original_time_series) {//181210 Range
	int left_id = first_id - 1;
	//int right_id = vector_id + 1;
	vector<AREA_COEFFICIENT> temp_vector;
	//AREA_COEFFICIENT temp_right_coefficient;

	if (first_id > 0) {
		//get min_point & max_point
		auto minmax = minmax_element(original_time_series + int(area_vector[left_id].right_endpoint + 1), original_time_series + int(area_vector[last_id].right_endpoint + 1));
		//print result
		/*cout << int((area_vector.begin() + left_id)->right_endpoint) + 1 << " " << int((area_vector.begin() + last_id)->right_endpoint) << endl;
		for (int array_id = (area_vector.begin() + left_id)->right_endpoint + 1; array_id <= int((area_vector.begin() + last_id)->right_endpoint); array_id++) {
			cout << "id: " << array_id << ", value: " << original_time_series[array_id] << " ";
		}
		cout << endl;
		cout << "min is " << *minmax.first;
		cout << ", at position " << (minmax.first - original_time_series) << '\n';
		cout << "max is " << *minmax.second;
		cout << ", at position " << (minmax.second - original_time_series) << '\n';*/

		//erease rectangle
		area_vector.erase(area_vector.begin() + first_id, area_vector.begin() + last_id);
		last_id = first_id;

		//Update coefficient
		computeRectangleCoefficient(area_vector, last_id, minmax.first - original_time_series, *minmax.first, minmax.second - original_time_series, *minmax.second);
	}
	else if (first_id == 0) {
		auto minmax = minmax_element(original_time_series, original_time_series + int((area_vector.begin() + last_id)->right_endpoint + 1));
		//print result
		/*cout << 0 << " " << int((area_vector.begin() + last_id)->right_endpoint) << endl;
		for (int array_id = 0; array_id <= int((area_vector.begin() + last_id)->right_endpoint); array_id++) {
			cout << "id: " << array_id << ", value: " << original_time_series[array_id] << " ";
		}
		cout << endl;
		cout << "min is " << *minmax.first;
		cout << ", at position " << (minmax.first - original_time_series) << '\n';
		cout << "max is " << *minmax.second;
		cout << ", at position " << (minmax.second - original_time_series) << '\n';*/

		//erease rectangle
		area_vector.erase(area_vector.begin() + first_id, area_vector.begin() + last_id);
		last_id = first_id;

		//Update coefficient
		computeRectangleCoefficient(area_vector, last_id, minmax.first - original_time_series, *minmax.first, minmax.second - original_time_series, *minmax.second);
	}
	else {
		assert(0);
	}
}

//************************************
// Method:mergeRectangleRecursive
// Qualifier: MergeRangeRectangle
// date:190410
// author:
//************************************
TEMPLATE
bool APLA::mergeRectangleRecursive(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector, int vector_id) {//190410
	return true;
}

//************************************
// Method:judgeRecMonotonic
// Qualifier:
// date:181212
// author:
//************************************
TEMPLATE
bool APLA::isRecMonotonic(vector<AREA_COEFFICIENT>& area_vector, int& first_id, int& last_id) {//181212
	assert(first_id < last_id);

	int rec_id = NULL;
	int increase_count = 0;
	int decrease_count = 0;
	int interval_len = last_id - first_id;

	//cmp id
	for (rec_id = first_id; rec_id <= last_id; rec_id++) {
		if (area_vector[rec_id].max_point.id > area_vector[rec_id].min_point.id)
			increase_count++;
		if (area_vector[rec_id].max_point.id < area_vector[rec_id].min_point.id)
			decrease_count++;
	}

	//cmp value
	if (increase_count == interval_len + 1) {
		for (rec_id = first_id; rec_id < last_id; rec_id++) {
			if (area_vector[rec_id].max_point.value < area_vector[rec_id + 1].min_point.value)
				increase_count++;
			else
				return false;
		}
	}
	else if (decrease_count == interval_len + 1) {
		for (rec_id = first_id; rec_id < last_id; rec_id++) {
			if (area_vector[rec_id].min_point.value > area_vector[rec_id + 1].max_point.value)
				decrease_count++;
			else
				return false;
		}
	}
	else {
		return false;
	}

	assert(decrease_count != increase_count);

	if (decrease_count == interval_len * 2 + 1 || increase_count == interval_len * 2 + 1)
		return true;

	return false;
}

//************************************
// Method:moveRecEndpoint
// Qualifier: //181211 Update Left current and reight rectangle
// date:181211
// author:
//************************************
TEMPLATE
bool APLA::moveRecEndpoint(vector<AREA_COEFFICIENT>& area_vector, int& vector_id, DataType*& const original_time_series) {
	if (area_vector.size() < input_argument.point_dimension || area_vector[vector_id].rectangle_width < 4)
		return false;

	AREA_COEFFICIENT temp_right_coefficient, temp_left_coefficient;
	auto left_id = vector_id - 1;
	auto right_id = vector_id + 1;

	assert(area_vector[vector_id].right_endpoint >= area_vector[vector_id].max_point.id && area_vector[vector_id].right_endpoint >= area_vector[vector_id].min_point.id);
	if (left_id >= 0)
		assert(area_vector[left_id].right_endpoint < area_vector[vector_id].max_point.id&& area_vector[left_id].right_endpoint < area_vector[vector_id].min_point.id);
	if (right_id < area_vector.size())
		assert(area_vector[vector_id].right_endpoint < area_vector[right_id].max_point.id&& area_vector[vector_id].right_endpoint < area_vector[right_id].min_point.id);

	if (vector_id >= 1 && right_id < area_vector.size()) {
		//cout << "left id: " << left_id << ", right id: " << right_id << endl;

		/*if (isRecMonotonic(area_vector, left_id, right_id)) {
			mergeRectangleRange(area_vector, left_id, right_id, original_time_series);
		}*/

		if (area_vector[vector_id].max_point.id > area_vector[vector_id].min_point.id) {
			area_vector[vector_id].right_endpoint = area_vector[vector_id].max_point.id;
			area_vector[left_id].right_endpoint = area_vector[vector_id].min_point.id - 1;

			updateRectangle(area_vector, left_id, original_time_series);
			updateRectangle(area_vector, vector_id, original_time_series);
			updateRectangle(area_vector, right_id, original_time_series);

			if (area_vector[vector_id].max_point.value < area_vector[right_id].min_point.value && area_vector[right_id].min_point.id < area_vector[right_id].max_point.id
				&& area_vector[left_id].max_point.value < area_vector[vector_id].min_point.value && area_vector[left_id].min_point.id < area_vector[left_id].max_point.id) {
				//mergeRectangleRange(area_vector, left_id, right_id, original_time_series);
			}
			else if (area_vector[vector_id].max_point.value < area_vector[right_id].min_point.value && area_vector[right_id].min_point.id < area_vector[right_id].max_point.id) {
				getMergedInfo(original_time_series, area_vector, right_id, temp_right_coefficient);
				if (!isSymmetry(temp_right_coefficient, original_time_series)) {
					//mergeRectangle2(area_vector, right_id, temp_right_coefficient, original_time_series);
				}
			}
			else if (area_vector[left_id].max_point.value < area_vector[vector_id].min_point.value && area_vector[left_id].min_point.id < area_vector[left_id].max_point.id) {
				getMergedInfo(original_time_series, area_vector, vector_id, temp_left_coefficient);
				if (!isSymmetry(temp_left_coefficient, original_time_series)) {
					//mergeRectangle2(area_vector, vector_id, temp_left_coefficient, original_time_series);
				}
			}

			return true;
		}
		else if (area_vector[vector_id].max_point.id < area_vector[vector_id].min_point.id) {
			area_vector[vector_id].right_endpoint = area_vector[vector_id].min_point.id;
			area_vector[left_id].right_endpoint = area_vector[vector_id].max_point.id - 1;

			updateRectangle(area_vector, left_id, original_time_series);
			updateRectangle(area_vector, vector_id, original_time_series);
			updateRectangle(area_vector, right_id, original_time_series);

			if (area_vector[vector_id].min_point.value > area_vector[right_id].max_point.value && area_vector[right_id].max_point.id < area_vector[right_id].min_point.id
				&& area_vector[left_id].min_point.value > area_vector[vector_id].max_point.value && area_vector[left_id].max_point.id < area_vector[left_id].min_point.id) {
				//mergeRectangleRange(area_vector, left_id, right_id, original_time_series);
			}

			if (area_vector[vector_id].min_point.value > area_vector[right_id].max_point.value && area_vector[right_id].max_point.id < area_vector[right_id].min_point.id) {
				getMergedInfo(original_time_series, area_vector, right_id, temp_right_coefficient);
				if (!isSymmetry(temp_right_coefficient, original_time_series)) {
					//mergeRectangle2(area_vector, right_id, temp_right_coefficient, original_time_series);
				}
			}

			/*vector_id = right_id - 1;
			left_id = vector_id - 1;*/

			else if (area_vector[left_id].min_point.value > area_vector[vector_id].max_point.value && area_vector[left_id].max_point.id < area_vector[left_id].min_point.id) {
				getMergedInfo(original_time_series, area_vector, vector_id, temp_left_coefficient);
				if (!isSymmetry(temp_left_coefficient, original_time_series)) {
					//mergeRectangle2(area_vector, vector_id, temp_left_coefficient, original_time_series);
				}
			}

			return true;
		}
		else {
			assert(0);
		}

		//(area_vector.begin() + vector_id)->rectangle_area = ((area_vector.begin() + vector_id)->max_point.value - (area_vector.begin() + vector_id)->min_point.value) * ((area_vector.begin() + vector_id)->right_endpoint - (area_vector.begin() + left_id - 1)->right_endpoint - 1);
	}
	else if (vector_id == 0) {
		//cout << "vector_id == 0" << endl;
		assert(area_vector[vector_id].right_endpoint >= area_vector[vector_id].max_point.id && area_vector[vector_id].right_endpoint >= area_vector[vector_id].min_point.id);

		if (area_vector[vector_id].max_point.id > area_vector[vector_id].min_point.id) {
			area_vector[vector_id].right_endpoint = area_vector[vector_id].max_point.id;
			//area_vector[vector_id].right_endpoint = area_vector[vector_id].min_point.id;//181211 sovle the first rectangle too large

			updateRectangle(area_vector, left_id, original_time_series);
			updateRectangle(area_vector, vector_id, original_time_series);
			updateRectangle(area_vector, right_id, original_time_series);

			if (area_vector[vector_id].max_point.value < area_vector[right_id].min_point.value && area_vector[right_id].min_point.id < area_vector[right_id].max_point.id) {
				getMergedInfo(original_time_series, area_vector, right_id, temp_right_coefficient);
				if (!isSymmetry(temp_right_coefficient, original_time_series)) {
					//mergeRectangle2(area_vector, right_id, temp_right_coefficient, original_time_series);
				}
			}
			return true;
		}
		else if (area_vector[vector_id].max_point.id < area_vector[vector_id].min_point.id) {
			area_vector[vector_id].right_endpoint = area_vector[vector_id].min_point.id;
			//(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.max_point.id;

			updateRectangle(area_vector, left_id, original_time_series);
			updateRectangle(area_vector, vector_id, original_time_series);
			updateRectangle(area_vector, right_id, original_time_series);

			if (area_vector[vector_id].min_point.value > area_vector[right_id].max_point.value && area_vector[right_id].max_point.id < area_vector[right_id].min_point.id) {
				getMergedInfo(original_time_series, area_vector, right_id, temp_right_coefficient);
				if (!isSymmetry(temp_right_coefficient, original_time_series)) {
					//mergeRectangle2(area_vector, right_id, temp_right_coefficient, original_time_series);
				}
			}
			return true;
		}
		else {
			assert(0);
		}
	}
	else if (vector_id == area_vector.size() - 1) {
		cout << "vector_id == area_vector.size() - 1" << endl;
		assert(area_vector[vector_id].right_endpoint >= area_vector[vector_id].max_point.id && area_vector[vector_id].right_endpoint >= area_vector[vector_id].min_point.id);
		//if (left_id > 0)
		assert(area_vector[left_id].right_endpoint <= area_vector[vector_id].max_point.id && area_vector[left_id].right_endpoint <= area_vector[vector_id].min_point.id);

		if (area_vector[vector_id].max_point.id > area_vector[vector_id].min_point.id) {
			//(area_vector.begin() + vector_id)->right_endpoint = area_vector.at(vector_id).max_point.id;
			area_vector[left_id].right_endpoint = area_vector[vector_id].min_point.id - 1;

			updateRectangle(area_vector, left_id, original_time_series);
			updateRectangle(area_vector, vector_id, original_time_series);
			updateRectangle(area_vector, right_id, original_time_series);

			if (area_vector[left_id].max_point.value <= area_vector[vector_id].min_point.value && area_vector[left_id].min_point.id < area_vector[left_id].max_point.id) {
				getMergedInfo(original_time_series, area_vector, vector_id, temp_left_coefficient);
				if (!isSymmetry(temp_left_coefficient, original_time_series)) {
					mergeRectangle2(area_vector, vector_id, temp_left_coefficient, original_time_series);
				}
			}
			return true;
		}
		else if (area_vector[vector_id].max_point.id < area_vector[vector_id].min_point.id) {
			//area_vector[vector_id].right_endpoint = area_vector[vector_id].min_point.id;
			area_vector[left_id].right_endpoint = area_vector[vector_id].max_point.id - 1;

			updateRectangle(area_vector, left_id, original_time_series);
			updateRectangle(area_vector, vector_id, original_time_series);
			updateRectangle(area_vector, right_id, original_time_series);

			if (area_vector[left_id].min_point.value > area_vector[vector_id].max_point.value && area_vector[left_id].max_point.id < area_vector[left_id].min_point.id) {
				getMergedInfo(original_time_series, area_vector, vector_id, temp_left_coefficient);
				if (!isSymmetry(temp_left_coefficient, original_time_series)) {
					mergeRectangle2(area_vector, vector_id, temp_left_coefficient, original_time_series);
				}
			}
			return true;
		}
		else {
			assert(0);
		}
	}
	else {
		assert(0);
	}
}

//************************************
// Method: moveRectagnleEndpoint
// Qualifier: move right end point or left end point to peak or
// date:190319
// author:
//************************************
TEMPLATE
bool APLA::moveRectagnleEndpoint(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector, int vector_id) {
	if (area_vector.size() < input_argument.point_dimension || area_vector[vector_id].rectangle_width < 4)
		return false;

	AREA_COEFFICIENT temp_right_coefficient, temp_left_coefficient;
	int left_id = vector_id - 1;
	int right_id = vector_id + 1;

#ifdef _DEBUG
	//cout << "Move endpoint: " << endl;
	assert(area_vector[vector_id].right_endpoint >= area_vector[vector_id].max_point.id && area_vector[vector_id].right_endpoint >= area_vector[vector_id].min_point.id);
	if (left_id >= 0)
		assert(area_vector[left_id].right_endpoint < area_vector[vector_id].max_point.id&& area_vector[left_id].right_endpoint < area_vector[vector_id].min_point.id);
	if (right_id < area_vector.size())
		assert(area_vector[vector_id].right_endpoint < area_vector[right_id].max_point.id&& area_vector[vector_id].right_endpoint < area_vector[right_id].min_point.id);
#endif

	//move point
	//if (isSymmetry(temp_coefficient, original_time_series)) moveRecEndpoint(area_vector, vector_id, original_time_series);
	if (vector_id >= 1 && right_id < area_vector.size()) {
		//cout << "left id: " << left_id << ", right id: " << right_id << endl;

		/*if (isRecMonotonic(area_vector, left_id, right_id)) {
			mergeRectangleRange(area_vector, left_id, right_id, original_time_series);
		}*/
#ifdef _DEBUG
		assert(area_vector[vector_id].right_endpoint >= area_vector[vector_id].max_point.id && area_vector[vector_id].right_endpoint >= area_vector[vector_id].min_point.id);
		if (left_id > 0)
			assert(area_vector[left_id].right_endpoint <= area_vector[vector_id].max_point.id && area_vector[left_id].right_endpoint <= area_vector[vector_id].min_point.id);
#endif

		if (area_vector[vector_id].max_point.id > area_vector[vector_id].min_point.id) {
			//move right endpoint
			area_vector[vector_id].right_endpoint = area_vector[vector_id].max_point.id;
			area_vector[left_id].right_endpoint = area_vector[vector_id].min_point.id - 1;

			//refresh segment
			updateRectangle(area_vector, left_id, original_time_series);
			updateRectangle(area_vector, vector_id, original_time_series);
			updateRectangle(area_vector, right_id, original_time_series);

			if (area_vector[vector_id].max_point.value < area_vector[right_id].min_point.value && area_vector[right_id].min_point.id < area_vector[right_id].max_point.id
				&& area_vector[left_id].max_point.value < area_vector[vector_id].min_point.value && area_vector[left_id].min_point.id < area_vector[left_id].max_point.id) {
				//mergeRectangleRange(area_vector, left_id, right_id, original_time_series);
			}
			else if (area_vector[vector_id].max_point.value < area_vector[right_id].min_point.value && area_vector[right_id].min_point.id < area_vector[right_id].max_point.id) {
				getMergedInfo(original_time_series, area_vector, right_id, temp_right_coefficient);
				if (!isSymmetry(temp_right_coefficient, original_time_series)) {
					//mergeRectangle2(area_vector, right_id, temp_right_coefficient, original_time_series);
				}
			}
			else if (area_vector[left_id].max_point.value < area_vector[vector_id].min_point.value && area_vector[left_id].min_point.id < area_vector[left_id].max_point.id) {
				getMergedInfo(original_time_series, area_vector, vector_id, temp_left_coefficient);
				if (!isSymmetry(temp_left_coefficient, original_time_series)) {
					//mergeRectangle2(area_vector, vector_id, temp_left_coefficient, original_time_series);
				}
			}

			return true;
		}
		else if (area_vector[vector_id].max_point.id < area_vector[vector_id].min_point.id) {
			//move right endpoint
			area_vector[vector_id].right_endpoint = area_vector[vector_id].min_point.id;
			area_vector[left_id].right_endpoint = area_vector[vector_id].max_point.id - 1;

			//refresh segment
			updateRectangle(area_vector, left_id, original_time_series);
			updateRectangle(area_vector, vector_id, original_time_series);
			updateRectangle(area_vector, right_id, original_time_series);

			if (area_vector[vector_id].min_point.value > area_vector[right_id].max_point.value && area_vector[right_id].max_point.id < area_vector[right_id].min_point.id
				&& area_vector[left_id].min_point.value > area_vector[vector_id].max_point.value && area_vector[left_id].max_point.id < area_vector[left_id].min_point.id) {
				//mergeRectangleRange(area_vector, left_id, right_id, original_time_series);
			}
			else if (area_vector[vector_id].min_point.value > area_vector[right_id].max_point.value && area_vector[right_id].max_point.id < area_vector[right_id].min_point.id) {
				getMergedInfo(original_time_series, area_vector, right_id, temp_right_coefficient);
				if (!isSymmetry(temp_right_coefficient, original_time_series)) {
					//mergeRectangle2(area_vector, right_id, temp_right_coefficient, original_time_series);
				}
			}
			else if (area_vector[left_id].min_point.value > area_vector[vector_id].max_point.value && area_vector[left_id].max_point.id < area_vector[left_id].min_point.id) {
				getMergedInfo(original_time_series, area_vector, vector_id, temp_left_coefficient);
				if (!isSymmetry(temp_left_coefficient, original_time_series)) {
					//mergeRectangle2(area_vector, vector_id, temp_left_coefficient, original_time_series);
				}
			}

			return true;
		}
		else {
			assert(0);
		}

		//(area_vector.begin() + vector_id)->rectangle_area = ((area_vector.begin() + vector_id)->max_point.value - (area_vector.begin() + vector_id)->min_point.value) * (area_vector[vector_id].right_endpoint - (area_vector.begin() + left_id - 1)->right_endpoint - 1);
	}
	else if (vector_id == 0) {
		//cout << "vector_id == 0" << endl;
#ifdef _DEBUG
		assert(area_vector[vector_id].right_endpoint >= area_vector[vector_id].max_point.id && area_vector[vector_id].right_endpoint >= area_vector[vector_id].min_point.id);
#endif
		if (area_vector[vector_id].max_point.id > area_vector[vector_id].min_point.id) {
			//move right endpoint
			area_vector[vector_id].right_endpoint = area_vector[vector_id].max_point.id;
			//area_vector[vector_id].right_endpoint = area_vector[vector_id].min_point.id;//181211 sovle the first rectangle too large
			//refresh segment
			updateRectangle(area_vector, left_id, original_time_series);
			updateRectangle(area_vector, vector_id, original_time_series);
			updateRectangle(area_vector, right_id, original_time_series);

			if (area_vector[vector_id].max_point.value < area_vector[right_id].min_point.value && area_vector[right_id].min_point.id < area_vector[right_id].max_point.id) {
				getMergedInfo(original_time_series, area_vector, right_id, temp_right_coefficient);
				if (!isSymmetry(temp_right_coefficient, original_time_series)) {
					//mergeRectangle2(area_vector, right_id, temp_right_coefficient, original_time_series);
				}
			}
		}
		else if (area_vector[vector_id].max_point.id < area_vector[vector_id].min_point.id) {
			//move right endpoint
			area_vector[vector_id].right_endpoint = area_vector[vector_id].min_point.id;
			//area_vector[vector_id].right_endpoint = area_vector[vector_id].max_point.id;
			//refresh segment
			updateRectangle(area_vector, left_id, original_time_series);
			updateRectangle(area_vector, vector_id, original_time_series);
			updateRectangle(area_vector, right_id, original_time_series);

			if (area_vector[vector_id].min_point.value > area_vector[right_id].max_point.value && area_vector[right_id].max_point.id < area_vector[right_id].min_point.id) {
				getMergedInfo(original_time_series, area_vector, right_id, temp_right_coefficient);
				if (!isSymmetry(temp_right_coefficient, original_time_series)) {
					//mergeRectangle2(area_vector, right_id, temp_right_coefficient, original_time_series);
				}
			}
		}
		else {
			assert(0);
		}
	}
	else if (vector_id == area_vector.size() - 1) {
#ifdef _DEBUG
		//cout << "vector_id == area_vector.size() - 1" << endl;
		assert(area_vector[vector_id].right_endpoint >= area_vector[vector_id].max_point.id && area_vector[vector_id].right_endpoint >= area_vector[vector_id].min_point.id);
		//if (left_id > 0)
		assert(area_vector[left_id].right_endpoint <= area_vector[vector_id].max_point.id && area_vector[left_id].right_endpoint <= area_vector[vector_id].min_point.id);
#endif
		if (area_vector[vector_id].max_point.id > area_vector[vector_id].min_point.id) {
			//move right endpoint
			//area_vector[vector_id].right_endpoint = area_vector[vector_id].max_point.id;
			area_vector[left_id].right_endpoint = area_vector[vector_id].min_point.id - 1;
			//refresh segment
			updateRectangle(area_vector, left_id, original_time_series);
			updateRectangle(area_vector, vector_id, original_time_series);

			if (area_vector[left_id].max_point.value <= area_vector[vector_id].min_point.value && area_vector[left_id].min_point.id < area_vector[left_id].max_point.id) {
				getMergedInfo(original_time_series, area_vector, vector_id, temp_left_coefficient);
				if (!isSymmetry(temp_left_coefficient, original_time_series)) {
					//mergeRectangle2(area_vector, vector_id, temp_left_coefficient, original_time_series);
				}
			}
			return true;
		}
		else if (area_vector[vector_id].max_point.id < area_vector[vector_id].min_point.id) {
			//move right endpoint
			//area_vector[vector_id].right_endpoint = area_vector[vector_id].min_point.id;
			area_vector[left_id].right_endpoint = area_vector[vector_id].max_point.id - 1;
			//refresh segment
			updateRectangle(area_vector, left_id, original_time_series);
			updateRectangle(area_vector, vector_id, original_time_series);

			if (area_vector[left_id].min_point.value > area_vector[vector_id].max_point.value && area_vector[left_id].max_point.id < area_vector[left_id].min_point.id) {
				getMergedInfo(original_time_series, area_vector, vector_id, temp_left_coefficient);
				if (!isSymmetry(temp_left_coefficient, original_time_series)) {
					//mergeRectangle2(area_vector, vector_id, temp_left_coefficient, original_time_series);
				}
			}
			return true;
		}
		else {
			assert(0);
		}
	}
	else {
		assert(0);
	}
}

//190327
//************************************
// Method: moveRectagnleSplitpoint
// Qualifier: move right end point or left end point to peak or
// date:190327
// author:
//************************************
TEMPLATE
bool APLA::moveRectagnleSplitpoint(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector, int vector_id) {
#ifdef _DEBUG
	cout << "Move Split point: " << endl;
#endif
	if (area_vector.size() < input_argument.point_dimension || area_vector[vector_id].rectangle_width < 4)
		return false;

	AREA_COEFFICIENT temp_right_coefficient, temp_left_coefficient;
	int left_id = vector_id - 1;
	int right_id = vector_id + 1;

#ifdef _DEBUG
	assert(area_vector[vector_id].right_endpoint >= area_vector[vector_id].max_point.id && area_vector[vector_id].right_endpoint >= area_vector[vector_id].min_point.id);
	if (left_id >= 0)
		assert(area_vector[left_id].right_endpoint < area_vector[vector_id].max_point.id&& area_vector[left_id].right_endpoint < area_vector[vector_id].min_point.id);
	if (right_id < area_vector.size())
		assert(area_vector[vector_id].right_endpoint < area_vector[right_id].max_point.id&& area_vector[vector_id].right_endpoint < area_vector[right_id].min_point.id);
#endif

	//move point
	//if (isSymmetry(temp_coefficient, original_time_series)) moveRecEndpoint(area_vector, vector_id, original_time_series);
	if (vector_id >= 1 && right_id < area_vector.size()) {
		//cout << "left id: " << left_id << ", right id: " << right_id << endl;

		/*if (isRecMonotonic(area_vector, left_id, right_id)) {
			mergeRectangleRange(area_vector, left_id, right_id, original_time_series);
		}*/

		assert(area_vector[vector_id].right_endpoint >= area_vector[vector_id].max_point.id && area_vector[vector_id].right_endpoint >= area_vector[vector_id].min_point.id);
		if (left_id > 0)
			assert(area_vector[left_id].right_endpoint <= area_vector[vector_id].max_point.id && area_vector[left_id].right_endpoint <= area_vector[vector_id].min_point.id);

		if (area_vector[vector_id].max_point.id > area_vector[vector_id].min_point.id) {
			//move right endpoint
			/*area_vector[vector_id].right_endpoint = area_vector[vector_id].max_point.id;
			area_vector[left_id].right_endpoint = area_vector[vector_id].min_point.id - 1;*/
			area_vector[vector_id].right_endpoint = area_vector[vector_id].deviation_point.id;

			//refresh segment
			updateRectangle(area_vector, left_id, original_time_series);
			updateRectangle(area_vector, vector_id, original_time_series);
			updateRectangle(area_vector, right_id, original_time_series);

			if (area_vector[vector_id].max_point.value < area_vector[right_id].min_point.value && area_vector[right_id].min_point.id < area_vector[right_id].max_point.id
				&& area_vector[left_id].max_point.value < area_vector[vector_id].min_point.value && area_vector[left_id].min_point.id < area_vector[left_id].max_point.id) {
				//mergeRectangleRange(area_vector, left_id, right_id, original_time_series);
			}
			else if (area_vector[vector_id].max_point.value < area_vector[right_id].min_point.value && area_vector[right_id].min_point.id < area_vector[right_id].max_point.id) {
				getMergedInfo(original_time_series, area_vector, right_id, temp_right_coefficient);
				if (!isSymmetry(temp_right_coefficient, original_time_series)) {
					//mergeRectangle2(area_vector, right_id, temp_right_coefficient, original_time_series);
				}
			}
			else if (area_vector[left_id].max_point.value < area_vector[vector_id].min_point.value && area_vector[left_id].min_point.id < area_vector[left_id].max_point.id) {
				getMergedInfo(original_time_series, area_vector, vector_id, temp_left_coefficient);
				if (!isSymmetry(temp_left_coefficient, original_time_series)) {
					//mergeRectangle2(area_vector, vector_id, temp_left_coefficient, original_time_series);
				}
			}

			return true;
		}
		else if (area_vector[vector_id].max_point.id < area_vector[vector_id].min_point.id) {
			//move right endpoint
			//area_vector[vector_id].right_endpoint = area_vector[vector_id].min_point.id;
			//area_vector[left_id].right_endpoint = area_vector[vector_id].max_point.id - 1;

			area_vector[vector_id].right_endpoint = area_vector[vector_id].deviation_point.id;

			//refresh segment
			updateRectangle(area_vector, left_id, original_time_series);
			updateRectangle(area_vector, vector_id, original_time_series);
			updateRectangle(area_vector, right_id, original_time_series);

			if (area_vector[vector_id].min_point.value > area_vector[right_id].max_point.value && area_vector[right_id].max_point.id < area_vector[right_id].min_point.id
				&& area_vector[left_id].min_point.value > area_vector[vector_id].max_point.value && area_vector[left_id].max_point.id < area_vector[left_id].min_point.id) {
				//mergeRectangleRange(area_vector, left_id, right_id, original_time_series);
			}
			else if (area_vector[vector_id].min_point.value > area_vector[right_id].max_point.value && area_vector[right_id].max_point.id < area_vector[right_id].min_point.id) {
				getMergedInfo(original_time_series, area_vector, right_id, temp_right_coefficient);
				if (!isSymmetry(temp_right_coefficient, original_time_series)) {
					//mergeRectangle2(area_vector, right_id, temp_right_coefficient, original_time_series);
				}
			}
			else if (area_vector[left_id].min_point.value > area_vector[vector_id].max_point.value && area_vector[left_id].max_point.id < area_vector[left_id].min_point.id) {
				getMergedInfo(original_time_series, area_vector, vector_id, temp_left_coefficient);
				if (!isSymmetry(temp_left_coefficient, original_time_series)) {
					//mergeRectangle2(area_vector, vector_id, temp_left_coefficient, original_time_series);
				}
			}

			return true;
		}
		else {
			assert(0);
		}

		//(area_vector.begin() + vector_id)->rectangle_area = ((area_vector.begin() + vector_id)->max_point.value - (area_vector.begin() + vector_id)->min_point.value) * (area_vector[vector_id].right_endpoint - (area_vector.begin() + left_id - 1)->right_endpoint - 1);
	}
	else if (vector_id == 0) {
		//cout << "vector_id == 0" << endl;
		assert(area_vector[vector_id].right_endpoint >= area_vector[vector_id].max_point.id && area_vector[vector_id].right_endpoint >= area_vector[vector_id].min_point.id);

		if (area_vector[vector_id].max_point.id > area_vector[vector_id].min_point.id) {
			//move right endpoint
			area_vector[vector_id].right_endpoint = area_vector[vector_id].max_point.id;
			//area_vector[vector_id].right_endpoint = area_vector[vector_id].min_point.id;//181211 sovle the first rectangle too large
			area_vector[vector_id].right_endpoint = area_vector[vector_id].deviation_point.id;
			//refresh segment
			updateRectangle(area_vector, left_id, original_time_series);
			updateRectangle(area_vector, vector_id, original_time_series);
			updateRectangle(area_vector, right_id, original_time_series);

			if (area_vector[vector_id].max_point.value < area_vector[right_id].min_point.value && area_vector[right_id].min_point.id < area_vector[right_id].max_point.id) {
				getMergedInfo(original_time_series, area_vector, right_id, temp_right_coefficient);
				if (!isSymmetry(temp_right_coefficient, original_time_series)) {
					//mergeRectangle2(area_vector, right_id, temp_right_coefficient, original_time_series);
				}
			}
		}
		else if (area_vector[vector_id].max_point.id < area_vector[vector_id].min_point.id) {
			//move right endpoint
			area_vector[vector_id].right_endpoint = area_vector[vector_id].min_point.id;
			//area_vector[vector_id].right_endpoint = area_vector[vector_id].max_point.id;
			area_vector[vector_id].right_endpoint = area_vector[vector_id].deviation_point.id;
			//refresh segment
			updateRectangle(area_vector, left_id, original_time_series);
			updateRectangle(area_vector, vector_id, original_time_series);
			updateRectangle(area_vector, right_id, original_time_series);

			if (area_vector[vector_id].min_point.value > area_vector[right_id].max_point.value && area_vector[right_id].max_point.id < area_vector[right_id].min_point.id) {
				getMergedInfo(original_time_series, area_vector, right_id, temp_right_coefficient);
				if (!isSymmetry(temp_right_coefficient, original_time_series)) {
					//mergeRectangle2(area_vector, right_id, temp_right_coefficient, original_time_series);
				}
			}
		}
		else {
			assert(0);
		}
	}
	else if (vector_id == area_vector.size() - 1) {
		//cout << "vector_id == area_vector.size() - 1" << endl;
		assert(area_vector[vector_id].right_endpoint >= area_vector[vector_id].max_point.id && area_vector[vector_id].right_endpoint >= area_vector[vector_id].min_point.id);
		//if (left_id > 0)
		assert(area_vector[left_id].right_endpoint <= area_vector[vector_id].max_point.id && area_vector[left_id].right_endpoint <= area_vector[vector_id].min_point.id);

		if (area_vector[vector_id].max_point.id > area_vector[vector_id].min_point.id) {
			//move right endpoint
			//area_vector[vector_id].right_endpoint = area_vector[vector_id].max_point.id;
			//area_vector[left_id].right_endpoint = area_vector[vector_id].min_point.id - 1;
			area_vector[vector_id].right_endpoint = area_vector[vector_id].deviation_point.id;
			//refresh segment
			updateRectangle(area_vector, left_id, original_time_series);
			updateRectangle(area_vector, vector_id, original_time_series);

			if (area_vector[left_id].max_point.value <= area_vector[vector_id].min_point.value && area_vector[left_id].min_point.id < area_vector[left_id].max_point.id) {
				getMergedInfo(original_time_series, area_vector, vector_id, temp_left_coefficient);
				if (!isSymmetry(temp_left_coefficient, original_time_series)) {
					//mergeRectangle2(area_vector, vector_id, temp_left_coefficient, original_time_series);
				}
			}
			return true;
		}
		else if (area_vector[vector_id].max_point.id < area_vector[vector_id].min_point.id) {
			//move right endpoint
			//area_vector[vector_id].right_endpoint = area_vector[vector_id].min_point.id;
			//area_vector[left_id].right_endpoint = area_vector[vector_id].max_point.id - 1;
			area_vector[vector_id].right_endpoint = area_vector[vector_id].deviation_point.id;
			//refresh segment
			updateRectangle(area_vector, left_id, original_time_series);
			updateRectangle(area_vector, vector_id, original_time_series);

			if (area_vector[left_id].min_point.value > area_vector[vector_id].max_point.value && area_vector[left_id].max_point.id < area_vector[left_id].min_point.id) {
				getMergedInfo(original_time_series, area_vector, vector_id, temp_left_coefficient);
				if (!isSymmetry(temp_left_coefficient, original_time_series)) {
					//mergeRectangle2(area_vector, vector_id, temp_left_coefficient, original_time_series);
				}
			}
			return true;
		}
		else {
			assert(0);
		}
	}
	else {
		assert(0);
	}
}

//************************************
// Method:mergeRectangle
// Qualifier: right rectangle merge left rectangle
// date:181120
// author:
//************************************
TEMPLATE
void APLA::mergeRectangle(vector<AREA_COEFFICIENT>& area_vector, const int vector_id) {//181120
	int left_id = vector_id - 1;
	AREA_COEFFICIENT temp_left_coefficient;
	vector<AREA_COEFFICIENT> temp_left_merged_rec;

	getMergedInfo(area_vector, vector_id, temp_left_coefficient);
	temp_left_merged_rec.push_back(temp_left_coefficient);
	area_vector.at(vector_id) = temp_left_merged_rec.at(0);
	area_vector.erase(area_vector.begin() + left_id);

	//cout <<"end point: "<< (area_vector.begin() + vector_id)->right_endpoint<<endl;
	//if (vector_id > 1 ) {
	//	//cout << "left id: " << left_id << ", right id: " << right_id << endl;
	//	(area_vector.begin() + vector_id)->heightest_value = max((area_vector.begin() + vector_id)->heightest_value, (area_vector.begin() + left_id)->heightest_value);
	//	(area_vector.begin() + vector_id)->lowest_value = min((area_vector.begin() + vector_id)->lowest_value, (area_vector.begin() + left_id)->lowest_value);
	//	(area_vector.begin() + vector_id)->rectangle_area = ((area_vector.begin() + vector_id)->heightest_value - (area_vector.begin() + vector_id)->lowest_value) * ((area_vector.begin() + vector_id)->right_endpoint - (area_vector.begin() + left_id - 1)->right_endpoint - 1);
	//	area_vector.erase(area_vector.begin() + left_id);
	//
	//}
	//else if (vector_id <=1) {
	//		(area_vector.begin() + 1)->heightest_value = max(area_vector.begin()->heightest_value, (area_vector.begin() + 1)->heightest_value);
	//		(area_vector.begin() + 1)->lowest_value = min(area_vector.begin()->lowest_value, (area_vector.begin() + 1)->lowest_value);
	//		(area_vector.begin() + 1)->rectangle_area = ((area_vector.begin() + 1)->heightest_value - (area_vector.begin() + 1)->lowest_value) * (area_vector.begin() + 1)->right_endpoint;
	//		area_vector.erase(area_vector.begin());
	//}
	//else {
	//	assert(0);
	//}
}
//************************************
// Method:mergeRectangle
// Qualifier: right rectangle merge left rectangle
// date:181127
// author:
//*******************************
//TEMPLATE
//void APLA::mergeRectangle(vector<AREA_COEFFICIENT>& area_vector, const int vector_id, const double temp_heightest_id, const double temp_lowest_id) {//181127
//	int left_id = vector_id - 1;
//	int right_id = vector_id + 1;
//	cout << "end point: " << (area_vector.begin() + vector_id)->right_endpoint << endl;
//	if (vector_id > 1 && right_id < area_vector.size()) {
//		//cout << "left id: " << left_id << ", right id: " << right_id << endl;
//		assert((area_vector.begin() + vector_id)->right_endpoint >= temp_heightest_id && (area_vector.begin() + vector_id)->right_endpoint >= temp_lowest_id);
//		if(left_id > 0 )
//			assert((area_vector.begin() + left_id-1)->right_endpoint <= temp_heightest_id && (area_vector.begin() + left_id - 1)->right_endpoint <= temp_lowest_id);
//
//		(area_vector.begin() + vector_id)->heightest_value = max((area_vector.begin() + vector_id)->heightest_value, (area_vector.begin() + left_id)->heightest_value);
//		(area_vector.begin() + vector_id)->lowest_value = min((area_vector.begin() + vector_id)->lowest_value, (area_vector.begin() + left_id)->lowest_value);
//		(area_vector.begin() + vector_id)->heightest_id = temp_heightest_id;
//		(area_vector.begin() + vector_id)->lowest_id = temp_lowest_id;
//
//		if (temp_heightest_id > temp_lowest_id) {
//			if ((area_vector.begin() + right_id)->heightest_id < (area_vector.begin() + right_id)->lowest_id && (area_vector.begin() + vector_id)->heightest_value < (area_vector.begin() + right_id)->heightest_value) {
//				(area_vector.begin() + vector_id)->right_endpoint = (area_vector.begin() + right_id)->heightest_id;
//				(area_vector.begin() + vector_id)->heightest_id = (area_vector.begin() + right_id)->heightest_id;
//				(area_vector.begin() + vector_id)->heightest_value = (area_vector.begin() + right_id)->heightest_value;
//			}
//			else {
//				(area_vector.begin() + vector_id)->right_endpoint = temp_heightest_id;
//			}
//		}
//		else if (temp_heightest_id < temp_lowest_id) {
//			(area_vector.begin() + vector_id)->right_endpoint = temp_lowest_id;
//		}
//		else {
//			assert(0);
//		}
//
//		(area_vector.begin() + vector_id)->rectangle_area = ((area_vector.begin() + vector_id)->heightest_value - (area_vector.begin() + vector_id)->lowest_value) * ((area_vector.begin() + vector_id)->right_endpoint - (area_vector.begin() + left_id - 1)->right_endpoint - 1);
//
//		area_vector.erase(area_vector.begin() + left_id);
//
//	}
//	else if (vector_id <= 1) {
//
//		if (temp_heightest_id > temp_lowest_id) {
//			(area_vector.begin() + 1)->right_endpoint = temp_heightest_id;
//		}
//		else if (temp_heightest_id < temp_lowest_id) {
//			(area_vector.begin() + 1)->right_endpoint = temp_lowest_id;
//		}
//		else {
//			assert(0);
//		}
//
//		(area_vector.begin() + 1)->heightest_value = max(area_vector.begin()->heightest_value, (area_vector.begin() + 1)->heightest_value);
//		(area_vector.begin() + 1)->lowest_value = min(area_vector.begin()->lowest_value, (area_vector.begin() + 1)->lowest_value);
//		(area_vector.begin() + 1)->rectangle_area = ((area_vector.begin() + 1)->heightest_value - (area_vector.begin() + 1)->lowest_value) * (area_vector.begin() + 1)->right_endpoint;
//		(area_vector.begin() + 1)->heightest_id = temp_heightest_id;
//		(area_vector.begin() + 1)->lowest_id = temp_lowest_id;
//
//		area_vector.erase(area_vector.begin());
//	}
//	else {
//		assert(0);
//		assert((area_vector.begin() + vector_id)->right_endpoint >= temp_heightest_id && (area_vector.begin() + vector_id)->right_endpoint >= temp_lowest_id);
//		if (left_id > 0)
//			assert((area_vector.begin() + left_id - 1)->right_endpoint <= temp_heightest_id && (area_vector.begin() + left_id - 1)->right_endpoint <= temp_lowest_id);
//
//		(area_vector.begin() + vector_id)->heightest_value = max((area_vector.begin() + vector_id)->heightest_value, (area_vector.begin() + left_id)->heightest_value);
//		(area_vector.begin() + vector_id)->lowest_value = min((area_vector.begin() + vector_id)->lowest_value, (area_vector.begin() + left_id)->lowest_value);
//		(area_vector.begin() + vector_id)->heightest_id = temp_heightest_id;
//		(area_vector.begin() + vector_id)->lowest_id = temp_lowest_id;
//
//		if (temp_heightest_id > temp_lowest_id) {
//
//			(area_vector.begin() + vector_id)->right_endpoint = temp_heightest_id;
//			(area_vector.begin() + vector_id)->heightest_id = temp_heightest_id;
//
//		}
//		else if (temp_heightest_id < temp_lowest_id) {
//			(area_vector.begin() + vector_id)->right_endpoint = temp_lowest_id;
//		}
//		else {
//			assert(0);
//		}
//
//		(area_vector.begin() + vector_id)->rectangle_area = ((area_vector.begin() + vector_id)->heightest_value - (area_vector.begin() + vector_id)->lowest_value) * ((area_vector.begin() + vector_id)->right_endpoint - (area_vector.begin() + left_id - 1)->right_endpoint - 1);
//		area_vector.erase(area_vector.begin() + left_id);
//
//	}
//}

//************************************
// Method:mergeRectangle
// Qualifier: rcurrent rectangle merge.  No recursive.
// date:181205
// author:
//*******************************
TEMPLATE
void APLA::mergeRectangle(vector<AREA_COEFFICIENT>& area_vector, int& vector_id, const AREA_COEFFICIENT& const temp_coefficient, DataType*& const original_time_series) {//181205
	assert(temp_coefficient.heightest_value - temp_coefficient.lowest_value == temp_coefficient.rectangle_height);
	assert(fabs(temp_coefficient.heightest_id - temp_coefficient.lowest_id) == temp_coefficient.minmax_distance);

	int left_id = vector_id - 1;
	int right_id = vector_id + 1;
	vector<AREA_COEFFICIENT> temp_vector;
	//AREA_COEFFICIENT temp_right_coefficient;

	temp_vector.push_back(temp_coefficient);
	area_vector.at(vector_id) = temp_vector.at(0);
	area_vector.erase(area_vector.begin() + left_id);
	left_id--;
	vector_id--;
	right_id--;

	//cout << "end point: " << (area_vector.begin() + vector_id)->right_endpoint << endl;

	if (vector_id >= 0 && right_id < area_vector.size()) {
		//cout << "left id: " << left_id << ", right id: " << right_id << endl;
		assert((area_vector.begin() + vector_id)->right_endpoint >= temp_coefficient.heightest_id && (area_vector.begin() + vector_id)->right_endpoint >= temp_coefficient.lowest_id);
		if (left_id > 0)
			assert((area_vector.begin() + left_id)->right_endpoint <= temp_coefficient.heightest_id && (area_vector.begin() + left_id)->right_endpoint <= temp_coefficient.lowest_id);

		if (temp_coefficient.heightest_id > temp_coefficient.lowest_id) {
			(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.heightest_id;
			/*if (area_vector.at(vector_id).heightest_value <= area_vector.at(right_id).lowest_value && area_vector.at(right_id).lowest_id < area_vector.at(right_id).heightest_id) {
				getMergedInfo(area_vector, right_id, temp_right_coefficient);
				mergeRectangle(area_vector, right_id, temp_right_coefficient, original_time_series);
			}*/
		}
		else if (temp_coefficient.heightest_id < temp_coefficient.lowest_id) {
			(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.lowest_id;
			/*if (area_vector.at(vector_id).lowest_value <= area_vector.at(right_id).heightest_value && area_vector.at(right_id).heightest_id < area_vector.at(right_id).lowest_id) {
				getMergedInfo(area_vector, right_id, temp_right_coefficient);
				mergeRectangle(area_vector, right_id, temp_right_coefficient, original_time_series);
			}*/
		}
		else {
			assert(0);
		}

		updateRectangle(area_vector, vector_id, original_time_series);
		updateRectangle(area_vector, right_id, original_time_series);

		//(area_vector.begin() + vector_id)->rectangle_area = ((area_vector.begin() + vector_id)->heightest_value - (area_vector.begin() + vector_id)->lowest_value) * ((area_vector.begin() + vector_id)->right_endpoint - (area_vector.begin() + left_id - 1)->right_endpoint - 1);
	}
	//else if (vector_id == 1) {
	//	//assert(0);
	//	assert((area_vector.begin() + vector_id)->right_endpoint >= temp_coefficient.heightest_id && (area_vector.begin() + vector_id)->right_endpoint >= temp_coefficient.lowest_id);
	//
	//	if (temp_coefficient.heightest_id > temp_coefficient.lowest_id) {
	//		(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.heightest_id;
	//	}
	//	else if (temp_coefficient.heightest_id < temp_coefficient.lowest_id) {
	//		(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.lowest_id;
	//	}
	//	else {
	//		assert(0);
	//	}

	//	(area_vector.begin() + 1)->heightest_value = max(area_vector.begin()->heightest_value, (area_vector.begin() + 1)->heightest_value);
	//	(area_vector.begin() + 1)->lowest_value = min(area_vector.begin()->lowest_value, (area_vector.begin() + 1)->lowest_value);
	//	(area_vector.begin() + 1)->rectangle_area = ((area_vector.begin() + 1)->heightest_value - (area_vector.begin() + 1)->lowest_value) * (area_vector.begin() + 1)->right_endpoint;
	//	(area_vector.begin() + 1)->heightest_id = temp_coefficient.heightest_id;
	//	(area_vector.begin() + 1)->lowest_id = temp_coefficient.lowest_id;

	//	//area_vector.erase(area_vector.begin());
	//}
	else if (vector_id == area_vector.size() - 1) {
		//assert(0);
		assert((area_vector.begin() + vector_id)->right_endpoint >= temp_coefficient.heightest_id && (area_vector.begin() + vector_id)->right_endpoint >= temp_coefficient.lowest_id);
		//if (left_id > 0)
		assert((area_vector.begin() + left_id)->right_endpoint <= temp_coefficient.heightest_id && (area_vector.begin() + left_id)->right_endpoint <= temp_coefficient.lowest_id);

		if (temp_coefficient.heightest_id > temp_coefficient.lowest_id) {
			(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.heightest_id;
		}
		else if (temp_coefficient.heightest_id < temp_coefficient.lowest_id) {
			(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.lowest_id;
		}
		else {
			assert(0);
		}
		updateRectangle(area_vector, vector_id, original_time_series);
		//area_vector.erase(area_vector.begin()+left_id);
	}
	else {
		assert(0);
	}
}

//************************************
// Method:mergeRectangle
// Qualifier: current rectangle merge right rectangle if current heightest value< right lowest value. merge. recursive
// date:181210
// author:
//*******************************
TEMPLATE
void APLA::mergeRectangle0(vector<AREA_COEFFICIENT>& area_vector, int& vector_id, const AREA_COEFFICIENT& const temp_coefficient, DataType*& const original_time_series) {//181210
	assert(temp_coefficient.heightest_value - temp_coefficient.lowest_value == temp_coefficient.rectangle_height);
	assert(fabs(temp_coefficient.heightest_id - temp_coefficient.lowest_id) == temp_coefficient.minmax_distance);

	int left_id = vector_id - 1;
	int right_id = vector_id + 1;
	vector<AREA_COEFFICIENT> temp_vector;
	AREA_COEFFICIENT temp_right_coefficient;

	temp_vector.push_back(temp_coefficient);
	area_vector.at(vector_id) = temp_vector.at(0);
	area_vector.erase(area_vector.begin() + left_id);
	left_id--;
	vector_id--;
	right_id--;

	//cout << "end point: " << (area_vector.begin() + vector_id)->right_endpoint << endl;

	if (vector_id >= 0 && right_id < area_vector.size()) {
		//cout << "left id: " << left_id << ", right id: " << right_id << endl;
		assert((area_vector.begin() + vector_id)->right_endpoint >= temp_coefficient.heightest_id && (area_vector.begin() + vector_id)->right_endpoint >= temp_coefficient.lowest_id);
		if (left_id > 0)
			assert((area_vector.begin() + left_id)->right_endpoint <= temp_coefficient.heightest_id && (area_vector.begin() + left_id)->right_endpoint <= temp_coefficient.lowest_id);

		if (temp_coefficient.heightest_id > temp_coefficient.lowest_id) {
			(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.heightest_id;
			updateRectangle(area_vector, vector_id, original_time_series);
			updateRectangle(area_vector, right_id, original_time_series);
			if (area_vector.at(vector_id).heightest_value < area_vector.at(right_id).lowest_value && area_vector.at(right_id).lowest_id < area_vector.at(right_id).heightest_id) {
				getMergedInfo(area_vector, right_id, temp_right_coefficient);
				mergeRectangle0(area_vector, right_id, temp_right_coefficient, original_time_series);
			}
		}
		else if (temp_coefficient.heightest_id < temp_coefficient.lowest_id) {
			(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.lowest_id;
			updateRectangle(area_vector, vector_id, original_time_series);
			updateRectangle(area_vector, right_id, original_time_series);
			if (area_vector.at(vector_id).lowest_value > area_vector.at(right_id).heightest_value && area_vector.at(right_id).heightest_id < area_vector.at(right_id).lowest_id) {
				getMergedInfo(area_vector, right_id, temp_right_coefficient);
				mergeRectangle0(area_vector, right_id, temp_right_coefficient, original_time_series);
			}
		}
		else {
			assert(0);
		}

		//(area_vector.begin() + vector_id)->rectangle_area = ((area_vector.begin() + vector_id)->heightest_value - (area_vector.begin() + vector_id)->lowest_value) * ((area_vector.begin() + vector_id)->right_endpoint - (area_vector.begin() + left_id - 1)->right_endpoint - 1);
	}
	//else if (vector_id == 1) {
	//	//assert(0);
	//	assert((area_vector.begin() + vector_id)->right_endpoint >= temp_coefficient.heightest_id && (area_vector.begin() + vector_id)->right_endpoint >= temp_coefficient.lowest_id);
	//
	//	if (temp_coefficient.heightest_id > temp_coefficient.lowest_id) {
	//		(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.heightest_id;
	//	}
	//	else if (temp_coefficient.heightest_id < temp_coefficient.lowest_id) {
	//		(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.lowest_id;
	//	}
	//	else {
	//		assert(0);
	//	}

	//	(area_vector.begin() + 1)->heightest_value = max(area_vector.begin()->heightest_value, (area_vector.begin() + 1)->heightest_value);
	//	(area_vector.begin() + 1)->lowest_value = min(area_vector.begin()->lowest_value, (area_vector.begin() + 1)->lowest_value);
	//	(area_vector.begin() + 1)->rectangle_area = ((area_vector.begin() + 1)->heightest_value - (area_vector.begin() + 1)->lowest_value) * (area_vector.begin() + 1)->right_endpoint;
	//	(area_vector.begin() + 1)->heightest_id = temp_coefficient.heightest_id;
	//	(area_vector.begin() + 1)->lowest_id = temp_coefficient.lowest_id;

	//	//area_vector.erase(area_vector.begin());
	//}
	else if (vector_id == area_vector.size() - 1) {
		//assert(0);
		assert((area_vector.begin() + vector_id)->right_endpoint >= temp_coefficient.heightest_id && (area_vector.begin() + vector_id)->right_endpoint >= temp_coefficient.lowest_id);
		//if (left_id > 0)
		assert((area_vector.begin() + left_id)->right_endpoint <= temp_coefficient.heightest_id && (area_vector.begin() + left_id)->right_endpoint <= temp_coefficient.lowest_id);
		/*	(area_vector.begin() + vector_id)->heightest_value = max((area_vector.begin() + vector_id)->heightest_value, (area_vector.begin() + left_id)->heightest_value);
			(area_vector.begin() + vector_id)->lowest_value = min((area_vector.begin() + vector_id)->lowest_value, (area_vector.begin() + left_id)->lowest_value);
			(area_vector.begin() + vector_id)->heightest_id = temp_coefficient.heightest_id;
			(area_vector.begin() + vector_id)->lowest_id = temp_coefficient.lowest_id;*/

		if (temp_coefficient.heightest_id > temp_coefficient.lowest_id) {
			(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.heightest_id;
		}
		else if (temp_coefficient.heightest_id < temp_coefficient.lowest_id) {
			(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.lowest_id;
		}
		else {
			assert(0);
		}
		updateRectangle(area_vector, vector_id, original_time_series);
		//area_vector.erase(area_vector.begin()+left_id);
	}
	else {
		assert(0);
	}
}

//************************************
// Method:mergeRectangle1
// Qualifier: current rectangle merge right rectangle and left rectangle. merge. No recursive
// date:181210
// author:
//*******************************
TEMPLATE
void APLA::mergeRectangle1(vector<AREA_COEFFICIENT>& area_vector, int& vector_id, const AREA_COEFFICIENT& const temp_coefficient, DataType*& const original_time_series) {//181210
	assert(temp_coefficient.heightest_value - temp_coefficient.lowest_value == temp_coefficient.rectangle_height);
	assert(fabs(temp_coefficient.heightest_id - temp_coefficient.lowest_id) == temp_coefficient.minmax_distance);

	int left_id = vector_id - 1;
	int right_id = vector_id + 1;
	vector<AREA_COEFFICIENT> temp_vector;
	//AREA_COEFFICIENT temp_right_coefficient;

	temp_vector.push_back(temp_coefficient);
	area_vector.at(vector_id) = temp_vector.at(0);
	area_vector.erase(area_vector.begin() + left_id);
	left_id--;
	vector_id--;
	right_id--;

	//cout << "end point: " << (area_vector.begin() + vector_id)->right_endpoint << endl;

	if (vector_id >= 1 && right_id < area_vector.size()) {
		//cout << "left id: " << left_id << ", right id: " << right_id << endl;
		assert((area_vector.begin() + vector_id)->right_endpoint >= temp_coefficient.heightest_id && (area_vector.begin() + vector_id)->right_endpoint >= temp_coefficient.lowest_id);
		if (left_id > 0)
			assert((area_vector.begin() + left_id)->right_endpoint <= temp_coefficient.heightest_id && (area_vector.begin() + left_id)->right_endpoint <= temp_coefficient.lowest_id);

		if (temp_coefficient.heightest_id > temp_coefficient.lowest_id) {
			(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.heightest_id;
			(area_vector.begin() + left_id)->right_endpoint = temp_coefficient.lowest_id - 1;
			/*if (area_vector.at(vector_id).heightest_value <= area_vector.at(right_id).lowest_value && area_vector.at(right_id).lowest_id < area_vector.at(right_id).heightest_id) {
				getMergedInfo(area_vector, right_id, temp_right_coefficient);
				mergeRectangle(area_vector, right_id, temp_right_coefficient, original_time_series);
			}*/
		}
		else if (temp_coefficient.heightest_id < temp_coefficient.lowest_id) {
			(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.lowest_id;
			(area_vector.begin() + left_id)->right_endpoint = temp_coefficient.heightest_id - 1;
			/*if (area_vector.at(vector_id).lowest_value > area_vector.at(right_id).heightest_value && area_vector.at(right_id).heightest_id < area_vector.at(right_id).lowest_id) {
				getMergedInfo(area_vector, right_id, temp_right_coefficient);
				mergeRectangle(area_vector, right_id, temp_right_coefficient, original_time_series);
			}*/
		}
		else {
			assert(0);
		}

		updateRectangle(area_vector, left_id, original_time_series);
		updateRectangle(area_vector, vector_id, original_time_series);
		updateRectangle(area_vector, right_id, original_time_series);

		//(area_vector.begin() + vector_id)->rectangle_area = ((area_vector.begin() + vector_id)->heightest_value - (area_vector.begin() + vector_id)->lowest_value) * ((area_vector.begin() + vector_id)->right_endpoint - (area_vector.begin() + left_id - 1)->right_endpoint - 1);
	}
	else if (vector_id == 0) {
		//assert(0);
		assert((area_vector.begin() + vector_id)->right_endpoint >= temp_coefficient.heightest_id && (area_vector.begin() + vector_id)->right_endpoint >= temp_coefficient.lowest_id);

		if (temp_coefficient.heightest_id > temp_coefficient.lowest_id) {
			(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.heightest_id;
		}
		else if (temp_coefficient.heightest_id < temp_coefficient.lowest_id) {
			(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.lowest_id;
		}
		else {
			assert(0);
		}

		updateRectangle(area_vector, vector_id, original_time_series);
		updateRectangle(area_vector, right_id, original_time_series);
	}
	else if (vector_id == area_vector.size() - 1) {
		//assert(0);
		assert((area_vector.begin() + vector_id)->right_endpoint >= temp_coefficient.heightest_id && (area_vector.begin() + vector_id)->right_endpoint >= temp_coefficient.lowest_id);
		//if (left_id > 0)
		assert((area_vector.begin() + left_id)->right_endpoint <= temp_coefficient.heightest_id && (area_vector.begin() + left_id)->right_endpoint <= temp_coefficient.lowest_id);

		if (temp_coefficient.heightest_id > temp_coefficient.lowest_id) {
			(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.heightest_id;
			(area_vector.begin() + left_id)->right_endpoint = temp_coefficient.lowest_id - 1;
		}
		else if (temp_coefficient.heightest_id < temp_coefficient.lowest_id) {
			(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.lowest_id;
			(area_vector.begin() + left_id)->right_endpoint = temp_coefficient.heightest_id - 1;
		}
		else {
			assert(0);
		}

		updateRectangle(area_vector, left_id, original_time_series);
		updateRectangle(area_vector, vector_id, original_time_series);
		//area_vector.erase(area_vector.begin()+left_id);
	}
	else {
		assert(0);
	}
}

//************************************
// Method:mergeRectangle2
// Qualifier: current rectangle merge right rectangle and left rectangle. merge. recursive
// date:181210
// author:
//*************************************
TEMPLATE
void APLA::mergeRectangle2(vector<AREA_COEFFICIENT>& area_vector, int& vector_id, const AREA_COEFFICIENT& const temp_coefficient, DataType*& const original_time_series) {//181210 recursive
	//assert(temp_coefficient.max_point.value != INF);
	//cout << "mergeRectangle2()" << endl;
	//cout << "		id: " << vector_id << endl;
	int left_id = vector_id - 1;
	int right_id = vector_id + 1;
	vector<AREA_COEFFICIENT> temp_vector{ temp_coefficient };
	//AREA_COEFFICIENT temp_right_coefficient, temp_left_coefficient;

	/*-------------------------------------------------------------assert------------------------------------------------------------*/
#ifdef _DEBUG
	//assert(temp_coefficient.rectangle_area != NULL);//190313
	assert(temp_coefficient.max_point.value - temp_coefficient.min_point.value == temp_coefficient.rectangle_height);
	assert(area_vector[vector_id].right_endpoint >= temp_coefficient.max_point.id && area_vector[vector_id].right_endpoint >= temp_coefficient.min_point.id);
	if (left_id >= 0)
		assert(area_vector[left_id].right_endpoint < area_vector[vector_id].max_point.id&& area_vector[left_id].right_endpoint < area_vector[vector_id].min_point.id);
#endif
	/*_______________________________________________________________________________________________________________________________   */

	/*----------------------------------------------------------*Megrge Process*------------------------------------------------------------*/
	area_vector[vector_id] = temp_vector.front();// .at(0);
	area_vector.erase(area_vector.begin() + left_id);
	left_id--;
	vector_id--;
	right_id--;
	//cout << "		id: " << vector_id << endl;
	/*_______________________________________________________________________________________________________________________________   */

	/*-------------------------------------------------------------assert------------------------------------------------------------*/
#ifdef _DEBUG
	if (left_id > 0)
		assert((area_vector.begin() + left_id)->right_endpoint <= temp_coefficient.max_point.id && (area_vector.begin() + left_id)->right_endpoint <= temp_coefficient.min_point.id);
	if (left_id >= 0)
		assert(area_vector.at(left_id).right_endpoint < area_vector.at(vector_id).max_point.id&& area_vector.at(left_id).right_endpoint < area_vector.at(vector_id).min_point.id);
#endif
	/*_______________________________________________________________________________________________________________________________   */

	/*-------------------------------------------------------------move point------------------------------------------------------------*/
	//moveRectagnleEndpoint(original_time_series, area_vector, vector_id);
	/*_______________________________________________________________________________________________________________________________   */

	if (isSymmetry(area_vector[vector_id], original_time_series)) {
		//moveRectagnleEndpoint(original_time_series, area_vector, vector_id);
		//splitRectangle(original_time_series, area_vector, vector_id);
		//moveRectagnleSplitpoint(original_time_series, area_vector, vector_id);
	}

	//if (vector_id >= 1 && right_id < area_vector.size()) {
	//	//cout << "left id: " << left_id << ", right id: " << right_id << endl;
	//	assert((area_vector.begin() + vector_id)->right_endpoint >= temp_coefficient.max_point.id && (area_vector.begin() + vector_id)->right_endpoint >= temp_coefficient.min_point.id);
	//	if (left_id > 0)
	//		assert((area_vector.begin() + left_id)->right_endpoint <= temp_coefficient.max_point.id && (area_vector.begin() + left_id)->right_endpoint <= temp_coefficient.min_point.id);

	//	if (temp_coefficient.max_point.id > temp_coefficient.min_point.id) {
	//		(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.max_point.id;
	//		(area_vector.begin() + left_id)->right_endpoint = temp_coefficient.min_point.id - 1;

	//		updateRectangle(area_vector, left_id, original_time_series);
	//		updateRectangle(area_vector, vector_id, original_time_series);
	//		updateRectangle(area_vector, right_id, original_time_series);

	//		if (area_vector.at(vector_id).heightest_value < area_vector.at(right_id).lowest_value && area_vector.at(right_id).min_point.id < area_vector.at(right_id).max_point.id
	//			&&area_vector.at(left_id).heightest_value < area_vector.at(vector_id).lowest_value && area_vector.at(left_id).min_point.id < area_vector.at(left_id).max_point.id) {
	//			//mergeRectangleRange(area_vector, left_id, right_id, original_time_series);
	//		}
	//		else if (area_vector.at(vector_id).heightest_value <= area_vector.at(right_id).lowest_value && area_vector.at(right_id).min_point.id < area_vector.at(right_id).max_point.id) {
	//			getMergedInfo(area_vector, right_id, temp_right_coefficient);
	//			mergeRectangle2(area_vector, right_id, temp_right_coefficient, original_time_series);
	//		}
	//		else if (area_vector.at(left_id).heightest_value < area_vector.at(vector_id).lowest_value && area_vector.at(left_id).min_point.id < area_vector.at(left_id).max_point.id) {
	//			getMergedInfo(area_vector, vector_id, temp_left_coefficient);
	//			mergeRectangle2(area_vector, vector_id, temp_left_coefficient, original_time_series);
	//		}
	//	}
	//	else if (temp_coefficient.max_point.id < temp_coefficient.min_point.id) {
	//		(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.min_point.id;
	//		(area_vector.begin() + left_id)->right_endpoint = temp_coefficient.max_point.id - 1;

	//		updateRectangle(area_vector, left_id, original_time_series);
	//		updateRectangle(area_vector, vector_id, original_time_series);
	//		updateRectangle(area_vector, right_id, original_time_series);

	//		if (area_vector.at(vector_id).lowest_value > area_vector.at(right_id).heightest_value && area_vector.at(right_id).max_point.id < area_vector.at(right_id).min_point.id
	//			&& area_vector.at(left_id).lowest_value > area_vector.at(vector_id).heightest_value && area_vector.at(left_id).max_point.id < area_vector.at(left_id).min_point.id) {
	//			//mergeRectangleRange(area_vector, left_id, right_id, original_time_series);
	//		}
	//		else if (area_vector.at(vector_id).lowest_value > area_vector.at(right_id).heightest_value && area_vector.at(right_id).max_point.id < area_vector.at(right_id).min_point.id) {
	//			getMergedInfo(area_vector, right_id, temp_right_coefficient);
	//			mergeRectangle2(area_vector, right_id, temp_right_coefficient, original_time_series);
	//		}
	//		else if (area_vector.at(left_id).lowest_value > area_vector.at(vector_id).heightest_value && area_vector.at(left_id).max_point.id < area_vector.at(left_id).min_point.id) {
	//			getMergedInfo(area_vector, vector_id, temp_left_coefficient);
	//			mergeRectangle2(area_vector, vector_id, temp_left_coefficient, original_time_series);
	//		}
	//	}
	//	else {
	//		assert(0);
	//	}

	//	//(area_vector.begin() + vector_id)->rectangle_area = ((area_vector.begin() + vector_id)->heightest_value - (area_vector.begin() + vector_id)->lowest_value) * ((area_vector.begin() + vector_id)->right_endpoint - (area_vector.begin() + left_id - 1)->right_endpoint - 1);
	//}
	//else if (vector_id == 0) {
	//	cout << "vector_id == 0" << endl;
	//	assert((area_vector.begin() + vector_id)->right_endpoint >= temp_coefficient.max_point.id && (area_vector.begin() + vector_id)->right_endpoint >= temp_coefficient.min_point.id);

	//	if (temp_coefficient.max_point.id > temp_coefficient.min_point.id) {
	//		(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.max_point.id;
	//	    //(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.min_point.id;//181211 sovle the first rectangle too large

	//		updateRectangle(area_vector, left_id, original_time_series);
	//		updateRectangle(area_vector, vector_id, original_time_series);
	//		updateRectangle(area_vector, right_id, original_time_series);

	//		if (area_vector.at(vector_id).heightest_value <= area_vector.at(right_id).lowest_value && area_vector.at(right_id).min_point.id < area_vector.at(right_id).max_point.id) {
	//			getMergedInfo(area_vector, right_id, temp_right_coefficient);
	//			mergeRectangle2(area_vector, right_id, temp_right_coefficient, original_time_series);
	//		}

	//	}
	//	else if (temp_coefficient.max_point.id < temp_coefficient.min_point.id) {
	//		(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.min_point.id;
	//		//(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.max_point.id;

	//		updateRectangle(area_vector, left_id, original_time_series);
	//		updateRectangle(area_vector, vector_id, original_time_series);
	//		updateRectangle(area_vector, right_id, original_time_series);

	//		if (area_vector.at(vector_id).lowest_value > area_vector.at(right_id).heightest_value && area_vector.at(right_id).max_point.id < area_vector.at(right_id).min_point.id) {
	//			getMergedInfo(area_vector, right_id, temp_right_coefficient);
	//			mergeRectangle2(area_vector, right_id, temp_right_coefficient, original_time_series);
	//		}
	//	}
	//	else {
	//		assert(0);
	//	}

	//}
	//else if (vector_id == area_vector.size() - 1) {
	//    cout << "vector_id == area_vector.size() - 1" << endl;
	//	assert((area_vector.begin() + vector_id)->right_endpoint >= temp_coefficient.max_point.id && (area_vector.begin() + vector_id)->right_endpoint >= temp_coefficient.min_point.id);
	//	//if (left_id > 0)
	//	assert((area_vector.begin() + left_id)->right_endpoint <= temp_coefficient.max_point.id && (area_vector.begin() + left_id)->right_endpoint <= temp_coefficient.min_point.id);

	//	if (temp_coefficient.max_point.id > temp_coefficient.min_point.id) {
	//		(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.max_point.id;
	//		(area_vector.begin() + left_id)->right_endpoint = temp_coefficient.min_point.id - 1;

	//		updateRectangle(area_vector, left_id, original_time_series);
	//		updateRectangle(area_vector, vector_id, original_time_series);
	//		updateRectangle(area_vector, right_id, original_time_series);

	//		if (area_vector.at(left_id).heightest_value <= area_vector.at(vector_id).lowest_value && area_vector.at(left_id).min_point.id < area_vector.at(left_id).max_point.id) {
	//			getMergedInfo(area_vector, vector_id, temp_left_coefficient);
	//			mergeRectangle2(area_vector, vector_id, temp_left_coefficient, original_time_series);

	//		}

	//	}
	//	else if (temp_coefficient.max_point.id < temp_coefficient.min_point.id) {
	//		(area_vector.begin() + vector_id)->right_endpoint = temp_coefficient.min_point.id;
	//		(area_vector.begin() + left_id)->right_endpoint = temp_coefficient.max_point.id - 1;

	//		updateRectangle(area_vector, left_id, original_time_series);
	//		updateRectangle(area_vector, vector_id, original_time_series);
	//		updateRectangle(area_vector, right_id, original_time_series);

	//		if (area_vector.at(left_id).lowest_value > area_vector.at(vector_id).heightest_value && area_vector.at(left_id).max_point.id < area_vector.at(left_id).min_point.id) {
	//			getMergedInfo(area_vector, vector_id, temp_left_coefficient);
	//			mergeRectangle2(area_vector, vector_id, temp_left_coefficient, original_time_series);
	//		}

	//	}
	//	else {
	//		assert(0);
	//	}
	//}
	//else {
	//	assert(0);
	//}
}

//************************************
// Method:mergeRectangle0ForParallelogram
// Qualifier: current rectangle merge right rectangle and left rectangle. merge. recursive
// date:181210
// author:
//*************************************
TEMPLATE
void APLA::mergeRectangle0ForParallelogram(vector<AREA_COEFFICIENT>& area_vector, int& vector_id, const AREA_COEFFICIENT& const temp_coefficient, DataType*& const original_time_series) {
	//assert(temp_coefficient.max_point.value != INF);
	//cout << "mergeRectangle2()" << endl;
	//cout << "		id: " << vector_id << endl;
	int left_id = vector_id - 1;
	vector<AREA_COEFFICIENT> temp_vector{ temp_coefficient };

	/*----------------------------------------------------------*Megrge Process*------------------------------------------------------------*/
	area_vector[vector_id] = temp_vector.front();// .at(0);
	area_vector.erase(area_vector.begin() + left_id);
	left_id--;
	vector_id--;
}

//************************************
// Method:mergeRectangle0ForParallelogramNoErase
// Qualifier: Only for ForParallelogram, No erase function
// date:190410
// author:
//*************************************
TEMPLATE
inline void APLA::mergeRectangle0ForParallelogramNoErase(vector<AREA_COEFFICIENT>& area_vector, int& vector_id, int& const segment_number, const AREA_COEFFICIENT& const temp_coefficient, DataType*& const original_time_series) {//190410 Only for ForParallelogram, No erase function
	int left_id = vector_id - 1;
	//vector<AREA_COEFFICIENT> temp_vector{ temp_coefficient };
	//area_vector[vector_id] = temp_vector.front();// .at(0);

	area_vector[vector_id] = temp_coefficient;

	//for (int i = 2; i <= segment_number;i++,left_id--) {
	area_vector[left_id].right_endpoint = INF;// .at(0);
	area_vector[left_id].rectangle_width = INF;// .at(0);

//}
}

//************************************
// Method:mergeRectangle0ForParallelogramNoEraseArray
// Qualifier: Only for ForParallelogram, No erase function
// date:190418
// author:
//*************************************
TEMPLATE
inline void APLA::mergeRectangle0ForParallelogramNoEraseArray(SEGMENT_COEFFICIENT*& area_vector, int& vector_id, const SEGMENT_COEFFICIENT& const temp_coefficient, DataType*& const original_time_series) {
	int left_id = vector_id - 1;
	area_vector[vector_id] = temp_coefficient;// .at(0);
	area_vector[left_id].right_endpoint = INF;// .at(0);
	area_vector[left_id].rectangle_width = INF;// .at(0);
}

//************************************
// Method:getMergedInfo
// Qualifier: right rectangle merge left rectangle
// date:181130
// author:
//************************************
//TEMPLATE
//void APLA::findMinMaxPoint(vector<AREA_COEFFICIENT>& area_vector, DataType *& const original_time_series,const int begin_id ,const int vector_id) {//181130 Find max id value & min value id
//
//}

//************************************
// Method:splitRectangle
// Qualifier: Whether max point or min point in the middle
// date:190114
// author:
//************************************
TEMPLATE
void APLA::splitRectangle(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector, int vector_id) {//190114
	AREA_COEFFICIENT splited_rec;
	int right_id = vector_id + 1;
	int segment_left_id = area_vector[vector_id].right_endpoint - area_vector[vector_id].rectangle_width + 1;
	int mid_id = vector_id > 0 ? (area_vector[vector_id].right_endpoint + area_vector[vector_id - 1].right_endpoint + 1) / 2 : area_vector[vector_id].right_endpoint / 2;
	/*if (area_vector[vector_id].right_endpoint == area_vector[vector_id].max_point.id || area_vector[vector_id].right_endpoint == area_vector[vector_id].min_point.id) {
		auto split_id = mid_id;
	}*/

	auto split_id = fabs(area_vector[vector_id].min_point.id - mid_id) < fabs(area_vector[vector_id].max_point.id - mid_id) ? area_vector[vector_id].min_point.id : area_vector[vector_id].max_point.id;
	split_id = mid_id;
	split_id = area_vector[vector_id].deviation_point.id;

	/*if (split_id == area_vector[vector_id].right_endpoint) {
		split_id = mid_id;
	}*/

	if (area_vector[vector_id].right_endpoint - split_id < 2 || split_id - segment_left_id < 1) return;

	//cout <<"width: "<< area_vector[vector_id].rectangle_width  << " split id: " << split_id<<"  right endpoint id: "<< area_vector[vector_id].right_endpoint<< endl;

	splited_rec.right_endpoint = area_vector[vector_id].right_endpoint;
	area_vector.insert(area_vector.begin() + right_id, splited_rec);
	area_vector[vector_id].right_endpoint = split_id;
	//cout << "split id: " << split_id << "  " << area_vector[vector_id].right_endpoint << " " << area_vector[right_id].right_endpoint << endl;
	updateRectangle(area_vector, vector_id, original_time_series);
	updateRectangle(area_vector, right_id, original_time_series);
#if _DEBUG
	assert(area_vector[vector_id].rectangle_width > 1);
	assert(area_vector[right_id].rectangle_width > 1);
#endif
	//cout << "split id: " << split_id << "  " << area_vector[vector_id].right_endpoint << " " << area_vector[right_id].right_endpoint << endl;
}

//************************************
// Method:binarySearchIdEquality
// Qualifier: find which point should be splited in one segment
// date:190709
// author:
//************************************
TEMPLATE
int APLA::binarySearchIdEquality(DataType*& const original_time_series, int& const left_id, int& const right_id) {//190709
#if _DEBUG
	assert(right_id - left_id > 1 && left_id > -1);
#endif
	//int point_number = right_id - left_id;
	int left_segment_id1 = left_id;
	int left_segment_id2 = left_id + 1;
	int right_segment_id1 = right_id - 1;
	int right_segment_id2 = right_id;
	int split_id = INF;

	double left_a = INF;
	double middle_a = INF;
	double right_a = INF;
	double left_a_difference = INF;
	double right_a_difference = INF;

	while (left_segment_id2 < right_segment_id2) {
		split_id = (left_segment_id2 + right_segment_id2) / 2;
		left_a = original_time_series[left_segment_id2] - original_time_series[left_segment_id2 - 1];
		middle_a = original_time_series[split_id] - original_time_series[split_id - 1];
		right_a = original_time_series[right_segment_id2] - original_time_series[right_segment_id2 - 1];
		//#if _DEBUG
		//		assert(left_a != right_a && middle_a != right_a);
		//#endif
		left_a_difference = fabs(middle_a - left_a);
		right_a_difference = fabs(right_a - middle_a);

		if (left_a_difference < right_a_difference) {
			left_segment_id2 = split_id + 1;
		}
		else if (left_a_difference > right_a_difference) {
			right_segment_id2 = split_id - 1;
		}
		else {
			break;
#if _DEBUG
			assert(split_id > 0 && right_id - split_id > 1 && split_id - left_id > 1);
#endif
			return split_id;
		}

#if _DEBUG
		assert(left_segment_id2 > 0 && right_segment_id2 < input_argument.time_series_length);
#endif
	}

	if (split_id == right_segment_id1) {
		split_id--;
		//cout << "right id 1: " << split_id << endl;
	}
	if (split_id == right_id) {
		assert(0);
	}
	assert(split_id > 0 && split_id < input_argument.time_series_length&& split_id != left_id);
	assert(split_id != 0 && split_id < input_argument.time_series_length);

	return split_id;
}

//************************************
// Method:AdaptiveSearchIdEquality
// Qualifier: get slope a & intercept b by adaptive length points
// date:190716
// author:
//************************************
TEMPLATE
double APLA::AdaptiveSearchIdEquality(DataType*& const original_time_series, int& const left_id, int& const right_id) {//190716 get slope a & intercept b by adaptive length points
#if _DEBUG
	assert(right_id - left_id > 1 && left_id > -1);
#endif
	//int point_number = right_id - left_id;
	int compute_point_number = (right_id - left_id + 1.0) / 6.0;
	//compute_point_number = compute_point_number > 1 ? compute_point_number : 2;
	compute_point_number = compute_point_number > 0 ? compute_point_number : 1;

	int left_segment_id1 = left_id;
	//int left_segment_id2 = left_id + compute_point_number - 1;
	//int right_segment_id1 = right_id - compute_point_number + 1;
	int left_segment_id2 = left_id + compute_point_number;
	int right_segment_id1 = right_id - compute_point_number;
	int right_segment_id2 = right_id;
	int split_id = INF;

	double left_a = INF;
	double middle_a = INF;
	double right_a = INF;
	double left_a_difference = INF;
	double right_a_difference = INF;

	double temp_b = INF;

	while (left_segment_id2 < right_segment_id2) {
		compute_point_number = (right_segment_id2 - left_segment_id2) / 6;
		//compute_point_number = compute_point_number > 1 ? compute_point_number : 2;

		split_id = (left_segment_id2 - compute_point_number + 1 + right_segment_id2) / 2;

		if (compute_point_number == 0) {
			break;
		}

#if _DEBUG
		assert(left_segment_id2 - compute_point_number + 1 >= left_id);
#endif

		//left_a = getABSlopeInterceptOriginal(original_time_series, left_segment_id2 - compute_point_number + 1, left_segment_id2, left_a, temp_b);
		//middle_a = getABSlopeInterceptOriginal(original_time_series, split_id - compute_point_number + 1, split_id, middle_a, temp_b);
		//right_a = getABSlopeInterceptOriginal(original_time_series, right_segment_id2 - compute_point_number + 1, right_segment_id2, right_a, temp_b);

		left_a = getABSlopeInterceptOriginal(original_time_series, left_segment_id2 - compute_point_number, left_segment_id2, left_a, temp_b);
		middle_a = getABSlopeInterceptOriginal(original_time_series, split_id - compute_point_number, split_id, middle_a, temp_b);
		right_a = getABSlopeInterceptOriginal(original_time_series, right_segment_id2 - compute_point_number, right_segment_id2, right_a, temp_b);
		//#if _DEBUG
		//		assert(left_a != right_a && middle_a != right_a);
		//#endif
		left_a_difference = fabs(middle_a - left_a);
		right_a_difference = fabs(right_a - middle_a);

		if (left_a_difference < right_a_difference) {
			left_segment_id2 = split_id + 1;
		}
		else if (left_a_difference > right_a_difference) {
			right_segment_id2 = split_id - 1;
		}
		else {
			break;
#if _DEBUG
			assert(split_id > 0 && right_id - split_id > 1 && split_id - left_id > 1);
#endif
			return split_id;
		}

#if _DEBUG
		assert(left_segment_id2 > 0 && right_segment_id2 < input_argument.time_series_length);
#endif
	}

	if (split_id == right_id - 1) {
		split_id--;
		//cout << "right id 1: " << split_id << endl;
	}
	if (split_id == right_id) {
		assert(0);
	}
	assert(split_id > 0 && split_id < input_argument.time_series_length&& split_id != left_id);
	assert(split_id != 0 && split_id < input_argument.time_series_length);

	return split_id;
}

//************************************
// Method:binarySearchIdPointDistance
// Qualifier: find which point should be splited in one segment, use middle point distance
// date:190715
// author:
//************************************
TEMPLATE
double APLA::binarySearchIdPointDistance(DataType*& const original_time_series, int& const left_id, int& const right_id) {//190715
#if _DEBUG
	assert(right_id - left_id > 1 && left_id > -1);
#endif
	int left_segment_id1 = left_id;
	int left_segment_id2 = left_id + 1;
	int right_segment_id1 = right_id - 1;
	int right_segment_id2 = right_id;
	int split_id = INF;

	double left_a = INF;
	double middle_a = INF;
	double right_a = INF;
	double left_a_difference = INF;
	double right_a_difference = INF;

	while (left_segment_id2 < right_segment_id2) {
		split_id = (left_segment_id2 + right_segment_id2) / 2;
		left_a = original_time_series[left_segment_id2] - original_time_series[left_segment_id2 - 1];
		double left_b = original_time_series[left_segment_id2 - 1];
		//double middle_a = original_time_series[split_id] - original_time_series[split_id - 1];
		right_a = original_time_series[right_segment_id2] - original_time_series[right_segment_id2 - 1];
		double right_b = original_time_series[right_segment_id2 - 1];
		//#if _DEBUG
		//		assert(left_a != right_a && middle_a != right_a);
		//#endif
		int left_width = split_id - left_segment_id2 + 1;
		int right_width = split_id - right_segment_id2 + 1;
#if _DEBUG
		assert(left_width >= 0 && right_width <= 0);
#endif
		double left_distance = fabs(left_a * left_width + left_b - original_time_series[split_id] + original_time_series[left_segment_id2 - 1]);// relative value = time series[middle id] - time series[left id]
		double right_distance = fabs(right_a * right_width + right_b - original_time_series[split_id] + original_time_series[right_segment_id2 - 1]); //relative value = time series[middle id] - time series[left id]

		//left_a_difference = fabs(middle_a - left_a);
		//right_a_difference = fabs(right_a - middle_a);

		if (left_distance < right_distance) {
			left_segment_id2 = split_id + 1;
		}
		else if (left_distance > right_distance) {
			right_segment_id2 = split_id - 1;
		}
		else {
			//return INF;

			break;
#if _DEBUG
			assert(split_id > 0 && right_id - split_id > 1 && split_id - left_id > 1);
#endif
			return split_id;
		}

#if _DEBUG
		assert(left_segment_id2 > 0 && right_segment_id2 < input_argument.time_series_length);
#endif
	}

	if (split_id == right_segment_id1) {
		split_id--;
		//cout << "right id 1: " << split_id << endl;
	}
	if (split_id == right_id) {
		assert(0);
	}
#if _DEBUG
	assert(split_id > 0 && split_id < input_argument.time_series_length&& split_id != left_id);
	assert(split_id != 0 && split_id < input_argument.time_series_length);
#endif
	return split_id;
}

//************************************
// Method:AdaptiveSearchIdPointDistance
// Qualifier: find which point should be splited in one segment, use middle point distance
// date:190715
// author:
//************************************
TEMPLATE
double APLA::AdaptiveSearchIdPointDistance(DataType*& const original_time_series, int& const left_id, int& const right_id) {//190716
#if _DEBUG
	assert(right_id - left_id > 1 && left_id > -1);
#endif
	int split_id = INF;

	int compute_point_number = (right_id - left_id + 1.0) / 6.0;
	compute_point_number = compute_point_number > 0 ? compute_point_number : 1;

	//int left_segment_id1 = left_id;
	int left_segment_id2 = left_id + compute_point_number;
	//int right_segment_id1 = right_id - compute_point_number;
	int right_segment_id2 = right_id;

	double left_a = INF;
	double left_b = INF;
	double right_a = INF;
	double right_b = INF;
	double left_a_difference = INF;
	double right_a_difference = INF;

	while (left_segment_id2 < right_segment_id2 - 1) {
		compute_point_number = (right_segment_id2 - left_segment_id2) / 6;

		if (compute_point_number == 0) {
			compute_point_number = 1;
			//break;
		}

		split_id = (left_segment_id2 - compute_point_number + 1 + right_segment_id2) / 2;

#if _DEBUG
		assert(left_segment_id2 - compute_point_number + 1 >= left_id);
#endif

		left_a = getABSlopeInterceptOriginal(original_time_series, left_segment_id2 - compute_point_number, left_segment_id2, left_a, left_b);
		right_a = getABSlopeInterceptOriginal(original_time_series, right_segment_id2 - compute_point_number, right_segment_id2, right_a, right_b);

		//#if _DEBUG
		//		assert(left_a != right_a && middle_a != right_a);
		//#endif
		int left_width = split_id - (left_segment_id2 - compute_point_number);
		int right_width = split_id - (right_segment_id2 - compute_point_number);
#if _DEBUG
		assert(left_width >= 0 && right_width <= 0);
#endif
		float left_distance = fabs(left_a * left_width + left_b - original_time_series[split_id]);// relative value = time series[middle id] - time series[left id]
		float right_distance = fabs(right_a * right_width + right_b - original_time_series[split_id]); //relative value = time series[middle id] - time series[left id]

		//left_a_difference = fabs(middle_a - left_a);
		//right_a_difference = fabs(right_a - middle_a);

		if (left_distance < right_distance) {
			left_segment_id2 = split_id + 1;
		}
		else if (left_distance > right_distance) {
			right_segment_id2 = split_id - 1;
		}
		else {
			//return INF;

			break;
#if _DEBUG
			assert(split_id > 0 && right_id - split_id > 1 && split_id - left_id > 1);
#endif
			//return split_id;
		}

#if _DEBUG
		assert(left_segment_id2 > 0 && right_segment_id2 < input_argument.time_series_length);
#endif
	}

	if (split_id == right_id - 1) {
		split_id--;
		//cout << "right id 1: " << split_id << endl;
	}

#if _DEBUG
	assert(split_id != right_id && split_id > 0 && split_id < input_argument.time_series_length&& split_id != left_id);
	assert(split_id != 0 && split_id < input_argument.time_series_length);
#endif
	cout << left_id + 1 << " : " << split_id + 1 << " : " << right_id + 1 << endl;
	/*====================================== 191008 For Burst Time series===============================================================================*/
	/*cout << left_id + 1 << " : " << split_id + 1 << " : " << right_id + 1 << endl;
	if (input_argument.burst_frquent_value != INF && right_id - left_id + 1 >6 ) {
		if (original_time_series[left_id] != input_argument.burst_frquent_value && original_time_series[split_id] == input_argument.burst_frquent_value && original_time_series[right_id] == input_argument.burst_frquent_value) {
			while(original_time_series[split_id-1] == input_argument.burst_frquent_value){
				split_id--;
			}
			split_id--;

			if (split_id - left_id < 1) {
				split_id++;
			}

			return split_id;
		}
		else if (original_time_series[right_id] != input_argument.burst_frquent_value && original_time_series[split_id] == input_argument.burst_frquent_value && original_time_series[left_id] == input_argument.burst_frquent_value) {
			while (original_time_series[split_id+1] == input_argument.burst_frquent_value ) {
				split_id++;
			}
			if (right_id - split_id == 1) {
				split_id--;
			}
			return split_id;
		}
	}*/
	/*==============================================================================================================================================*/
	return split_id;
}

//************************************
// Method:AdaptiveSearchIdPointDistance2
// Qualifier: find which point should be splited in one segment, use middle point distance.nly comput changed left id or right id
// date:191008
// author:
//************************************
TEMPLATE
double APLA::AdaptiveSearchIdPointDistance2(DataType*& const original_time_series, int& const left_id, int& const right_id) {//191008 For every binary, only comput changed left id or right id
#if _DEBUG
	assert(right_id - left_id > 1 && left_id > -1);
#endif
	int split_id = INF;
	int compute_point_number = (right_id - left_id + 1.0) / 6.0;
	compute_point_number = compute_point_number > 0 ? compute_point_number : 1;

	//int left_segment_id1 = left_id;
	int left_segment_id2 = left_id + compute_point_number;
	//	//int right_segment_id1 = right_id - compute_point_number;
	int right_segment_id2 = right_id;
	double left_a = INF;
	double left_b = INF;
	double right_a = INF;
	double right_b = INF;
	double left_a_difference = INF;

	double right_a_difference = INF;

	////	left_a = getABSlopeInterceptOriginal(original_time_series, left_segment_id2 - compute_point_number, left_segment_id2, left_a, left_b);
	////	right_a = getABSlopeInterceptOriginal(original_time_series, right_segment_id2 - compute_point_number, right_segment_id2, right_a, right_b);
	int left_width = split_id - (left_segment_id2 - compute_point_number);
	int right_width = split_id - (right_segment_id2 - compute_point_number);
	////#if _DEBUG
	////	assert(left_width >= 0 && right_width <= 0);
	////#endif
	double left_distance = INF;// relative value = time series[middle id] - time series[left id]
	double right_distance = INF; //relative value = time series[middle id] - time series[left id]
////
	double original_difference_sum = INF;
	double new_difference_sum = INF;
	int original_split_id = INF;
	//
	int original_left_id = left_segment_id2;
	int original_right_id = right_segment_id2;
	while (left_segment_id2 < right_segment_id2 - 1) {
		compute_point_number = (right_segment_id2 - left_segment_id2) / 6;
		if (compute_point_number == 0) {
			compute_point_number = 1;
			//break;
		}
		split_id = (left_segment_id2 - compute_point_number + 1 + right_segment_id2) / 2;
		if (original_difference_sum == INF) {
#if _DEBUG
			assert(left_segment_id2 - compute_point_number + 1 >= left_id);
#endif
			left_a = getABSlopeInterceptOriginal(original_time_series, left_segment_id2 - compute_point_number, left_segment_id2, left_a, left_b);
			right_a = getABSlopeInterceptOriginal(original_time_series, right_segment_id2 - compute_point_number, right_segment_id2, right_a, right_b);
			left_width = split_id - (left_segment_id2 - compute_point_number);
			right_width = split_id - (right_segment_id2 - compute_point_number);
#if _DEBUG
			assert(left_width >= 0 && right_width <= 0);
#endif
			left_distance = fabs(left_a * left_width + left_b - original_time_series[split_id]);// relative value = time series[middle id] - time series[left id]
			right_distance = fabs(right_a * right_width + right_b - original_time_series[split_id]); //relative value = time series[middle id] - time series[left id]
			original_difference_sum = left_distance + right_distance;
			original_split_id = split_id;
		}
		else if (left_segment_id2 == original_left_id) {
			left_a = getABSlopeInterceptOriginal(original_time_series, left_segment_id2 - compute_point_number, left_segment_id2, left_a, left_b);
			left_width = split_id - (left_segment_id2 - compute_point_number);
			right_width = split_id - (original_right_id - compute_point_number);
#if _DEBUG
			assert(left_width >= 0 && right_width <= 0);
#endif
			left_distance = fabs(left_a * left_width + left_b - original_time_series[split_id]);// relative value = time series[middle id] - time series[left id]
			right_distance = fabs(right_a * right_width + right_b - original_time_series[split_id]); //relative value = time series[middle id] - time series[left id]
			if (left_distance + right_distance < original_difference_sum) {
				original_difference_sum = left_distance + right_distance;
				original_split_id = split_id;
				//continue;
			}
			else {
				split_id = original_split_id;
				break;
			}
		}
		else if (right_segment_id2 == original_right_id) {
			right_a = getABSlopeInterceptOriginal(original_time_series, right_segment_id2 - compute_point_number, right_segment_id2, right_a, right_b);
			left_width = split_id - (original_left_id - compute_point_number);
			right_width = split_id - (right_segment_id2 - compute_point_number);
#if _DEBUG
			assert(left_width >= 0 && right_width <= 0);
#endif
			left_distance = fabs(left_a * left_width + left_b - original_time_series[split_id]);// relative value = time series[middle id] - time series[left id]
			right_distance = fabs(right_a * right_width + right_b - original_time_series[split_id]); //relative value = time series[middle id] - time series[left id]
			if (left_distance + right_distance < original_difference_sum) {
				original_difference_sum = left_distance + right_distance;
				original_split_id = split_id;
				//continue;
			}
			else {
				split_id = original_split_id;
				break;
			}
		}
		//
		//
		if (left_distance < right_distance) {
			left_segment_id2 = split_id + 1;
		}
		else if (left_distance > right_distance) {
			right_segment_id2 = split_id - 1;
		}
		else {
			//			//return INF;
			//
			break;
#if _DEBUG
			assert(split_id > 0 && right_id - split_id > 1 && split_id - left_id > 1);
#endif
			//			//return split_id;
		}
		//
#if _DEBUG
		assert(left_segment_id2 > 0 && right_segment_id2 <= right_id);
#endif
	}
	//
	if (split_id == right_id - 1) {
		split_id--;
		//cout << "right id 1: " << split_id << endl;
	}
	//
#if _DEBUG
	assert(split_id > 0 && split_id < right_id&& split_id != left_id);
	//cout << left_id + 1 << " : " << split_id + 1 << " : " << right_id + 1 << endl;
#endif

	/*====================================== 191008 For Burst Time series===============================================================================*/
	/*cout << left_id + 1 << " : " << split_id + 1 << " : " << right_id + 1 << endl;
//	if (input_argument.burst_frquent_value != INF && right_id - left_id + 1 >6 ) {
//
//		if (original_time_series[left_id] != input_argument.burst_frquent_value && original_time_series[split_id] == input_argument.burst_frquent_value && original_time_series[right_id] == input_argument.burst_frquent_value) {
//			while(original_time_series[split_id-1] == input_argument.burst_frquent_value){
//				split_id--;
//			}
//			split_id--;
//
//			if (split_id - left_id < 1) {
//				split_id++;
//			}
//
//			return split_id;
//
//		}
//		else if (original_time_series[right_id] != input_argument.burst_frquent_value && original_time_series[split_id] == input_argument.burst_frquent_value && original_time_series[left_id] == input_argument.burst_frquent_value) {
//			while (original_time_series[split_id+1] == input_argument.burst_frquent_value ) {
//				split_id++;
//			}
//			if (right_id - split_id == 1) {
//				split_id--;
//			}
//			return split_id;
//		}
//	}
//	/*==============================================================================================================================================*/
	return split_id;
}

//************************************
// Method:AdaptiveSearchIdPointDistance2
// Qualifier: find which point should be splited in one segment, use middle point distance.nly comput changed left id or right id
// date:191231
// Oput: vector to instead pointer
// author:
//************************************
TEMPLATE
template<typename T>
double APLA::AdaptiveSearchIdPointDistance2(const vector<T>& const original_time_series, int& const left_id, int& const right_id) {//191231 For every binary, only comput changed left id or right id
#if _DEBUG
	assert(right_id - left_id > 1 && left_id > -1 && !original_time_series.empty());
#endif
	int split_id = INF;
	int compute_point_number = (right_id - left_id + 1.0) / 6.0;
	compute_point_number = compute_point_number > 0 ? compute_point_number : 1;

	//int left_segment_id1 = left_id;
	int left_segment_id2 = left_id + compute_point_number;
	//	//int right_segment_id1 = right_id - compute_point_number;
	int right_segment_id2 = right_id;
	double left_a = INF;
	double left_b = INF;
	double right_a = INF;
	double right_b = INF;
	double left_a_difference = INF;
	double right_a_difference = INF;

	////	left_a = getABSlopeInterceptOriginal(original_time_series, left_segment_id2 - compute_point_number, left_segment_id2, left_a, left_b);
	////	right_a = getABSlopeInterceptOriginal(original_time_series, right_segment_id2 - compute_point_number, right_segment_id2, right_a, right_b);
	int left_width = split_id - (left_segment_id2 - compute_point_number);
	int right_width = split_id - (right_segment_id2 - compute_point_number);
	////#if _DEBUG
	////	assert(left_width >= 0 && right_width <= 0);
	////#endif
	double left_distance = INF;// relative value = time series[middle id] - time series[left id]
	double right_distance = INF; //relative value = time series[middle id] - time series[left id]
////
	double original_difference_sum = INF;
	double new_difference_sum = INF;
	int original_split_id = INF;
	//
	int original_left_id = left_segment_id2;
	int original_right_id = right_segment_id2;
	while (left_segment_id2 < right_segment_id2 - 1) {
		compute_point_number = (right_segment_id2 - left_segment_id2) / 6;
		if (compute_point_number == 0) {
			compute_point_number = 1;
			//break;
		}
		split_id = (left_segment_id2 - compute_point_number + 1 + right_segment_id2) / 2;
		if (original_difference_sum == INF) {
#if _DEBUG
			assert(left_segment_id2 - compute_point_number + 1 >= left_id);
#endif
			left_a = getABSlopeInterceptOriginal(original_time_series, left_segment_id2 - compute_point_number, left_segment_id2, left_a, left_b);
			right_a = getABSlopeInterceptOriginal(original_time_series, right_segment_id2 - compute_point_number, right_segment_id2, right_a, right_b);
			left_width = split_id - (left_segment_id2 - compute_point_number);
			right_width = split_id - (right_segment_id2 - compute_point_number);
#if _DEBUG
			assert(left_width >= 0 && right_width <= 0);
#endif
			left_distance = fabs(left_a * left_width + left_b - original_time_series[split_id]);// relative value = time series[middle id] - time series[left id]
			right_distance = fabs(right_a * right_width + right_b - original_time_series[split_id]); //relative value = time series[middle id] - time series[left id]
			original_difference_sum = left_distance + right_distance;
			original_split_id = split_id;
		}
		else if (left_segment_id2 == original_left_id) {
			left_a = getABSlopeInterceptOriginal(original_time_series, left_segment_id2 - compute_point_number, left_segment_id2, left_a, left_b);
			left_width = split_id - (left_segment_id2 - compute_point_number);
			right_width = split_id - (original_right_id - compute_point_number);
#if _DEBUG
			assert(left_width >= 0 && right_width <= 0);
#endif
			left_distance = fabs(left_a * left_width + left_b - original_time_series[split_id]);// relative value = time series[middle id] - time series[left id]
			right_distance = fabs(right_a * right_width + right_b - original_time_series[split_id]); //relative value = time series[middle id] - time series[left id]
			//if (left_distance + right_distance < original_difference_sum) {
			original_difference_sum = left_distance + right_distance;
			original_split_id = split_id;
			//continue;
		//}
		//else {
			//split_id = original_split_id;
			//break;
		//}
		}
		else if (right_segment_id2 == original_right_id) {
			right_a = getABSlopeInterceptOriginal(original_time_series, right_segment_id2 - compute_point_number, right_segment_id2, right_a, right_b);
			left_width = split_id - (original_left_id - compute_point_number);
			right_width = split_id - (right_segment_id2 - compute_point_number);
#if _DEBUG
			assert(left_width >= 0 && right_width <= 0);
#endif
			left_distance = fabs(left_a * left_width + left_b - original_time_series[split_id]);// relative value = time series[middle id] - time series[left id]
			right_distance = fabs(right_a * right_width + right_b - original_time_series[split_id]); //relative value = time series[middle id] - time series[left id]
			//if (left_distance + right_distance < original_difference_sum) {
			original_difference_sum = left_distance + right_distance;
			original_split_id = split_id;
			//continue;
		//}
		//else {
			//split_id = original_split_id;
			//break;
		//}
		}

		if (left_distance < right_distance) {
			left_segment_id2 = split_id + 1;
			original_right_id = right_segment_id2;
		}
		else if (left_distance > right_distance) {
			right_segment_id2 = split_id - 1;
			original_left_id = left_segment_id2;
		}
		else {
			//return INF;
			break;
#if _DEBUG
			assert(split_id > 0 && right_id - split_id > 1 && split_id - left_id > 1);
#endif
			//return split_id;
		}
#if _DEBUG
		assert(left_segment_id2 > 0 && right_segment_id2 <= right_id);
#endif
	}
	if (split_id == right_id - 1) {
		split_id--;
		//cout << "right id 1: " << split_id << endl;
	}
#if _DEBUG
	assert(split_id > 0 && split_id < right_id&& split_id != left_id);
	//cout << left_id + 1 << " : " << split_id + 1 << " : " << right_id + 1 << endl;
#endif

	/*====================================== 191008 For Burst Time series===============================================================================*/
	/*cout << left_id + 1 << " : " << split_id + 1 << " : " << right_id + 1 << endl;
//	if (input_argument.burst_frquent_value != INF && right_id - left_id + 1 >6 ) {
//
//		if (original_time_series[left_id] != input_argument.burst_frquent_value && original_time_series[split_id] == input_argument.burst_frquent_value && original_time_series[right_id] == input_argument.burst_frquent_value) {
//			while(original_time_series[split_id-1] == input_argument.burst_frquent_value){
//				split_id--;
//			}
//			split_id--;
//
//			if (split_id - left_id < 1) {
//				split_id++;
//			}
//
//			return split_id;
//
//		}
//		else if (original_time_series[right_id] != input_argument.burst_frquent_value && original_time_series[split_id] == input_argument.burst_frquent_value && original_time_series[left_id] == input_argument.burst_frquent_value) {
//			while (original_time_series[split_id+1] == input_argument.burst_frquent_value ) {
//				split_id++;
//			}
//			if (right_id - split_id == 1) {
//				split_id--;
//			}
//			return split_id;
//		}
//	}
//	/*==============================================================================================================================================*/
	return split_id;
}

//200219
// compute intersection point by endpoint of one segment
//************************************
// Method:get_intersection_point_by_segment
// Qualifier: find the intersection point by endpoint at two side of one segment
// date:200219
// Notice:
// Input:
// Output:
// author:
//************************************
TEMPLATE
template<typename T>
double APLA::get_intersection_point_by_segment(const vector<T>& const original_time_series_vector, const int& const left_id, const int& const right_id) {
#if _DEBUG
	assert(right_id - left_id > 1 && left_id > -1 && !original_time_series_vector.empty() && right_id < original_time_series_vector.size());
#endif
	double split_id = INF;
	int compute_point_number = (right_id - left_id + 1.0) / 6.0;
	compute_point_number = compute_point_number > 0 ? compute_point_number : 1;

	//const int begin_id_left = left_id;
	const int end_id_left = left_id + compute_point_number;
	const int begin_id_right = right_id - compute_point_number;
	//const int end_id_right = right_id;

	double left_a = INF;
	double left_b = INF;
	double right_a = INF;
	double right_b = INF;

	// compute a & b of left and right side
	getABSlopeInterceptOriginal(original_time_series_vector, left_id, left_id + compute_point_number, left_a, left_b);
	getABSlopeInterceptOriginal(original_time_series_vector, right_id - compute_point_number, right_id, right_a, right_b);

#if _DEBUG
	assert(left_a != INF && right_a != INF && left_b != INF && right_b != INF);
#endif

	// left a == right a means two lines are parallel
	if (left_a == right_a) {
		//assert(left_b != right_b);
		return (left_id + right_id) / 2;
	}

	/*........................ 200219 find true b in original coordinate ....................*/
	double left_b_in_true_coordinate = left_a * left_id * -1 + left_b;
	double right_b_in_true_coordinate = right_a * begin_id_right * -1 + right_b;
	/*.......................................................................................*/

	//CrossP.x = (b1 - b2) / (a2 - a1);
	// a1 != a2
	split_id = (left_b_in_true_coordinate - right_b_in_true_coordinate) / (right_a - left_a);

	return split_id;
}

//************************************
// Method:find_split_point_by_binary_gradient
// Qualifier: Find split point by By Gradient Descent, if no equal, pick mid point.
// Input:
// Output:
// date:191207
// author:
//************************************
TEMPLATE
double APLA::find_split_point_by_binary_gradient(DataType*& const original_time_series, const int& const left_id, const int& const right_id) { //For every binary, only comput changed left id or right id by middle gradient
#if _DEBUG
	assert(left_id < right_id);
	//cout << "left id: " << left_id << " right id: "<< right_id << endl;

	//if (right_id == 404) {
	//	cout << "        " << endl;
	//}
#endif
	int segment_width = right_id - left_id + 1;
	if (segment_width == 2) {
		return left_id;
	}

	if (segment_width == 3 || segment_width == 4) {
		return left_id + 1;
	}

	int split_id = INF;
	int pla_width = INF;
	double left_a = INF;
	double left_b = INF;
	double right_a = INF;
	double right_b = INF;
	double split_a = INF;
	double split_b = INF;

	double error = 1;
	unsigned int max_iters = 100000;

	//getABSlopeInterceptOriginal(original_time_series, left_id, left_id + pla_width - 1, left_a, left_b);
	//getABSlopeInterceptOriginal(original_time_series, right_id - pla_width + 1, right_id, right_a, right_b);

	int step_size = 1;
	double c_error = error + 1;
	c_error = 1;
	unsigned int iters = 0;
	double p_error;
	double dx = left_id;
	double right_dx = right_id;
	double left_error = 1;
	double right_error = 1;

	double left_pla_right_id = INF;
	double spit_pla_left_id = INF;
	double split_pla_right_id = INF;
	double right_pla_left_id = INF;
	double left_move_length = INF;
	double right_move_length = INF;

	double left_width;
	double right_width;

	while (dx < right_dx) {
		//p_error = dx;
		split_id = (dx + right_dx) / 2;
		pla_width = (right_dx - dx + 1.0) / 10.0;
		//pla_width = log2(right_dx - dx + 1.0);
		if (pla_width < 3) {
			break;
		}
		//pla_width = pla_width > 2 ? pla_width : 2;
		//step_size = pla_width;

		left_pla_right_id = dx + pla_width - 1;
		right_pla_left_id = right_dx - pla_width + 1;
		spit_pla_left_id = split_id - 0.5 * pla_width;
		split_pla_right_id = split_id + 0.5 * pla_width;
		assert(spit_pla_left_id >= left_id && split_pla_right_id <= right_id && split_id < right_id&& split_id > left_id);
		//cout << "left begin id: " << dx << " left end id: " << left_pla_right_id << "     right begin id: " << right_pla_left_id << " right end id: "<< right_dx <<endl;
		getABSlopeInterceptOriginal(original_time_series, dx, left_pla_right_id, left_a, left_b);
		getABSlopeInterceptOriginal(original_time_series, spit_pla_left_id, split_pla_right_id, split_a, split_b);
		getABSlopeInterceptOriginal(original_time_series, right_pla_left_id, right_dx, right_a, right_b);
		//cout << "lfet a: " << left_a << ",  right a: " << right_a << endl;
		//dx = left_pla_right_id;
		//right_dx = right_pla_left_id;

		left_width = split_id - dx;
		right_width = split_id - right_pla_left_id;



		double left_a_difference = fabs(split_a - left_a);
		double right_a_difference = fabs(split_a - right_a);

		double split_y_value = split_a * 0.5 * pla_width + split_b;
		double left_y_value = left_a * left_width + left_b;
		double right_y_value = right_a * right_width + right_b;

		left_a_difference = fabs(left_y_value - split_y_value);
		right_a_difference = fabs(right_y_value - split_y_value);

		if (left_a_difference < right_a_difference) {
			dx = split_id - pla_width;
			right_dx -= pla_width;
		}
		else if (left_a_difference > right_a_difference) {
			right_dx = split_id + pla_width;
			dx += pla_width;
		}
		else {
			dx += pla_width;
			right_dx -= pla_width;
			assert(dx >= left_id && right_dx <= right_id);
		}

		//if (dx >= right_id || right_dx <= left_id)
			//cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1step left id: " << dx << ",   right id: " << right_dx << endl;
			//if (p_error + pla_width - 1 > right_id) 
				//break;
		/*if (left_a == 0) {
			left_move_length = pla_width;
		}
		else {
			left_move_length = step_size * fabs(1 / left_a);
		}

		if (right_a == 0) {
			right_move_length = pla_width;
		}
		else {
			right_move_length = step_size * fabs(1 / right_a);
		}*/

		//cout << "left length: " << left_move_length << " right length: " << right_move_length << endl;
		//left_move_length = left_move_length > 1 ? left_move_length : 1;
		//right_move_length = right_move_length > 1 ? right_move_length : 1;

		//dx += left_move_length;
		//right_dx -= right_move_length;
		//cout << "left dx: " << dx << "        right dx: " << right_dx << endl;

		/*if (dx >= right_id) {
			split_id = left_pla_right_id;
			split_id = right_id - 2;
			assert(split_id < right_id - 1);
			return split_id;
			break;
		}
		else if (right_dx <= left_id) {
			split_id = right_pla_left_id;
			split_id = left_id + 1;
			assert(split_id > left_id);
			return split_id;
			break;
		}*/

		//c_error = fabs(p_error - dx);
		iters++;
		//if (dx >= right_id || right_dx <= left_id)
		//cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!2step left id: " << dx <<",   right id: "<< right_dx << endl;
	}
	//cout << "left right split_id: " << left_pla_right_id << ",  right left split id: " << right_pla_left_id << endl;
	//split_id = (left_pla_right_id + right_pla_left_id) / 2;
	//cout << "left split_id: " << dx << ",  right split id: " << right_dx << endl;
	//split_id = (dx + right_dx) / 2;

	if (split_id <= left_id) {
		split_id = left_id + 1;
		//split_id = right_id - 2;

	}
	else if (split_id > right_id - 2) {
		split_id = right_id - 2;
		//split_id = left_id + 1;
	}


	//cout << "Left gradient descent split id: " << split_id <<",       middle id: "<< (left_id + right_id) / 2<< endl;
	//cout << "!!!!!!!!!!!!!!" << split_id - (left_id + right_id) / 2 << endl;
#if _DEBUG
	assert(split_id != INF && left_id < split_id&& split_id < right_id - 1 && split_id > 0);
#endif
	return split_id;
}

//************************************
// Method:find_split_point_by_gradient_descent
// Qualifier: Find split point by By Gradient Descent, if no equal, pick mid point.
// date:191206 
// author:
//************************************
TEMPLATE
int APLA::find_split_point_by_gradient_descent(DataType*& const original_time_series, const int& const left_id, const int& const right_id) {
#if _DEBUG
	assert(left_id < right_id);
	//cout << "left id: " << left_id << " right id: "<< right_id << endl;
#endif
	int segment_width = right_id - left_id + 1;
	if (segment_width == 2) {
		return left_id;
	}

	if (segment_width == 3 || segment_width == 4) {
		return left_id + 1;
	}

	int split_id = INF;
	int pla_width = INF;
	double left_a = INF;
	double left_b = INF;
	double right_a = INF;
	double right_b = INF;

	double error = 1;
	unsigned int max_iters = 100000;

	//getABSlopeInterceptOriginal(original_time_series, left_id, left_id + pla_width - 1, left_a, left_b);
	//getABSlopeInterceptOriginal(original_time_series, right_id - pla_width + 1, right_id, right_a, right_b);

	int step_size = 1;
	double c_error = error + 1;
	c_error = 1;
	unsigned int iters = 0;
	double p_error;
	double dx = left_id;
	double right_dx = right_id;
	double left_error = 1;
	double right_error = 1;

	double left_pla_right_id = INF;
	double right_pla_left_id = INF;
	double left_move_length = INF;
	double right_move_length = INF;

	while (dx < right_dx && iters < max_iters && c_error >= 1) {
		//p_error = dx;
		split_id = (dx + right_dx) / 2;
		//pla_width = (right_dx - dx + 1.0) / 10.0;
		pla_width = log2(right_dx - dx + 1.0);
		pla_width = pla_width > 2 ? pla_width : 2;
		//step_size = pla_width;

		left_pla_right_id = dx + pla_width - 1;
		right_pla_left_id = right_dx - pla_width + 1;
		//cout << "left begin id: " << dx << " left end id: " << left_pla_right_id << "     right begin id: " << right_pla_left_id << " right end id: "<< right_dx <<endl;
		getABSlopeInterceptOriginal(original_time_series, dx, left_pla_right_id, left_a, left_b);
		getABSlopeInterceptOriginal(original_time_series, right_pla_left_id, right_dx, right_a, right_b);
		//cout << "lfet a: " << left_a << ",  right a: " << right_a << endl;
		//dx = left_pla_right_id;
		//right_dx = right_pla_left_id;

		//if (dx >= right_id || right_dx <= left_id)
			//cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1step left id: " << dx << ",   right id: " << right_dx << endl;
			//if (p_error + pla_width - 1 > right_id) 
				//break;
		if (left_a == 0) {
			left_move_length = pla_width;
		}
		else {
			left_move_length = step_size * fabs(1 / left_a);
		}

		if (right_a == 0) {
			right_move_length = pla_width;
		}
		else {
			right_move_length = step_size * fabs(1 / right_a);
		}

		//cout << "left length: " << left_move_length << " right length: " << right_move_length << endl;
		//left_move_length = left_move_length > 1 ? left_move_length : 1;
		//right_move_length = right_move_length > 1 ? right_move_length : 1;

		dx += left_move_length;
		right_dx -= right_move_length;
		//cout << "left dx: " << dx << "        right dx: " << right_dx << endl;

		/*if (dx >= right_id) {
			split_id = left_pla_right_id;
			split_id = right_id - 2;
			assert(split_id < right_id - 1);
			return split_id;
			break;
		}
		else if (right_dx <= left_id) {
			split_id = right_pla_left_id;
			split_id = left_id + 1;
			assert(split_id > left_id);
			return split_id;
			break;
		}*/

		//c_error = fabs(p_error - dx);
		iters++;
		//if (dx >= right_id || right_dx <= left_id)
		//cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!2step left id: " << dx <<",   right id: "<< right_dx << endl;
	}
	//cout << "left right split_id: " << left_pla_right_id << ",  right left split id: " << right_pla_left_id << endl;
	//split_id = (left_pla_right_id + right_pla_left_id) / 2;
	//cout << "left split_id: " << dx << ",  right split id: " << right_dx << endl;
	//split_id = (dx + right_dx) / 2;

	if (split_id <= left_id) {
		split_id = left_id + 1;
		//split_id = right_id - 2;

	}
	else if (split_id >= right_id) {
		split_id = right_id - 2;
		//split_id = left_id + 1;
	}


	//cout << "Left gradient descent split id: " << split_id <<",       middle id: "<< (left_id + right_id) / 2<< endl;
	//cout << "!!!!!!!!!!!!!!" << split_id - (left_id + right_id) / 2 << endl;
#if _DEBUG
	assert(split_id != INF && left_id < split_id&& split_id < right_id - 1 && split_id > 0);
#endif
	return split_id;
}



//************************************
// Method:findSplitSegmentByEndpoint2length
// Qualifier: Find split point by a&b of length 2 endpoint of segment, if no equal, pick mid point.
// date:1900709
// author:
//************************************
TEMPLATE
double APLA::findSplitSegmentByEndpoint2length(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient) {//190709 Find split point by a&b of length 2 endpoint of segment, if no equal, pick mid point.
#if _DEBUG
	assert(temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF);
#endif
	if (temp_coefficient.rectangle_width < 4) return INF;

	double split_point_id = INF;
	int left_segment_id1 = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	//int left_segment_id2 = left_segment_id1 + 1;
	//int right_segment_id1 = temp_coefficient.right_endpoint - 1;
	int right_segment_id2 = temp_coefficient.right_endpoint;

	//double left_a = original_time_series[left_segment_id2] - original_time_series[left_segment_id1];
	//double right_a = original_time_series[right_segment_id2] - original_time_series[right_segment_id1];
	//double endpoint_value = (temp_coefficient.rectangle_width - 1) * left_a + original_time_series[left_segment_id1];
	/*if (float(left_a) == float(right_a) && float(endpoint_value) == float(original_time_series[right_segment_id2])) {
		return INF;
	}*/
#if _DEBUG
	assert(left_segment_id1 > -1);
#endif

	if (temp_coefficient.rectangle_width > 4) {
		//cout << "Segment left id: " << left_segment_id1 << "         segment right id: " << right_segment_id2 << endl;

		split_point_id = AdaptiveSearchIdPointDistance2(original_time_series, left_segment_id1, right_segment_id2);//190717
		//191206
		//double test_id = find_split_point_by_gradient_descent(original_time_series, left_segment_id1, right_segment_id2);
		//split_point_id = find_split_point_by_gradient_descent(original_time_series, left_segment_id1, right_segment_id2);

		//split_point_id = find_split_point_by_binary_gradient(original_time_series, left_segment_id1, right_segment_id2);//191207

		if (split_point_id == left_segment_id1) {
			split_point_id++;
		}
		else if (split_point_id == right_segment_id2) {
			split_point_id -= 2;
		}
		else if (split_point_id == right_segment_id2 - 1) {
			split_point_id--;
		}
		//cout << "=============================: " << left_segment_id1 << ",  " << right_segment_id2 <<"   "<< (left_segment_id1 + right_segment_id2)/2 << endl;
		//cout << "Split!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!: " << test_id <<",    "<< split_point_id<<",  "<< test_id - split_point_id << endl;
		/*cout << "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" << endl;
		for (int array_id = left_segment_id1; array_id <= right_segment_id2; array_id++) {
			cout << original_time_series[array_id] << ",";
		}
		cout << endl;
		cout << "Split ID: " << split_point_id - left_segment_id1 + 1 << endl;*/
		//split_point_id = AdaptiveSearchIdEquality(original_time_series, left_segment_id1, right_segment_id2);//slope a comparison, similarity 2 points
		//split_point_id = binarySearchIdEquality(original_time_series, left_segment_id1, right_segment_id2);//slope a comparison, similarity 2 points
		//split_point_id = binarySearchIdPointDistance(original_time_series, left_segment_id1, right_segment_id2);//distance to middle point
#if _DEBUG
		assert(split_point_id > 0);
#endif
		return split_point_id;
	}
	else if (temp_coefficient.rectangle_width == 4) {
		return split_point_id = left_segment_id1 + 1;
	}
	else if (temp_coefficient.rectangle_width < 4) {
		return INF;
	}
}

//191231 vector to instead pointer
//************************************
// Method:findSplitSegmentByEndpoint2length
// Qualifier: Use Binary method to get split point.
// date:191231
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
double APLA::findSplitSegmentByEndpoint2length(const vector<T>& const original_time_series, const Y& const temp_coefficient) {//191231 Find split point by a&b of length 2 endpoint of segment, if no equal, pick mid point.
#if _DEBUG
	assert(temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF && !original_time_series.empty());
#endif
	if (temp_coefficient.rectangle_width < 4) return INF;

	double split_point_id = INF;
	int left_segment_id1 = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	//int left_segment_id2 = left_segment_id1 + 1;
	//int right_segment_id1 = temp_coefficient.right_endpoint - 1;
	int right_segment_id2 = temp_coefficient.right_endpoint;

	//double left_a = original_time_series[left_segment_id2] - original_time_series[left_segment_id1];
	//double right_a = original_time_series[right_segment_id2] - original_time_series[right_segment_id1];
	//double endpoint_value = (temp_coefficient.rectangle_width - 1) * left_a + original_time_series[left_segment_id1];
	/*if (float(left_a) == float(right_a) && float(endpoint_value) == float(original_time_series[right_segment_id2])) {
		return INF;
	}*/
#if _DEBUG
	assert(left_segment_id1 > -1);
#endif

	if (temp_coefficient.rectangle_width > 4) {
		//cout << "Segment left id: " << left_segment_id1 << "         segment right id: " << right_segment_id2 << endl;

		split_point_id = AdaptiveSearchIdPointDistance2(original_time_series, left_segment_id1, right_segment_id2);//190717
		//191206
		//double test_id = find_split_point_by_gradient_descent(original_time_series, left_segment_id1, right_segment_id2);
		//split_point_id = find_split_point_by_gradient_descent(original_time_series, left_segment_id1, right_segment_id2);

		//split_point_id = find_split_point_by_binary_gradient(original_time_series, left_segment_id1, right_segment_id2);//191207

		if (split_point_id == left_segment_id1) {
			split_point_id++;
		}
		else if (split_point_id == right_segment_id2) {
			split_point_id -= 2;
		}
		else if (split_point_id == right_segment_id2 - 1) {
			split_point_id--;
		}
		//cout << "=============================: " << left_segment_id1 << ",  " << right_segment_id2 <<"   "<< (left_segment_id1 + right_segment_id2)/2 << endl;
		//cout << "Split!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!: " << test_id <<",    "<< split_point_id<<",  "<< test_id - split_point_id << endl;
		/*cout << "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" << endl;
		for (int array_id = left_segment_id1; array_id <= right_segment_id2; array_id++) {
			cout << original_time_series[array_id] << ",";
		}
		cout << endl;
		cout << "Split ID: " << split_point_id - left_segment_id1 + 1 << endl;*/
		//split_point_id = AdaptiveSearchIdEquality(original_time_series, left_segment_id1, right_segment_id2);//slope a comparison, similarity 2 points
		//split_point_id = binarySearchIdEquality(original_time_series, left_segment_id1, right_segment_id2);//slope a comparison, similarity 2 points
		//split_point_id = binarySearchIdPointDistance(original_time_series, left_segment_id1, right_segment_id2);//distance to middle point
#if _DEBUG
		assert(split_point_id > 0);
#endif
		return split_point_id;
	}
	else if (temp_coefficient.rectangle_width == 4) {
		return split_point_id = left_segment_id1 + 1;
	}
	else if (temp_coefficient.rectangle_width < 4) {
		return INF;
	}
}

// 
//************************************
// Method:find_split_point_by_direct_intersection_point
// Qualifier: regard the intersection point from  two endpoint of segment as sp;lit id
// Input: the begin id and end id of segment.
// date:200220
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
int APLA::find_split_point_by_direct_intersection_point(const vector<T>& const original_time_series_vector, const Y& const temp_coefficient) {
#if _DEBUG
	assert(temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF && !original_time_series_vector.empty());
#endif
	if (temp_coefficient.rectangle_width < 4) return INF;

	int split_point_id = INF;
	int begin_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	int end_id = temp_coefficient.right_endpoint;

	if (temp_coefficient.rectangle_width > 4) {
		//cout << "Segment left id: " << left_segment_id1 << "         segment right id: " << right_segment_id2 << endl;

		//split_point_id = AdaptiveSearchIdPointDistance2(original_time_series_vector, begin_id, end_id);//190717
		// 200219
		split_point_id = get_intersection_point_by_segment(original_time_series_vector, begin_id, end_id);
		//191206
		//double test_id = find_split_point_by_gradient_descent(original_time_series, left_segment_id1, right_segment_id2);
		//split_point_id = find_split_point_by_gradient_descent(original_time_series, left_segment_id1, right_segment_id2);
		//split_point_id = find_split_point_by_binary_gradient(original_time_series, left_segment_id1, right_segment_id2);//191207
		if (split_point_id < begin_id || split_point_id > end_id) {
			split_point_id = (begin_id + end_id) / 2;
		}
		else if (split_point_id == begin_id) {
			split_point_id++;
		}
		else if (split_point_id == end_id) {
			split_point_id -= 2;
		}
		else if (split_point_id == end_id - 1) {
			split_point_id--;
		}
#if _DEBUG
		assert(split_point_id != INF);
#endif
		return split_point_id;
	}
	else if (temp_coefficient.rectangle_width == 4) {
		return split_point_id = begin_id + 1;
	}
	else if (temp_coefficient.rectangle_width < 4) {
		return INF;
	}
}


//************************************
// Method:find_split_point_by_middle_point
// Qualifier: // regard the middle point of segment split id
// Input:
// Output: Middle point as split point 
// Note: 
// date:200224
// author:
//************************************
TEMPLATE
template<typename T>
inline double APLA::find_split_point_by_middle_point(const T& const temp_coefficient) {
#if _DEBUG
	assert(temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF);
#endif

	switch (int(temp_coefficient.rectangle_width)) {
	case 1:
	case 2:
	case 3:
		return INF;
	case 4:
		return temp_coefficient.right_endpoint - 2;
	default:
		return temp_coefficient.right_endpoint - 0.5 * temp_coefficient.rectangle_width + 0.5;
	}
	assert(0);
}

//************************************
// Method:findSplitSegmentBaseline
// Qualifier: Use optimal method to find split point in one segment.
// Input:
// Output: Best plist point Or min triangle denstiy 
// Note: split_point_type: 0 best split point. 1 min triangle density
// date:200206
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
double APLA::findSplitSegmentBaseline(const vector<T>& const original_time_series, const Y& const temp_coefficient, const int split_point_type) {
#if _DEBUG
	assert(!original_time_series.empty() && temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF && split_point_type >= 0 && split_point_type <= 1);
#endif

	if (temp_coefficient.rectangle_width == 1 || temp_coefficient.rectangle_width == 2 || temp_coefficient.rectangle_width == 3) return INF;
	if (temp_coefficient.rectangle_width == 4) {
		return temp_coefficient.right_endpoint - 2;
	}

	int best_split_id = INF;
	Y temp_temp_coefficient = temp_coefficient;
	Y sub_left_segment;
	Y sub_right_segment;
	int left_segment_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	const int& segment_right_id = temp_coefficient.right_endpoint;
	int candidate_split_id = left_segment_id;// is the right_endpoint of left segment;

	if (split_point_type == 1 && (temp_coefficient.apla.a == INF || temp_coefficient.apla.b == INF)) {
		get_ab_segment(original_time_series, temp_temp_coefficient);
	}


	vector<T> part_original_time_series(original_time_series.begin() + left_segment_id, original_time_series.begin() + segment_right_id + 1);
#if _DEBUG
	assert(part_original_time_series.size() == temp_coefficient.rectangle_width && original_time_series[left_segment_id] == part_original_time_series.front() && original_time_series[segment_right_id] == part_original_time_series.back());
#endif
	vector<T> left_reconstruct_time_series;
	vector<T> right_reconstruct_time_series;

	std::multimap<double, int> eu_id_map;//sum deviation, split id
	std::multimap<double, int> density_id_map;// triangle denstiy, plit id
	std::multimap<double, int> long_segment_height_difference_id_map;// get height difference with long line segment endpoint

	for (candidate_split_id = left_segment_id + 1; candidate_split_id < segment_right_id; candidate_split_id++) {
		//APLA::get_PLA_part_reconstruct_series(original_time_series, left_segment_id, candidate_split_id, left_reconstruct_time_series);
		//APLA::get_PLA_part_reconstruct_series(original_time_series, candidate_split_id + 1, segment_right_id, right_reconstruct_time_series);

		// get left & right sub sgment a&b, right endopint, rectangle width, reconstrcution time series.s
		APLA::get_PLA_part_reconstruct_series(original_time_series, left_segment_id, candidate_split_id, sub_left_segment, left_reconstruct_time_series);
		APLA::get_PLA_part_reconstruct_series(original_time_series, candidate_split_id + 1, segment_right_id, sub_right_segment, right_reconstruct_time_series);

#if _DEBUG
		assert(temp_coefficient.rectangle_width == left_reconstruct_time_series.size() + right_reconstruct_time_series.size() && temp_coefficient.rectangle_width == sub_left_segment.rectangle_width + sub_right_segment.rectangle_width && sub_left_segment.apla.a != INF && sub_left_segment.apla.b != INF && sub_right_segment.apla.a != INF && sub_right_segment.apla.b != INF);
		assert(sub_left_segment.right_endpoint == candidate_split_id && sub_right_segment.right_endpoint == segment_right_id && sub_left_segment.rectangle_width == candidate_split_id - left_segment_id + 1 && sub_right_segment.rectangle_width == segment_right_id - candidate_split_id);
#endif

		switch (split_point_type) {
		case 0: {// best split id 
			/*----------------------------200206 get sum deviaiton of two time series---------------------------------------------------------------------*/
			left_reconstruct_time_series.insert(left_reconstruct_time_series.end(), right_reconstruct_time_series.begin(), right_reconstruct_time_series.end());
#if _DEBUG
			assert(left_reconstruct_time_series.size() == temp_coefficient.rectangle_width);
#endif
			double sum_deviation = TOOL::distanceEUC(part_original_time_series, left_reconstruct_time_series);
			eu_id_map.insert(std::pair<double, int>(sum_deviation, candidate_split_id));
			/*--------------------------------------------------------------------------------------------------------------------------------------------*/
			break;
		}
		case 1: {// min density id
			/*----------------------------200206 get Triangle Density of long semgnet and short segemtns -------------------------------------------*/
			//const AREA_COEFFICIENT& const temp_sub_left_segment = sub_left_segment;
			//const AREA_COEFFICIENT& const  temp_sub_right_segment = sub_right_segment;

			double triangle_density = APLA::getLineSegmentTriangleAreaDensity(sub_left_segment, sub_right_segment, temp_temp_coefficient);//190611
			//triangle_density =  APLA::get_line_segment_height_diference(sub_left_segment, sub_right_segment, temp_coefficient);200206 height difference

			density_id_map.insert(pair<double, int>(triangle_density, candidate_split_id));//200106
			/*--------------------------------------------------------------------------------------------------------------------------------------*/
			break;
		}
		default:
			assert(0);
			break;
		}
		/*----------------------------200206 get height difference with long line segment endpoint  --------------------------------------------*/
		/*--------------------------------------------------------------------------------------------------------------------------------------*/
		left_reconstruct_time_series.clear();
		left_reconstruct_time_series.shrink_to_fit();
		right_reconstruct_time_series.clear();
		right_reconstruct_time_series.shrink_to_fit();
	}
#if _DEBUG
	assert(eu_id_map.size() == part_original_time_series.size() - 2);
	//cout << " Best Split Point: " << eu_id_map.begin()->second << endl;
	//cout << " Min Density Split Point: " << density_id_map.begin()->second << endl;
#endif

	switch (split_point_type) {
	case 0:
		best_split_id = eu_id_map.begin()->second;
		break;
	case 1: {
		best_split_id = density_id_map.begin()->second;
		vector<int> id_of_density_vector;
		//cout << "\n %% Map in this segment: " << endl;
		for (auto&& au : density_id_map) {
			//cout << au.first << " : " << au.second << endl;
			//cout << au.second << ",";
			id_of_density_vector.emplace_back(au.second);
		}
		//cout << endl;

		TOOL::writeResultNoCover("./200206DrawPlotChart/OrderOfDensity", id_of_density_vector);

		id_of_density_vector.clear();
		id_of_density_vector.shrink_to_fit();

		break;
	}
	default:
		assert(0);
		break;
	}

	//cout << "###########################    " << best_split_id << " == " << density_id_map.begin()->second << endl;
	part_original_time_series.clear();
	part_original_time_series.shrink_to_fit();
	eu_id_map.clear();
	density_id_map.clear();

	if (best_split_id == left_segment_id) {
		best_split_id++;
	}
	else if (best_split_id == segment_right_id) {
		best_split_id -= 2;
	}
	else if (best_split_id == segment_right_id - 1) {
		best_split_id--;
	}

	return best_split_id;
}

//200210 
//************************************
// Method:get_split_coefficient
// Qualifier: get split coefficient: left & right a&b, triangle denstiys
// Input:   1 original time series
//          2 Long segment a&b, right point, width.
//          3 Split point id
// Output:  1 left & right sub segment : a&b, right points, width,sum value.
//          2 Triangle Density
// Note: 
// date:200210
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
long double& APLA::get_split_coefficient(const vector<T>& const original_time_series_vector, Y& const temp_coefficient, SPLIT_COEFFICIENT& const split_coefficent) {
#if _DEBUG
	assert(split_coefficent.segment_left.right_endpoint != INF && split_coefficent.segment_left.right_endpoint > 0 && split_coefficent.segment_left.right_endpoint < original_time_series_vector.size() && temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF && temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF && !original_time_series_vector.empty());
#endif	
	int begin_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	int end_id = temp_coefficient.right_endpoint;
#if _DEBUG
	assert(split_coefficent.segment_left.right_endpoint > begin_id && split_coefficent.segment_left.right_endpoint < end_id);
#endif	

	/*.........................................get right endpoint & width..........................................................*/
	//split_coefficent.segment_left.right_endpoint = split_coefficent.segment_left.right_endpoint;
	split_coefficent.segment_right.right_endpoint = temp_coefficient.right_endpoint;
	split_coefficent.segment_right.rectangle_width = temp_coefficient.right_endpoint - split_coefficent.segment_left.right_endpoint;
	split_coefficent.segment_left.rectangle_width = temp_coefficient.rectangle_width - split_coefficent.segment_right.rectangle_width;
	/*..............................................................................................................................*/

	if (split_coefficent.segment_right.rectangle_width == 1) return split_coefficent.segment_right.segment_density = INF;

	APLA::getSubAAndBByPLA(original_time_series_vector, split_coefficent.segment_left, split_coefficent.segment_right, temp_coefficient);

#if _DEBUG
	assert(split_coefficent.segment_left.right_endpoint != INF && split_coefficent.segment_right.right_endpoint != INF && split_coefficent.segment_left.rectangle_width != INF && split_coefficent.segment_right.rectangle_width != INF);
	assert(split_coefficent.segment_left.apla.a != INF && split_coefficent.segment_right.apla.a != INF && split_coefficent.segment_left.apla.b != INF && split_coefficent.segment_right.apla.b != INF);
	//assert(split_coefficent.segment_left.sum_value != INF && split_coefficent.segment_right.sum_value != INF && float(split_coefficent.segment_left.sum_value + split_coefficent.segment_right.sum_value) == float(temp_coefficient.sum_value));
#endif


	return split_coefficent.segment_right.segment_density = getLineSegmentTriangleAreaDensity(split_coefficent.segment_left, split_coefficent.segment_right, temp_coefficient);//190611
}

//200220 get split coefficient: left & right a&b, triangle densitys. return triangle density
//************************************
// Method:get_split_coefficient
// Qualifier: get split coefficient: left & right a&b, triangle denstiys
// Input:   1 original time series
//          2 Long segment a&b, right point, width.
//          3 Split point id
// Output:  1 left & right sub segment : a&b, right points, width,sum value.
//          2 Triangle Density
// Note: 
// date:200210
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
long double& APLA::get_split_coefficient(const vector<T>& const original_time_series_vector, Y& const temp_coefficient, SPLIT_COEFFICIENT& const split_coefficent, const int& const split_id_left, const int& const split_id_right, vector<U>& const segments_density_vector, const int& const split_point_left_segment_id) {
	/*................................................................................................................................*/
#if _DEBUG
	assert(split_coefficent.segment_left.right_endpoint != INF && split_coefficent.segment_left.right_endpoint > 0 && split_coefficent.segment_left.right_endpoint < original_time_series_vector.size() && temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF && temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF && !original_time_series_vector.empty());
	//assert(split_id_left < split_coefficent.segment_left.right_endpoint && split_coefficent.segment_left.right_endpoint < split_id_right && split_point_left_segment_id < segments_density_vector.size());
	const int begin_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	assert(split_coefficent.segment_left.right_endpoint > begin_id && split_coefficent.segment_left.right_endpoint < temp_coefficient.right_endpoint&& begin_id - 1 <= split_id_left && split_id_right <= temp_coefficient.right_endpoint);
#endif
	/*.................................................................................................................................*/

	/*-----------------------------------------             get right endpoint & width         ----------------------------------------*/
	split_coefficent.segment_left.right_endpoint = split_coefficent.segment_left.right_endpoint;
	split_coefficent.segment_right.right_endpoint = temp_coefficient.right_endpoint;
	split_coefficent.segment_right.rectangle_width = temp_coefficient.right_endpoint - split_coefficent.segment_left.right_endpoint;
	split_coefficent.segment_left.rectangle_width = temp_coefficient.rectangle_width - split_coefficent.segment_right.rectangle_width;
	/*---------------------------------------------------------------------------------------------------------------------------------*/

	if (split_coefficent.segment_right.rectangle_width == 1) return split_coefficent.segment_right.segment_density = INF;

	/*split_coefficent.segment_left.apla.a = (original_time_series_vector[split_coefficent.segment_left.right_endpoint] - original_time_series_vector[begin_id]) / split_coefficent.segment_left.rectangle_width;
	split_coefficent.segment_left.apla.b = original_time_series_vector[begin_id];
	split_coefficent.segment_right.apla.a = (original_time_series_vector[temp_coefficient.right_endpoint] - original_time_series_vector[split_coefficent.segment_left.right_endpoint + 1]) / split_coefficent.segment_right.rectangle_width;
	split_coefficent.segment_right.apla.b = original_time_series_vector[split_coefficent.segment_left.right_endpoint + 1];*/

	Y sub_temp_segment;// compute shortest a&b by scan
	const int right_segment_id = split_point_left_segment_id + 1;
	const int left_segment_id = split_point_left_segment_id;
	const int left_width = split_coefficent.segment_left.right_endpoint - split_id_left;
	const int right_width = split_id_right - split_coefficent.segment_left.right_endpoint;

	// Empty vector
	if (segments_density_vector.empty()) {// No split coefficient in vector
		/*......................................................................................................*/
#if _DEBUG
		assert(split_coefficent.segment_left.right_endpoint == (begin_id + temp_coefficient.right_endpoint) / 2);
#endif
		/*......................................................................................................*/
		getSubAAndBByPLA(original_time_series_vector, split_coefficent.segment_left, split_coefficent.segment_right, temp_coefficient);
	}// current is the last segment, add new segment at tail
	else if (right_segment_id == segments_density_vector.size()) {
		getAAndBByPLA(original_time_series_vector, split_coefficent.segment_right);
		// get split sub left segment, already know total as long segment, split sub right segment
		getSubLeftAAndBByPLA(split_coefficent.segment_right, temp_coefficient, split_coefficent.segment_left);
	}// current is the first segment, add nes segmetn at head
	else if (left_segment_id < 0) {
		getAAndBByPLA(original_time_series_vector, split_coefficent.segment_left);
		// get split sub left segment, already know total as long segment, split sub right segment
		getSubRightAAndBByPLA(split_coefficent.segment_left, temp_coefficient, split_coefficent.segment_right);
	}//near left split id
	else if (left_width < right_width) {//Already has split coefficient in vector.
		/*.....get a&b from left spit id to middle split id .......*/
		if (left_width == 1) {
			get_ab_segment_by_accumulation(original_time_series_vector, segments_density_vector[split_point_left_segment_id].segment_left, split_coefficent.segment_left);
			getSubRightAAndBByPLA(split_coefficent.segment_left, temp_coefficient, split_coefficent.segment_right);
		}
		else {
			sub_temp_segment.right_endpoint = split_coefficent.segment_left.right_endpoint;
			sub_temp_segment.rectangle_width = left_width;
			getAAndBByPLA(original_time_series_vector, sub_temp_segment);
			/*........................................................*/
			/*.....get a&b from left spit id to middle split id .......*/
			// scan as sub left segment, left split sub right segment as long segment.
			getSubRightAAndBByPLA(sub_temp_segment, segments_density_vector[split_point_left_segment_id].segment_right, split_coefficent.segment_right);
			// get split sub left segment, already know total as long segment, split sub right segment
			getSubLeftAAndBByPLA(split_coefficent.segment_right, temp_coefficient, split_coefficent.segment_left);
			/*........................................................*/
		}
	}
	else {//near right split id
		if (right_width == 1) {
			get_ab_segment_by_decrement(original_time_series_vector, segments_density_vector[split_point_left_segment_id + 1].segment_left, split_coefficent.segment_left);
			getSubRightAAndBByPLA(split_coefficent.segment_left, temp_coefficient, split_coefficent.segment_right);
		}
		else {
			sub_temp_segment.right_endpoint = split_id_right;
			sub_temp_segment.rectangle_width = right_width;
			getAAndBByPLA(original_time_series_vector, sub_temp_segment);

			/*..... get a&b from right spit id to middle split id .......*/
			// scan as sub right segment, right split sub left segment as long segment.
			getSubLeftAAndBByPLA(sub_temp_segment, segments_density_vector[split_point_left_segment_id + 1].segment_left, split_coefficent.segment_left);
			// get split sub right segment, already know total as long segment, split sub left segment
			getSubRightAAndBByPLA(split_coefficent.segment_left, temp_coefficient, split_coefficent.segment_right);
			/*...........................................................*/
		}
	}

	/*.........................................................................................................................................*/
#if _DEBUG
	Y test_sub_left_segment = split_coefficent.segment_left;
	Y test_sub_right_segment = split_coefficent.segment_right;
	Y test_long_segment = temp_coefficient;
	getSubAAndBByPLA(original_time_series_vector, test_sub_left_segment, test_sub_right_segment, temp_coefficient);
	assert_two_segments_a_b(test_sub_left_segment, split_coefficent.segment_left);
	assert_two_segments_a_b(test_sub_right_segment, split_coefficent.segment_right);

	get_ab_segment(original_time_series_vector, test_sub_left_segment);
	get_ab_segment(original_time_series_vector, test_sub_right_segment);
	get_ab_segment(original_time_series_vector, test_long_segment);
	assert_two_segments_a_b(test_sub_left_segment, split_coefficent.segment_left);
	assert_two_segments_a_b(test_sub_right_segment, split_coefficent.segment_right);
	assert_two_segments_a_b(test_long_segment, temp_coefficient);

	assert(split_coefficent.segment_left.right_endpoint != INF && split_coefficent.segment_right.right_endpoint != INF && split_coefficent.segment_left.rectangle_width != INF && split_coefficent.segment_right.rectangle_width != INF);
	assert(split_coefficent.segment_left.apla.a != INF && split_coefficent.segment_right.apla.a != INF && split_coefficent.segment_left.apla.b != INF && split_coefficent.segment_right.apla.b != INF);
	assert(split_coefficent.segment_left.rectangle_width + split_coefficent.segment_right.rectangle_width == temp_coefficient.rectangle_width);
#endif
	/*.........................................................................................................................................*/

	return split_coefficent.segment_right.segment_density = getLineSegmentTriangleAreaDensity(split_coefficent.segment_left, split_coefficent.segment_right, temp_coefficient);//190611
}

//200301 Use linked list to instead vector. get split coefficient: left & right a&b, triangle densitys. return triangle density
//************************************
// Method:get_split_coefficient
// Qualifier: get split coefficient: left & right a&b, triangle denstiys
// Input:   1 original time series
//          2 Long segment a&b, right point, width.
//          3 Split point id
// Output:  1 left & right sub segment : a&b, right points, width,sum value.
//          2 Triangle Density
// Note: Linked list to instead vector
// date:200301
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
long double& APLA::get_split_coefficient(const vector<T>& const original_time_series_vector, Y& const temp_coefficient, SPLIT_COEFFICIENT& const split_coefficent, const int& const split_id_left, const int& const split_id_right, DoublyLinkedList<U>& const segments_density_linked_list, const int& const split_point_left_segment_id) {
#if _DEBUG
	assert(split_coefficent.segment_left.right_endpoint != INF && split_coefficent.segment_left.right_endpoint > 0 && split_coefficent.segment_left.right_endpoint < original_time_series_vector.size() && temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF && temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF && !original_time_series_vector.empty());
	//assert(split_id_left < split_coefficent.segment_left.right_endpoint && split_coefficent.segment_left.right_endpoint < split_id_right && split_point_left_segment_id < segments_density_vector.size());
	const int begin_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	assert(split_coefficent.segment_left.right_endpoint > begin_id && split_coefficent.segment_left.right_endpoint < temp_coefficient.right_endpoint&& begin_id - 1 <= split_id_left && split_id_right <= temp_coefficient.right_endpoint);
#endif

	/*.....................................................get right endpoint & width...............................................*/
	split_coefficent.segment_left.right_endpoint = split_coefficent.segment_left.right_endpoint;
	split_coefficent.segment_right.right_endpoint = temp_coefficient.right_endpoint;
	split_coefficent.segment_right.rectangle_width = temp_coefficient.right_endpoint - split_coefficent.segment_left.right_endpoint;
	split_coefficent.segment_left.rectangle_width = temp_coefficient.rectangle_width - split_coefficent.segment_right.rectangle_width;
	/*..............................................................................................................................*/

	if (split_coefficent.segment_right.rectangle_width == 1) return split_coefficent.segment_right.segment_density = INF;

	/*split_coefficent.segment_left.apla.a = (original_time_series_vector[split_coefficent.segment_left.right_endpoint] - original_time_series_vector[begin_id]) / split_coefficent.segment_left.rectangle_width;
	split_coefficent.segment_left.apla.b = original_time_series_vector[begin_id];
	split_coefficent.segment_right.apla.a = (original_time_series_vector[temp_coefficient.right_endpoint] - original_time_series_vector[split_coefficent.segment_left.right_endpoint + 1]) / split_coefficent.segment_right.rectangle_width;
	split_coefficent.segment_right.apla.b = original_time_series_vector[split_coefficent.segment_left.right_endpoint + 1];*/

	Y sub_temp_segment;// compute shortest a&b by scan
	const int right_segment_id = split_point_left_segment_id + 1;
	const int left_segment_id = split_point_left_segment_id;
	const int left_width = split_coefficent.segment_left.right_endpoint - split_id_left;
	const int right_width = split_id_right - split_coefficent.segment_left.right_endpoint;

	// Empty vector
	if (segments_density_linked_list.empty()) {// No split coefficient in vector
#if _DEBUG
		assert(split_coefficent.segment_left.right_endpoint == (begin_id + temp_coefficient.right_endpoint) / 2);
#endif
		getSubAAndBByPLA(original_time_series_vector, split_coefficent.segment_left, split_coefficent.segment_right, temp_coefficient);
	}// current is the last segment, add new segment at tail
	else if (right_segment_id == segments_density_linked_list.size()) {
		getAAndBByPLA(original_time_series_vector, split_coefficent.segment_right);
		// get split sub left segment, already know total as long segment, split sub right segment
		getSubLeftAAndBByPLA(split_coefficent.segment_right, temp_coefficient, split_coefficent.segment_left);
	}// current is the first segment, add nes segmetn at head
	else if (left_segment_id < 0) {
		getAAndBByPLA(original_time_series_vector, split_coefficent.segment_left);
		// get split sub left segment, already know total as long segment, split sub right segment
		getSubRightAAndBByPLA(split_coefficent.segment_left, temp_coefficient, split_coefficent.segment_right);
	}//near left split id
	else if (left_width < right_width) {//Already has split coefficient in vector.
		/*.....get a&b from left spit id to middle split id .......*/
		if (left_width == 1) {
			get_ab_segment_by_accumulation(original_time_series_vector, segments_density_linked_list[split_point_left_segment_id].segment_left, split_coefficent.segment_left);
			getSubRightAAndBByPLA(split_coefficent.segment_left, temp_coefficient, split_coefficent.segment_right);
		}
		else {
			sub_temp_segment.right_endpoint = split_coefficent.segment_left.right_endpoint;
			sub_temp_segment.rectangle_width = left_width;
			getAAndBByPLA(original_time_series_vector, sub_temp_segment);
			/*........................................................*/
			/*.....get a&b from left spit id to middle split id .......*/
			// scan as sub left segment, left split sub right segment as long segment.
			getSubRightAAndBByPLA(sub_temp_segment, segments_density_linked_list[split_point_left_segment_id].segment_right, split_coefficent.segment_right);
			// get split sub left segment, already know total as long segment, split sub right segment
			getSubLeftAAndBByPLA(split_coefficent.segment_right, temp_coefficient, split_coefficent.segment_left);
			/*........................................................*/
		}
	}
	else {//near right split id
		if (right_width == 1) {
			get_ab_segment_by_decrement(original_time_series_vector, segments_density_linked_list[split_point_left_segment_id + 1].segment_left, split_coefficent.segment_left);
			getSubRightAAndBByPLA(split_coefficent.segment_left, temp_coefficient, split_coefficent.segment_right);
		}
		else {
			sub_temp_segment.right_endpoint = split_id_right;
			sub_temp_segment.rectangle_width = right_width;
			getAAndBByPLA(original_time_series_vector, sub_temp_segment);
			/*.....get a&b from right spit id to middle split id .......*/
			// scan as sub right segment, right split sub left segment as long segment.
			getSubLeftAAndBByPLA(sub_temp_segment, segments_density_linked_list[split_point_left_segment_id + 1].segment_left, split_coefficent.segment_left);
			// get split sub right segment, already know total as long segment, split sub left segment
			getSubRightAAndBByPLA(split_coefficent.segment_left, temp_coefficient, split_coefficent.segment_right);
			/*........................................................*/
		}
	}

#if _DEBUG
	Y test_sub_left_segment = split_coefficent.segment_left;
	Y test_sub_right_segment = split_coefficent.segment_right;
	getSubAAndBByPLA(original_time_series_vector, test_sub_left_segment, test_sub_right_segment, temp_coefficient);

	assert(fabs(float(test_sub_left_segment.apla.a) - float(split_coefficent.segment_left.apla.a)) <= MIN_D && float(test_sub_left_segment.apla.b) == float(split_coefficent.segment_left.apla.b) && fabs(float(test_sub_right_segment.apla.a) - float(split_coefficent.segment_right.apla.a)) <= MIN_D && float(test_sub_right_segment.apla.b) == float(split_coefficent.segment_right.apla.b));
	assert(split_coefficent.segment_left.right_endpoint != INF && split_coefficent.segment_right.right_endpoint != INF && split_coefficent.segment_left.rectangle_width != INF && split_coefficent.segment_right.rectangle_width != INF);
	assert(split_coefficent.segment_left.apla.a != INF && split_coefficent.segment_right.apla.a != INF && split_coefficent.segment_left.apla.b != INF && split_coefficent.segment_right.apla.b != INF);
	//assert(split_coefficent.segment_left.sum_value != INF && split_coefficent.segment_right.sum_value != INF && float(split_coefficent.segment_left.sum_value + split_coefficent.segment_right.sum_value) == float(temp_coefficient.sum_value));
#endif

	return split_coefficent.segment_right.segment_density = getLineSegmentTriangleAreaDensity(split_coefficent.segment_left, split_coefficent.segment_right, temp_coefficient);//190611
}

//200217 get split coefficient:sub left & right a&b, triangle denstiys
// return trianle density
//************************************
// Method:get_split_coefficient
// Qualifier: get split coefficient: left & right a&b, triangle denstiys
// Input:   1 original time series
//          2 Long segment a&b, right point, width.
//          3 Split point
//          4 blank sub left & right segments
// Output:  1 left & right sub segment : a&b, right points, width,sum value.
//          2 long segment Triangle Density
// Note: 
// date:200217
// author:
//************************************
//template<typename T, typename Y , typename U>
//double& get_split_coefficient(const vector<T>& const original_time_series_vector, U& const split_coefficent,Y& const sub_segment_left, Y& const sub_segment_right, Y& const original_long_segment) {
//	assert(split_coefficent.segment_left.right_endpoint != INF && split_coefficent.segment_left.right_endpoint > 0 && split_coefficent.segment_left.right_endpoint < original_time_series_vector.size() && temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF && temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF && !original_time_series_vector.empty());
//	int begin_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
//	int end_id = temp_coefficient.right_endpoint;
//	assert(split_coefficent.segment_left.right_endpoint > begin_id&& split_coefficent.segment_left.right_endpoint < end_id);
//
//	/*..............get right endpoint & width..............*/
//	split_coefficent.segment_left.right_endpoint = split_coefficent.segment_left.right_endpoint;
//	split_coefficent.segment_right.right_endpoint = temp_coefficient.right_endpoint;
//	split_coefficent.segment_right.rectangle_width = temp_coefficient.right_endpoint - split_coefficent.segment_left.right_endpoint;
//	split_coefficent.segment_left.rectangle_width = temp_coefficient.rectangle_width - split_coefficent.segment_right.rectangle_width;
//	/*......................................................*/
//	if (split_coefficent.segment_right.rectangle_width == 1) return split_coefficent.segment_right.segment_density = INF;
//
//	APLA::getSubAAndBByPLA(original_time_series_vector, split_coefficent.segment_left, split_coefficent.segment_right, temp_coefficient);
//
//#if _DEBUG
//	assert(split_coefficent.segment_left.right_endpoint != INF && split_coefficent.segment_right.right_endpoint != INF && split_coefficent.segment_left.rectangle_width != INF && split_coefficent.segment_right.rectangle_width != INF);
//	assert(split_coefficent.segment_left.apla.a != INF && split_coefficent.segment_right.apla.a != INF && split_coefficent.segment_left.apla.b != INF && split_coefficent.segment_right.apla.b != INF);
//	assert(split_coefficent.segment_left.sum_value != INF && split_coefficent.segment_right.sum_value != INF);
//#endif
//
//	return split_coefficent.segment_right.segment_density = getLineSegmentTriangleAreaDensity(split_coefficent.segment_left, split_coefficent.segment_right, temp_coefficient);//190611
//}

//200214 Find min density point fast use vector. prove coefficeints for sub left segment, sub irght segment, and long smegnetnr
//************************************
// Method:get_segment_min_density_local_id
// Qualifier: Find local min density point fast use vector in one long segment
// Input: 1 original time series 
//        2 min density vector not empty
//        3 long segment: right endpoint, rectangle width, a&b, sum_value
// Output: 1 min density local Split point id, coefficients of sub left & right and logne semgng a&b, right endpoint, rectanle width. 
//         2 Long segmnet triangle density
// Note: 
// date:200214
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
U APLA::get_segment_min_density_local_id(const vector<T>& const original_time_series_vector, Y& const original_long_segment, vector<U>& const segments_density_vector) {

#if _DEBUG
	assert(segments_density_vector.empty() && !original_time_series_vector.empty() && original_long_segment.right_endpoint != INF && original_long_segment.rectangle_width != INF);
	DensityIncrease density_min_to_max;
#endif

	const int begin_id = original_long_segment.right_endpoint - original_long_segment.rectangle_width + 1;
	const int& const end_id = original_long_segment.right_endpoint;
	//int middle_id = (begin_id + end_id) / 2;

	//*1 int split_id = INF;// pint id
	//*2 int split_magnitude = INF;
	//*3 double segment_density = INF;
	U temporary_split_coefficients;

	temporary_split_coefficients.split_magnitude = -1;
	//split_coefficent_left.split_magnitude = -1;
	//split_coefficent_right.split_magnitude = -1;

	temporary_split_coefficients.segment_left.right_endpoint = (begin_id + end_id) / 2;
	//split_coefficent_left.segment_left.right_endpoint = split_coefficent_right.segment_left.right_endpoint = 1;
	//split_coefficent_left.segment_left.right_endpoint = (begin_id + middle_id) / 2;
	//split_coefficent_right.segment_left.right_endpoint = (middle_id + end_id) / 2;

	/*if (temp_coefficient.rectangle_width == 4) {
		split_coefficent_middle.segment_left.right_endpoint = temp_coefficient.right_endpoint - 2;
		APLA::get_split_coefficient(original_time_series_vector, long_segment, split_coefficent_middle);
		return split_coefficent_middle.segment_left.right_endpoint;
	}*/

	/*............................ get triangle density of each split point......................*/
	//get  sub left & right segment : a&b. trianle density.
	//APLA::get_split_coefficient(original_time_series_vector, long_segment, split_coefficent_left);
	get_split_coefficient(original_time_series_vector, original_long_segment, temporary_split_coefficients);
	//APLA::get_split_coefficient(original_time_series_vector, long_segment, split_coefficent_right);
#if _DEBUG
	//assert segment density, magnitude, sub left & right a&b, right endpoint, width, sum value
	assert_structure_split_coefficients(temporary_split_coefficients);
#endif
	/*............................................................................................*/

	if (temporary_split_coefficients.segment_right.segment_density == INF) {
		return temporary_split_coefficients;
	}

	//segments_density_vector.emplace_back(split_coefficent_left);
	segments_density_vector.emplace_back(temporary_split_coefficients);
	//segments_density_vector.emplace_back(split_coefficent_right);

	//std::sort(segments_density_vector.begin(), segments_density_vector.end(), split_id_min_to_max);
	//auto [min, max] = minmax_element(segments_density_vector.begin(), segments_density_vector.end(), density_min_to_max);

	/*====================================== Use gradient descent to get local min density split pint===========================================*/
	bool has_split_id_right = true;
	bool has_split_id_left = true;

	int id_min_density_segment_current = 0;
	int id_min_density_segment_next = 0;

#if _DEBUG
	assert(segments_density_vector.size() == 1 && temporary_split_coefficients.segment_right.segment_density != INF);
#endif

	// note: insert action will influence id of vector
	while (has_split_id_left || has_split_id_right) {
		id_min_density_segment_current = id_min_density_segment_next;
#if _DEBUG
		assert(!segments_density_vector.empty() && id_min_density_segment_current >= 0 && id_min_density_segment_current < segments_density_vector.size() && id_min_density_segment_next >= 0 && id_min_density_segment_next < segments_density_vector.size());
		const auto& const test_temp_min_density_segment = min_element(segments_density_vector.begin(), segments_density_vector.end(), density_min_to_max);
		const int test_min_density_segment_id = test_temp_min_density_segment - segments_density_vector.begin();// id in vector [0,n-1);
		assert(id_min_density_segment_current == test_min_density_segment_id);
#endif
		/*................................get adjacent id, left & right id in vector............................*/
		auto& segment_min_density_current = segments_density_vector[id_min_density_segment_current];
		const int right_segment_id = id_min_density_segment_current + 1;
		const int left_segment_id = id_min_density_segment_current - 1;
		/*.......................................................................................................*/
		//temp_min_density_segment->split_magnitude++;
		segments_density_vector[id_min_density_segment_current].split_magnitude++;
		temporary_split_coefficients.split_magnitude = segments_density_vector[id_min_density_segment_current].split_magnitude;
		// note: insert action will influence id of vector
		// Right Split ID 
		/*------------------------------------------------------------------- Right split id -------------------------------------------------------------------------------*/
		if (right_segment_id == segments_density_vector.size() && end_id - 2 > segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint) {//middle segment is the last segment in vector
			////the last two points consist one segment. end id of segment
			//if () {// 
				//get segment triangle density && insert vecter
			temporary_split_coefficients.segment_left.right_endpoint = (end_id + segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint) / 2;
			//temporary_split_coefficients.split_magnitude++;
			//APLA::get_split_coefficient(original_time_series_vector, original_long_segment, temporary_split_coefficients);
			get_split_coefficient(original_time_series_vector, original_long_segment, temporary_split_coefficients, segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint, end_id, segments_density_vector, id_min_density_segment_current);
#if _DEBUG
			//assert segment density, magnitude, sub left & right a&b, right endpoint, width, sum value
			assert_structure_split_coefficients(temporary_split_coefficients);
#endif
			segments_density_vector.emplace_back(temporary_split_coefficients);// push back last segment in the tail of vector
			if (temporary_split_coefficients.segment_right.segment_density < segments_density_vector[id_min_density_segment_current].segment_right.segment_density) {
				id_min_density_segment_next = right_segment_id;
#if _DEBUG
				assert(!segments_density_vector.empty() && id_min_density_segment_current >= 0 && id_min_density_segment_current < segments_density_vector.size() && id_min_density_segment_next >= 0 && id_min_density_segment_next < segments_density_vector.size());
				const auto& const test_temp_min_density_segment = min_element(segments_density_vector.begin(), segments_density_vector.end(), density_min_to_max);
				const int test_min_density_segment_id = test_temp_min_density_segment - segments_density_vector.begin();// id in vector [0,n-1);
				assert(id_min_density_segment_next == test_min_density_segment_id);
#endif
			}
			//}
			//else {
				//has_split_id_right = false;
			//}
		}
		else if (right_segment_id < segments_density_vector.size() && segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint + 1 < segments_density_vector[right_segment_id].segment_left.right_endpoint) {// middle and right split id is not adjacent
			//get split point id
			temporary_split_coefficients.segment_left.right_endpoint = (segments_density_vector[right_segment_id].segment_left.right_endpoint + segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint) / 2;
			//temporary_split_coefficients.split_magnitude++;
			//APLA::get_split_coefficient(original_time_series_vector, original_long_segment, temporary_split_coefficients);
			get_split_coefficient(original_time_series_vector, original_long_segment, temporary_split_coefficients, segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint, segments_density_vector[right_segment_id].segment_left.right_endpoint, segments_density_vector, id_min_density_segment_current);
#if _DEBUG
			//assert segment density, magnitude, sub left & right a&b, right endpoint, width, sum value
			assert_structure_split_coefficients(temporary_split_coefficients);
#endif
			segments_density_vector.emplace(segments_density_vector.begin() + right_segment_id, temporary_split_coefficients);// insert position is before begin() + id
			if (temporary_split_coefficients.segment_right.segment_density < segments_density_vector[id_min_density_segment_current].segment_right.segment_density) {
				id_min_density_segment_next = right_segment_id;
#if _DEBUG
				assert(!segments_density_vector.empty() && id_min_density_segment_current >= 0 && id_min_density_segment_current < segments_density_vector.size() && id_min_density_segment_next >= 0 && id_min_density_segment_next < segments_density_vector.size());
				const auto& const test_temp_min_density_segment = min_element(segments_density_vector.begin(), segments_density_vector.end(), density_min_to_max);
				const int test_min_density_segment_id = test_temp_min_density_segment - segments_density_vector.begin();// id in vector [0,n-1);
				assert(id_min_density_segment_next == test_min_density_segment_id);
#endif
			}
		}
		else {
			has_split_id_right = false;
		}
		/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
		//200218
		//Now, after above insertion, the min segment id in vector may changed,  
		//id_min_density_segment_next == id_min_density_segment_current || id_min_density_segment_next == id_min_density_segment_current = 1
		//Middle segment is first segment // begin id of segment
		/*-------------------------------------------------------------------------    Left split id     -------------------------------------------------------------------------*/
		if (left_segment_id < 0 && begin_id + 1 < segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint) {
#if _DEBUG
			assert(id_min_density_segment_current == 0);
#endif
			//if () {// begin id of segment
				//get segment triangle density && insert vecter
			temporary_split_coefficients.segment_left.right_endpoint = (begin_id + segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint) / 2;
			//temporary_split_coefficients.split_magnitude++;
			//APLA::get_split_coefficient(original_time_series_vector, original_long_segment, temporary_split_coefficients);
			get_split_coefficient(original_time_series_vector, original_long_segment, temporary_split_coefficients, begin_id - 1, segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint, segments_density_vector, left_segment_id);
#if _DEBUG
			//assert segment density, magnitude, sub left & right a&b, right endpoint, width, sum value
			assert_structure_split_coefficients(temporary_split_coefficients);
#endif
			segments_density_vector.emplace(segments_density_vector.cbegin(), temporary_split_coefficients);// insert segment at the first of vector
			//after left insertion, the id in vector was changed
			id_min_density_segment_next++;
			if (temporary_split_coefficients.segment_right.segment_density <= segments_density_vector[id_min_density_segment_next].segment_right.segment_density) {
				id_min_density_segment_next = 0;
#if _DEBUG
				assert(!segments_density_vector.empty() && id_min_density_segment_current >= 0 && id_min_density_segment_current < segments_density_vector.size() && id_min_density_segment_next >= 0 && id_min_density_segment_next < segments_density_vector.size());
				const auto& const test_temp_min_density_segment = min_element(segments_density_vector.begin(), segments_density_vector.end(), density_min_to_max);
				const int test_min_density_segment_id = test_temp_min_density_segment - segments_density_vector.begin();// id in vector [0,n-1);
				assert(id_min_density_segment_next == test_min_density_segment_id);
#endif
			}
			//}
			//else {
				//has_split_id_left = false;
			//}
		}// left and middle split id is not ajacent
		else if (left_segment_id > -1 && segments_density_vector[left_segment_id].segment_left.right_endpoint + 1 < segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint) {
			//get segment triangle density && insert vecter
			temporary_split_coefficients.segment_left.right_endpoint = (segments_density_vector[left_segment_id].segment_left.right_endpoint + segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint) / 2;
			//temporary_split_coefficients.split_magnitude++;
			//APLA::get_split_coefficient(original_time_series_vector, original_long_segment, temporary_split_coefficients);
			get_split_coefficient(original_time_series_vector, original_long_segment, temporary_split_coefficients, segments_density_vector[left_segment_id].segment_left.right_endpoint, segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint, segments_density_vector, left_segment_id);
#if _DEBUG
			//assert segment density, magnitude, sub left & right a&b, right endpoint, width, sum value
			assert_structure_split_coefficients(temporary_split_coefficients);
#endif
			segments_density_vector.emplace(segments_density_vector.begin() + id_min_density_segment_current, temporary_split_coefficients);// insert position is before begin() + id
			//after left insertion, the id in vector was changed
			id_min_density_segment_next++;
			if (temporary_split_coefficients.segment_right.segment_density <= segments_density_vector[id_min_density_segment_next].segment_right.segment_density) {
				id_min_density_segment_next = id_min_density_segment_current;
#if _DEBUG
				assert(!segments_density_vector.empty() && id_min_density_segment_current >= 0 && id_min_density_segment_current < segments_density_vector.size() && id_min_density_segment_next >= 0 && id_min_density_segment_next < segments_density_vector.size());
				const auto& const test_temp_min_density_segment = min_element(segments_density_vector.begin(), segments_density_vector.end(), density_min_to_max);
				const int test_min_density_segment_id = test_temp_min_density_segment - segments_density_vector.begin();// id in vector [0,n-1);
				assert(id_min_density_segment_next == test_min_density_segment_id);
#endif
			}
		}
		else {
			has_split_id_left = false;
		}
		/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	}

#if _DEBUG
	const auto& const min_density_segment = min_element(segments_density_vector.begin(), segments_density_vector.end(), density_min_to_max);
	assert(segments_density_vector[id_min_density_segment_next].segment_left.right_endpoint == min_density_segment->segment_left.right_endpoint);
#endif
	return segments_density_vector[id_min_density_segment_next];
}

//200301 Find min density point fast use linked list. prove coefficeints for sub left segment, sub right segment, and long segment pointer
//************************************
// Method:get_segment_min_density_local_id
// Qualifier: Find local min density point fast use vector in one long segment
// Input: 1 original time series 
//        2 min density vector not empty
//        3 long segment: right endpoint, rectangle width, a&b, sum_value
// Output: 1 min density local Split point id, coefficients of sub left & right and logne semgng a&b, right endpoint, rectanle width. 
//         2 Long segmnet triangle density
// Note: Use linked list to instead vector
// date:200301
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
U APLA::get_segment_min_density_local_id(const vector<T>& const original_time_series_vector, Y& const original_long_segment, DoublyLinkedList<U>& const segments_density_linked_list) {
#if _DEBUG
	assert(segments_density_linked_list.empty() && !original_time_series_vector.empty() && original_long_segment.right_endpoint != INF && original_long_segment.rectangle_width != INF);
	DensityIncrease density_min_to_max;
#endif

	const int begin_id = original_long_segment.right_endpoint - original_long_segment.rectangle_width + 1;
	const int& const end_id = original_long_segment.right_endpoint;
	//int middle_id = (begin_id + end_id) / 2;

	//*1 int split_id = INF;// pint id
	//*2 int split_magnitude = INF;
	//*3 double segment_density = INF;
	U temporary_split_coefficients;

	temporary_split_coefficients.split_magnitude = -1;
	//split_coefficent_left.split_magnitude = -1;
	//split_coefficent_right.split_magnitude = -1;

	temporary_split_coefficients.segment_left.right_endpoint = (begin_id + end_id) / 2;
	//split_coefficent_left.segment_left.right_endpoint = split_coefficent_right.segment_left.right_endpoint = 1;
	//split_coefficent_left.segment_left.right_endpoint = (begin_id + middle_id) / 2;
	//split_coefficent_right.segment_left.right_endpoint = (middle_id + end_id) / 2;

	/*if (temp_coefficient.rectangle_width == 4) {
		split_coefficent_middle.segment_left.right_endpoint = temp_coefficient.right_endpoint - 2;
		APLA::get_split_coefficient(original_time_series_vector, long_segment, split_coefficent_middle);
		return split_coefficent_middle.segment_left.right_endpoint;
	}*/

	/*............................ get triangle density of each split point......................*/
	//get  sub left & right segment : a&b. trianle density.
	//APLA::get_split_coefficient(original_time_series_vector, long_segment, split_coefficent_left);
	get_split_coefficient(original_time_series_vector, original_long_segment, temporary_split_coefficients);
	//APLA::get_split_coefficient(original_time_series_vector, long_segment, split_coefficent_right);
#if _DEBUG
//assert segment density, magnitude, sub left & right a&b, right endpoint, width, sum value
	assert_structure_split_coefficients(temporary_split_coefficients);
#endif
	/*............................................................................................*/


	//segments_density_vector.emplace_back(split_coefficent_left);
	segments_density_linked_list.emplace_back(temporary_split_coefficients);
	//segments_density_vector.emplace_back(split_coefficent_right);

	//std::sort(segments_density_vector.begin(), segments_density_vector.end(), split_id_min_to_max);
	//auto [min, max] = minmax_element(segments_density_vector.begin(), segments_density_vector.end(), density_min_to_max);

	/*====================================== Use gradient descent to get local min density split pint===========================================*/
	bool has_split_id_right = true;
	bool has_split_id_left = true;

	int id_min_density_segment_current = 0;
	int id_min_density_segment_next = 0;

#if _DEBUG
	assert(segments_density_linked_list.size() == 1 && temporary_split_coefficients.segment_right.segment_density != INF);
#endif

	// note: insert action will influence id of vector
	while (has_split_id_left || has_split_id_right) {
		id_min_density_segment_current = id_min_density_segment_next;
#if _DEBUG
		assert(!segments_density_linked_list.empty() && id_min_density_segment_current >= 0 && id_min_density_segment_current < segments_density_linked_list.size() && id_min_density_segment_next >= 0 && id_min_density_segment_next < segments_density_linked_list.size());
		//const auto& const test_temp_min_density_segment = min_element(segments_density_linked_list.begin(), segments_density_linked_list.end(), density_min_to_max);
		//const int test_min_density_segment_id = test_temp_min_density_segment - segments_density_linked_list.begin();// id in vector [0,n-1);
		//assert(id_min_density_segment_current == test_min_density_segment_id);
#endif
		/*................................get adjacent id, left & right id in vector............................*/
		auto& const segment_min_density_current = segments_density_linked_list[id_min_density_segment_current];
		auto& const node_min_density_current = segments_density_linked_list.getNode(id_min_density_segment_current);
		const int id_segment_right = id_min_density_segment_current + 1;
		const int id_segment_left = id_min_density_segment_current - 1;
		/*.......................................................................................................*/
		//temp_min_density_segment->split_magnitude++;
		//segments_density_linked_list[id_min_density_segment_current].split_magnitude++;
		temporary_split_coefficients.split_magnitude = ++segment_min_density_current.split_magnitude;
		// note: insert action will influence id of vector
		// Right Split ID 
		/*------------------------------------------------------------------- Right split id -------------------------------------------------------------------------------*/
		if (id_segment_right == segments_density_linked_list.size() && end_id - 2 > segment_min_density_current.segment_left.right_endpoint) {//middle segment is the last segment in vector
			////the last two points consist one segment. end id of segment
			//if () {// 
				//get segment triangle density && insert vecter
			temporary_split_coefficients.segment_left.right_endpoint = (end_id + segment_min_density_current.segment_left.right_endpoint) / 2;
			//temporary_split_coefficients.split_magnitude++;
			//APLA::get_split_coefficient(original_time_series_vector, original_long_segment, temporary_split_coefficients);
			get_split_coefficient(original_time_series_vector, original_long_segment, temporary_split_coefficients, segment_min_density_current.segment_left.right_endpoint, end_id, segments_density_linked_list, id_min_density_segment_current);
#if _DEBUG
			//assert segment density, magnitude, sub left & right a&b, right endpoint, width, sum value
			assert_structure_split_coefficients(temporary_split_coefficients);
#endif
			segments_density_linked_list.emplace_back(temporary_split_coefficients);// push back last segment in the tail of vector
			if (temporary_split_coefficients.segment_right.segment_density < segment_min_density_current.segment_right.segment_density) {
				id_min_density_segment_next = id_segment_right;//+1
#if _DEBUG
				assert(!segments_density_linked_list.empty() && id_min_density_segment_current >= 0 && id_min_density_segment_current < segments_density_linked_list.size() && id_min_density_segment_next >= 0 && id_min_density_segment_next < segments_density_linked_list.size());
				//const auto& const test_temp_min_density_segment = min_element(segments_density_linked_list.begin(), segments_density_linked_list.end(), density_min_to_max);
				//const int test_min_density_segment_id = test_temp_min_density_segment - segments_density_linked_list.begin();// id in vector [0,n-1);
				//assert(id_min_density_segment_next == test_min_density_segment_id);
#endif
			}
			//}
			//else {
				//has_split_id_right = false;
			//}
		}
		else if (id_segment_right < segments_density_linked_list.size() && segment_min_density_current.segment_left.right_endpoint + 1 < node_min_density_current.next_value().segment_left.right_endpoint) {// middle and right split id is not adjacent <<  node_min_density_current.next_value() == segments_density_linked_list[id_segment_right].segment_left.right_endpoint  >>
			//get segment triangle density && insert vecter
			temporary_split_coefficients.segment_left.right_endpoint = (node_min_density_current.next_value().segment_left.right_endpoint + segment_min_density_current.segment_left.right_endpoint) / 2;
			//temporary_split_coefficients.split_magnitude++;
			//APLA::get_split_coefficient(original_time_series_vector, original_long_segment, temporary_split_coefficients);
			get_split_coefficient(original_time_series_vector, original_long_segment, temporary_split_coefficients, segment_min_density_current.segment_left.right_endpoint, node_min_density_current.next_value().segment_left.right_endpoint, segments_density_linked_list, id_min_density_segment_current);
#if _DEBUG
			//assert segment density, magnitude, sub left & right a&b, right endpoint, width, sum value
			assert_structure_split_coefficients(temporary_split_coefficients);
#endif
			segments_density_linked_list.insert_new_value_after_current_node(temporary_split_coefficients, node_min_density_current);
			//segments_density_linked_list.insertValueBeforeNode(temporary_split_coefficients, node_min_density_current);
			//segments_density_vector.emplace(segments_density_vector.begin() + id_segment_right, temporary_split_coefficients);// insert position is before begin() + id
			if (temporary_split_coefficients.segment_right.segment_density < segment_min_density_current.segment_right.segment_density) {
				id_min_density_segment_next = id_segment_right;//+1
#if _DEBUG
				assert(!segments_density_linked_list.empty() && id_min_density_segment_current >= 0 && id_min_density_segment_current < segments_density_linked_list.size() && id_min_density_segment_next >= 0 && id_min_density_segment_next < segments_density_linked_list.size());
				//const auto& const test_temp_min_density_segment = min_element(segments_density_linked_list.begin(), segments_density_linked_list.end(), density_min_to_max);
				//const int test_min_density_segment_id = test_temp_min_density_segment - segments_density_linked_list.begin();// id in vector [0,n-1);
				//assert(id_min_density_segment_next == test_min_density_segment_id);
#endif
			}
		}
		else {
			has_split_id_right = false;
		}
		/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
		//200218
		//Now, after above insertion, the min segment id in vector may changed,  
		//id_min_density_segment_next == id_min_density_segment_current || id_min_density_segment_next == id_min_density_segment_current = 1
		//Middle segment is first segment // begin id of segment
		/*-------------------------------------------------------------------------    Left split id     -------------------------------------------------------------------------*/
		if (id_segment_left < 0 && begin_id + 1 < segment_min_density_current.segment_left.right_endpoint) {
#if _DEBUG
			assert(id_min_density_segment_current == 0);
#endif
			//if () {// begin id of segment
				//get segment triangle density && insert vecter
			temporary_split_coefficients.segment_left.right_endpoint = (begin_id + segment_min_density_current.segment_left.right_endpoint) / 2;
			//temporary_split_coefficients.split_magnitude++;
			//APLA::get_split_coefficient(original_time_series_vector, original_long_segment, temporary_split_coefficients);
			get_split_coefficient(original_time_series_vector, original_long_segment, temporary_split_coefficients, begin_id - 1, segment_min_density_current.segment_left.right_endpoint, segments_density_linked_list, id_segment_left);
#if _DEBUG
			//assert segment density, magnitude, sub left & right a&b, right endpoint, width, sum value
			assert_structure_split_coefficients(temporary_split_coefficients);
#endif
			segments_density_linked_list.emplace_front(temporary_split_coefficients);
			//segments_density_vector.emplace(segments_density_vector.cbegin(), temporary_split_coefficients);// insert segment at the first of vector
			//after left insertion, the id in vector was changed
			id_min_density_segment_next++;
			if (temporary_split_coefficients.segment_right.segment_density <= segments_density_linked_list[id_min_density_segment_next].segment_right.segment_density) {
				id_min_density_segment_next = 0;
#if _DEBUG
				assert(!segments_density_linked_list.empty() && id_min_density_segment_current >= 0 && id_min_density_segment_current < segments_density_linked_list.size() && id_min_density_segment_next >= 0 && id_min_density_segment_next < segments_density_linked_list.size());
				//const auto& const test_temp_min_density_segment = min_element(segments_density_linked_list.begin(), segments_density_linked_list.end(), density_min_to_max);
				//const int test_min_density_segment_id = test_temp_min_density_segment - segments_density_linked_list.begin();// id in vector [0,n-1);
				//assert(id_min_density_segment_next == test_min_density_segment_id);
#endif
			}
			//}
			//else {
				//has_split_id_left = false;
			//}
		}// left and middle split id is not ajacent
		else if (id_segment_left > -1 && node_min_density_current.previous_value().segment_left.right_endpoint + 1 < segment_min_density_current.segment_left.right_endpoint) {
			//get segment triangle density && insert vecter
			temporary_split_coefficients.segment_left.right_endpoint = (node_min_density_current.previous_value().segment_left.right_endpoint + segment_min_density_current.segment_left.right_endpoint) / 2;
			//temporary_split_coefficients.split_magnitude++;
			//APLA::get_split_coefficient(original_time_series_vector, original_long_segment, temporary_split_coefficients);
			get_split_coefficient(original_time_series_vector, original_long_segment, temporary_split_coefficients, node_min_density_current.previous_value().segment_left.right_endpoint, segment_min_density_current.segment_left.right_endpoint, segments_density_linked_list, id_segment_left);
#if _DEBUG
			//assert segment density, magnitude, sub left & right a&b, right endpoint, width, sum value
			assert_structure_split_coefficients(temporary_split_coefficients);
#endif
			segments_density_linked_list.insertValueBeforeNode(temporary_split_coefficients, node_min_density_current);
			//segments_density_vector.emplace(segments_density_vector.begin() + id_min_density_segment_current, temporary_split_coefficients);// insert position is before begin() + id
			//after left insertion, the id in vector was changed
			id_min_density_segment_next++;
			if (temporary_split_coefficients.segment_right.segment_density <= segments_density_linked_list[id_min_density_segment_next].segment_right.segment_density) {
				id_min_density_segment_next = id_min_density_segment_current;
#if _DEBUG
				assert(!segments_density_linked_list.empty() && id_min_density_segment_current >= 0 && id_min_density_segment_current < segments_density_linked_list.size() && id_min_density_segment_next >= 0 && id_min_density_segment_next < segments_density_linked_list.size());
				//const auto& const test_temp_min_density_segment = min_element(segments_density_linked_list.begin(), segments_density_linked_list.end(), density_min_to_max);
				//const int test_min_density_segment_id = test_temp_min_density_segment - segments_density_linked_list.begin();// id in vector [0,n-1);
				//assert(id_min_density_segment_next == test_min_density_segment_id);
#endif
			}
		}
		else {
			has_split_id_left = false;
		}
		/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	}

#if _DEBUG
	/*const auto& const min_density_segment = min_element(segments_density_linked_list.begin(), segments_density_linked_list.end(), density_min_to_max);
	assert(segments_density_linked_list[id_min_density_segment_next].segment_left.right_endpoint == min_density_segment->split_id);*/
#endif
	return segments_density_linked_list[id_min_density_segment_next];
}

//************************************
// Method:get_segment_min_density_global_id
// Qualifier: Find local min density point fast use vector in one long segment
// Input: 1 original time series 
//        2 min density vector not empty
//        3 long segment: right endpoint, rectangle width, a&b, sum_value
// Output: 1 min density local Split point id, coefficients of sub left & right and logne semgng a&b, right endpoint, rectanle width. 
//         2 Long segmnet triangle density
// Note: Already know local mind density split id. Try to search border section. make local section as global section. Find min density point fast use vector. prove coefficeints for sub left segment, sub irght segment, and long smegnetnr 
// date:200301
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
U& APLA::get_segment_min_density_global_id(const vector<T>& const original_time_series_vector, Y& const long_segment, U& const min_density_segment_local, vector<U>& const segments_density_vector) {
#if _DEBUG
	assert(min_density_segment_local.split_magnitude != int(INF));
#endif

	//double new_min_segment_density = INF;
	int less_magnitude_account = 1;
	U split_coefficient_temp;
	int begin_id = long_segment.right_endpoint - long_segment.rectangle_width + 1;
	int end_id = long_segment.right_endpoint;

	//while (less_magnitude_account > 0 && new_min_segment_density > min_density_segment_local.segment_right.segment_density) {200301 when find new min density < current min density. Break Loop
	while (less_magnitude_account > 0) {
		less_magnitude_account = 0;
		for (int segment_id = 0; segment_id < segments_density_vector.size(); segment_id++) {
			// local min density segmeng has the max magnitude.
			if (segments_density_vector[segment_id].split_magnitude < min_density_segment_local.split_magnitude) {
				less_magnitude_account++;
				segments_density_vector[segment_id].split_magnitude++;
				//split_coefficient_temp.split_magnitude = split_coefficent_left.split_magnitude = segments_density_vector[segment_id].split_magnitude;
				split_coefficient_temp.split_magnitude = segments_density_vector[segment_id].split_magnitude;
				/*................................get adjacent id, left & right id............................*/
				const int id_min_density_segment_current = segment_id;// id in vector [0,n-1);
				const int left_segment_id = id_min_density_segment_current - 1;
				const int right_segment_id = id_min_density_segment_current + 1;
				/*.......................................    right split point computation segment triangle density & insertion..........................................*/
				if (right_segment_id == segments_density_vector.size() && end_id - 2 > segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint) {//middle segment is last segment
					//if () {
					split_coefficient_temp.segment_left.right_endpoint = (end_id + segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint) / 2;
					//}
					//else {
						//split_coefficent_right.segment_left.right_endpoint = -1;
					//}
					segment_id++;//skip new inserted right segment, id is new right segment now
					//get_split_coefficient(original_time_series_vector, long_segment, split_coefficient_temp);
					get_split_coefficient(original_time_series_vector, long_segment, split_coefficient_temp, segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint, end_id, segments_density_vector, id_min_density_segment_current);
#if _DEBUG
					//assert segment density, magnitude, sub left & right a&b, right endpoint, width, sum value
					assert_structure_split_coefficients(split_coefficient_temp);
#endif
					if (split_coefficient_temp.segment_right.segment_density < min_density_segment_local.segment_right.segment_density) {
						//new_min_segment_density = split_coefficient_temp.segment_right.segment_density;
						//return min_density_split_point_id = split_coefficient_temp.segment_left.right_endpoint;
						return min_density_segment_local = split_coefficient_temp;
						break;
					}
					segments_density_vector.emplace(segments_density_vector.begin() + right_segment_id, split_coefficient_temp);// insert position is before begin() + id

				}
				else if (right_segment_id < segments_density_vector.size() && segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint + 1 < segments_density_vector[right_segment_id].segment_left.right_endpoint) {// middle and right split id is not adjacent
					split_coefficient_temp.segment_left.right_endpoint = (segments_density_vector[right_segment_id].segment_left.right_endpoint + segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint) / 2;
					segment_id++;//skip new inserted right segment, id is new right segment now
					//get_split_coefficient(original_time_series_vector, long_segment, split_coefficient_temp);
					get_split_coefficient(original_time_series_vector, long_segment, split_coefficient_temp, segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint, segments_density_vector[right_segment_id].segment_left.right_endpoint, segments_density_vector, id_min_density_segment_current);
#if _DEBUG
					//assert segment density, magnitude, sub left & right a&b, right endpoint, width, sum value
					assert_structure_split_coefficients(split_coefficient_temp);
#endif
					if (split_coefficient_temp.segment_right.segment_density < min_density_segment_local.segment_right.segment_density) {
						//new_min_segment_density = split_coefficient_temp.segment_right.segment_density;
						//return min_density_split_point_id = split_coefficient_temp.segment_left.right_endpoint;
						return min_density_segment_local = split_coefficient_temp;
						break;
					}
					segments_density_vector.emplace(segments_density_vector.begin() + right_segment_id, split_coefficient_temp);// insert position is before begin() + id
				}
				else {
					split_coefficient_temp.segment_left.right_endpoint = -1;
				}
				/*......................................................................................................................................................*/
				/*.......................................    left split point computation segment triangle density & insertion..........................................*/
				if (left_segment_id < 0 && begin_id + 1 < segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint) {// middle segment is first segment
					//if () {
					split_coefficient_temp.segment_left.right_endpoint = (begin_id + segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint) / 2;
					//}
					//else {
						//split_coefficent_left.segment_left.right_endpoint = -1;
					//}
					segment_id++;//insertion will influence id of vector, id is on new right segment now, next <for loop> will +1
					//get_split_coefficient(original_time_series_vector, long_segment, split_coefficient_temp);
					get_split_coefficient(original_time_series_vector, long_segment, split_coefficient_temp, begin_id - 1, segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint, segments_density_vector, left_segment_id);
#if _DEBUG
					//assert segment density, magnitude, sub left & right a&b, right endpoint, width, sum value
					assert_structure_split_coefficients(split_coefficient_temp);
#endif
					if (split_coefficient_temp.segment_right.segment_density < min_density_segment_local.segment_right.segment_density) {
						//new_min_segment_density = split_coefficient_temp.segment_right.segment_density;
						//return min_density_split_point_id = split_coefficient_temp.segment_left.right_endpoint;
						return min_density_segment_local = split_coefficient_temp;
#if _DEBUG
						assert(split_coefficient_temp.segment_left.right_endpoint != INF && split_coefficient_temp.segment_right.right_endpoint != INF && split_coefficient_temp.segment_left.rectangle_width != INF && split_coefficient_temp.segment_right.rectangle_width != INF);
						assert(split_coefficient_temp.segment_left.apla.a != INF && split_coefficient_temp.segment_right.apla.a != INF && split_coefficient_temp.segment_left.apla.b != INF && split_coefficient_temp.segment_right.apla.b != INF);
						//assert(split_coefficient_temp.segment_left.sum_value != INF && split_coefficient_temp.segment_right.sum_value != INF);
#endif
						break;
					}
					segments_density_vector.emplace(segments_density_vector.begin() + id_min_density_segment_current, split_coefficient_temp);// insert position is before begin() + id
				}
				else if (left_segment_id > -1 && segments_density_vector[left_segment_id].segment_left.right_endpoint + 1 < segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint) {// left and middle split id is not ajacent
					split_coefficient_temp.segment_left.right_endpoint = (segments_density_vector[left_segment_id].segment_left.right_endpoint + segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint) / 2;
					segment_id++;//insertion will influence id of vector, id is on new right segment now, next <for loop> will +1
					//get_split_coefficient(original_time_series_vector, long_segment, split_coefficient_temp);
					get_split_coefficient(original_time_series_vector, long_segment, split_coefficient_temp, segments_density_vector[left_segment_id].segment_left.right_endpoint, segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint, segments_density_vector, left_segment_id);
					if (split_coefficient_temp.segment_right.segment_density < min_density_segment_local.segment_right.segment_density) {
						//new_min_segment_density = split_coefficient_temp.segment_right.segment_density;
						//return min_density_split_point_id = split_coefficient_temp.segment_left.right_endpoint;
						return min_density_segment_local = split_coefficient_temp;
						break;
					}
					segments_density_vector.emplace(segments_density_vector.begin() + id_min_density_segment_current, split_coefficient_temp);// insert position is before begin() + id
				}
				else {
					split_coefficient_temp.segment_left.right_endpoint = -1;
				}


				/*.............................................................................................*/

				/*.......................................get segment triangle density && insert vecter..........................................*/
				// note: insert action will influence id of vector
				//if (split_coefficent_right.segment_left.right_endpoint > 0) {// right split id 
				//	
				//}

				//if (split_coefficent_left.segment_left.right_endpoint > 0) {// left split id
				//	
				//}
				/*.............................................................................................................................*/
			}
		}
	}

	return min_density_segment_local;
	//return min_density_split_point_id;
}

//200302 
//************************************
// Method:get_segment_min_density_global_id
// Qualifier: Find local min density point fast use vector in one long segment
// Input: 1 original time series 
//        2 min density vector not empty
//        3 long segment: right endpoint, rectangle width, a&b, sum_value
// Output: 1 min density local Split point id, coefficients of sub left & right and logne semgng a&b, right endpoint, rectanle width. 
//         2 Long segmnet triangle density
// Note: Use linked list ot instead vector. Already know local mind density split id. Try to search border section. make local section as global section. Find min density point fast use vector. prove coefficeints for sub left segment, sub irght segment, and long smegnetnr 
// date:200302
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
U& APLA::get_segment_min_density_global_id(const vector<T>& const original_time_series_vector, Y& const long_segment, U& const min_density_segment_local, DoublyLinkedList<U>& const segments_density_linked_list) {
#if _DEBUG
	assert(min_density_segment_local.split_magnitude != int(INF));
#endif

	//double new_min_segment_density = INF;
	int less_magnitude_account = 1;
	SPLIT_COEFFICIENT split_coefficient_temp;
	int begin_id = long_segment.right_endpoint - long_segment.rectangle_width + 1;
	int end_id = long_segment.right_endpoint;

	//while (less_magnitude_account > 0 && new_min_segment_density > min_density_segment_local.segment_right.segment_density) {
	while (less_magnitude_account > 0) {
		less_magnitude_account = 0;
		for (int segment_id = 0; segment_id < segments_density_linked_list.size(); segment_id++) {
			auto& const value_segment_min_density_current = segments_density_linked_list[segment_id];
			auto& const node_segment_min_density_current = segments_density_linked_list.getNode(segment_id);
			// local min density segmeng has the max magnitude.
			if (value_segment_min_density_current.split_magnitude < min_density_segment_local.split_magnitude) {
				less_magnitude_account++;
				value_segment_min_density_current.split_magnitude++;
				//split_coefficient_temp.split_magnitude = split_coefficent_left.split_magnitude = segments_density_vector[segment_id].split_magnitude;
				split_coefficient_temp.split_magnitude = value_segment_min_density_current.split_magnitude;
				/*................................get adjacent id, left & right id............................*/
				const int id_min_density_segment_current = segment_id;// id in vector [0,n-1);
				const int left_segment_id = id_min_density_segment_current - 1;
				const int right_segment_id = id_min_density_segment_current + 1;
				/*.......................................    right split point computation segment triangle density & insertion..........................................*/
				if (right_segment_id == segments_density_linked_list.size() && end_id - 2 > value_segment_min_density_current.segment_left.right_endpoint) {//middle segment is last segment
					//if () {
					split_coefficient_temp.segment_left.right_endpoint = (end_id + value_segment_min_density_current.segment_left.right_endpoint) / 2;
					//}
					//else {
						//split_coefficent_right.segment_left.right_endpoint = -1;
					//}
					segment_id++;//skip new inserted right segment, id is new right segment now
					//get_split_coefficient(original_time_series_vector, long_segment, split_coefficient_temp);
					get_split_coefficient(original_time_series_vector, long_segment, split_coefficient_temp, value_segment_min_density_current.segment_left.right_endpoint, end_id, segments_density_linked_list, id_min_density_segment_current);//segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint
#if _DEBUG
					//assert segment density, magnitude, sub left & right a&b, right endpoint, width, sum value
					assert_structure_split_coefficients(split_coefficient_temp);
#endif
					if (split_coefficient_temp.segment_right.segment_density < min_density_segment_local.segment_right.segment_density) {
						//new_min_segment_density = split_coefficient_temp.segment_right.segment_density;
						//return min_density_split_point_id = split_coefficient_temp.segment_left.right_endpoint;
						return min_density_segment_local = split_coefficient_temp;
						break;
					}
					//segments_density_vector.emplace(segments_density_vector.begin() + right_segment_id, split_coefficient_temp);// insert position is before begin() + id
					segments_density_linked_list.insert_new_value_after_current_node(split_coefficient_temp, node_segment_min_density_current);

				}
				else if (right_segment_id < segments_density_linked_list.size() && value_segment_min_density_current.segment_left.right_endpoint + 1 < node_segment_min_density_current.next_value().segment_left.right_endpoint) {// middle and right split id is not adjacent // segments_density_vector[right_segment_id].segment_left.right_endpoint
					split_coefficient_temp.segment_left.right_endpoint = (node_segment_min_density_current.next_value().segment_left.right_endpoint + value_segment_min_density_current.segment_left.right_endpoint) / 2;
					segment_id++;//skip new inserted right segment, id is new right segment now
					//get_split_coefficient(original_time_series_vector, long_segment, split_coefficient_temp);
					get_split_coefficient(original_time_series_vector, long_segment, split_coefficient_temp, value_segment_min_density_current.segment_left.right_endpoint, node_segment_min_density_current.next_value().segment_left.right_endpoint, segments_density_linked_list, id_min_density_segment_current);
#if _DEBUG
					//assert segment density, magnitude, sub left & right a&b, right endpoint, width, sum value
					assert_structure_split_coefficients(split_coefficient_temp);
#endif
					if (split_coefficient_temp.segment_right.segment_density < min_density_segment_local.segment_right.segment_density) {
						//new_min_segment_density = split_coefficient_temp.segment_right.segment_density;
						//return min_density_split_point_id = split_coefficient_temp.segment_left.right_endpoint;
						return min_density_segment_local = split_coefficient_temp;
						break;
					}
					//segments_density_vector.emplace(segments_density_vector.begin() + right_segment_id, split_coefficient_temp);// insert position is before begin() + id
					segments_density_linked_list.insert_new_value_after_current_node(split_coefficient_temp, node_segment_min_density_current);
				}
				else {
					split_coefficient_temp.segment_left.right_endpoint = -1;
				}
				/*......................................................................................................................................................*/


				/*.......................................    left split point computation segment triangle density & insertion..........................................*/
				if (left_segment_id < 0 && begin_id + 1 < value_segment_min_density_current.segment_left.right_endpoint) {// middle segment is first segment
					//if () {
					split_coefficient_temp.segment_left.right_endpoint = (begin_id + value_segment_min_density_current.segment_left.right_endpoint) / 2;
					//}
					//else {
						//split_coefficent_left.segment_left.right_endpoint = -1;
					//}
					segment_id++;//insertion will influence id of vector, id is on new right segment now, next <for loop> will +1
					//get_split_coefficient(original_time_series_vector, long_segment, split_coefficient_temp);
					get_split_coefficient(original_time_series_vector, long_segment, split_coefficient_temp, begin_id - 1, value_segment_min_density_current.segment_left.right_endpoint, segments_density_linked_list, left_segment_id);
#if _DEBUG
					//assert segment density, magnitude, sub left & right a&b, right endpoint, width, sum value
					assert_structure_split_coefficients(split_coefficient_temp);
#endif
					if (split_coefficient_temp.segment_right.segment_density < min_density_segment_local.segment_right.segment_density) {
						//new_min_segment_density = split_coefficient_temp.segment_right.segment_density;
						//return min_density_split_point_id = split_coefficient_temp.segment_left.right_endpoint;
						return min_density_segment_local = split_coefficient_temp;
						break;
					}
					//segments_density_vector.emplace(segments_density_vector.begin() + id_min_density_segment_current, split_coefficient_temp);// insert position is before begin() + id
					segments_density_linked_list.insertValueBeforeNode(split_coefficient_temp, node_segment_min_density_current);
				}
				else if (left_segment_id > -1 && node_segment_min_density_current.previous_value().segment_left.right_endpoint + 1 < value_segment_min_density_current.segment_left.right_endpoint) {// left and middle split id is not ajacent
					split_coefficient_temp.segment_left.right_endpoint = (node_segment_min_density_current.previous_value().segment_left.right_endpoint + value_segment_min_density_current.segment_left.right_endpoint) / 2;
					segment_id++;//insertion will influence id of vector, id is on new right segment now, next <for loop> will +1
					//get_split_coefficient(original_time_series_vector, long_segment, split_coefficient_temp);
					get_split_coefficient(original_time_series_vector, long_segment, split_coefficient_temp, node_segment_min_density_current.previous_value().segment_left.right_endpoint, value_segment_min_density_current.segment_left.right_endpoint, segments_density_linked_list, left_segment_id);
#if _DEBUG
					//assert segment density, magnitude, sub left & right a&b, right endpoint, width, sum value
					assert_structure_split_coefficients(split_coefficient_temp);
#endif
					if (split_coefficient_temp.segment_right.segment_density < min_density_segment_local.segment_right.segment_density) {
						//new_min_segment_density = split_coefficient_temp.segment_right.segment_density;
						//return min_density_split_point_id = split_coefficient_temp.segment_left.right_endpoint;
						return min_density_segment_local = split_coefficient_temp;
						break;
					}
					//segments_density_vector.emplace(segments_density_vector.begin() + id_min_density_segment_current, split_coefficient_temp);// insert position is before begin() + id
					segments_density_linked_list.insertValueBeforeNode(split_coefficient_temp, node_segment_min_density_current);// insert position is before begin() + id
				}
				else {
					split_coefficient_temp.segment_left.right_endpoint = -1;
				}


				/*.............................................................................................*/

				/*.......................................get segment triangle density && insert vecter..........................................*/
				// note: insert action will influence id of vector
				//if (split_coefficent_right.segment_left.right_endpoint > 0) {// right split id 
				//	
				//}

				//if (split_coefficent_left.segment_left.right_endpoint > 0) {// left split id
				//	
				//}
				/*.............................................................................................................................*/
			}
		}
	}

	return min_density_segment_local;
	//return min_density_split_point_id;
}

//200210 
//************************************
// Method:find_split_point_by_min_density_fast
// Qualifier: Find min density point fast use vector 
// Input:
// Output: Split point
// Note: 
// date:200210
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
double APLA::find_split_point_by_min_density_fast(const vector<T>& const original_time_series_vector, Y& const temp_coefficient) {
	assert(0);
#if _DEBUG
	assert(temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF);
#endif

	////////////////////////////////////////// Intersection Point ////////////////////////////////////////////////////////////////////////
	//return int(find_split_point_by_direct_intersection_point(original_time_series_vector, temp_coefficient));// Intersection points
	//return findSplitSegmentBaseline(original_time_series_vector, temp_coefficient, 0);//best split id
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (temp_coefficient.rectangle_width == 1 || temp_coefficient.rectangle_width == 2 || temp_coefficient.rectangle_width == 3) return INF;

	if (temp_coefficient.rectangle_width == 4) {
		return temp_coefficient.right_endpoint - 2;
	}

	/*........................Switch linkelist & vector.................................*/
	// 0 is linked list, 1 vector.
	int option_linkedlist_or_vector = 1;
	/*..................................................................................*/

	vector<SPLIT_COEFFICIENT> segments_density_vector;
	//DoublyLinkedList<SPLIT_COEFFICIENT> segments_density_vector = DoublyLinkedList<SPLIT_COEFFICIENT>();
	/*-----------------------         200301 Linked list & Pointer       -----------------------*/
	DoublyLinkedList<SPLIT_COEFFICIENT> segments_density_linked_list = DoublyLinkedList<SPLIT_COEFFICIENT>();
	/*------------------------------------------------------------------------------------------*/

	//SPLIT_COEFFICIENT split_coefficent_middle;
	//SPLIT_COEFFICIENT split_coefficent_left;
	//SPLIT_COEFFICIENT split_coefficent_right;
	SPLIT_COEFFICIENT split_coefficient_temp;

	//SPLIT_COEFFICIENT* final_min_density_segment_pointer = nullptr;

//#ifdef TIME_H
//	typename TOOL::TIME time_find_split;
//	TOOL::recordStartTime(time_find_split);//compare percentage time
//#endif
	/*........ if long segment has no a & b. scan to get a & b ..........*/
	if (temp_coefficient.apla.a == INF || temp_coefficient.apla.b == INF) {
		//assert(0);
		APLA::getAAndBByPLA(original_time_series_vector, temp_coefficient);
	}
	/*...................................................................*/

	AREA_COEFFICIENT_CONCISE long_segment;
	long_segment.right_endpoint = temp_coefficient.right_endpoint;
	long_segment.rectangle_width = temp_coefficient.rectangle_width;
	long_segment.sum_value = temp_coefficient.sum_value;
	long_segment.apla = temp_coefficient.apla;

	//DensityIncrease density_min_to_max;
	//SPLIT_ID_INCREASE split_id_min_to_max;

	double min_density_split_point_id_from_vector = INF;
	double min_density_split_point_id_from_linkedlist = INF;
	int begin_id = long_segment.right_endpoint - long_segment.rectangle_width + 1;
	int end_id = long_segment.right_endpoint;
	//int middle_id = (begin_id + end_id) / 2;

	/*split_coefficent_middle.split_magnitude = -1;
	split_coefficent_left.split_magnitude = -1;
	split_coefficent_right.split_magnitude = -1;

	split_coefficent_middle.segment_left.right_endpoint = middle_id;
	split_coefficent_left.segment_left.right_endpoint = split_coefficent_right.segment_left.right_endpoint = 1;*/
	//split_coefficent_left.segment_left.right_endpoint = (begin_id + middle_id) / 2;
	//split_coefficent_right.segment_left.right_endpoint = (middle_id + end_id) / 2;

	/*............................ get triangle density of each split point......................*/
	//get  sub left & right segment : a&b. trianle density.
	//APLA::get_split_coefficient(original_time_series_vector, long_segment, split_coefficent_left);
//	APLA::get_split_coefficient(original_time_series_vector, long_segment, split_coefficent_middle);
//	//APLA::get_split_coefficient(original_time_series_vector, long_segment, split_coefficent_right);
//	/*............................................................................................*/
//
//	//segments_density_vector.emplace_back(split_coefficent_left);
//	segments_density_vector.emplace_back(split_coefficent_middle);
//	//segments_density_vector.emplace_back(split_coefficent_right);
//
//	//std::sort(segments_density_vector.begin(), segments_density_vector.end(), split_id_min_to_max);
//	//auto [min, max] = minmax_element(segments_density_vector.begin(), segments_density_vector.end(), density_min_to_max);
//
//	/*====================================== Use gradient descent to get local min density split pint===========================================*/
//	while (split_coefficent_left.segment_left.right_endpoint > 0 || split_coefficent_right.segment_left.right_endpoint > 0) {
//
//		const auto& const temp_min_density_segment = min_element(segments_density_vector.begin(), segments_density_vector.end(), density_min_to_max);
//		temp_min_density_segment->split_magnitude++;
//		/*................................get adjacent id, left & right id............................*/
//		const int min_density_segment_id = temp_min_density_segment - segments_density_vector.begin();// id in vector [0,n-1);
//		int left_segment_id = min_density_segment_id - 1;
//		int right_segment_id = min_density_segment_id + 1;
//
//		if (left_segment_id < 0) {// middle segment is first segment
//			if (begin_id + 1 < temp_min_density_segment->split_id) {
//				split_coefficent_left.segment_left.right_endpoint = (begin_id + temp_min_density_segment->split_id) / 2;
//			}
//			else {
//				split_coefficent_left.segment_left.right_endpoint = -1;
//			}
//		}
//		else if (segments_density_vector[left_segment_id].segment_left.right_endpoint + 1 < temp_min_density_segment->split_id) {// left and middle split id is not ajacent
//			split_coefficent_left.segment_left.right_endpoint = (segments_density_vector[left_segment_id].segment_left.right_endpoint + temp_min_density_segment->split_id) / 2;
//		}
//		else {
//			split_coefficent_left.segment_left.right_endpoint = -1;
//		}
//		/*.............      Right part      ....................*/
//		if (right_segment_id == segments_density_vector.size()) {//middle segment is last segment
//			//the last two points consist one segment
//			if (end_id - 2 > temp_min_density_segment->split_id) {
//				split_coefficent_right.segment_left.right_endpoint = (end_id + temp_min_density_segment->split_id) / 2;
//			}
//			else {
//				split_coefficent_right.segment_left.right_endpoint = -1;
//			}
//		}
//		else if (temp_min_density_segment->split_id + 1 < segments_density_vector[right_segment_id].segment_left.right_endpoint) {// middle and right split id is not adjacent
//			split_coefficent_right.segment_left.right_endpoint = (segments_density_vector[right_segment_id].segment_left.right_endpoint + temp_min_density_segment->split_id) / 2;
//		}
//		else {
//			split_coefficent_right.segment_left.right_endpoint = -1;
//		}
//		/*.......................................................*/
//		/*.............................................................................................*/
//		
//		/*.......................................get segment triangle density && insert vecter..........................................*/
//		// note: insert action will influence id of vector
//		if (split_coefficent_right.segment_left.right_endpoint > 0) {// Right split id 
//			split_coefficent_right.split_magnitude++;
//			APLA::get_split_coefficient(original_time_series_vector, long_segment, split_coefficent_right);
//			segments_density_vector.insert(segments_density_vector.begin() + right_segment_id, split_coefficent_right);// insert position is before begin() + id
//		}
//
//		if (split_coefficent_left.segment_left.right_endpoint > 0) {// Left split id
//			split_coefficent_left.split_magnitude++;
//			APLA::get_split_coefficient(original_time_series_vector, long_segment, split_coefficent_left);
//			segments_density_vector.insert(segments_density_vector.begin() + min_density_segment_id, split_coefficent_left);// insert position is before begin() + id
//		}
//		/*.............................................................................................................................*/
//		//break;
//	}
//	const auto& const min_density_segment = min_element(segments_density_vector.begin(), segments_density_vector.end(), density_min_to_max);
//
//#if _DEBUG
//	assert(min_density_segment->segment_left.right_endpoint != INF && min_density_segment->segment_right.right_endpoint != INF && min_density_segment->segment_left.rectangle_width != INF  && min_density_segment->segment_right.rectangle_width != INF);
//	assert(min_density_segment->segment_left.apla.a != INF && min_density_segment->segment_right.apla.a != INF && min_density_segment->segment_left.apla.b != INF && min_density_segment->segment_right.apla.b != INF);
//	assert(min_density_segment->segment_left.sum_value != INF && min_density_segment->segment_right.sum_value != INF);
//
//	SPLIT_COEFFICIENT test_min_density_segment;
//	vector<SPLIT_COEFFICIENT> test_segments_density_vector;
//	test_min_density_segment = APLA::get_segment_min_density_local_id(original_time_series_vector, long_segment, test_segments_density_vector);
//	assert(test_segments_density_vector.size() == segments_density_vector.size() && test_min_density_segment.segment_left.right_endpoint == min_density_segment->split_id);
//
//	for (int segment_id = 0; segment_id < segments_density_vector.size(); segment_id++) {
//		const auto& const segment = segments_density_vector[segment_id];
//		const auto& const test_segment = test_segments_density_vector[segment_id];
//
//		assert(segment.segment_left.right_endpoint == test_segment.segment_left.right_endpoint && segment.split_magnitude == test_segment.split_magnitude && segment.segment_density == test_segment.segment_density);
//
//		assert(segment.segment_left.right_endpoint == test_segment.segment_left.right_endpoint && segment.segment_left.rectangle_width == test_segment.segment_left.rectangle_width && segment.segment_left.sum_value == test_segment.segment_left.sum_value);
//		assert(segment.segment_left.apla.a == test_segment.segment_left.apla.a && segment.segment_left.apla.b == test_segment.segment_left.apla.b);
//
//		assert(segment.segment_right.right_endpoint == test_segment.segment_right.right_endpoint && segment.segment_right.rectangle_width == test_segment.segment_right.rectangle_width && segment.segment_right.sum_value == test_segment.segment_right.sum_value);
//		assert(segment.segment_right.apla.a == test_segment.segment_right.apla.a && segment.segment_right.apla.b == test_segment.segment_right.apla.b);
//	}
//
//	test_segments_density_vector.clear();
//	test_segments_density_vector.shrink_to_fit();
//#endif

	//final_min_density_segment_pointer = min_density_segment;

	switch (option_linkedlist_or_vector) {
	case 0: {// linked list
		auto min_density_segment_local_from_linkedlist = get_segment_min_density_local_id(original_time_series_vector, long_segment, segments_density_linked_list);
		//min_density_split_point_id_from_linkedlist = min_density_segment_local_from_linkedlist.segment_left.right_endpoint;
		split_coefficient_temp = get_segment_min_density_global_id(original_time_series_vector, long_segment, min_density_segment_local_from_linkedlist, segments_density_linked_list);
		break;
	}
	case 1: {// vector
		auto min_density_segment_local_from_vector = get_segment_min_density_local_id(original_time_series_vector, long_segment, segments_density_vector);
		//min_density_split_point_id_from_vector = min_density_segment_local_from_vector.segment_left.right_endpoint;
		split_coefficient_temp = get_segment_min_density_global_id(original_time_series_vector, long_segment, min_density_segment_local_from_vector, segments_density_vector);
		break;
	}
	default:
		assert(0);
	}

	/*====================================================              Get Local min density id               ================================================================*/
	/*---------------------------------------------------------by vector------------------------------------------------------------------------------*/
	//auto min_density_segment_local_from_vector = get_segment_min_density_local_id(original_time_series_vector, long_segment, segments_density_vector);
	//min_density_split_point_id_from_vector = min_density_segment_local_from_vector.segment_left.right_endpoint;
	/*------------------------------------------------------------------------------------------------------------------------------------------------*/
	/*------------------------------------------------------------by linked list----------------------------------------------------------------------*/
	/*auto min_density_segment_local_from_linkedlist = get_segment_min_density_local_id(original_time_series_vector, long_segment, segments_density_linked_list);
	min_density_split_point_id_from_linkedlist = min_density_segment_local_from_linkedlist.segment_left.right_endpoint;*/
	/*-------------------------------------------------------------------------------------------------------------------------------------------------*/
	/*==========================================================================================================================================================================*/

	/*----------------------------------------------------Evaluate Linked list method-----------------------------------------------------------------------*/
	/*assert(min_density_split_point_id_from_vector == min_density_split_point_id_from_linkedlist && segments_density_vector.size() == segments_density_linked_list.size());
	for (int segment_id = 0; segment_id < segments_density_linked_list.size(); segment_id++) {
		const auto& const segment_vector = segments_density_vector[segment_id];
		const auto& const segment_linkedlist = segments_density_linked_list[segment_id];
		assert(segment_vector.segment_left.right_endpoint == segment_linkedlist.segment_left.right_endpoint && segment_vector.split_magnitude == segment_linkedlist.split_magnitude && segment_vector.segment_density == segment_linkedlist.segment_density);
		assert(segment_vector.segment_left.right_endpoint == segment_linkedlist.segment_left.right_endpoint && segment_vector.segment_left.rectangle_width == segment_linkedlist.segment_left.rectangle_width && segment_vector.segment_left.apla.a == segment_linkedlist.segment_left.apla.a && segment_vector.segment_left.apla.b == segment_linkedlist.segment_left.apla.b);
		assert(segment_vector.segment_right.right_endpoint == segment_linkedlist.segment_right.right_endpoint && segment_vector.segment_right.rectangle_width == segment_linkedlist.segment_right.rectangle_width && segment_vector.segment_right.apla.a == segment_linkedlist.segment_right.apla.a && segment_vector.segment_right.apla.b == segment_linkedlist.segment_right.apla.b);
	}*/
	/*------------------------------------------------------------------------------------------------------------------------------------------------------*/
#if _DEBUG
	for (auto&& au : segments_density_vector) {
		assert(au.segment_left.right_endpoint == au.segment_left.right_endpoint && au.segment_right.right_endpoint == long_segment.right_endpoint);
		//assert(au.split_magnitude <= min_density_segment_local.split_magnitude && au.segment_density >= min_density_segment_local.segment_right.segment_density);
	}
#endif
	/*================================================================================================================================================================*/
	/*==================================================== compensate small magnitude split point ====================================================================*/
	//segments_density_vector.clear();
	//segments_density_vector.shrink_to_fit();
	//const double current_min_segment_density = min_density_segment_local->segment_density;
	//int current_max_spit_magnitude = min_density_segment_local->split_magnitude;
	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	/*====================================================              Get Global min density id               ================================================================*/
	/*---------------------------------------------------------by vector------------------------------------------------------------------------------*/
	//min_density_split_point_id_from_vector = get_segment_min_density_global_id(original_time_series_vector, long_segment, min_density_segment_local_from_vector, min_density_split_point_id_from_vector, segments_density_vector);
	/*------------------------------------------------------------------------------------------------------------------------------------------------*/
	/*------------------------------------------------------------by linked list----------------------------------------------------------------------*/
	//min_density_split_point_id_from_linkedlist = get_segment_min_density_global_id(original_time_series_vector, long_segment, min_density_segment_local_from_linkedlist, min_density_split_point_id_from_linkedlist, segments_density_linked_list);
	/*------------------------------------------------------------------------------------------------------------------------------------------------*/
	/*==========================================================================================================================================================================*/
	/*----------------------------------------------------Evaluate Linked list method-----------------------------------------------------------------------*/
	/*assert(min_density_split_point_id_from_vector == min_density_split_point_id_from_linkedlist && segments_density_vector.size() == segments_density_linked_list.size());
	for (int segment_id = 0; segment_id < segments_density_linked_list.size(); segment_id++) {
		const auto& const segment_vector = segments_density_vector[segment_id];
		const auto& const segment_linkedlist = segments_density_linked_list[segment_id];
		assert(segment_vector.segment_left.right_endpoint == segment_linkedlist.segment_left.right_endpoint && segment_vector.split_magnitude == segment_linkedlist.split_magnitude && segment_vector.segment_density == segment_linkedlist.segment_density);
		assert(segment_vector.segment_left.right_endpoint == segment_linkedlist.segment_left.right_endpoint && segment_vector.segment_left.rectangle_width == segment_linkedlist.segment_left.rectangle_width && segment_vector.segment_left.apla.a == segment_linkedlist.segment_left.apla.a && segment_vector.segment_left.apla.b == segment_linkedlist.segment_left.apla.b);
		assert(segment_vector.segment_right.right_endpoint == segment_linkedlist.segment_right.right_endpoint && segment_vector.segment_right.rectangle_width == segment_linkedlist.segment_right.rectangle_width && segment_vector.segment_right.apla.a == segment_linkedlist.segment_right.apla.a && segment_vector.segment_right.apla.b == segment_linkedlist.segment_right.apla.b);
	}*/
	/*------------------------------------------------------------------------------------------------------------------------------------------------------*/

//	double new_min_segment_density = INF;
//	int less_magnitude_account = 1;
//
//	while (less_magnitude_account > 0 && new_min_segment_density > min_density_segment_local.segment_right.segment_density) {
//		less_magnitude_account = 0;
//		for (int segment_id = 0; segment_id < segments_density_vector.size(); segment_id++) {
//			// local min density segmeng has the max magnitude.
//			if (segments_density_vector[segment_id].split_magnitude < min_density_segment_local.split_magnitude) {
//				less_magnitude_account++;
//				segments_density_vector[segment_id].split_magnitude++;
//				//split_coefficient_temp.split_magnitude = split_coefficent_left.split_magnitude = segments_density_vector[segment_id].split_magnitude;
//				split_coefficient_temp.split_magnitude = segments_density_vector[segment_id].split_magnitude;
//				/*................................get adjacent id, left & right id............................*/
//				const int id_min_density_segment_current = segment_id;// id in vector [0,n-1);
//				const int left_segment_id = id_min_density_segment_current - 1;
//				const int right_segment_id = id_min_density_segment_current + 1;
//				/*.......................................    right split point computation segment triangle density & insertion..........................................*/
//				if (right_segment_id == segments_density_vector.size() && end_id - 1 > segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint) {//middle segment is last segment
//					//if () {
//					split_coefficient_temp.segment_left.right_endpoint = (end_id + segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint) / 2;
//					//}
//					//else {
//						//split_coefficent_right.segment_left.right_endpoint = -1;
//					//}
//					segment_id++;//skip new inserted right segment, id is new right segment now
//					//get_split_coefficient(original_time_series_vector, long_segment, split_coefficient_temp);
//					get_split_coefficient(original_time_series_vector, long_segment, split_coefficient_temp, segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint, end_id, segments_density_vector, id_min_density_segment_current);
//					if (split_coefficient_temp.segment_right.segment_density < min_density_segment_local.segment_right.segment_density) {
//						new_min_segment_density = split_coefficient_temp.segment_right.segment_density;
//						min_density_split_point_id = split_coefficient_temp.segment_left.right_endpoint;
//#if _DEBUG
//						assert(split_coefficient_temp.segment_left.right_endpoint != INF && split_coefficient_temp.segment_right.right_endpoint != INF && split_coefficient_temp.segment_left.rectangle_width != INF && split_coefficient_temp.segment_right.rectangle_width != INF);
//						assert(split_coefficient_temp.segment_left.apla.a != INF && split_coefficient_temp.segment_right.apla.a != INF && split_coefficient_temp.segment_left.apla.b != INF && split_coefficient_temp.segment_right.apla.b != INF);
//						assert(split_coefficient_temp.segment_left.sum_value != INF && split_coefficient_temp.segment_right.sum_value != INF);
//#endif
//						break;
//					}
//					segments_density_vector.emplace(segments_density_vector.begin() + right_segment_id, split_coefficient_temp);// insert position is before begin() + id
//
//				}
//				else if (right_segment_id < segments_density_vector.size() && segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint + 1 < segments_density_vector[right_segment_id].segment_left.right_endpoint) {// middle and right split id is not adjacent
//					split_coefficient_temp.segment_left.right_endpoint = (segments_density_vector[right_segment_id].segment_left.right_endpoint + segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint) / 2;
//					segment_id++;//skip new inserted right segment, id is new right segment now
//					//get_split_coefficient(original_time_series_vector, long_segment, split_coefficient_temp);
//					get_split_coefficient(original_time_series_vector, long_segment, split_coefficient_temp, segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint, segments_density_vector[right_segment_id].segment_left.right_endpoint, segments_density_vector, id_min_density_segment_current);
//					if (split_coefficient_temp.segment_right.segment_density < min_density_segment_local.segment_right.segment_density) {
//						new_min_segment_density = split_coefficient_temp.segment_right.segment_density;
//						min_density_split_point_id = split_coefficient_temp.segment_left.right_endpoint;
//#if _DEBUG
//						assert(split_coefficient_temp.segment_left.right_endpoint != INF && split_coefficient_temp.segment_right.right_endpoint != INF && split_coefficient_temp.segment_left.rectangle_width != INF && split_coefficient_temp.segment_right.rectangle_width != INF);
//						assert(split_coefficient_temp.segment_left.apla.a != INF && split_coefficient_temp.segment_right.apla.a != INF && split_coefficient_temp.segment_left.apla.b != INF && split_coefficient_temp.segment_right.apla.b != INF);
//						assert(split_coefficient_temp.segment_left.sum_value != INF && split_coefficient_temp.segment_right.sum_value != INF);
//#endif
//						break;
//					}
//					segments_density_vector.emplace(segments_density_vector.begin() + right_segment_id, split_coefficient_temp);// insert position is before begin() + id
//				}
//				else {
//					split_coefficient_temp.segment_left.right_endpoint = -1;
//				}
//				/*......................................................................................................................................................*/
//				/*.......................................    left split point computation segment triangle density & insertion..........................................*/
//				if (left_segment_id < 0 && begin_id + 1 < segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint) {// middle segment is first segment
//					//if () {
//					split_coefficient_temp.segment_left.right_endpoint = (begin_id + segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint) / 2;
//					//}
//					//else {
//						//split_coefficent_left.segment_left.right_endpoint = -1;
//					//}
//					segment_id++;//insertion will influence id of vector, id is on new right segment now, next <for loop> will +1
//					//get_split_coefficient(original_time_series_vector, long_segment, split_coefficient_temp);
//					get_split_coefficient(original_time_series_vector, long_segment, split_coefficient_temp, begin_id - 1, segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint, segments_density_vector, left_segment_id);
//					if (split_coefficient_temp.segment_right.segment_density < min_density_segment_local.segment_right.segment_density) {
//						new_min_segment_density = split_coefficient_temp.segment_right.segment_density;
//						min_density_split_point_id = split_coefficient_temp.segment_left.right_endpoint;
//#if _DEBUG
//						assert(split_coefficient_temp.segment_left.right_endpoint != INF && split_coefficient_temp.segment_right.right_endpoint != INF && split_coefficient_temp.segment_left.rectangle_width != INF && split_coefficient_temp.segment_right.rectangle_width != INF);
//						assert(split_coefficient_temp.segment_left.apla.a != INF && split_coefficient_temp.segment_right.apla.a != INF && split_coefficient_temp.segment_left.apla.b != INF && split_coefficient_temp.segment_right.apla.b != INF);
//						assert(split_coefficient_temp.segment_left.sum_value != INF && split_coefficient_temp.segment_right.sum_value != INF);
//#endif
//						break;
//					}
//					segments_density_vector.emplace(segments_density_vector.begin() + id_min_density_segment_current, split_coefficient_temp);// insert position is before begin() + id
//				}
//				else if (left_segment_id > -1 && segments_density_vector[left_segment_id].segment_left.right_endpoint + 1 < segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint) {// left and middle split id is not ajacent
//					split_coefficient_temp.segment_left.right_endpoint = (segments_density_vector[left_segment_id].segment_left.right_endpoint + segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint) / 2;
//					segment_id++;//insertion will influence id of vector, id is on new right segment now, next <for loop> will +1
//					//get_split_coefficient(original_time_series_vector, long_segment, split_coefficient_temp);
//					get_split_coefficient(original_time_series_vector, long_segment, split_coefficient_temp, segments_density_vector[left_segment_id].segment_left.right_endpoint, segments_density_vector[id_min_density_segment_current].segment_left.right_endpoint, segments_density_vector, left_segment_id);
//					if (split_coefficient_temp.segment_right.segment_density < min_density_segment_local.segment_right.segment_density) {
//						new_min_segment_density = split_coefficient_temp.segment_right.segment_density;
//						min_density_split_point_id = split_coefficient_temp.segment_left.right_endpoint;
//#if _DEBUG
//						assert(split_coefficient_temp.segment_left.right_endpoint != INF && split_coefficient_temp.segment_right.right_endpoint != INF && split_coefficient_temp.segment_left.rectangle_width != INF && split_coefficient_temp.segment_right.rectangle_width != INF);
//						assert(split_coefficient_temp.segment_left.apla.a != INF && split_coefficient_temp.segment_right.apla.a != INF && split_coefficient_temp.segment_left.apla.b != INF && split_coefficient_temp.segment_right.apla.b != INF);
//						assert(split_coefficient_temp.segment_left.sum_value != INF && split_coefficient_temp.segment_right.sum_value != INF);
//#endif
//						break;
//					}
//					segments_density_vector.emplace(segments_density_vector.begin() + id_min_density_segment_current, split_coefficient_temp);// insert position is before begin() + id
//				}
//				else {
//					split_coefficient_temp.segment_left.right_endpoint = -1;
//				}
//
//
//				/*.............................................................................................*/
//
//				/*.......................................get segment triangle density && insert vecter..........................................*/
//				// note: insert action will influence id of vector
//				//if (split_coefficent_right.segment_left.right_endpoint > 0) {// right split id 
//				//	
//				//}
//
//				//if (split_coefficent_left.segment_left.right_endpoint > 0) {// left split id
//				//	
//				//}
//				/*.............................................................................................................................*/
//			}
//		}
//	}

	/*================================================================================================================================================================*/

	/*cout << " Fast Density Split Point: " << min_density_split_point_id << endl;

	cout << "Fast split point selection: ";
	for (auto&& au : segments_density_vector) {
		cout << au.segment_left.right_endpoint << ",";
	}
	cout << endl;
	cout << "Fast split Magnitude selection: ";
	for (auto&& au : segments_density_vector) {
		cout << au.split_magnitude << ",";
	}
	cout << endl;*/

	/*........................................   Evaluate accuracy & time of four finding split point methods.............*/
//#ifdef TIME_H
//	double split_time = TOOL::recordFinishTime(time_find_split);// 180923
//#endif
	//evaluate_accuracy_time_split_point(original_time_series_vector, temp_coefficient, min_density_split_point_id, split_time);
	/*......................................................................................................................*/

	segments_density_vector.clear();
	//segments_density_vector.shrink_to_fit();
	segments_density_linked_list.clear();

	return split_coefficient_temp.segment_left.right_endpoint;

	//switch (option_linkedlist_or_vector) {
	//case 0:
	//	//return min_density_split_point_id_from_linkedlist;
	//	return min_density_segment_local_from_linkedlist.segment_left.right_endpoint;
	//	break;
	//case 1:
	//	return min_density_segment_local_from_vector.segment_left.right_endpoint;
	//	//return min_density_split_point_id_from_vector;
	//	break;
	//default:
	//	assert(0);
	//}
}

//200214 Find min density point fast use vector. prove coefficeints for sub left segment, sub irght segment, and long smegnetnr 
//200210 
//************************************
// Method:find_split_point_by_min_density_fast
// Qualifier: Find min density point fast use vector 
// Input:
// Output: 1 Split point == sub left segment right endpoint, 
//         2 coefficients of sub left & right and long segment: a&b, right endpoint, rectanle width, sum value. 
//         3 Long segmnet triangle density with left & right segments
// Note: 
// date:200302
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
double APLA::find_split_point_by_min_density_fast(const vector<T>& const original_time_series_vector, Y& const sub_segment_left, Y& const sub_segment_right, U& const temp_coefficient) {
#if _DEBUG
	//assert(temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF && temp_coefficient.rectangle_width > 4);
#endif

	////////////////////////////////////////// Intersection Point ////////////////////////////////////////////////////////////////////////
	//return int(find_split_point_by_direct_intersection_point(original_time_series_vector, temp_coefficient));// Intersection points
	//return findSplitSegmentBaseline(original_time_series_vector, temp_coefficient, 0);//best split id
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&      segment width <= 4      &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	switch (int(temp_coefficient.rectangle_width)) {
	case 1:
	case 2:
	case 3:
		return INF;
	case 4:
		return temp_coefficient.right_endpoint - 2;
	default:
		break;
	}
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&               Switch linkelist & vector       &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	// 0 is linked list, 1 vector.
	int option_linkedlist_or_vector = 1;
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	vector<SPLIT_COEFFICIENT> segments_density_vector;
	//DoublyLinkedList<SPLIT_COEFFICIENT> segments_density_vector = DoublyLinkedList<SPLIT_COEFFICIENT>();
	/*-----------------------         200301 Linked list & Pointer       -----------------------*/
	DoublyLinkedList<SPLIT_COEFFICIENT> segments_density_linked_list = DoublyLinkedList<SPLIT_COEFFICIENT>();
	/*------------------------------------------------------------------------------------------*/

	//SPLIT_COEFFICIENT split_coefficent_middle;
	//SPLIT_COEFFICIENT split_coefficent_left;
	//SPLIT_COEFFICIENT split_coefficent_right;
	SPLIT_COEFFICIENT split_coefficient_min_density_global;

	//SPLIT_COEFFICIENT* final_min_density_segment_pointer = nullptr;

//#ifdef TIME_H
//	typename TOOL::TIME time_find_split;
//	TOOL::recordStartTime(time_find_split);//compare percentage time
//#endif

	/*##########################    if long segment has no a & b, min&max point. scan to get a & b, min&max point      ###################*/
	if (temp_coefficient.apla.a == INF || temp_coefficient.apla.b == INF) {
		//assert(0);
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!    Only get a&b     !!!!!!!!!!!!!!!!!!!!!*/
		get_ab_segment(original_time_series_vector, temp_coefficient);
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		/*!!!!!!!!!!!!!!!!!!!!    210203 get a&b , minmax points    !!!!!!!!!!!!!*/
		//get_ab_minmax_segment(original_time_series_vector, temp_coefficient);
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	}
	/*####################################################################################################################################*/

	AREA_COEFFICIENT_CONCISE long_segment;
	long_segment.right_endpoint = temp_coefficient.right_endpoint;
	long_segment.rectangle_width = temp_coefficient.rectangle_width;
	long_segment.apla = temp_coefficient.apla;
	//SPLIT_ID_INCREASE split_id_min_to_max;

	double min_density_split_point_id_from_vector = INF;
	double min_density_split_point_id_from_linkedlist = INF;
	int begin_id = long_segment.right_endpoint - long_segment.rectangle_width + 1;
	int end_id = long_segment.right_endpoint;
	//int middle_id = (begin_id + end_id) / 2;

	/*split_coefficent_middle.split_magnitude = -1;
	split_coefficent_left.split_magnitude = -1;
	split_coefficent_right.split_magnitude = -1;

	split_coefficent_middle.segment_left.right_endpoint = middle_id;
	split_coefficent_left.segment_left.right_endpoint = split_coefficent_right.segment_left.right_endpoint = 1;*/
	//split_coefficent_left.segment_left.right_endpoint = (begin_id + middle_id) / 2;
	//split_coefficent_right.segment_left.right_endpoint = (middle_id + end_id) / 2;

	//0 is linked list
	//1 is vector
	switch (option_linkedlist_or_vector) {
	case 0: {// linked list
		assert(0);
		auto min_density_segment_local_from_linkedlist = get_segment_min_density_local_id(original_time_series_vector, long_segment, segments_density_linked_list);
		//min_density_split_point_id_from_linkedlist = min_density_segment_local_from_linkedlist.segment_left.right_endpoint;
		split_coefficient_min_density_global = get_segment_min_density_global_id(original_time_series_vector, long_segment, min_density_segment_local_from_linkedlist, segments_density_linked_list);
		break;
	}
	case 1: {// vector
		auto min_density_segment_local = get_segment_min_density_local_id(original_time_series_vector, long_segment, segments_density_vector);
		//min_density_split_point_id_from_vector = min_density_segment_local_from_vector.segment_left.right_endpoint;

		if (min_density_segment_local.segment_right.segment_density != INF) {
			split_coefficient_min_density_global = get_segment_min_density_global_id(original_time_series_vector, long_segment, min_density_segment_local, segments_density_vector);
		}
		else {
			//assert(0);
			split_coefficient_min_density_global = min_density_segment_local;
		}

		/*.....................................................................................................................................................*/
#if _DEBUG
		if (!segments_density_vector.empty()) {
			DensityIncrease density_min_to_max;
			const auto& const min_density_segment = min_element(segments_density_vector.begin(), segments_density_vector.end(), density_min_to_max);
			assert(split_coefficient_min_density_global.segment_right.segment_density <= min_density_segment->segment_right.segment_density);
			auto test_density = getLineSegmentTriangleAreaDensity(split_coefficient_min_density_global.segment_left, split_coefficient_min_density_global.segment_right, long_segment);
			assert(split_coefficient_min_density_global.segment_right.segment_density == test_density);
			for (auto&& au : segments_density_vector) {
				test_density = getLineSegmentTriangleAreaDensity(au.segment_left, au.segment_right, long_segment);
				assert(au.segment_right.segment_density == test_density);
			}
		}
#endif
		/*.....................................................................................................................................................*/

		break;
	}
	default:
		assert(0);
	}

	/*###################################     return sub left & right a&b, right endpoint, width, segment_density     #####################################*/

	/*++++++++++++++++++++++++++++++++ Sub segment: Left ++++++++++++++++++++++++++++++++++++++++++++++*/
	sub_segment_left.right_endpoint = split_coefficient_min_density_global.segment_left.right_endpoint;
	sub_segment_left.rectangle_width = split_coefficient_min_density_global.segment_left.rectangle_width;
	//200316 sum value
	//sub_segment_left.sum_value = split_coefficient_min_density_global.segment_left.sum_value;
	sub_segment_left.apla = split_coefficient_min_density_global.segment_left.apla;
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/*++++++++++++++++++++++++++++++++ Sub segment: Right +++++++++++++++++++++++++++++++++++++++++++++*/
	sub_segment_right.right_endpoint = split_coefficient_min_density_global.segment_right.right_endpoint;
	sub_segment_right.rectangle_width = split_coefficient_min_density_global.segment_right.rectangle_width;
	//200316 sum value
	//sub_segment_right.sum_value = split_coefficient_min_density_global.segment_right.sum_value;
	sub_segment_right.apla = split_coefficient_min_density_global.segment_right.apla;
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	temp_coefficient.segment_density = split_coefficient_min_density_global.segment_right.segment_density;

	/*#####################################################################################################################################################*/

	/*.....................................................................................................................................................*/
#if _DEBUG
	//assert segment density, magnitude, sub left & right a&b, right endpoint, width, sum value
	assert_structure_split_coefficients(split_coefficient_min_density_global);

	assert_split_coefficients(sub_segment_left);
	assert_split_coefficients(sub_segment_right);
	assert_split_coefficients(temp_coefficient);

	assert_segment_a_b(original_time_series_vector, sub_segment_left);
	assert_segment_a_b(original_time_series_vector, sub_segment_right);
	assert_segment_a_b(original_time_series_vector, temp_coefficient);

	const auto test_density = getLineSegmentTriangleAreaDensity(sub_segment_left, sub_segment_right, long_segment);
	if (test_density != INF) {
		//assert(fabs(test_density - temp_coefficient.segment_density) <= 0.1);
		assert(fabs(test_density - temp_coefficient.segment_density) <= EPS);
	}

	/*Y test_sub_segment_left = sub_segment_left;
	Y test_sub_segment_right = sub_segment_right;
	AREA_COEFFICIENT_CONCISE test_temp_coefficient = long_segment;
	get_ab_segment(original_time_series_vector, test_sub_segment_left);
	get_ab_segment(original_time_series_vector, test_sub_segment_right);
	get_ab_segment(original_time_series_vector, test_temp_coefficient);
	assert(fabs(test_sub_segment_left.apla.a - sub_segment_left.apla.a) <= MIN_D && fabs(test_sub_segment_left.apla.b - sub_segment_left.apla.b) <= MIN_D);
	assert(fabs(test_sub_segment_right.apla.a - sub_segment_right.apla.a) <= MIN_D && fabs(test_sub_segment_right.apla.b - sub_segment_right.apla.b) <= MIN_D);
	assert(fabs(test_temp_coefficient.apla.a - temp_coefficient.apla.a) <= MIN_D && fabs(test_temp_coefficient.apla.b - temp_coefficient.apla.b) <= MIN_D);*/
#endif
	/*.....................................................................................................................................................*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&            No Need        &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	/*====================================================              Get Local min density id               ================================================================*/
	/*---------------------------------------------------------     by vector     ---------------------------------------------------------------------*/
	//auto min_density_segment_local_from_vector = get_segment_min_density_local_id(original_time_series_vector, long_segment, segments_density_vector);
	//min_density_split_point_id_from_vector = min_density_segment_local_from_vector.segment_left.right_endpoint;
	/*-------------------------------------------------------------------------------------------------------------------------------------------------*/
	/*------------------------------------------------------------by linked list-----------------------------------------------------------------------*/
	/*auto min_density_segment_local_from_linkedlist = get_segment_min_density_local_id(original_time_series_vector, long_segment, segments_density_linked_list);
	min_density_split_point_id_from_linkedlist = min_density_segment_local_from_linkedlist.segment_left.right_endpoint;*/
	/*-------------------------------------------------------------------------------------------------------------------------------------------------*/
	/*==========================================================================================================================================================================*/

	/*----------------------------------------------------Evaluate Linked list method-----------------------------------------------------------------------*/
	/*assert(min_density_split_point_id_from_vector == min_density_split_point_id_from_linkedlist && segments_density_vector.size() == segments_density_linked_list.size());
	for (int segment_id = 0; segment_id < segments_density_linked_list.size(); segment_id++) {
		const auto& const segment_vector = segments_density_vector[segment_id];
		const auto& const segment_linkedlist = segments_density_linked_list[segment_id];
		assert(segment_vector.segment_left.right_endpoint == segment_linkedlist.segment_left.right_endpoint && segment_vector.split_magnitude == segment_linkedlist.split_magnitude && segment_vector.segment_density == segment_linkedlist.segment_density);
		assert(segment_vector.segment_left.right_endpoint == segment_linkedlist.segment_left.right_endpoint && segment_vector.segment_left.rectangle_width == segment_linkedlist.segment_left.rectangle_width && segment_vector.segment_left.apla.a == segment_linkedlist.segment_left.apla.a && segment_vector.segment_left.apla.b == segment_linkedlist.segment_left.apla.b);
		assert(segment_vector.segment_right.right_endpoint == segment_linkedlist.segment_right.right_endpoint && segment_vector.segment_right.rectangle_width == segment_linkedlist.segment_right.rectangle_width && segment_vector.segment_right.apla.a == segment_linkedlist.segment_right.apla.a && segment_vector.segment_right.apla.b == segment_linkedlist.segment_right.apla.b);
	}*/
	/*------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*.................................................................................................................................................................*/
#if _DEBUG
	assert(sub_segment_right.right_endpoint == long_segment.right_endpoint && sub_segment_left.rectangle_width + sub_segment_right.rectangle_width == long_segment.rectangle_width);
	for (auto&& au : segments_density_vector) {
		assert(au.segment_left.right_endpoint == au.segment_left.right_endpoint && au.segment_right.right_endpoint == long_segment.right_endpoint);
		//assert(au.split_magnitude <= min_density_segment_local.split_magnitude && au.segment_density >= min_density_segment_local.segment_right.segment_density);
	}
#endif
	/*.................................................................................................................................................................*/

	/*........................................   Evaluate accuracy & time of four finding split point methods    .............*/
//#ifdef TIME_H
//	double split_time = TOOL::recordFinishTime(time_find_split);// 180923
//#endif
	//evaluate_accuracy_time_split_point(original_time_series_vector, temp_coefficient, min_density_split_point_id, split_time);
	/*........................................................................................................................*/

	segments_density_vector.clear();
	segments_density_vector.shrink_to_fit();
	segments_density_linked_list.clear();

	return split_coefficient_min_density_global.segment_left.right_endpoint;

	//switch (option_linkedlist_or_vector) {
	//case 0:
	//	//return min_density_split_point_id_from_linkedlist;
	//	break;
	//case 1:
	//	//return min_density_split_point_id_from_vector;
	//	break;
	//default:
	//	assert(0);
	//}
}

//************************************
// Method:group_find_split_point_methods
// Qualifier: contain 5 split point methods 1 min denisty , 2 BInary 3 Intersectoin point 4 middle point 5 best split id 
// date://200225 
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
double APLA::group_find_split_point_methods(const vector<T>& const original_time_series_vector, Y& const temp_coefficient, const int& const option_split_method) {
	//assert(output_argument.coefficents_split_id.split_time_min_density != INF && output_argument.coefficents_split_id.split_time_binary != INF && output_argument.coefficents_split_id.split_time_direct_intersection != INF && output_argument.split_time_best != INF);
	//assert(output_argument.coefficents_split_id.split_sum_deviation_min_density != INF && output_argument.coefficents_split_id.split_sum_deviation_binary != INF && output_argument.coefficents_split_id.split_sum_deviation_direct_intersection != INF && output_argument.coefficents_split_id.split_sum_deviation_best != INF);
	//assert(split_id_min_density != INF && split_time_min_density != NULL && temp_coefficient.rectangle_width > 3);
	assert(0);
#if _DEBUG
	assert(output_argument.coefficents_split_id.local_split_time != INF && output_argument.coefficents_split_id.local_split_sum_deviation != INF && output_argument.coefficents_split_id.local_split_shift_abs != INF);
	assert(temp_coefficient.rectangle_width != INF && temp_coefficient.right_endpoint != INF && !original_time_series_vector.empty());
#endif

	double split_id = INF;

	switch (int(temp_coefficient.rectangle_width)) {
	case 1:
	case 2:
	case 3:
		return INF;
	case 4:
		return temp_coefficient.right_endpoint - 2;
	}

#ifdef TIME_H
	typename TOOL::TIME time_find_split;
	TOOL::recordStartTime(time_find_split);//compare percentage time
#endif

	switch (option_split_method) {
	case 0:
		split_id = find_split_point_by_min_density_fast(original_time_series_vector, temp_coefficient);
		break;
	case 1:
		split_id = findSplitSegmentByEndpoint2length(original_time_series_vector, temp_coefficient);//200205 find binary split point
		break;
	case 2:
		split_id = int(find_split_point_by_direct_intersection_point(original_time_series_vector, temp_coefficient));// directly find intersection point as split point
		break;
	case 3:
		split_id = int(find_split_point_by_middle_point(temp_coefficient));// directly find intersection point as split point
		break;
	case 4:
		split_id = findSplitSegmentBaseline(original_time_series_vector, temp_coefficient, 0);//0 is best split id, 1 is min density id
		break;
	default:
		assert(0);
		break;
	}

#ifdef TIME_H
	output_argument.coefficents_split_id.local_split_time += TOOL::recordFinishTime(time_find_split);//
#endif
#if _DEBUG
	assert(split_id > 0 && split_id != int(INF));
#endif

	double current_split_id_sum_deviation = get_segment_sum_deviation_by_split_id(original_time_series_vector, temp_coefficient, split_id);
	output_argument.coefficents_split_id.local_split_sum_deviation += current_split_id_sum_deviation;

	/*--------------------------------------------Differece between best split id------------------------------------------------------------------------------------*/

	int split_id_best = findSplitSegmentBaseline(original_time_series_vector, temp_coefficient, 0);

#if _DEBUG
	double test_best_split_id_sum_devation = get_segment_sum_deviation_by_split_id(original_time_series_vector, temp_coefficient, split_id_best);
	if (option_split_method != 4) {
		assert(float(current_split_id_sum_deviation) >= float(test_best_split_id_sum_devation));
	}
#endif

	output_argument.coefficents_split_id.local_split_shift_abs += fabs(split_id - split_id_best);

	/*output_argument.coefficents_split_id.split_accuracy_min_density += fabs(split_id - split_id_best);
	output_argument.coefficents_split_id.split_accuracy_binary += fabs(split_id - split_id_best);
	output_argument.coefficents_split_id.split_accuracy_direct_intersection += fabs(split_id - split_id_best);
	output_argument.coefficents_split_id.split_accuracy_middle += fabs(split_id - split_id_best);
	output_argument.coefficents_split_id.split_id_best += fabs(split_id - split_id_best);*/
	/*---------------------------------------------------------------------------------------------------------------------------------------------------------------*/

	//assert(split_id != int(INF) && split_id_best != int(INF) && output_argument.coefficents_split_id.local_split_shift_abs != INF && output_argument.coefficents_split_id.local_split_sum_deviation != INF && output_argument.coefficents_split_id.local_split_time != INF);
	//assert(output_argument.coefficents_split_id.split_time_min_density != INF && output_argument.coefficents_split_id.split_time_binary != INF && output_argument.coefficents_split_id.split_time_direct_intersection != INF && output_argument.coefficents_split_id.split_time_middle != INF && output_argument.coefficents_split_id.split_time_best != INF && output_argument.coefficents_split_id.split_accuracy_min_density != INF && output_argument.coefficents_split_id.split_accuracy_binary != INF && output_argument.coefficents_split_id.split_accuracy_direct_intersection != INF && output_argument.coefficents_split_id.split_accuracy_middle != INF && output_argument.split_id_best != INF);
	//assert(output_argument.coefficents_split_id.split_sum_deviation_min_density != INF && output_argument.coefficents_split_id.split_sum_deviation_binary != INF && output_argument.split_sum_deviation_direct_intersection != INF && output_argument.coefficents_split_id.split_sum_deviation_middle != INF && output_argument.coefficents_split_id.split_sum_deviation_best != INF);

	return split_id;
}


//************************************
// Method:group_find_split_point_methods
// Qualifier: contain 5 split point methods 1 min denisty , 2 BInary 3 Intersectoin point 4 middle point 5 best split id 
// output: a&b, right endpoint, width, sume value of sub left&right segments; split id; segment density of long segment with sub left&right segments.
// date://200225 
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
double APLA::group_find_split_point_methods(const vector<T>& const original_time_series_vector, const int& const option_split_method, Y& const sub_segment_left, Y& const sub_segment_right, Y& const temp_coefficient, U& const output_argument) {

	/*..................................................................................................................................................................*/
	//assert(output_argument.coefficents_split_id.split_time_min_density != INF && output_argument.coefficents_split_id.split_time_binary != INF && output_argument.coefficents_split_id.split_time_direct_intersection != INF && output_argument.split_time_best != INF);
	//assert(output_argument.coefficents_split_id.split_sum_deviation_min_density != INF && output_argument.coefficents_split_id.split_sum_deviation_binary != INF && output_argument.coefficents_split_id.split_sum_deviation_direct_intersection != INF && output_argument.coefficents_split_id.split_sum_deviation_best != INF);
	//assert(split_id_min_density != INF && split_time_min_density != NULL && temp_coefficient.rectangle_width > 3);
#if _DEBUG
	/*output_argument.coefficents_split_id.local_split_time = 0;
	output_argument.coefficents_split_id.local_split_sum_deviation = 0;
	output_argument.coefficents_split_id.local_split_shift_abs = 0;*/
	//assert(output_argument.coefficents_split_id.local_split_time != INF && output_argument.coefficents_split_id.local_split_sum_deviation != INF && output_argument.coefficents_split_id.local_split_shift_abs != INF);
	assert(temp_coefficient.rectangle_width != INF && temp_coefficient.right_endpoint != INF && !original_time_series_vector.empty());
	if (temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF) {
		Y test_long_segment = temp_coefficient;
		get_ab_segment(original_time_series_vector, test_long_segment);
		assert_two_segments_a_b(test_long_segment, temp_coefficient);
	}
#endif
	/*.................................................................................................................................................................*/

	double split_id = INF;
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++    long segment width <= 4 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	switch (int(temp_coefficient.rectangle_width)) {
	case 1:
	case 2:
	case 3:
		return INF;
	case 4:

		/*..........................................................................................*/
#if _DEBUG
		assert(sub_segment_left.apla.a == INF);
		//assert(sub_segment_left.right_endpoint == INF && sub_segment_right.right_endpoint == INF);
#endif
		/*...........................................................................................*/

		/*=============================             right endpoint, width:  sub left & right segmnet.          ==================================================*/
		sub_segment_left.right_endpoint = temp_coefficient.right_endpoint - 2;
		//sub_segment_right.right_endpoint = temp_coefficient.right_endpoint;
		sub_segment_left.rectangle_width = sub_segment_right.rectangle_width = 2;
		/*=======================================================================================================================================================*/

		/*===================     210203   200508  Min&Max Points sub left segment, sub right segment, long segment.        ===========================================*/
		/*get_segment_two_point_minmax(original_time_series_vector, sub_segment_left);
		get_segment_two_point_minmax(original_time_series_vector, sub_segment_right);
		get_long_segment_minmax_by_sub_segments(sub_segment_left, sub_segment_right, temp_coefficient);*/
		/*=======================================================================================================================================================*/

		/*===========================================             //200316  sum value        ====================================================================*/
		/*sub_segment_left.sum_value = original_time_series_vector[sub_segment_left.right_endpoint - 1] + original_time_series_vector[sub_segment_left.right_endpoint];
		sub_segment_right.sum_value = original_time_series_vector[sub_segment_right.right_endpoint - 1] + original_time_series_vector[sub_segment_right.right_endpoint];*/
		/*=======================================================================================================================================================*/

		/*=====================================        a&b for split option 0 : sub left right, long segment   ===================================================*/
		if (option_split_method == 0) {
			// get a&b of sub left segment
			getAandBSlopInterceptTwoPoint(original_time_series_vector[sub_segment_left.right_endpoint - 1], original_time_series_vector[sub_segment_left.right_endpoint], sub_segment_left);//190929(original_time_series, temp_coefficient);
			// get a&b of sub right segment
			getAandBSlopInterceptTwoPoint(original_time_series_vector[sub_segment_right.right_endpoint - 1], original_time_series_vector[sub_segment_right.right_endpoint], sub_segment_right);//190929(original_time_series, temp_coefficient);
			//a&b: long segment 
			if (temp_coefficient.apla.a == INF) {
				//200311
				//+++ Input: left & right & temp segment, sum value, a&b, width, right endpoint
				//+++ Output: temp segment a & b
				getAAndBByPLAShortSegSpeed(sub_segment_left, sub_segment_right, temp_coefficient);//get long a&b from short a&b and sum value
			}
			temp_coefficient.segment_density = getLineSegmentTriangleAreaDensity(sub_segment_left, sub_segment_right, temp_coefficient);

			/*.............................................................*/
#if _DEBUG
			Y test_long_segment = temp_coefficient;
			get_ab_segment(original_time_series_vector, test_long_segment);
			assert_two_segments_a_b(test_long_segment, temp_coefficient);
#endif
			/*..............................................................*/

		}
		/*=======================================================================================================================================================*/

		/*+++++++++++++++++++++++++++++++++   210114 compute upper bound   ++++++++++++++++++++++++++++++++++++++++*/
		get_upper_bound_sub_segment_left_right(original_time_series_vector, sub_segment_left, sub_segment_right, temp_coefficient, output_argument);
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		return sub_segment_left.right_endpoint;
	default:
		break;
	}
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/*.............................................................................................................................*/
#if _DEBUG
#ifdef TIME_H
	typename TOOL::TIME time_find_split;
	TOOL::recordStartTime(time_find_split);//compare percentage time
#endif
#endif
	/*.............................................................................................................................*/
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++    Short segment >= 4 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	split_id = find_split_point_by_min_density_fast(original_time_series_vector, sub_segment_left, sub_segment_right, temp_coefficient);

	//switch (option_split_method) {
	//case 0:
	//	//split_id = find_split_point_by_min_density_fast(original_time_series_vector, temp_coefficient);
	//	//200302 return coefficients of sub left & right segments
	//	split_id = find_split_point_by_min_density_fast(original_time_series_vector, sub_segment_left, sub_segment_right, temp_coefficient);
	//	break;
	//case 1:
	//	split_id = findSplitSegmentByEndpoint2length(original_time_series_vector, temp_coefficient);//200205 find binary split point
	//	break;
	//case 2:
	//	split_id = int(find_split_point_by_direct_intersection_point(original_time_series_vector, temp_coefficient));// directly find intersection point as split point
	//	break;
	//case 3:
	//	split_id = int(find_split_point_by_middle_point(temp_coefficient));// directly find intersection point as split point
	//	break;
	//case 4:
	//	split_id = findSplitSegmentBaseline(original_time_series_vector, temp_coefficient, 0);//0 is best split id, 1 is min density id
	//	break;
	//default:
	//	assert(0);
	//	break;
	//}

	/*..................................................................................................................................*/
#if _DEBUG
	assert(split_id > 0 && split_id != int(INF));
#endif
	/*.............................................................................................................................*/

	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*+++++++++++++++++++++++++++++++++   210114 compute upper bound   ++++++++++++++++++++++++++++++++++++++++*/
	get_upper_bound_sub_segment_left_right(original_time_series_vector, sub_segment_left, sub_segment_right, temp_coefficient, output_argument);
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*++++++++++++++++++++++++++++++++++          Min&max point & right endpoint & width: sub left & right segment            +++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
//	/*==================================================           Split method option > 0            ===========================================================*/
//	if (option_split_method > 0) {
//		/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  Width, right endpoint: sub left & right segment  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
//		sub_segment_left.right_endpoint = split_id;
//		sub_segment_left.rectangle_width = temp_coefficient.rectangle_width;
//		sub_segment_right.rectangle_width = temp_coefficient.right_endpoint - sub_segment_left.right_endpoint;
//		sub_segment_left.rectangle_width -= sub_segment_right.rectangle_width;
//#if _DEBUG
//		assert(sub_segment_left.rectangle_width > 1 && temp_coefficient.rectangle_width > 1 && sub_segment_left.right_endpoint < temp_coefficient.right_endpoint && temp_coefficient.right_endpoint == sub_segment_right.right_endpoint);
//#endif
//		/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
//	
//		/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^      Min&max points: sub left & right segment      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
//		getSegmentMinMaxPoint(original_time_series_vector, sub_segment_left);
//		getSegmentMinMaxPoint(original_time_series_vector, sub_segment_right);
//		/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
//		
//	}/*==========================================================================================================================================================*/
//	else {
//		/*==================================================           Split method option == 0            ======================================================*/
//		/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^             Min&max points: sub left, right segment         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
//		//200212 get min&max point of left&right segment by long segment, speed up
//		//200314 minmax point
//		getSubMinMaxPoint(original_time_series_vector, sub_segment_left, sub_segment_right, temp_coefficient);
//		/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
//		/*==========================================================================================================================================================*/
//	}
	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*......................................................................................................................................................................*/
#ifdef _DEBUG
#ifdef TIME_H
	output_argument.coefficents_split_id.local_split_time += TOOL::recordFinishTime(time_find_split);//
#endif
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&                 Evaluation of split point          &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++     compute sum deviation of segment     +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	double current_split_id_sum_deviation = get_segment_sum_deviation_by_split_id(original_time_series_vector, temp_coefficient, split_id);
	output_argument.coefficents_split_id.local_split_sum_deviation += current_split_id_sum_deviation;
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*+++++++++++++++++++++++++++++++++++++++++++++                 Differece between best split id      +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	int split_id_best = findSplitSegmentBaseline(original_time_series_vector, temp_coefficient, 0);
	double test_best_split_id_sum_devation = get_segment_sum_deviation_by_split_id(original_time_series_vector, temp_coefficient, split_id_best);
	/*if (option_split_method != 4) {
		assert(float(current_split_id_sum_deviation) >= float(test_best_split_id_sum_devation));
	}*/
	output_argument.coefficents_split_id.local_split_shift_abs += fabs(split_id - split_id_best);
	/*output_argument.coefficents_split_id.split_accuracy_min_density += fabs(split_id - split_id_best);
	output_argument.coefficents_split_id.split_accuracy_binary += fabs(split_id - split_id_best);
	output_argument.coefficents_split_id.split_accuracy_direct_intersection += fabs(split_id - split_id_best);
	output_argument.coefficents_split_id.split_accuracy_middle += fabs(split_id - split_id_best);
	output_argument.coefficents_split_id.split_id_best += fabs(split_id - split_id_best);*/
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	//assert(split_id != int(INF) && split_id_best != int(INF) && output_argument.coefficents_split_id.local_split_shift_abs != INF && output_argument.coefficents_split_id.local_split_sum_deviation != INF && output_argument.coefficents_split_id.local_split_time != INF);
	//assert(output_argument.coefficents_split_id.split_time_min_density != INF && output_argument.coefficents_split_id.split_time_binary != INF && output_argument.coefficents_split_id.split_time_direct_intersection != INF && output_argument.coefficents_split_id.split_time_middle != INF && output_argument.coefficents_split_id.split_time_best != INF && output_argument.coefficents_split_id.split_accuracy_min_density != INF && output_argument.coefficents_split_id.split_accuracy_binary != INF && output_argument.coefficents_split_id.split_accuracy_direct_intersection != INF && output_argument.coefficents_split_id.split_accuracy_middle != INF && output_argument.split_id_best != INF);
	//assert(output_argument.coefficents_split_id.split_sum_deviation_min_density != INF && output_argument.coefficents_split_id.split_sum_deviation_binary != INF && output_argument.split_sum_deviation_direct_intersection != INF && output_argument.coefficents_split_id.split_sum_deviation_middle != INF && output_argument.coefficents_split_id.split_sum_deviation_best != INF);
	if (option_split_method == 0) {
		assert_segment_a_b(original_time_series_vector, sub_segment_left);
		assert_segment_a_b(original_time_series_vector, sub_segment_right);
		assert_segment_a_b(original_time_series_vector, temp_coefficient);
	}
#endif
	/*.....................................................................................................................................................................*/

	return split_id;
}

//************************************
// Method:findSegmentMiddleID
// Qualifier: Find middle id of segment.
// date:1900715
// author:
//************************************
TEMPLATE
template<typename T>
inline int APLA::findSegmentMiddleID(T& const temp_coefficient) {//190715
	int left_segment_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	int middle_id = (left_segment_id + temp_coefficient.right_endpoint) / 2;
#if _DEBUG
	assert(middle_id - left_segment_id > 0 && temp_coefficient.right_endpoint - middle_id > 1 && left_segment_id != INF && middle_id != INF);
#endif
	return middle_id;
}

//190903
//************************************
// Method:getAreaDifference
// Qualifier: Find middle id of segment.
// Input: 1 width, 2 right endpoint, 3 a&b, 4 min&max point
// Output:
// date:190903
// author:
//************************************
TEMPLATE
inline double& APLA::getAreaDifference(AREA_COEFFICIENT& const temp_coefficient) {//Min Max area - PLA area
	assert(0);
#ifdef _DEBUG
	assert(temp_coefficient.min_point.value != INF && temp_coefficient.min_point.value != INF && temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF && temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF && temp_coefficient.sum_value != INF && temp_coefficient.max_point.value != INF && temp_coefficient.min_point.value != INF && temp_coefficient.max_point.id != INF && temp_coefficient.min_point.id != INF);
	int segment_left_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	assert(temp_coefficient.min_point.value <= temp_coefficient.max_point.value && temp_coefficient.min_point.id <= temp_coefficient.right_endpoint && temp_coefficient.max_point.id <= temp_coefficient.right_endpoint && temp_coefficient.min_point.id >= segment_left_id && temp_coefficient.max_point.id >= segment_left_id);
	if (temp_coefficient.min_point.value == temp_coefficient.max_point.value) {
		temp_coefficient.min_point.id < temp_coefficient.max_point.id;
	}
#endif
	temp_coefficient.area_difference = 0;

	if (temp_coefficient.max_point.value == temp_coefficient.min_point.value) {
		return temp_coefficient.area_difference;
	}

	if (temp_coefficient.rectangle_width > 3) {
		/*===================================================      MinMax & PLA Area       =============================================================================*/
		temp_coefficient.rectangle_area = fabs(temp_coefficient.apla.a * (temp_coefficient.rectangle_width - 1)) * temp_coefficient.rectangle_width;
		temp_coefficient.minmax_width_area = (temp_coefficient.max_point.value - temp_coefficient.min_point.value) * temp_coefficient.rectangle_width;
		temp_coefficient.minmax_distance_area = (temp_coefficient.max_point.value - temp_coefficient.min_point.value) * fabs(temp_coefficient.max_point.id - temp_coefficient.min_point.id);
		/*==============================================================================================================================================================*/
#ifdef _DEBUG
		assert(temp_coefficient.rectangle_width >= fabs(temp_coefficient.max_point.id - temp_coefficient.min_point.id));//n is even
		assert(temp_coefficient.minmax_width_area >= 0 && temp_coefficient.minmax_distance_area >= 0);//n is even
#endif
		/*====================================================       Compute Area difference       ======================================================================*/
		if (temp_coefficient.rectangle_area <= temp_coefficient.minmax_distance_area && temp_coefficient.minmax_distance_area <= temp_coefficient.minmax_width_area) {
			temp_coefficient.area_difference = temp_coefficient.minmax_width_area - temp_coefficient.rectangle_area;
		}
		else if (temp_coefficient.minmax_distance_area <= temp_coefficient.rectangle_area && temp_coefficient.rectangle_area <= temp_coefficient.minmax_width_area) {
			temp_coefficient.area_difference = temp_coefficient.minmax_width_area - temp_coefficient.minmax_distance_area;
		}
		else if (temp_coefficient.minmax_distance_area <= temp_coefficient.minmax_width_area && temp_coefficient.minmax_width_area <= temp_coefficient.rectangle_area) {
			temp_coefficient.area_difference = temp_coefficient.rectangle_area - temp_coefficient.minmax_distance_area;
		}
		else {
			assert(0);
		}
		/////////////////////////////////////////////////////////////////
		//temp_coefficient.area_difference = fabs(temp_coefficient.minmax_width_area - temp_coefficient.rectangle_area); // temp_coefficient.rectangle_width;

#ifdef _DEBUG
		assert(temp_coefficient.area_difference >= 0 && temp_coefficient.area_difference != INF);
#endif
	}
	return temp_coefficient.area_difference;
}

//190918
//************************************
// Method:getAreaDifference
// Qualifier: Find middle id of segment.
// Input: 1 width, 2 right endpoint, 3 a&b,
// Output:
// date:190918
// author:
//************************************
TEMPLATE
inline double& APLA::getAreaDifference(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient) {//Right end point area - PLA area
#ifdef _DEBUG
	assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF && temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF && temp_coefficient.sum_value != INF);
#endif
	temp_coefficient.area_difference = 0;
	if (temp_coefficient.rectangle_width > 3) {
		/*===================================================      MinMax & PLA Area       =============================================================================*/
		//temp_coefficient.rectangle_area = fabs(temp_coefficient.apla.a * (temp_coefficient.rectangle_width - 1)) * temp_coefficient.rectangle_width;
		//temp_coefficient.minmax_width_area = fabs(original_time_series[int(temp_coefficient.right_endpoint)] - original_time_series[int(temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1)]) * temp_coefficient.rectangle_width;
		temp_coefficient.rectangle_area = fabs(temp_coefficient.apla.a * (temp_coefficient.rectangle_width - 1)) * temp_coefficient.rectangle_width;
		temp_coefficient.minmax_width_area = fabs(original_time_series[int(temp_coefficient.right_endpoint)] - original_time_series[int(temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1)]) * temp_coefficient.rectangle_width;
		/*...............................................................................................................................................................*/
#ifdef _DEBUG
		//assert(temp_coefficient.rectangle_width >= fabs(temp_coefficient.max_point.id - temp_coefficient.min_point.id));//n is even
		assert(temp_coefficient.minmax_width_area >= 0 && temp_coefficient.area_difference >= 0 && temp_coefficient.area_difference != INF);
#endif


		return temp_coefficient.area_difference = fabs(temp_coefficient.minmax_width_area - temp_coefficient.rectangle_area);
		/*==================================200109 Test new area difference======================================*/
		/*int left_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
		double original_min_value = min(original_time_series[left_id], original_time_series[int(temp_coefficient.right_endpoint)]);
		double original_max_value = max(original_time_series[left_id], original_time_series[int(temp_coefficient.right_endpoint)]);

		double reconstruct_left_value = temp_coefficient.apla.b;
		double reconstruct_right_value = temp_coefficient.apla.a * (temp_coefficient.rectangle_width - 1) + temp_coefficient.apla.b;

		double reconstruct_min_value = min(reconstruct_left_value, reconstruct_right_value);
		double reconstruct_max_value = max(reconstruct_left_value, reconstruct_right_value);

		assert(original_min_value <= original_max_value && reconstruct_min_value <= reconstruct_max_value);

		if (original_max_value <= reconstruct_min_value || original_min_value >= reconstruct_max_value) {
			return temp_coefficient.area_difference = DBL_MAX;
		}
		else if (original_max_value >= reconstruct_max_value) {
			return temp_coefficient.area_difference = 1 / ( (reconstruct_max_value - max(original_min_value, reconstruct_min_value)) * temp_coefficient.rectangle_width );
		}
		else if (original_max_value <= reconstruct_max_value) {
			return temp_coefficient.area_difference = 1 / ( (original_max_value - max(reconstruct_min_value, original_min_value)) * temp_coefficient.rectangle_width );
		}
		else {
			assert(0);
		}*/
		/*=======================================================================================================*/
	}
	else {
		return temp_coefficient.area_difference;
	}
}

//200212 change original time series from pointer to vector. Add template
//************************************
// Method:getAreaDifference
// Qualifier: Find middle id of segment.
// Input: 1 width, 2 right endpoint, 3 a&b,
// Output:
// date:200212
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline long double& APLA::getAreaDifference(const vector<T>& const original_time_series_vector, Y& const temp_coefficient) { //Right end point area - PLA area
	assert(0);
	/*........................................................................................................................................................*/
#ifdef _DEBUG
	assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF && temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF);
	//assert_segment_a_b_minmax(original_time_series_vector, temp_coefficient); //210203
#endif
	/*........................................................................................................................................................*/
	return temp_coefficient.area_difference = temp_coefficient.bound.upper_bound_area;
	//temp_coefficient.area_difference = 0.0;

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&    Get Area Difference / Sum Deviation   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	/*##################################     segment length > 3, has potential to split     ################################################*/
	if (temp_coefficient.rectangle_width > 2) {
		//if (temp_coefficient.rectangle_width > 2 && temp_coefficient.max_point.value != temp_coefficient.min_point.value) {//210203
			/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!       MinMax & PLA Area       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
			//temp_coefficient.rectangle_area = fabs(temp_coefficient.apla.a * (temp_coefficient.rectangle_width - 1)) * temp_coefficient.rectangle_width;
			//temp_coefficient.minmax_width_area = fabs(original_time_series[int(temp_coefficient.right_endpoint)] - original_time_series[int(temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1)]) * temp_coefficient.rectangle_width;
			/*temp_coefficient.rectangle_area = fabs(temp_coefficient.apla.a * (temp_coefficient.rectangle_width - 1)) * temp_coefficient.rectangle_width;
			temp_coefficient.minmax_width_area = fabs(original_time_series_vector[int(temp_coefficient.right_endpoint)] - original_time_series_vector[int(temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1)]) * temp_coefficient.rectangle_width;*/


			//200305 delete rectangle_area & minmax_width_area
			//long double rectangle_area = fabs(temp_coefficient.apla.a * (temp_coefficient.rectangle_width - 1)) * temp_coefficient.rectangle_width;
			//long double minmax_width_area = fabs(original_time_series_vector[int(temp_coefficient.right_endpoint)] - original_time_series_vector[int(temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1)]) * temp_coefficient.rectangle_width;
			/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

			/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
			/*-----------------------------------------------------------------------------------------------------------------------------------*/
			/*+++++++++++      pla height      +++++++++++++++*/
			//const long double pla_height = fabs(temp_coefficient.apla.a * (temp_coefficient.rectangle_width - 1));
			/*++++++++++++++++++++++++++++++++++++++++++++++++*/
			/*+++++++++++   min&max height   ++++++++++++++++*/
			//const long double minmax_height = temp_coefficient.max_point.value - temp_coefficient.min_point.value;
			/*+++++++++++++++++++++++++++++++++++++++++++++++*/
			/*........................................................................................................................................................*/
#ifdef _DEBUG
		//assert(temp_coefficient.rectangle_width >= fabs(temp_coefficient.max_point.id - temp_coefficient.min_point.id));//n is even
		/*assert(temp_coefficient.minmax_width_area >= 0 && temp_coefficient.area_difference >= 0 && temp_coefficient.area_difference != INF);*/
		//200305
		assert(temp_coefficient.area_difference >= 0 && temp_coefficient.area_difference != INF);
#endif
		/*........................................................................................................................................................*/
		/*+++++++++++   minmax diff of whole time series   ++++++++++++++++*/
		/*const auto [min_point_whole, max_point_whole] = minmax_element(original_time_series_vector.begin(), original_time_series_vector.end());
		const long double height_minmax_whole_series = *max_point_whole - *min_point_whole;
		const long double height_width_ratio_sereis = height_minmax_whole_series / original_time_series_vector.size();*/
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/*-----------------------------------------------------------------------------------------------------------------------------------*/
		/*++++++++++++++++++++++++++++++++++++++++++++++++++++  Area Difference   +++++++++++++++++++++++++++++++++++++++++++++++++++*/
		//return temp_coefficient.area_difference = fabs(rectangle_area - minmax_width_area);
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/*+++++++++++++++++++++++++++++++++++++++++++++++   200410 Sum Deviation     ++++++++++++++++++++++++++++++++++++++++++++++++*/
		//return temp_coefficient.area_difference = get_segment_sum_deviation(original_time_series_vector, temp_coefficient);
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/*++++++++++++++++++++++++++++++++++     200415 Sum absolute difference of segment     ++++++++++++++++++++++++++++++++++++++*/
		//return temp_coefficient.area_difference = fabs(fabs(temp_coefficient.apla.a * (temp_coefficient.rectangle_width - 1)) - get_sum_segment_absolute_difference(original_time_series_vector, temp_coefficient));
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/*+++++++++++++++++++++++++++     200419 Area Difference: Sum absolute difference of segment     ++++++++++++++++++++++++++++*/
		//return temp_coefficient.area_difference = fabs(fabs(temp_coefficient.apla.a * (temp_coefficient.rectangle_width - 1)) - get_sum_segment_absolute_difference(original_time_series_vector, temp_coefficient)) * temp_coefficient.rectangle_width;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		//assert(temp_coefficient.max_point.value - temp_coefficient.min_point.value == get_segment_minmax_height(original_time_series_vector, temp_coefficient));
		/*+++++++++++++++++++++++++++        200419 Min&Max Y value absolute difference of segment       ++++++++++++++++++++++++++++*/
		//return temp_coefficient.area_difference = minmax_height * temp_coefficient.rectangle_width* height_width_ratio_sereis;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/*+++++++++++++++++++++++++++        2000601 height difference: minmax height - pla height       ++++++++++++++++++++++++++++*/
		//return temp_coefficient.area_difference = fabs(get_segment_minmax_height(original_time_series_vector, temp_coefficient) - fabs(temp_coefficient.apla.a * (temp_coefficient.rectangle_width - 1))) *temp_coefficient.rectangle_width;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*+++++++++++++++++++++++++++         200601 height difference: pla height - minmax height       +++++++++++++++++++++++++++++*/
		//return temp_coefficient.area_difference = pla_height * temp_coefficient.rectangle_width * height_width_ratio_sereis;
		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/*+++++++++++++++++++++++++++         200601 height difference: pla height - minmax height       +++++++++++++++++++++++++++++*/
		//return temp_coefficient.area_difference = fabs( get_segment_minmax_height(original_time_series_vector, temp_coefficient) - fabs(temp_coefficient.apla.a * (temp_coefficient.rectangle_width - 1)) ) * temp_coefficient.rectangle_width;// *height_width_ratio_sereis;
		//201025
		//return temp_coefficient.area_difference = fabs(temp_coefficient.max_point.value - temp_coefficient.min_point.value - fabs(temp_coefficient.apla.a * (temp_coefficient.rectangle_width - 1))) * temp_coefficient.rectangle_width;// *height_width_ratio_sereis;
		//return temp_coefficient.area_difference = fabs(temp_coefficient.max_point.value - temp_coefficient.min_point.value - fabs(temp_coefficient.apla.a * (temp_coefficient.rectangle_width - 1)));// *height_width_ratio_sereis;
		//210112
		//return get_segment_max_deviation_instead1(original_time_series_vector, temp_coefficient);
		//201029
		//return get_segment_max_deviation_instead(original_time_series_vector[temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1], original_time_series_vector[temp_coefficient.right_endpoint], temp_coefficient);
		//210115
		/*........................................................................................................................................................*/
#ifdef _DEBUG
		assert(temp_coefficient.bound.upper_bound_area != -INF && temp_coefficient.bound.upper_bound_diff != -INF);
#endif
		/*........................................................................................................................................................*/
		return temp_coefficient.area_difference = temp_coefficient.bound.upper_bound_area;
		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

		/*=================================================               200109 Test new area difference             ==================================================*/
		/*int left_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
		double original_min_value = min(original_time_series[left_id], original_time_series[int(temp_coefficient.right_endpoint)]);
		double original_max_value = max(original_time_series[left_id], original_time_series[int(temp_coefficient.right_endpoint)]);

		double reconstruct_left_value = temp_coefficient.apla.b;
		double reconstruct_right_value = temp_coefficient.apla.a * (temp_coefficient.rectangle_width - 1) + temp_coefficient.apla.b;

		double reconstruct_min_value = min(reconstruct_left_value, reconstruct_right_value);
		double reconstruct_max_value = max(reconstruct_left_value, reconstruct_right_value);

		assert(original_min_value <= original_max_value && reconstruct_min_value <= reconstruct_max_value);

		if (original_max_value <= reconstruct_min_value || original_min_value >= reconstruct_max_value) {
			return temp_coefficient.area_difference = DBL_MAX;
		}
		else if (original_max_value >= reconstruct_max_value) {
			return temp_coefficient.area_difference = 1 / ( (reconstruct_max_value - max(original_min_value, reconstruct_min_value)) * temp_coefficient.rectangle_width );
		}
		else if (original_max_value <= reconstruct_max_value) {
			return temp_coefficient.area_difference = 1 / ( (original_max_value - max(reconstruct_min_value, original_min_value)) * temp_coefficient.rectangle_width );
		}
		else {
			assert(0);
		}*/
		/*===================================================================================================================================================================*/
	}/*####################################################################################################################################################################*/
	else {/*##########################################    When segment length <= 3, No need to split   ############################################################################*/
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  Area Difference   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		return temp_coefficient.area_difference = temp_coefficient.bound.upper_bound_area;
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	}
	/*####################################################################################################################################################################*/
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
}


//************************************
// Method:getAreaDifference
// Qualifier:  without original time series
// Input: 1 width, 2 right endpoint, 3 a&b,
// Output:
// date:201004 10:13 
// author:
//************************************
//TEMPLATE
//template<typename T>
//inline long double& APLA::getAreaDifference(T& const temp_coefficient) { // MinMax Area - PLA Area
//
//	/*........................................................................................................................................................*/
//#ifdef _DEBUG
//	assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF && temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF);
//#endif
//	/*........................................................................................................................................................*/
//
//	temp_coefficient.area_difference = 0.0;
//
//	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&    Get Area Difference / Sum Deviation   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
//	/*##################################     segment length > 3, has potential to split     ################################################*/
//	if (temp_coefficient.rectangle_width > 2 && temp_coefficient.max_point.value != temp_coefficient.min_point.value) {
//
//		/*........................................................................................................................................................*/
//#ifdef _DEBUG
//		//assert(temp_coefficient.rectangle_width >= fabs(temp_coefficient.max_point.id - temp_coefficient.min_point.id));//n is even
//		/*assert(temp_coefficient.minmax_width_area >= 0 && temp_coefficient.area_difference >= 0 && temp_coefficient.area_difference != INF);*/
//		//200305
//		assert(temp_coefficient.area_difference >= 0 && temp_coefficient.area_difference != INF);
//#endif
//		/*........................................................................................................................................................*/
//
//		/*+++++++++++++++++++++++++++         200601 height difference: pla height - minmax height       +++++++++++++++++++++++++++++*/
//		//return temp_coefficient.area_difference = fabs(temp_coefficient.max_point.value - temp_coefficient.min_point.value - fabs(temp_coefficient.apla.a * (temp_coefficient.rectangle_width - 1)));
//		return temp_coefficient.area_difference = fabs(temp_coefficient.max_point.value - temp_coefficient.min_point.value - fabs(temp_coefficient.apla.a * (temp_coefficient.rectangle_width - 1))) * temp_coefficient.rectangle_width;// *height_width_ratio_sereis;
//		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
//	}
//	else {
//		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   When segment length <= 3, No need to split   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
//		return temp_coefficient.area_difference;
//		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
//	}
//	/*####################################################################################################################################################################*/
//	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
//}

//201007 02:21 Use the endpoint height difference instead area difference
//************************************
// Method:get_area_difference_segment
// Qualifier:  without original time series
// Input: 1 width, 2 right endpoint, 3 a&b,
// Output:
// date:201004 10:13 
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline long double& APLA::get_area_difference_segment(const vector<T>& const original_time_series_vector, Y& const temp_coefficient) {
	/*........................................................................................................................................................*/
#ifdef _DEBUG
	assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF && temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF);
#endif
	/*........................................................................................................................................................*/

	return getAreaDifference(original_time_series_vector, temp_coefficient);

	/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/

	temp_coefficient.area_difference = 0.0;

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&    Get Area Difference / Sum Deviation   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	/*##################################     segment length > 3, has potential to split     ################################################*/
	if (temp_coefficient.rectangle_width > 2 && temp_coefficient.max_point.value != temp_coefficient.min_point.value) {

		/*........................................................................................................................................................*/
#ifdef _DEBUG
		//assert(temp_coefficient.rectangle_width >= fabs(temp_coefficient.max_point.id - temp_coefficient.min_point.id));//n is even
		/*assert(temp_coefficient.minmax_width_area >= 0 && temp_coefficient.area_difference >= 0 && temp_coefficient.area_difference != INF);*/
		//200305
		assert(temp_coefficient.area_difference >= 0 && temp_coefficient.area_difference != INF);
#endif
		/*........................................................................................................................................................*/

		/*+++++++++++++++++++++++++++         200601 height difference: pla height - minmax height       +++++++++++++++++++++++++++++*/
		const int left_endpoint = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
		const long double height_difference_left = pow(temp_coefficient.apla.b - original_time_series_vector[left_endpoint], 2.0);
		const long double height_difference_right = pow(temp_coefficient.apla.a * (temp_coefficient.rectangle_width - 1) + temp_coefficient.apla.b - original_time_series_vector[temp_coefficient.right_endpoint], 2.0);
		//return temp_coefficient.area_difference = sqrt(height_difference_left + height_difference_right);
		return temp_coefficient.area_difference = get_triangle_area_by_points(temp_coefficient, original_time_series_vector[left_endpoint], original_time_series_vector[temp_coefficient.right_endpoint]);

		//return temp_coefficient.area_difference = fabs(temp_coefficient.max_point.value - temp_coefficient.min_point.value - fabs(temp_coefficient.apla.a * (temp_coefficient.rectangle_width - 1))) * temp_coefficient.rectangle_width;// *height_width_ratio_sereis;
		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	}
	else {
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   When segment length <= 3, No need to split   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		return temp_coefficient.area_difference;
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	}
	/*####################################################################################################################################################################*/
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
}

//201029 13:35 Compute max_deviation from left&right min&max points
//************************************
// Method:get_segment_max_deviation_instead
// Qualifier:  without original time series
// Input: 1 width, 2 right endpoint, 3 a&b, 4 minmax points
// Output:
// date:201029 15:25
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline long double& APLA::get_segment_max_deviation_instead(const T& const left_endpoint_value, const T& const right_endpoint_value, Y& const temp_coefficient) {

	/*........................................................................................*/
#ifdef _DEBUG
	assert(temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF);
	assert_segment_a_b(temp_coefficient);
	assert_segment_minmax(temp_coefficient);
#endif
	/*........................................................................................*/

	const size_t id_segment_left = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;

	long double min_point_difference = temp_coefficient.apla.a * (temp_coefficient.min_point.id - id_segment_left) + temp_coefficient.apla.b - temp_coefficient.min_point.value;
	long double max_point_difference = temp_coefficient.apla.a * (temp_coefficient.max_point.id - id_segment_left) + temp_coefficient.apla.b - temp_coefficient.max_point.value;
	long double left_end_point_difference = temp_coefficient.apla.b - left_endpoint_value;
	long double right_end_point_difference = temp_coefficient.apla.a * (temp_coefficient.rectangle_width - 1) + temp_coefficient.apla.b - right_endpoint_value;

	const long double upper_bound_condition = max(max(fabs(min_point_difference), fabs(max_point_difference)), max(fabs(left_end_point_difference), fabs(right_end_point_difference))) * temp_coefficient.rectangle_width;

	size_t already_know_id = 4;

	if (temp_coefficient.rectangle_width > 3) {

		if (id_segment_left == temp_coefficient.min_point.id) {
			left_end_point_difference = 0;
			//right_end_point_difference = 0;
			already_know_id--;
		}

		if (id_segment_left == temp_coefficient.max_point.id) {
			left_end_point_difference = 0;
			//right_end_point_difference = 0;
			already_know_id--;
		}

		if (temp_coefficient.right_endpoint == temp_coefficient.min_point.id) {
			//left_end_point_difference = 0;
			right_end_point_difference = 0;
			already_know_id--;
		}

		if (temp_coefficient.right_endpoint == temp_coefficient.max_point.id) {
			//left_end_point_difference = 0;
			right_end_point_difference = 0;
			already_know_id--;
		}

		/*............................*/
#ifdef _DEBUG
		assert(already_know_id > 0);
#endif
		/*............................*/

		const long double sum_four_points_difference = min_point_difference + max_point_difference + left_end_point_difference + right_end_point_difference;
		//const long double sum_four_points_difference_pow = min_point_difference_pow + max_point_difference_pow + left_end_point_difference_pow + right_end_point_difference_pow;

		const size_t rest_point_number = temp_coefficient.rectangle_width - already_know_id;

		if (rest_point_number == 0) {
			return temp_coefficient.area_difference = sqrt(pow(min_point_difference, 2) + pow(max_point_difference, 2) + pow(left_end_point_difference, 2) + pow(right_end_point_difference, 2));
		}

		/*...........................*/
#ifdef _DEBUG
		assert(rest_point_number > 0);
#endif
		/*...........................*/

		//const long double rest_difference_pow = pow(sum_four_points_difference / rest_point_number, 2.0);
		//const long double rest_difference_pow_sum = pow(sum_four_points_difference, 2.0) / rest_point_number;
		const long double lower_bound_uncondition = sqrt(pow(min_point_difference, 2) + pow(max_point_difference, 2) + pow(left_end_point_difference, 2) + pow(right_end_point_difference, 2) + pow(sum_four_points_difference, 2.0) / rest_point_number);
		//const long double lower_bound = sqrt(sum_four_points_difference_pow);

		/*......................................................*/
#ifdef _DEBUG
		assert(upper_bound_condition >= lower_bound_uncondition);
#endif
		/*......................................................*/

		return temp_coefficient.area_difference = upper_bound_condition - lower_bound_uncondition;
	}
	else if (temp_coefficient.rectangle_width == 3) {

		return temp_coefficient.area_difference = max(fabs(left_end_point_difference + right_end_point_difference), max(fabs(left_end_point_difference), fabs(right_end_point_difference))) * sqrt(3.0) - sqrt(pow(left_end_point_difference, 2) + pow(left_end_point_difference + right_end_point_difference, 2) + pow(right_end_point_difference, 2));
	}
	else {
		assert(0);
	}
}

//************************************
// Method:get_segment_max_deviation_instead1
// Qualifier:  Compute upper bound from left&right min&max points
// Input: 1 width, 2 right endpoint, 3 a&b, 4 minmax points
// Output:
// date:210112 09:10
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
long double& APLA::get_segment_max_deviation_instead1(const vector<T>& const original_time_series_vector, Y& const temp_coefficient) {
	/*........................................................................................*/
#ifdef _DEBUG
	assert(temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF);
	assert_segment_a_b(temp_coefficient);
	assert_segment_minmax(temp_coefficient);
#endif
	/*........................................................................................*/

	const size_t id_segment_left = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;

	long double min_point_difference = temp_coefficient.apla.a * (temp_coefficient.min_point.id - id_segment_left) + temp_coefficient.apla.b - temp_coefficient.min_point.value;
	long double max_point_difference = temp_coefficient.apla.a * (temp_coefficient.max_point.id - id_segment_left) + temp_coefficient.apla.b - temp_coefficient.max_point.value;
	long double left_end_point_difference = temp_coefficient.apla.b - original_time_series_vector[id_segment_left];
	long double right_end_point_difference = temp_coefficient.apla.a * (temp_coefficient.rectangle_width - 1) + temp_coefficient.apla.b - original_time_series_vector[temp_coefficient.right_endpoint];

	long double lower_bound_uncondition = -INF;
	long double upper_bound_uncondition = -INF;
	const long double upper_bound_condition = max(max(fabs(min_point_difference), fabs(max_point_difference)), max(fabs(left_end_point_difference), fabs(right_end_point_difference))) * temp_coefficient.rectangle_width;
	long double max_difference = max(max(fabs(min_point_difference), fabs(max_point_difference)), max(fabs(left_end_point_difference), fabs(right_end_point_difference)));

	size_t already_know_id = 4;

	if (temp_coefficient.rectangle_width > 3) {

		if (id_segment_left == temp_coefficient.min_point.id) {
			assert(left_end_point_difference == min_point_difference);
			left_end_point_difference = 0;
			//right_end_point_difference = 0;
			already_know_id--;
		}

		if (id_segment_left == temp_coefficient.max_point.id) {
			assert(left_end_point_difference == max_point_difference);
			left_end_point_difference = 0;
			//right_end_point_difference = 0;
			already_know_id--;
		}

		if (temp_coefficient.right_endpoint == temp_coefficient.min_point.id) {
			assert(right_end_point_difference == min_point_difference);
			//left_end_point_difference = 0;
			right_end_point_difference = 0;
			already_know_id--;
		}

		if (temp_coefficient.right_endpoint == temp_coefficient.max_point.id) {
			assert(right_end_point_difference == max_point_difference);
			//left_end_point_difference = 0;
			right_end_point_difference = 0;
			already_know_id--;
		}

		/*............................*/
#ifdef _DEBUG
		assert(already_know_id > 0);
#endif
		/*............................*/

		const long double sum_four_points_difference = min_point_difference + max_point_difference + left_end_point_difference + right_end_point_difference;
		//const long double sum_four_points_difference_pow = min_point_difference_pow + max_point_difference_pow + left_end_point_difference_pow + right_end_point_difference_pow;

		const size_t rest_point_number = temp_coefficient.rectangle_width - already_know_id;

		if (rest_point_number == 0) {
			return temp_coefficient.area_difference = sqrt(pow(min_point_difference, 2) + pow(max_point_difference, 2) + pow(left_end_point_difference, 2) + pow(right_end_point_difference, 2));
		}

		/*...........................*/
#ifdef _DEBUG
		assert(rest_point_number >= 0);
#endif
		/*...........................*/

		//const long double rest_difference_pow = pow(sum_four_points_difference / rest_point_number, 2.0);
		//const long double rest_difference_pow_sum = pow(sum_four_points_difference, 2.0) / rest_point_number;
		lower_bound_uncondition = sqrt(pow(min_point_difference, 2) + pow(max_point_difference, 2) + pow(left_end_point_difference, 2) + pow(right_end_point_difference, 2) + pow(sum_four_points_difference, 2.0) / rest_point_number);
		//const long double lower_bound = sqrt(sum_four_points_difference_pow);
		/*......................................................*/
#ifdef _DEBUG
		assert(upper_bound_condition >= lower_bound_uncondition);
#endif
		/*......................................................*/

		temp_coefficient.area_difference = upper_bound_condition - lower_bound_uncondition;


		upper_bound_uncondition = max_difference * (temp_coefficient.rectangle_width - 1);//max(max_difference, sum_four_points_difference * rest_point_number);

		long double sum_deviation = 0;
		long double max_deviation = -INF;
		long double point_difference = INF;
		long double point_difference_abs = INF;
		long double point_difference_pow = INF;

		long double difference_no_fabs = 0;

		typename GEOMETRY::POINT point_max_deviation;

		for (int i = 0; i < temp_coefficient.rectangle_width; i++) {

			point_difference = temp_coefficient.apla.a * i + temp_coefficient.apla.b - original_time_series_vector[temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1 + i];
			cout << temp_coefficient.apla.a * i + temp_coefficient.apla.b << " , " << original_time_series_vector[temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1 + i] << endl;

			difference_no_fabs += point_difference;
			point_difference_pow = pow(point_difference, 2.0);
			point_difference_abs = fabs(point_difference);
			sum_deviation += point_difference_pow;
			//max_deviation = max(max_deviation, point_difference_abs);
			if (max_deviation < point_difference_abs) {
				point_max_deviation.value = max_deviation = point_difference_abs;
				point_max_deviation.id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1 + i;
			}

		}
		cout << endl;
		assert(fabs(difference_no_fabs) < 0.00000001);
		sum_deviation = sqrt(sum_deviation);

		assert(max_deviation <= upper_bound_uncondition);

	}
	else if (temp_coefficient.rectangle_width == 3) {

		temp_coefficient.area_difference = max(fabs(left_end_point_difference + right_end_point_difference), max(fabs(left_end_point_difference), fabs(right_end_point_difference))) * sqrt(3.0) - sqrt(pow(left_end_point_difference, 2) + pow(left_end_point_difference + right_end_point_difference, 2) + pow(right_end_point_difference, 2));
	}
	else {
		assert(0);
	}

	return temp_coefficient.area_difference;
}

//************************************
// Method:SplitSegmentByRealPLAArea
// Qualifier: Split, find which point should be splited and split them
// Input: Long segment sum_value, a&b, min&max point, width , right endpoint
// Output: Sub segment sum_value, a&b, min&max point, width , right endpoint , *right_subsegment != nullptr
// date:190722
// author:
//************************************
TEMPLATE
void APLA::SplitSegmentByRealPLAArea(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector, const int& const split_number) { //190722 find which point should be splited in one segment
	//assert(area_vector.size);
#ifdef _DEBUG
	assert(split_number > 0);
#endif

	set<pair<double, int>> area_difference_id_set;
	priority_queue<int> decrease_id_queue;
	double area_difference = 0;
	int segment_id = 0;
	/*====================================Get Area difference===============================================================================*/
	for (auto&& au : area_vector) {
#ifdef _DEBUG
		assert(au.right_subsegment != nullptr && au.apla.a != INF && au.apla.b != INF && au.right_endpoint != INF && au.rectangle_width != INF && au.sum_value != INF && au.max_point.value != INF && au.min_point.value != INF && au.max_point.id != INF && au.min_point.id != INF);
#endif

		/*===============Min&Max Point================*/
		getSegmentMinMaxPoint(original_time_series, au);
		/*............................................*/
		if (au.deviation_point.value != -1) {
			/*================PLA Area=====================*/
			auto pla_rectangle_height = fabs(au.apla.a * (au.rectangle_width - 1));
			au.rectangle_area = pla_rectangle_height * au.rectangle_width;
			//au.rectangle_density = 1.0 / pla_rectangle_height;
			/*...............................................*/

			/*=======Min&Max width area & MinMax dist area======*/
			au.minmax_width_area = (au.max_point.value - au.min_point.value) * au.rectangle_width;
			au.minmax_distance_area = (au.max_point.value - au.min_point.value) * fabs(au.max_point.id - au.min_point.id);
#ifdef _DEBUG
			assert(au.rectangle_width >= fabs(au.max_point.id - au.min_point.id));//n is even
			assert(au.minmax_width_area >= 0 && au.minmax_distance_area >= 0);//n is even
#endif
			/*.................................................*/

			/*=======Compute Area difference==============*/
			if (au.rectangle_area <= au.minmax_distance_area && au.minmax_distance_area <= au.minmax_width_area) {
				area_difference = au.minmax_width_area - au.rectangle_area;
			}
			else if (au.minmax_distance_area <= au.rectangle_area && au.rectangle_area <= au.minmax_width_area) {
				area_difference = au.minmax_width_area - au.minmax_distance_area;
			}
			else if (au.minmax_distance_area <= au.minmax_width_area && au.minmax_width_area <= au.rectangle_area) {
				area_difference = au.rectangle_area - au.minmax_distance_area;
			}
			else {
				assert(0);
			}

			area_difference = fabs(au.minmax_width_area - au.rectangle_area); // au.rectangle_width;
#ifdef _DEBUG
			assert(area_difference >= 0);
#endif
			/*..............................................*/
			area_difference_id_set.emplace(make_pair(area_difference, segment_id));
		}

		segment_id++;
	}
#ifdef _DEBUG
	assert(area_difference_id_set.size() > split_number);
#endif
	/*......................................................................................*/
	/*=============================Sort ID of Max Area difference=======================*/
	//cout << "++++++++++++++++++++++++++Area difference+++++++++++++++++++++++++++++++++++++++" << endl;
	int set_emplace_count = 0;
	for (auto au = area_difference_id_set.rbegin(); set_emplace_count < split_number; au++) {
		//for (auto au = area_difference_id_set.rbegin(); au != area_difference_id_set.rend(); au++) {
			//cout << au->first << " "<< au->second << endl;
		decrease_id_queue.emplace(au->second);
		set_emplace_count++;
	}
	/*..................................................................................*/
	/*=============================Sort ID of Max Area difference=======================*/
	while (!decrease_id_queue.empty()) {
		//cout << decrease_id_queue.top() << " ";
		segment_id = decrease_id_queue.top();
		if (area_vector[segment_id].rectangle_width > 3) {
			AREA_COEFFICIENT left_segment;
			left_segment.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, area_vector[segment_id]);
			//sub_segment.right_endpoint=findSegmentMiddleID(area_vector[segment_id]);
#ifdef _DEBUG
			assert(left_segment.right_endpoint > 0 && left_segment.right_endpoint < area_vector[segment_id].right_endpoint);
#endif
			if (left_segment.right_endpoint != INF) {
				left_segment.right_subsegment = new AREA_COEFFICIENT;

				if (segment_id < area_vector.size() - 1)
					area_vector[segment_id + 1].already_compute = false;
				area_vector[segment_id].already_compute = false;
				left_segment.already_compute = false;

				left_segment.rectangle_width = area_vector[segment_id].rectangle_width;
				area_vector[segment_id].rectangle_width = area_vector[segment_id].right_endpoint - left_segment.right_endpoint;
				left_segment.rectangle_width -= area_vector[segment_id].rectangle_width;
#ifdef _DEBUG
				assert(left_segment.rectangle_width > 1 && area_vector[segment_id].rectangle_width > 1 && left_segment.right_endpoint < area_vector[segment_id].right_endpoint);
				if (segment_id > 0)
					assert(left_segment.rectangle_width + area_vector[segment_id].rectangle_width == area_vector[segment_id].right_endpoint - area_vector[segment_id - 1].right_endpoint);
#endif
				area_vector.insert(area_vector.begin() + segment_id, left_segment);

				/*=================get sum value, a & b slope intercept================*/
				getAAndBByPLA(original_time_series, area_vector[segment_id]);//get a&b slope intercept
				getAAndBByPLA(original_time_series, area_vector[segment_id + 1]);//get a&b slope intercept
				/*.......................................................................*/
				/*======================get Min&Max point================================*/
				getSegmentMinMaxPoint(original_time_series, area_vector[segment_id]);
				getSegmentMinMaxPoint(original_time_series, area_vector[segment_id + 1]);
				/*.......................................................................*/
#ifdef _DEBUG
				if (segment_id > 0)
					assert(area_vector[segment_id].rectangle_width == area_vector[segment_id].right_endpoint - area_vector[segment_id - 1].right_endpoint);
				assert(area_vector[segment_id + 1].rectangle_width == area_vector[segment_id + 1].right_endpoint - area_vector[segment_id].right_endpoint);
				assert(area_vector[segment_id].rectangle_width != INF && area_vector[segment_id + 1].rectangle_width != INF && area_vector[segment_id].right_endpoint != INF && area_vector[segment_id + 1].right_endpoint != INF && area_vector[segment_id].apla.a != INF && area_vector[segment_id + 1].apla.a != INF && area_vector[segment_id].min_point.id != INF && area_vector[segment_id + 1].max_point.id != INF && area_vector[segment_id].min_point.value != INF && area_vector[segment_id + 1].max_point.value != INF);
#endif
			}
		}
		decrease_id_queue.pop();
	}
	//cout << endl;
	/*..................................................................................*/
	/*............................................................................................................................................*/
	area_difference_id_set.clear();
#if _DEBUG
	for (auto&& au : area_vector) {
		assert(au.sum_value != INF);
	}
#endif
}

//************************************
// Method:SplitSegmentByRealPLAArea
// Qualifier: Split, find which point should be splited and split them
// Input: Long segment sum_value, a&b, min&max point, width , right endpoint
// Output: Sub segment sum_value, a&b, min&max point, width , right endpoint , *right_subsegment != nullptr
// date:190722
// author:
//************************************
TEMPLATE
void APLA::SplitSegmentByRealPLAArea(DataType*& const original_time_series, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list, const int& const split_number) {
#ifdef _DEBUG
	assert(split_number > 0);
#endif

	set<pair<double, int>> area_difference_id_set;
	priority_queue<int> decrease_id_queue;
	double area_difference = 0;
	int segment_id = 0;
	/*====================================Get Area difference===============================================================================*/
	for (segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
#ifdef _DEBUG
		assert(doubly_linked_list[segment_id].right_subsegment != nullptr && doubly_linked_list[segment_id].apla.a != INF && doubly_linked_list[segment_id].apla.b != INF && doubly_linked_list[segment_id].right_endpoint != INF && doubly_linked_list[segment_id].rectangle_width != INF && doubly_linked_list[segment_id].sum_value != INF && doubly_linked_list[segment_id].max_point.value != INF && doubly_linked_list[segment_id].min_point.value != INF && doubly_linked_list[segment_id].max_point.id != INF && doubly_linked_list[segment_id].min_point.id != INF);
#endif

		/*===============Min&Max Point================????????????????????????????*/
		getSegmentMinMaxPoint(original_time_series, doubly_linked_list[segment_id]);
		/*............................................*/
		if (doubly_linked_list[segment_id].deviation_point.value != -1) {
			/*================PLA Area=====================*/
			auto pla_rectangle_height = fabs(doubly_linked_list[segment_id].apla.a * (doubly_linked_list[segment_id].rectangle_width - 1));
			doubly_linked_list[segment_id].rectangle_area = pla_rectangle_height * doubly_linked_list[segment_id].rectangle_width;
			//doubly_linked_list[segment_id].rectangle_density = 1.0 / pla_rectangle_height;
			/*...............................................*/

			/*=======Min&Max width area & MinMax dist area======*/
			doubly_linked_list[segment_id].minmax_width_area = (doubly_linked_list[segment_id].max_point.value - doubly_linked_list[segment_id].min_point.value) * doubly_linked_list[segment_id].rectangle_width;
			doubly_linked_list[segment_id].minmax_distance_area = (doubly_linked_list[segment_id].max_point.value - doubly_linked_list[segment_id].min_point.value) * fabs(doubly_linked_list[segment_id].max_point.id - doubly_linked_list[segment_id].min_point.id);
#ifdef _DEBUG
			assert(doubly_linked_list[segment_id].rectangle_width >= fabs(doubly_linked_list[segment_id].max_point.id - doubly_linked_list[segment_id].min_point.id));//n is even
			assert(doubly_linked_list[segment_id].minmax_width_area >= 0 && doubly_linked_list[segment_id].minmax_distance_area >= 0);//n is even
#endif
			/*.................................................*/

			/*=======Compute Area difference==============*/
			if (doubly_linked_list[segment_id].rectangle_area <= doubly_linked_list[segment_id].minmax_distance_area && doubly_linked_list[segment_id].minmax_distance_area <= doubly_linked_list[segment_id].minmax_width_area) {
				area_difference = doubly_linked_list[segment_id].minmax_width_area - doubly_linked_list[segment_id].rectangle_area;
			}
			else if (doubly_linked_list[segment_id].minmax_distance_area <= doubly_linked_list[segment_id].rectangle_area && doubly_linked_list[segment_id].rectangle_area <= doubly_linked_list[segment_id].minmax_width_area) {
				area_difference = doubly_linked_list[segment_id].minmax_width_area - doubly_linked_list[segment_id].minmax_distance_area;
			}
			else if (doubly_linked_list[segment_id].minmax_distance_area <= doubly_linked_list[segment_id].minmax_width_area && doubly_linked_list[segment_id].minmax_width_area <= doubly_linked_list[segment_id].rectangle_area) {
				area_difference = doubly_linked_list[segment_id].rectangle_area - doubly_linked_list[segment_id].minmax_distance_area;
			}
			else {
				assert(0);
			}

			area_difference = fabs(doubly_linked_list[segment_id].minmax_width_area - doubly_linked_list[segment_id].rectangle_area); // doubly_linked_list[segment_id].rectangle_width;
#ifdef _DEBUG
			assert(area_difference >= 0);
#endif
			/*..............................................*/
			area_difference_id_set.emplace(make_pair(area_difference, segment_id));
		}
	}
#ifdef _DEBUG
	assert(area_difference_id_set.size() > split_number);
#endif
	/*......................................................................................*/

	/*=============================Sort ID of Max Area difference=======================*/
	//cout << "++++++++++++++++++++++++++Area difference+++++++++++++++++++++++++++++++++++++++" << endl;
	int set_emplace_count = 0;
	for (auto au = area_difference_id_set.rbegin(); set_emplace_count < split_number; au++) {
		//for (auto au = area_difference_id_set.rbegin(); au != area_difference_id_set.rend(); au++) {
			//cout << au->first << " "<< au->second << endl;
		decrease_id_queue.emplace(au->second);
		set_emplace_count++;
	}
	/*..................................................................................*/

	/*=============================Sort ID of Max Area difference=======================*/
	while (!decrease_id_queue.empty()) {
		//cout << decrease_id_queue.top() << " ";
		segment_id = decrease_id_queue.top();
		if (doubly_linked_list[segment_id].rectangle_width > 3) {
			AREA_COEFFICIENT left_segment;
			left_segment.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, doubly_linked_list[segment_id]);
			//sub_segment.right_endpoint=findSegmentMiddleID(area_vector[segment_id]);
#ifdef _DEBUG
			assert(left_segment.right_endpoint > 0 && left_segment.right_endpoint < doubly_linked_list[segment_id].right_endpoint);
#endif
			if (left_segment.right_endpoint != INF) {
				left_segment.right_subsegment = new AREA_COEFFICIENT;

				if (segment_id < doubly_linked_list.size() - 1)
					doubly_linked_list[segment_id + 1].already_compute = false;
				doubly_linked_list[segment_id].already_compute = false;
				left_segment.already_compute = false;

				left_segment.rectangle_width = doubly_linked_list[segment_id].rectangle_width;
				doubly_linked_list[segment_id].rectangle_width = doubly_linked_list[segment_id].right_endpoint - left_segment.right_endpoint;
				left_segment.rectangle_width -= doubly_linked_list[segment_id].rectangle_width;
#ifdef _DEBUG
				assert(left_segment.rectangle_width > 1 && doubly_linked_list[segment_id].rectangle_width > 1 && left_segment.right_endpoint < doubly_linked_list[segment_id].right_endpoint);
				if (segment_id > 0)
					assert(left_segment.rectangle_width + doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint);
#endif
				doubly_linked_list.add(segment_id, left_segment);

				/*=================get sum value, a & b slope intercept================*/
				getAAndBByPLA(original_time_series, doubly_linked_list[segment_id]);//get a&b slope intercept
				getAAndBByPLA(original_time_series, doubly_linked_list[segment_id + 1]);//get a&b slope intercept
				/*.......................................................................*/
				/*======================get Min&Max point================================*/
				getSegmentMinMaxPoint(original_time_series, doubly_linked_list[segment_id]);
				getSegmentMinMaxPoint(original_time_series, doubly_linked_list[segment_id + 1]);
				/*.......................................................................*/
#ifdef _DEBUG
				if (segment_id > 0)
					assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint);
				assert(doubly_linked_list[segment_id + 1].rectangle_width == doubly_linked_list[segment_id + 1].right_endpoint - doubly_linked_list[segment_id].right_endpoint);
				assert(doubly_linked_list[segment_id].rectangle_width != INF && doubly_linked_list[segment_id + 1].rectangle_width != INF && doubly_linked_list[segment_id].right_endpoint != INF && doubly_linked_list[segment_id + 1].right_endpoint != INF && doubly_linked_list[segment_id].apla.a != INF && doubly_linked_list[segment_id + 1].apla.a != INF && doubly_linked_list[segment_id].min_point.id != INF && doubly_linked_list[segment_id + 1].max_point.id != INF && doubly_linked_list[segment_id].min_point.value != INF && doubly_linked_list[segment_id + 1].max_point.value != INF);
#endif
			}
		}
		decrease_id_queue.pop();
	}
	//cout << endl;
	/*..................................................................................*/
	/*............................................................................................................................................*/
	area_difference_id_set.clear();
#if _DEBUG
	for (segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		assert(doubly_linked_list[segment_id].sum_value != INF);
	}
#endif
}

//190930
//************************************
// Method:splitSegmentBySplitedPoint
// Qualifier: Split long segment into 2 short segments by splited point.
// Input: Long segment right endpoint, width,
// Output: sub left segment right endpoint & width, sub right segment right endpoint & width.
// date:191006
// author:
//************************************
TEMPLATE
void APLA::splitSegmentBySplitedPoint(DataType*& const original_time_series, AREA_COEFFICIENT& const sub_left_segment, AREA_COEFFICIENT& const long_segment) {
	assert(0);
#ifdef _DEBUG
	assert(sub_left_segment.rectangle_width == INF && sub_left_segment.right_endpoint == INF && long_segment.rectangle_width > 3 && long_segment.rectangle_width != INF && long_segment.right_endpoint > 0 && long_segment.right_endpoint != INF);
#endif
	sub_left_segment.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, long_segment);
#ifdef _DEBUG
	assert(long_segment.right_endpoint > 0 && long_segment.right_endpoint - sub_left_segment.right_endpoint > 1);
#endif
	if (sub_left_segment.right_endpoint != INF) {
		//rest_segment_size--;
		sub_left_segment.rectangle_width = long_segment.rectangle_width;
		long_segment.rectangle_width = long_segment.right_endpoint - sub_left_segment.right_endpoint;
		sub_left_segment.rectangle_width -= long_segment.rectangle_width;
#ifdef _DEBUG
		assert(sub_left_segment.rectangle_width > 1 && long_segment.rectangle_width > 1 && sub_left_segment.right_endpoint < long_segment.right_endpoint);
#endif
	}
	else {
		assert(0);
		sub_left_segment.rectangle_width = INF;
	}
#ifdef _DEBUG
	assert(sub_left_segment.rectangle_width > 1 && long_segment.rectangle_width > 1 && sub_left_segment.right_endpoint < long_segment.right_endpoint);
#endif
}

//191006
//200212 Add template. Use pointer to instead vector for time series
//************************************
// Method:splitSegmentBySplitedPoint
// Qualifier: Split long segment into 2 short segments by splited point.
// Input: Long segment right endpoint, width,
// Output: sub left segment right endpoint & width, sub right segment right endpoint & width.
// date:200212
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
void APLA::splitSegmentBySplitedPoint(const vector<T>& const original_time_series_vector, Y& const sub_left_segment, Y& const long_segment) {
	assert(0);
#ifdef _DEBUG
	assert(input_argument.option_split_method != int(INF) && sub_left_segment.rectangle_width == INF && sub_left_segment.right_endpoint == INF && long_segment.rectangle_width > 3 && long_segment.rectangle_width != INF && long_segment.right_endpoint > 0 && long_segment.right_endpoint != INF);
#endif
	//sub_left_segment.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series_vector, long_segment);
	//200214 replace with fast find split point function
	//sub_left_segment.right_endpoint = find_split_point_by_min_density_fast(original_time_series_vector, long_segment);
	//200225 replace min densituy methd to gourp methods
	input_argument.option_split_method = 0;
	sub_left_segment.right_endpoint = group_find_split_point_methods(original_time_series_vector, long_segment, input_argument.option_split_method);
#ifdef _DEBUG
	assert(long_segment.right_endpoint > 0 && long_segment.right_endpoint - sub_left_segment.right_endpoint > 1);
#endif
	if (sub_left_segment.right_endpoint != INF) {
		//rest_segment_size--;
		sub_left_segment.rectangle_width = long_segment.rectangle_width;
		long_segment.rectangle_width = long_segment.right_endpoint - sub_left_segment.right_endpoint;
		sub_left_segment.rectangle_width -= long_segment.rectangle_width;
#ifdef _DEBUG
		assert(sub_left_segment.rectangle_width > 1 && long_segment.rectangle_width > 1 && sub_left_segment.right_endpoint < long_segment.right_endpoint);
		//assert_segment_a_b(long_segment);
#endif
	}
	else {
		assert(0);
		sub_left_segment.rectangle_width = INF;
	}
#ifdef _DEBUG
	assert(sub_left_segment.rectangle_width > 1 && long_segment.rectangle_width > 1 && sub_left_segment.right_endpoint < long_segment.right_endpoint);
#endif
}

//200226 Add template. Use pointer to instead vector for time series
//************************************
// Method:splitSegmentBySplitedPoint
// Qualifier: Split long segment into 2 short segments by splited point.
// Input: Long segment right endpoint, width,
// Output: sub left segment right endpoint & width, sub right segment right endpoint & width.
// date:200212
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
void APLA::splitSegmentBySplitedPoint(const vector<T>& const original_time_series_vector, const int& const option_split_method, Y& const sub_left_segment, Y& const long_segment) {
	assert(0);
#ifdef _DEBUG
	assert(sub_left_segment.rectangle_width == INF && sub_left_segment.right_endpoint == INF && long_segment.rectangle_width > 3 && long_segment.rectangle_width != INF && long_segment.right_endpoint > 0 && long_segment.right_endpoint != INF);
#endif
	//sub_left_segment.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series_vector, long_segment);
	//200214 replace with fast find split point function
	//sub_left_segment.right_endpoint = find_split_point_by_min_density_fast(original_time_series_vector, long_segment);
	//200225 replace min densituy methd to gourp methods
	sub_left_segment.right_endpoint = group_find_split_point_methods(original_time_series_vector, long_segment, input_argument.option_split_method, output_argument);
#ifdef _DEBUG
	assert(long_segment.right_endpoint > 0 && long_segment.right_endpoint - sub_left_segment.right_endpoint > 1);
#endif
	if (sub_left_segment.right_endpoint != INF) {
		//rest_segment_size--;
		sub_left_segment.rectangle_width = long_segment.rectangle_width;
		long_segment.rectangle_width = long_segment.right_endpoint - sub_left_segment.right_endpoint;
		sub_left_segment.rectangle_width -= long_segment.rectangle_width;
#ifdef _DEBUG
		assert(sub_left_segment.rectangle_width > 1 && long_segment.rectangle_width > 1 && sub_left_segment.right_endpoint < long_segment.right_endpoint);
		//assert_segment_a_b(long_segment);
#endif
	}
	else {
		assert(0);
		sub_left_segment.rectangle_width = INF;
	}
#ifdef _DEBUG
	assert(sub_left_segment.rectangle_width > 1 && long_segment.rectangle_width > 1 && sub_left_segment.right_endpoint < long_segment.right_endpoint);
#endif
}

//200226 Add template. Use pointer to instead vector for time series
//************************************
// Method:splitSegmentBySplitedPoint
// Qualifier: Split long segment into 2 short segments by splited point.
// Input: Long segment right endpoint, width,
// Output: 1 MinMax point of sub left&right segment. sub left&right segments, long segment a&b, right endpoint, width and long segment density.
// date:200212
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
void APLA::splitSegmentBySplitedPoint(const vector<T>& const original_time_series_vector, const int& const option_split_method, Y& const sub_left_segment, Y& const long_segment, U& const output_argument) {
	/*..............................................................................................................................................*/
#ifdef _DEBUG
	assert(option_split_method != int(INF) && sub_left_segment.rectangle_width == INF && sub_left_segment.right_endpoint == INF && long_segment.rectangle_width > 3 && long_segment.rectangle_width != INF && long_segment.right_endpoint > 0 && long_segment.right_endpoint != INF);
#endif
	/*..............................................................................................................................................*/

	//sub_left_segment.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series_vector, long_segment);
	//200214 replace with fast find split point function
	//sub_left_segment.right_endpoint = find_split_point_by_min_density_fast(original_time_series_vector, long_segment);
	//200225 replace min densituy methd to gourp methods

	/*&&&&&&&&&&&&&&&&&&&&               200306 Split Coefficient            &&&&&&&&&&&&&&&&&&&&&&&&&&*/
	long_segment.right_subsegment = new Y;
	*long_segment.right_subsegment = long_segment;
	//Y long_segment_original = long_segment;
	//Y sub_left_segment_test;
	//Y sub_right_segment_test;
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*&&&&&&&&&&&&&&&&&&&&          Find split point of long segment          &&&&&&&&&&&&&&&&&&&&&&&&&&*/
	sub_left_segment.right_endpoint = group_find_split_point_methods(original_time_series_vector, option_split_method, sub_left_segment, long_segment, *long_segment.right_subsegment, output_argument);
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*............................................................................................................................................*/
#ifdef _DEBUG
	assert(long_segment.right_endpoint > 0 && long_segment.right_endpoint - sub_left_segment.right_endpoint > 1);//&& sub_left_segment.rectangle_width + long_segment.rectangle_width == long_segment.right_subsegment->rectangle_width);
#endif
	/*............................................................................................................................................*/

	/*&&&&&&&&&&&   IF not min density split mthod. Need to get sub left & right segment: right endpoint and rectangle width  &&&&&&&&&&&&&&*/
	// min density split method already compute sub left & right segments coefficietns
	// ++ other split methods only get sub left & right, long segment: right endpoint, width.
	// ++ min density split method also get sub left & right segments, long segment a&b, long segment density.
	/*################### 210203    Other Split method.   Width & Minmax point: get sub left & right segment   #######################################*/
//	if (sub_left_segment.right_endpoint != INF && option_split_method > 0) {// other split methods
//		//rest_segment_size--;
//
//		/*!!!!!!!!!       Update segment width: sub left & right segment      !!!!!!!!!!!!!!!!!!!!!!!*/
//		sub_left_segment.rectangle_width = long_segment.right_subsegment->rectangle_width;
//		long_segment.rectangle_width = long_segment.right_endpoint - sub_left_segment.right_endpoint;
//		sub_left_segment.rectangle_width -= long_segment.rectangle_width;
//		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
//
//		/*!!!!!!!!!!!     Update segment a&b, minmax point: sub left & right segment   !!!!!!!!!!!!!*/
//		get_ab_minmax_segment(original_time_series_vector, sub_left_segment);
//		get_ab_minmax_segment(original_time_series_vector, long_segment);
//		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
//
//		/*!!!!!!!!!!    Update segment, minmax point: sub left & right segment    !!!!!!!!!!!!!!!!!!*/
//		//getSegmentMinMaxPoint(original_time_series_vector, sub_left_segment);
//		//getSegmentMinMaxPoint(original_time_series_vector, long_segment);
//		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
//
//		/*............................................................................................................................................*/
//#ifdef _DEBUG
//		assert(sub_left_segment.rectangle_width > 1 && long_segment.rectangle_width > 1 && sub_left_segment.right_endpoint < long_segment.right_endpoint);
//		//assert_segment_a_b(long_segment);
//#endif
//		/*............................................................................................................................................*/
//
//	}
//	/*#########################################################################################################################*/
//	else if (sub_left_segment.right_endpoint == INF && option_split_method > 0) {
//		assert(0);
//		//sub_left_segment.rectangle_width = INF;
//	}
//	/*###    Split Option == 0. subleft segment new pointer. minmax point: sub left&right, long segment  ###########################*/
//	else if (option_split_method == 0) {
//		/*!!!!!!!!!!!!      get min&max of sub left and right segment        !!!!!!!!!!!!!!!!!!!!!!!*/
//		getSubMinMaxPoint(original_time_series_vector, sub_left_segment, long_segment, *long_segment.right_subsegment);
//		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
//	}
	/*##############################################################################################################################*/

	/*!!!!!!!!!!!!     new pointer: sub left segment        !!!!!!!!!!!!!!!!!!!!!!!*/
	sub_left_segment.right_subsegment = new Y;
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*..........................................................................................................................................................................*/
#ifdef _DEBUG
	/*##############################           Assert width & right endpoint of one segment        ##################################*/
	assert(sub_left_segment.rectangle_width + long_segment.rectangle_width == long_segment.right_subsegment->rectangle_width && sub_left_segment.rectangle_width > 1 && long_segment.rectangle_width > 1 && sub_left_segment.right_endpoint < long_segment.right_endpoint);
	assert(long_segment.right_subsegment->right_endpoint == long_segment.right_endpoint && sub_left_segment.rectangle_width + long_segment.rectangle_width == long_segment.right_subsegment->rectangle_width);
	/*##############################################################################################################################*/
	/*##################################           Assert a&b min&max of one segment        ########################################*/
	assert_segment_a_b_minmax(original_time_series_vector, sub_left_segment);
	assert_segment_a_b_minmax(original_time_series_vector, long_segment);
	/*##############################################################################################################################*/
	/*###############      If is min density split mthod: get sub left & right segment & long segment: right endpoint and rectangle width     ###############*/
	if (option_split_method == 0) {
		assert_segment_a_b_minmax(original_time_series_vector, *long_segment.right_subsegment);
		//assert(long_segment.right_subsegment->segment_density != INF);
	}
	else {
		assert(long_segment.right_subsegment->segment_density == INF && sub_left_segment.right_subsegment->segment_density == INF);
	}
	/*######################################################################################################################################################*/
#endif
	/*...................................................................................................................................................................*/
}

//200821 find if multimap has key
//************************************
// Method:binarySearchIdEquality
// Qualifier: find which point should be splited in one segment
// date:190709
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
bool APLA::find_if_in_multimap(const T& const key, const multimap<U, Y, std::greater<U>>& const multi_map) {
	const auto test_key = multi_map.find(key);
	if (test_key == multi_map.end()) {
		std::cout << "Not found\n";
		assert(0);
		return false;
	}
	return true;
}

//************************************
// Method:find_key_in_map
// Qualifier: if key in map
// Input: map, key
// Output: key in map
// date:201223
// author:
//************************************
TEMPLATE
template<typename T, typename T1, typename Y>
inline bool APLA::find_key_in_map(const multimap<Y, DoublyListNode<T>&, std::greater<Y>>& const sorted_multimap, const T1& const key) {
	auto find_node = sorted_multimap.find(key);
	if (find_node == sorted_multimap.end()) {
		//std::cout << "Not found\n";
		//assert(0);
		return false;
	}
	return true;
}

//************************************
// Method:find_endpoint_key_in_map
// Qualifier: if key, right endpoint in map
// Input: map, key, right endpoint
// Output: right endpoint, key in map
// date:201228
// author:
//************************************
TEMPLATE
template<typename T, typename T1, typename Y, typename U>
bool APLA::find_endpoint_key_in_map(const multimap<Y, DoublyListNode<T>&, std::greater<Y>>& const sorted_multimap, const U& const unique_right_endpoint, const T1& const key) {
	auto node_equal_range = sorted_multimap.equal_range(key);//get pairs with same key value.

	for (auto equal_node = node_equal_range.first; equal_node != node_equal_range.second; ++equal_node) {// use right endpoint as the unique key to get the unique segment
		if (equal_node->second._value.right_endpoint == unique_right_endpoint) return true;
	}

	return false;
}

//190930
//************************************
// Method:eraseMapByKey
// Qualifier: Split long segment into 2 short segments.
// Input: Long segment sum_value, a&b, min&max point, width , right endpoint
// Output: Sub segment sum_value, a&b, min&max point, width , right endpoint , *right_subsegment != nullptr
// date:190830
// author:
//************************************
TEMPLATE
template<typename T, typename T1, typename Y, typename U>
void APLA::eraseMapByKey(multimap<Y, DoublyListNode<T>&, std::greater<Y>>& const sorted_multimap, const U& const unique_right_endpoint, const T1& const key) {

	/*....................................................................*/
#ifdef _DEBUG
	//assert_split_map_area_difference(sorted_multimap);
	assert(!sorted_multimap.empty());
	auto find_node = sorted_multimap.find(key);
	if (find_node == sorted_multimap.end()) {
		std::cout << "Not found\n";
		assert(0);
	}
#endif
	/*....................................................................*/

	if (sorted_multimap.count(key) < 2) {
		sorted_multimap.erase(key);
	}
	else {
		auto node_equal_range = sorted_multimap.equal_range(key);
		for (auto equal_node = node_equal_range.first; equal_node != node_equal_range.second; ++equal_node) {
			if (equal_node->second._value.right_endpoint == unique_right_endpoint) {
				sorted_multimap.erase(equal_node);
				break;
			}
		}
	}
	/*....................................................................*/
#ifdef _DEBUG
	//assert_split_map_area_difference(sorted_multimap);
#endif
	/*....................................................................*/
}

//************************************
// Method:updateMapByKey
// Qualifier: update the merged segment by key value, key value can get range, then use right endpoint to get unique segment
// Input: 1 multi MAP, 2 segment right endpoint, 3 multiple key, 4 new value to update 
// Output: updated MAP
// date:190830
// author:
//************************************
TEMPLATE
template<typename T, typename T1, typename T2, typename Y, typename U>
void APLA::updateMapByKey(multimap<Y, DoublyListNode<T>&, std::greater<Y>>& const sorted_multimap, const U& const unique_right_endpoint, const T1& const key, const T2& const new_value) {
	/*....................................................................................*/
#ifdef _DEBUG
	//assert_split_map_area_difference(sorted_multimap);
	assert(!sorted_multimap.empty());
	auto find_node = sorted_multimap.find(key);
	if (find_node == sorted_multimap.end()) {
		std::cout << "Not found\n";
		assert(0);
	}
#endif
	/*....................................................................................*/

	if (sorted_multimap.count(key) < 2) {//==1
		auto node_handler = sorted_multimap.extract(key);
		node_handler.key() = new_value;
		sorted_multimap.insert(std::move(node_handler));
	}
	else {
		auto node_equal_range = sorted_multimap.equal_range(key);//get pairs with same key value.
		for (auto equal_node = node_equal_range.first; equal_node != node_equal_range.second; ++equal_node) {// use right endpoint as the unique key to get the unique segment
			if (equal_node->second._value.right_endpoint == unique_right_endpoint) {
				auto node_handler = sorted_multimap.extract(equal_node);
				node_handler.key() = new_value;
				sorted_multimap.insert(std::move(node_handler));
				return;
			}
		}
		assert(0);//has key, but not match segment right endpoint
	}

	/*..............................................................................................................................*/
#ifdef _DEBUG
	//assert_split_map_area_difference(sorted_multimap);
#endif
	/*..............................................................................................................................*/
}

//190830
//************************************
// Method:SplitSegmentByRealPLAArea
// Qualifier: Split long segment into 2 short segments.
// Input: Long segment sum_value, a&b, min&max point, width , right endpoint
// Output: Sub segment sum_value, a&b, min&max point, width , right endpoint , *right_subsegment != nullptr
// date:190830
// author:
//************************************
TEMPLATE
void APLA::splitSegmentBySlope(DataType*& const original_time_series, multimap<double, DoublyListNode<AREA_COEFFICIENT>&, std::greater<double>>& const merge_segment_density_map, multimap<double, DoublyListNode<AREA_COEFFICIENT>&, std::greater<double>>& const split_area_difference_map, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list) {
	assert(0);
#ifdef _DEBUG
	assert(!merge_segment_density_map.empty());
	//evaluate right point, min&max point, width. a&b, sum value
	//assertLinkedListAndSubLinkedList(doubly_linked_list);
#endif

	auto& const splited_node = split_area_difference_map.begin()->second;
	auto& const splited_node_segment = splited_node._value;
	const double origianl_splited_area_difference = splited_node_segment.area_difference;
	DoublyListNode<AREA_COEFFICIENT>* newElement = new DoublyListNode<AREA_COEFFICIENT>;
	AREA_COEFFICIENT& const left_segment = newElement->_value;

#ifdef _DEBUG
	assert(origianl_splited_area_difference > 0 && splited_node_segment.right_subsegment != nullptr && splited_node_segment.apla.a != INF && splited_node_segment.apla.b != INF && splited_node_segment.right_endpoint != INF && splited_node_segment.rectangle_width != INF && splited_node_segment.sum_value != INF);
	assert(splited_node_segment.min_point.value <= splited_node_segment.max_point.value);
	if (splited_node_segment.min_point.value == splited_node_segment.max_point.value) {
		assert(splited_node_segment.min_point.id < splited_node_segment.max_point.id);
	}
	//cout << "Split Area difference:" << endl;
	for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
		//cout << doubly_linked_list[segment_id].right_endpoint << "," << doubly_linked_list[segment_id].rectangle_width << "; ";
		//cout << doubly_linked_list[segment_id].area_difference << " ";
		assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint && doubly_linked_list[segment_id].area_difference != INF);
		assert(doubly_linked_list[segment_id].right_subsegment->rectangle_width == doubly_linked_list[segment_id].rectangle_width + doubly_linked_list[segment_id - 1].rectangle_width && doubly_linked_list[segment_id].right_subsegment->area_difference != INF);
		assert(doubly_linked_list[segment_id].min_point.value <= doubly_linked_list[segment_id].max_point.value);
	}
	//cout << endl;
#endif
	/*---------------------------------------------      Find splited new segemnt right_id      ------------------------------------------*/
	left_segment.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series, splited_node_segment);
	//200225 Instead binary split id method
	//left_segment.right_endpoint = APLA::find_split_point_by_min_density_fast(temp_original_time_series_vector, splited_node_segment);
	//200225 Instead fast split id. option is 0 is min density method, 1 is binary method, 2 is itersectio npoint method, 3  midlew method 4 besti id method
	//left_segment.right_endpoint = group_find_split_point_methods(original_time_series_vector, temp_coefficient, input_argument.option_split_method);

	/*----------------------------200105 Find split method Improvement--------------------------------------------*/
#ifdef _DEBUG
	int time_series_length = doubly_linked_list.back().right_endpoint + 1;
	vector<DataType> temp_original_time_series_vector(original_time_series, original_time_series + time_series_length);
	assert(temp_original_time_series_vector.size() == time_series_length);
	//int best_split_id = APLA::findSplitSegmentBaseline(temp_original_time_series_vector, splited_node_segment, 0);
	//left_segment.right_endpoint = APLA::find_split_point_by_min_density_fast(temp_original_time_series_vector, splited_node_segment);
	//left_segment.right_endpoint = best_split_id;
	temp_original_time_series_vector.clear();
	temp_original_time_series_vector.shrink_to_fit();
#endif
	/*----------------------------------------------------------------------------------------------------------*/


	////sub_segment.right_endpoint=findSegmentMiddleID(area_vector[segment_id]);
	/*-----------------------------------------------------------------------------------------------------------------------------------*/
	if (left_segment.right_endpoint != INF) {
#ifdef _DEBUG
		assert(left_segment.right_endpoint > 0 && left_segment.right_endpoint < splited_node_segment.right_endpoint);
#endif
		bool is_head_node = false;
		if (splited_node_segment.right_endpoint + 1 == splited_node_segment.rectangle_width)
			is_head_node = true;

		/*----------------------------  Merged segment Density, MAP ID    ----------------------*/
		AREA_COEFFICIENT original_splited_segment = splited_node_segment;

		const auto original_splited_density = splited_node_segment.right_subsegment->segment_density;
		double right_splited_density = -1;
		if (splited_node._next)
			right_splited_density = splited_node._next->_value.right_subsegment->segment_density;
		/*......................................................................................*/
		left_segment.right_subsegment = new AREA_COEFFICIENT;
		/*-------------------------------     new segment width    ------------------------------------------------------------------------------------------------------*/
		left_segment.rectangle_width = splited_node_segment.rectangle_width;
		splited_node_segment.rectangle_width = splited_node_segment.right_endpoint - left_segment.right_endpoint;
		left_segment.rectangle_width -= splited_node_segment.rectangle_width;

#ifdef _DEBUG
		assert(left_segment.rectangle_width > 1 && splited_node_segment.rectangle_width > 1 && left_segment.right_endpoint < splited_node_segment.right_endpoint);
		if (splited_node._prev)
			assert(left_segment.rectangle_width + splited_node_segment.rectangle_width == splited_node_segment.right_endpoint - splited_node._prev->_value.right_endpoint);
#endif
		/*......................................................................................................................................................................................*/

		/*=====================     get sum value, a & b slope intercept    ==================================================*/
		// Input: 1 Original time series : long segment a & b, sum, width, right endpoint; 2 left(right) sub segment : a & b, sum, width, right endopint;
		// Output: right(left) sub segment: 1 a&b, 2 sum, 3 min&max point
		getSubAAndBByPLA(original_time_series, left_segment, splited_node_segment, original_splited_segment);
		/*====================================================================================================================*/
		/*------------------------         get Min&Max point     ------------------------------*/
		////** Input: 1 width, 2 right endpoint
		////** Output: min max point
		//getSegmentMinMaxPoint(original_time_series, left_segment);
		//getSegmentMinMaxPoint(original_time_series, splited_node_segment);
		/*......................................................................................*/

		/*========================================    Insert Node(copy) in LinkedList   ======================================*/
		doubly_linked_list.insertNodeBeforeNode(*newElement, splited_node);
		/*====================================================================================================================*/

		/*=========================================           get Area Difference & Emplace Split MAP        ====================================================*/
		/*--------------------------Split MAP: insert left sub segment---------------*/
		if (getAreaDifference(original_time_series, left_segment) > 0) {
			//if (getAreaDifference(left_segment) > 0) {
			split_area_difference_map.emplace(left_segment.area_difference, *splited_node._prev);
		}
		/*---------------------------------------------------------------------------*/
#ifdef _DEBUG
		assert(left_segment.area_difference == splited_node._prev->_value.area_difference && left_segment.area_difference != INF);
		auto test_max_area_difference = split_area_difference_map.find(origianl_splited_area_difference);
		if (test_max_area_difference == split_area_difference_map.end()) {
			std::cout << "Not found\n";
			assert(0);
		}
#endif
		/*----------------------------------Split MAP: change splited segment key in map--------------------------*/
		if (getAreaDifference(original_time_series, splited_node_segment) > 0) {
			//if (getAreaDifference(splited_node_segment) > 0) {
			updateMapByKey(split_area_difference_map, splited_node_segment.right_endpoint, origianl_splited_area_difference, splited_node_segment.area_difference);
		}
		else {
			//split_area_difference_map.erase(origianl_splited_area_difference);
			eraseMapByKey(split_area_difference_map, splited_node_segment.right_endpoint, origianl_splited_area_difference);
		}
		/*-----------------------------------------------------------------------------------------------------------*/
		/*=======================================================================================================================================================*/

		/*==================================================    Update max density MAP      ========================================================================*/
#ifdef _DEBUG
		if (!is_head_node) {
			auto max_difference_segment = merge_segment_density_map.find(original_splited_density);
			if (max_difference_segment == merge_segment_density_map.end()) {
				std::cout << "Not found\n";
				assert(0);
			}
		}
		if (splited_node._next) {
			auto right_max_difference_segment = merge_segment_density_map.find(right_splited_density);
			if (right_max_difference_segment == merge_segment_density_map.end()) {
				std::cout << "Right Not found\n";
				assert(0);
			}
		}
#endif
		if (!is_head_node) {//middle node
			/*-------------------------------          Insert left segment           ---------------------------------*/
			merge_segment_density_map.emplace(getMergedSubSegmentInformation(original_time_series, *splited_node._prev), *splited_node._prev);//200109 For area difference
			//merge_segment_density_map.emplace(getMergedSubSegmentInformation(*splited_node._prev), *splited_node._prev);
			/*........................................................................................................*/
			/*-------------------------------   Change max difference segment density in map    ----------------------*/
			updateMapByKey(merge_segment_density_map, splited_node_segment.right_endpoint, original_splited_density, getMergedSubSegmentInformation(original_time_series, splited_node));//200109 For area difference
			//updateMapByKey(merge_segment_density_map, splited_node_segment.right_endpoint, original_splited_density, getMergedSubSegmentInformation(splited_node));
			/*.......................................................................................................*/
			/*.......................................................................................................*/
		}
		else {//head node
			/*------------------------------------    Insert Max area difference -------------------------------------*/
			merge_segment_density_map.emplace(getMergedSubSegmentInformation(original_time_series, splited_node), splited_node);//200109 for area difference
			//merge_segment_density_map.emplace(getMergedSubSegmentInformation(splited_node), splited_node);
			/*........................................................................................................*/
		}

		/*----------------------------------------    Update right segment in map    ---------------------------------*/
		if (splited_node._next) {
			updateMapByKey(merge_segment_density_map, splited_node._next->_value.right_endpoint, right_splited_density, getMergedSubSegmentInformation(original_time_series, *splited_node._next));//200109 For area difference
			//updateMapByKey(merge_segment_density_map, splited_node._next->_value.right_endpoint, right_splited_density, getMergedSubSegmentInformation(*splited_node._next));
		}
		/*...........................................................................................................*/

		/*=====================================================================================================================================================*/

#ifdef _DEBUG
		for_each_n(split_area_difference_map.begin(), split_area_difference_map.size(), [](auto&& au) {assert(au.first != INF); });
		for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
			assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint && doubly_linked_list[segment_id].area_difference != INF);
			assert(doubly_linked_list[segment_id].right_subsegment->rectangle_width == doubly_linked_list[segment_id].rectangle_width + doubly_linked_list[segment_id - 1].rectangle_width && doubly_linked_list[segment_id].right_subsegment->area_difference != INF);
		}
#endif
	}

#ifdef _DEBUG
	assert(!merge_segment_density_map.empty());
	//evaluate right point, min&max point, width. a&b, sum value
	//assertLinkedListAndSubLinkedList(doubly_linked_list);
#endif
}

//200212 change original time series from pointer to vector. Add templatea
//************************************
// Method:splitSegmentBySlope
// Qualifier: Split long segment into 2 short segments.
// Input: Long segment sum_value, a&b, min&max point, width , right endpoint
// Output: Sub segment sum_value, a&b, min&max point, width , right endpoint , *right_subsegment != nullptr
// Notice: 200213 Remove min max POInt and FUnction
// date:200213
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
void APLA::splitSegmentBySlope(const vector<T>& const original_time_series_vector, multimap<double, DoublyListNode<Y>&, std::greater<double>>& const merge_segment_density_map, multimap<double, DoublyListNode<Y>&, std::greater<double>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list) {
	assert(0);
#ifdef _DEBUG
	assert(!merge_segment_density_map.empty());
	//evaluate right point, min&max point, width. a&b, sum value
	assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif

	auto& const splited_node = split_area_difference_map.begin()->second;
	auto& const splited_node_segment = splited_node._value;
	const double origianl_splited_area_difference = splited_node_segment.area_difference;
	DoublyListNode<Y>* newElement = new DoublyListNode<Y>;
	Y& const left_segment = newElement->_value;

#ifdef _DEBUG
	assert(origianl_splited_area_difference > 0 && splited_node_segment.right_subsegment != nullptr && splited_node_segment.apla.a != INF && splited_node_segment.apla.b != INF && splited_node_segment.right_endpoint != INF && splited_node_segment.rectangle_width != INF && splited_node_segment.sum_value != INF);

	//cout << "Split Area difference:" << endl;
	for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
		//cout << doubly_linked_list[segment_id].right_endpoint << "," << doubly_linked_list[segment_id].rectangle_width << "; ";
		//cout << doubly_linked_list[segment_id].area_difference << " ";
		assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint && doubly_linked_list[segment_id].area_difference != INF);
		assert(doubly_linked_list[segment_id].right_subsegment->rectangle_width == doubly_linked_list[segment_id].rectangle_width + doubly_linked_list[segment_id - 1].rectangle_width && doubly_linked_list[segment_id].right_subsegment->area_difference != INF);
	}
	//cout << endl;
#endif
	/*---------------------------------------------      Find splited new segemnt right_id      ------------------------------------------*/
	//left_segment.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series_vector, splited_node_segment);
	//200214 Replace with fast find split point
	//left_segment.right_endpoint =  APLA::find_split_point_by_min_density_fast(original_time_series_vector, splited_node_segment);
	//200225 Instead fast split id. option is 0 is min density method, 1 is binary method, 2 is itersectio npoint method, 3  midlew method 4 besti id method
	input_argument.option_split_method = 0;
	left_segment.right_endpoint = group_find_split_point_methods(original_time_series_vector, splited_node_segment, input_argument.option_split_method);
	/*--------------------------200105 Find split method Improvement--------------------------------------------*/
#ifdef _DEBUG
	int time_series_length = doubly_linked_list.back().right_endpoint + 1;
	//int best_split_id = APLA::findSplitSegmentBaseline(temp_original_time_series_vector, splited_node_segment, 0);
	//left_segment.right_endpoint = APLA::find_split_point_by_min_density_fast(temp_original_time_series_vector, splited_node_segment);
	//left_segment.right_endpoint = best_split_id;
#endif
	/*----------------------------------------------------------------------------------------------------------*/
	////sub_segment.right_endpoint=findSegmentMiddleID(area_vector[segment_id]);
	/*-----------------------------------------------------------------------------------------------------------------------------------*/
	// Has split point, begin to split segment
	if (left_segment.right_endpoint != INF) {
#ifdef _DEBUG
		assert(left_segment.right_endpoint > 0 && left_segment.right_endpoint < splited_node_segment.right_endpoint);
#endif
		bool is_head_node = false;
		if (splited_node_segment.right_endpoint + 1 == splited_node_segment.rectangle_width)
			is_head_node = true;

		/*----------------------------  Merged segment Density, MAP ID    ----------------------*/
		Y original_splited_segment = splited_node_segment;

		const auto original_splited_density = splited_node_segment.right_subsegment->segment_density;
		double right_splited_density = -1;
		if (splited_node._next)
			right_splited_density = splited_node._next->_value.right_subsegment->segment_density;
		/*......................................................................................*/
		left_segment.right_subsegment = new Y;
		/*-------------------------------     new segment width    ------------------------------------------------------------------------------------------------------*/
		left_segment.rectangle_width = splited_node_segment.rectangle_width;
		splited_node_segment.rectangle_width = splited_node_segment.right_endpoint - left_segment.right_endpoint;
		left_segment.rectangle_width -= splited_node_segment.rectangle_width;

#ifdef _DEBUG
		assert(left_segment.rectangle_width > 1 && splited_node_segment.rectangle_width > 1 && left_segment.right_endpoint < splited_node_segment.right_endpoint);
		if (splited_node._prev)
			assert(left_segment.rectangle_width + splited_node_segment.rectangle_width == splited_node_segment.right_endpoint - splited_node._prev->_value.right_endpoint);
#endif
		/*......................................................................................................................................................................................*/

		/*=====================  get Min Max Point in each segment.   get sum value, a & b slope intercept    ==================================================*/
#ifdef _DEBUG
		//assert(left_segment.apla.a != INF && left_segment.apla.b != INF && splited_node_segment.apla.a != INF && splited_node_segment.apla.b != INF && original_splited_segment.apla.a != INF && original_splited_segment.apla.b != INF);
		assert(left_segment.right_endpoint != INF && splited_node_segment.right_endpoint != INF && original_splited_segment.right_endpoint != INF && original_splited_segment.rectangle_width != INF);
#endif
		// Input: 1 Original time series : long segment a & b, sum, width, right endpoint; 2 left(right) sub segment : a & b, sum, width, right endopint;
		// Output: right(left) sub segment: 1 a&b, 2 sum, 3 min&max point
		getSubAAndBByPLA(original_time_series_vector, left_segment, splited_node_segment, original_splited_segment);

		//200212 get min&max point of left&right segment by long segment, speed up
		//200314 minmax point
		//getSubMinMaxPoint(original_time_series_vector, left_segment, splited_node_segment, original_splited_segment);
		/*=======================================================================================================================================================*/
		/*------------------------         get Min&Max point     ------------------------------*/
		////** Input: 1 width, 2 right endpoint
		////** Output: min max point
		//getSegmentMinMaxPoint(original_time_series, left_segment);
		//getSegmentMinMaxPoint(original_time_series, splited_node_segment);
		/*......................................................................................*/

		/*========================================    Insert Node(copy) in LinkedList   ======================================*/
		doubly_linked_list.insertNodeBeforeNode(*newElement, splited_node);
		/*====================================================================================================================*/

		/*=========================================           get Area Difference & Emplace Split MAP        ====================================================*/
		/*--------------------------Split MAP: insert left sub segment---------------*/
		if (getAreaDifference(original_time_series_vector, left_segment) > 0) {
			//if (getAreaDifference(left_segment) > 0) {
			split_area_difference_map.emplace(left_segment.area_difference, *splited_node._prev);
		}
		/*---------------------------------------------------------------------------*/
#ifdef _DEBUG
		assert(left_segment.area_difference == splited_node._prev->_value.area_difference && left_segment.area_difference != INF);
		auto test_max_area_difference = split_area_difference_map.find(origianl_splited_area_difference);
		if (test_max_area_difference == split_area_difference_map.end()) {
			std::cout << "Not found\n";
			assert(0);
		}
#endif
		/*------------------------Split MAP: change splited segment key in map---------*/
		if (getAreaDifference(original_time_series_vector, splited_node_segment) > 0) {
			//if (getAreaDifference(splited_node_segment) > 0) {
			updateMapByKey(split_area_difference_map, splited_node_segment.right_endpoint, origianl_splited_area_difference, splited_node_segment.area_difference);
		}
		else {
			//split_area_difference_map.erase(origianl_splited_area_difference);
			eraseMapByKey(split_area_difference_map, splited_node_segment.right_endpoint, origianl_splited_area_difference);
		}
		/*-----------------------------------------------------------------------------*/
		/*=======================================================================================================================================================*/

		/*==================================================    Update max density MAP      ========================================================================*/
#ifdef _DEBUG
		if (!is_head_node) {
			auto max_difference_segment = merge_segment_density_map.find(original_splited_density);
			if (max_difference_segment == merge_segment_density_map.end()) {
				std::cout << "Not found\n";
				assert(0);
			}
		}
		if (splited_node._next) {
			auto right_max_difference_segment = merge_segment_density_map.find(right_splited_density);
			if (right_max_difference_segment == merge_segment_density_map.end()) {
				std::cout << "Right Not found\n";
				assert(0);
			}
		}
#endif
		if (!is_head_node) {//middle node
			/*-------------------------------          Insert left segment           ---------------------------------*/
			merge_segment_density_map.emplace(getMergedSubSegmentInformation(original_time_series_vector, *splited_node._prev), *splited_node._prev);//200109 For area difference
			//merge_segment_density_map.emplace(getMergedSubSegmentInformation(*splited_node._prev), *splited_node._prev);
			/*........................................................................................................*/
			/*-------------------------------   Change max difference segment density in map    ----------------------*/
			updateMapByKey(merge_segment_density_map, splited_node_segment.right_endpoint, original_splited_density, getMergedSubSegmentInformation(original_time_series_vector, splited_node));//200109 For area difference
			//updateMapByKey(merge_segment_density_map, splited_node_segment.right_endpoint, original_splited_density, getMergedSubSegmentInformation(splited_node));
			/*.......................................................................................................*/
			/*.......................................................................................................*/
		}
		else {//head node
			/*------------------------------------    Insert Max area difference -------------------------------------*/
			merge_segment_density_map.emplace(getMergedSubSegmentInformation(original_time_series_vector, splited_node), splited_node);//200109 for area difference
			//merge_segment_density_map.emplace(getMergedSubSegmentInformation(splited_node), splited_node);
			/*........................................................................................................*/
		}

		/*----------------------------------------    Update right segment in map    ---------------------------------*/
		if (splited_node._next) {
			updateMapByKey(merge_segment_density_map, splited_node._next->_value.right_endpoint, right_splited_density, getMergedSubSegmentInformation(original_time_series_vector, *splited_node._next));//200109 For area difference
			//updateMapByKey(merge_segment_density_map, splited_node._next->_value.right_endpoint, right_splited_density, getMergedSubSegmentInformation(*splited_node._next));
		}
		/*...........................................................................................................*/

		/*=====================================================================================================================================================*/

#ifdef _DEBUG
		for_each_n(split_area_difference_map.begin(), split_area_difference_map.size(), [](auto&& au) {assert(au.first != INF); });
		for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
			assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint && doubly_linked_list[segment_id].area_difference != INF);
			assert(doubly_linked_list[segment_id].right_subsegment->rectangle_width == doubly_linked_list[segment_id].rectangle_width + doubly_linked_list[segment_id - 1].rectangle_width && doubly_linked_list[segment_id].right_subsegment->area_difference != INF);
		}
#endif
	}

	/*....................................................................*/
#ifdef _DEBUG
	assert(!merge_segment_density_map.empty());
	//evaluate right point, min&max point, width. a&b, sum value
	assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
	/*....................................................................*/

}

//200226 Add split method option.  change original time series from pointer to vector. Add templatea
//************************************
// Method:splitSegmentBySlope
// Qualifier: Split long segment into 2 short segments.
// Input: Long segment sum_value, a&b, min&max point, width , right endpoint
// Output: Sub segment sum_value, a&b, min&max point, width , right endpoint , *right_subsegment != nullptr
// Notice: 200213 Remove min max POInt and FUnction
// date:200226
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U, typename T1>
void APLA::splitSegmentBySlope(const vector<T>& const original_time_series_vector, const int& const split_method_option, multimap<T1, DoublyListNode<Y>&, std::greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, std::greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U& const output_argument) {

	/*..................................................................................................*/
#ifdef _DEBUG
	assert(split_method_option != int(INF) && split_method_option >= 0);
	//evaluate right point, min&max point, width. a&b, sum value
	assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
	assert_bound(original_time_series_vector, doubly_linked_list);
#endif
	/*..................................................................................................*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!             Whether MAP Empty      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	// If MAP is empty, no need to split
	if (split_area_difference_map.empty()) {
		return;
	}
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*========================================   Long segment  ========================================*/
	auto& const splited_node = split_area_difference_map.begin()->second;
	auto& const splited_node_segment = splited_node._value;

	//evaluate_segment_upper_lower_bound(input_argument, original_time_series_vector, splited_node_segment);

	/*-------------------------------Key of MAP--------------------------------------------*/
	// original long segment area difference
	const double origianl_splited_area_difference = splited_node_segment.area_difference;
	// original long segment and previous segment triangle density.
	const auto original_splited_density = splited_node_segment.right_subsegment->segment_density;
	/*-------------------------------------------------------------------------------------*/

	// original long segment
	//Y original_splited_segment = splited_node_segment;
	/*==================================================================================================*/

	/*************************   sub left segment   **************************/
	//sub left segemnt
	DoublyListNode<Y>* node_left_new = new DoublyListNode<Y>;
	Y& const left_segment = node_left_new->_value;
	left_segment.area_difference = 0;
	/*************************************************************************/

	/************************       If the splited segment is head segment      **************************/
	bool is_head_node = false;
	if (splited_node_segment.right_endpoint + 1 == splited_node_segment.rectangle_width)
		is_head_node = true;
	/*****************************************************************************************************/

	/*...................................................................................................*/
#ifdef _DEBUG
	Y original_splited_segment_test = splited_node_segment;
	assert_two_segments_a_b(splited_node_segment, get_ab_segment(original_time_series_vector, original_splited_segment_test));
	assert(origianl_splited_area_difference > 0 && origianl_splited_area_difference != INF && splited_node_segment.right_subsegment != nullptr);
	assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
	/*...................................................................................................*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&      Find splited new segemnt right_id      &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	//left_segment.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series_vector, splited_node_segment);
	//200214 Replace with fast find split point
	//left_segment.right_endpoint =  APLA::find_split_point_by_min_density_fast(original_time_series_vector, splited_node_segment);
	//200225 Instead fast split id. option is 0 is min density method, 1 is binary method, 2 is itersectio npoint method, 3  midlew method 4 besti id method
	//left_segment.right_endpoint = group_find_split_point_methods(original_time_series_vector, splited_node_segment, split_method_option, output_argument);
	*splited_node_segment.right_subsegment = splited_node_segment;
	left_segment.right_endpoint = group_find_split_point_methods(original_time_series_vector, split_method_option, left_segment, splited_node_segment, *splited_node_segment.right_subsegment, output_argument);
	////sub_segment.right_endpoint=findSegmentMiddleID(area_vector[segment_id]);
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   Has Spilt Point   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// Has split point, begin to split segment
	if (left_segment.right_endpoint != INF) {
		left_segment.right_subsegment = new Y;

		/*........................................................................................*/
#ifdef _DEBUG
		assert(left_segment.right_endpoint > 0 && left_segment.right_endpoint < splited_node_segment.right_endpoint);
#endif
		/*........................................................................................*/

		/*##########################################      Key of density MAP: Right long semgent      ################################*/
		long double right_splited_density = -1;

		if (splited_node._next) {//not tail node
			right_splited_density = splited_node._next->_value.right_subsegment->segment_density;
		}
		/*############################################################################################################################*/

		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&          get sub left & right segment right endpoint, rectangle width, a&b       &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

		/*#####################         Not min density split method, other split methods, needs to compute a&b, only know spit id          #################################################*/
		if (left_segment.apla.a == INF) {

			/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!              new sub left segment, sub right segment width        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
			if (splited_node_segment.right_subsegment->rectangle_width > 4) {
				left_segment.rectangle_width = splited_node_segment.rectangle_width;
				splited_node_segment.rectangle_width = splited_node_segment.right_endpoint - left_segment.right_endpoint;
				left_segment.rectangle_width -= splited_node_segment.rectangle_width;
			}

			/*................................................................................................................................*/
#ifdef _DEBUG
			assert(split_method_option > 0 && left_segment.rectangle_width > 1 && splited_node_segment.rectangle_width > 1 && left_segment.right_endpoint < splited_node_segment.right_endpoint);
			if (splited_node._prev)
				assert(left_segment.rectangle_width + splited_node_segment.rectangle_width == splited_node_segment.right_endpoint - splited_node._prev->_value.right_endpoint);
#endif
			/*................................................................................................................................*/

			/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

			/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!          compute a & b, min&max point, scan segment                 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

			/*................................................................................................................................*/
#ifdef _DEBUG
			//assert(left_segment.apla.a != INF && left_segment.apla.b != INF && splited_node_segment.apla.a != INF && splited_node_segment.apla.b != INF && *splited_node_segment.right_subsegment.apla.a != INF && *splited_node_segment.right_subsegment.apla.b != INF);
			assert(left_segment.right_endpoint != INF && splited_node_segment.right_endpoint != INF && splited_node_segment.right_subsegment->right_endpoint != INF && splited_node_segment.right_subsegment->rectangle_width != INF);
#endif
			/*................................................................................................................................*/

			/*+++++++++++++++++++++++++++++++          compute sub a&b left, right        +++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			// Input: 1 Original time series : long segment a & b, sum, width, right endpoint; 2 left(right) sub segment : a & b, sum, width, right endopint;
			// Output: right(left) sub segment: 1 a&b, 2 sum, 3 min&max point
			getSubAAndBByPLA(original_time_series_vector, left_segment, splited_node_segment, *splited_node_segment.right_subsegment);
			/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			/*+++++++++++++++++++++++++++++++ 210203 compute minmax width left, right      ++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			//200212 get min&max point of left&right segment by long segment, speed up
			//200314 minmax point
			//getSubMinMaxPoint(original_time_series_vector, left_segment, splited_node_segment, *splited_node_segment.right_subsegment);
			/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

			/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		}
		/*################################################################################################################################################################*/

		/*.............................................................................................................................................*/
#ifdef _DEBUG
		else {// evaluate already get sub a&b and density by min density split method
			Y test_sub_segment_left = left_segment;
			Y test_sub_segment_right = splited_node_segment;
			Y test_temp_coefficient = *splited_node_segment.right_subsegment;

			assert_two_segments_a_b(get_ab_segment(original_time_series_vector, test_sub_segment_left), left_segment);
			assert_two_segments_a_b(get_ab_segment(original_time_series_vector, test_sub_segment_right), splited_node_segment);
			assert_two_segments_a_b(get_ab_segment(original_time_series_vector, test_temp_coefficient), *splited_node_segment.right_subsegment);

			test_temp_coefficient = *splited_node_segment.right_subsegment;
			const auto test_density = getLineSegmentTriangleAreaDensity(left_segment, splited_node_segment, test_temp_coefficient);
			if (splited_node_segment.right_subsegment->segment_density != INF)
				assert(fabs(test_density - splited_node_segment.right_subsegment->segment_density) <= MIN_D);
		}
#endif
		/*.............................................................................................................................................*/

		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

		/*------------------------     210203    get Min&Max point     ------------------------------*/
		////** Input: 1 width, 2 right endpoint
		////** Output: min max point
		/*getSegmentMinMaxPoint(original_time_series_vector, left_segment);
		getSegmentMinMaxPoint(original_time_series_vector, splited_node_segment);*/
		/*-------------------------------------------------------------------------------------*/

		/*...........................................................................*/
#ifdef _DEBUG
		assert(left_segment.rectangle_width + splited_node_segment.rectangle_width == splited_node_segment.right_subsegment->rectangle_width);
#endif
		/*...........................................................................*/

		/*======================================== Linked list: Insert sub left segment   ======================================*/
		doubly_linked_list.insertNodeBeforeNode(*node_left_new, splited_node);
		/*======================================================================================================================*/

		/*====================================================    Update Split MAP: get Area Difference & Emplace Split =================================================================*/

		/*--------------------------Split MAP: Insertion left segment----------------*/
		//getAreaDifference(original_time_series_vector, left_segment) 210203
		if (left_segment.area_difference > 0 && left_segment.rectangle_width > 3) {
			//if (getAreaDifference(left_segment) > 0) {
			split_area_difference_map.emplace(left_segment.area_difference, *splited_node._prev);
		}
		/*---------------------------------------------------------------------------*/

		/*...........................................................................*/
#ifdef _DEBUG
		assert(left_segment.area_difference == splited_node._prev->_value.area_difference && left_segment.area_difference != INF);
		find_if_in_multimap(origianl_splited_area_difference, split_area_difference_map);
#endif
		/*...........................................................................*/

		/*------------------------Split MAP: Update current segment------------------*/
		//getAreaDifference(original_time_series_vector, splited_node_segment) > 0 210203
		if (splited_node_segment.area_difference > 0 && splited_node_segment.rectangle_width > 3) {
			//if (getAreaDifference(splited_node_segment) > 0) {
			updateMapByKey(split_area_difference_map, splited_node_segment.right_endpoint, origianl_splited_area_difference, splited_node_segment.area_difference);
		}
		else {
			//split_area_difference_map.erase(origianl_splited_area_difference);
			eraseMapByKey(split_area_difference_map, splited_node_segment.right_endpoint, origianl_splited_area_difference);
		}
		/*-----------------------------------------------------------------------------*/
		/*============================================================================================================================================================================*/


		/*==================================================================   Merge MAP : left, current and right segment     ======================================================*/

		/*..........................................................................................................................*/
#ifdef _DEBUG
		if (!is_head_node) { find_if_in_multimap(original_splited_density, merge_segment_density_map); }
		if (splited_node._next) { find_if_in_multimap(right_splited_density, merge_segment_density_map); }
#endif
		/*..........................................................................................................................*/

		if (split_method_option > 0) getMergedSubSegmentInformation(original_time_series_vector, splited_node, output_argument);

		if (!is_head_node) {//middle node
			/*---------------------  Density MAP Insertion: the density between left segment and left's previous segment   -----------------------*/
			merge_segment_density_map.emplace(getMergedSubSegmentInformation(original_time_series_vector, *splited_node._prev, output_argument), *splited_node._prev);//200109 For area difference
			//merge_segment_density_map.emplace(getMergedSubSegmentInformation(*splited_node._prev), *splited_node._prev);
			/*------------------------------------------------------------------------------------------------------------------------------------*/
			/*---------------------  Density MAP Update:     the density between current segment and left segment---------------------------------*/
			updateMapByKey(merge_segment_density_map, splited_node_segment.right_endpoint, original_splited_density, splited_node_segment.right_subsegment->segment_density);//200109 For area difference
			//updateMapByKey(merge_segment_density_map, splited_node_segment.right_endpoint, original_splited_density, getMergedSubSegmentInformation(splited_node));
			/*------------------------------------------------------------------------------------------------------------------------------------*/
		}
		else {//head node
			/*---------------------  Density MAP Update:     the density between current segment and left segment---------------------------------*/
			merge_segment_density_map.emplace(splited_node_segment.right_subsegment->segment_density, splited_node);//200109 for area difference
			//merge_segment_density_map.emplace(getMergedSubSegmentInformation(splited_node), splited_node);
			/*------------------------------------------------------------------------------------------------------------------------------------*/
		}
		/*---------------------  Density MAP Update:     the density between right segment and current segment   -----------------------------*/
		if (splited_node._next) {
			updateMapByKey(merge_segment_density_map, splited_node._next->_value.right_endpoint, right_splited_density, getMergedSubSegmentInformation(original_time_series_vector, *splited_node._next, output_argument));//200109 For area difference
			//updateMapByKey(merge_segment_density_map, splited_node._next->_value.right_endpoint, right_splited_density, getMergedSubSegmentInformation(*splited_node._next));
		}
		/*------------------------------------------------------------------------------------------------------------------------------------*/
	/*==============================================================================================================================================================================*/

		/*..........................................................................................................................*/
#ifdef _DEBUG
		for_each_n(split_area_difference_map.begin(), split_area_difference_map.size(), [](auto&& au) {assert(au.first != INF); });
		assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
		/*..........................................................................................................................*/

	}
	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	/*..........................................................................................................................*/
#ifdef _DEBUG
	assert_bound(original_time_series_vector, doubly_linked_list);
	assert(!merge_segment_density_map.empty());
	//evaluate right point, min&max point, width. a&b, sum value
	assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
	assert_merge_map_triangle_density(merge_segment_density_map);
#endif
	/*..........................................................................................................................*/
}

//************************************
// Method:split_burst_segment
// Qualifier: Split long segment into 2 short segments. For burst time series that need to split segment
// Input: Long segment sum_value, a&b, min&max point, width , right endpoint
// Output: Sub segment sum_value, a&b, min&max point, width , right endpoint , *right_subsegment != nullptr
// date:191124
// author:
//************************************
TEMPLATE
template<typename T>
void APLA::split_burst_segment(DataType*& const original_time_series, const int& const  point_dimension, DoublyLinkedList<T>& const doubly_linked_list) {

	int segment_id = 0;
	while (doubly_linked_list.size() < point_dimension) {

		if (segment_id == doubly_linked_list.size()) segment_id = 0;

		if (doubly_linked_list[segment_id].rectangle_width > 3) {
			auto& const splited_node = doubly_linked_list.getNode(segment_id);
			auto& const splited_node_segment = splited_node._value;
			DoublyListNode<AREA_COEFFICIENT>* newElement = new DoublyListNode<AREA_COEFFICIENT>;
			AREA_COEFFICIENT& const left_segment = newElement->_value;
#ifdef _DEBUG
			assert(splited_node_segment.sum_value != INF && splited_node_segment.min_point.value == splited_node_segment.max_point.value);
#endif
			/*---------------------------------right end point------------------------*/
			left_segment.right_endpoint = left_segment.max_point.id = findSegmentMiddleID(splited_node_segment);
			/*------------------------------------------------------------------------*/
			/*-----------------------------------width--------------------------------*/
			left_segment.rectangle_width = splited_node_segment.rectangle_width;
			splited_node_segment.rectangle_width = splited_node_segment.right_endpoint - left_segment.right_endpoint;
			left_segment.rectangle_width -= splited_node_segment.rectangle_width;
			/*------------------------------------------------------------------------*/
			/*------------------------------a&b / min max point-----------------------*/
			left_segment.apla.a = 0;
			left_segment.apla.b = left_segment.min_point.value = left_segment.max_point.value = original_time_series[int(left_segment.right_endpoint)];
			left_segment.min_point.id = left_segment.right_endpoint - left_segment.rectangle_width + 1;

			splited_node_segment.min_point.id = left_segment.right_endpoint + 1;
			splited_node_segment.max_point.id = splited_node_segment.right_endpoint;
			/*------------------------------------------------------------------------*/
#ifdef _DEBUG
			assert(float(left_segment.apla.b) == float(splited_node_segment.apla.b) && splited_node_segment.min_point.value == splited_node_segment.max_point.value && splited_node_segment.max_point.value == left_segment.max_point.value);
#endif

			/*-----------------------------sum value ----------------------------------*/
			left_segment.sum_value = left_segment.rectangle_width * left_segment.apla.b;
			splited_node_segment.sum_value - left_segment.sum_value;
			/*-------------------------------------------------------------------------*/

			/*========================================    Insert Node(copy) in LinkedList   ======================================*/
			doubly_linked_list.insertNodeBeforeNode(*newElement, splited_node);
			segment_id++;
			/*====================================================================================================================*/
		}
		segment_id++;
	}
#ifdef _DEBUG
	assert(doubly_linked_list.size() == point_dimension);
	APLA::assertLinkedList(doubly_linked_list);
#endif
}

//191124 for burst time series that need to split segment
	//200212 change original time series from pointer to vector. Add template
//************************************
// Method:split_burst_segment
// Qualifier: Split long segment into 2 short segments. For burst time series that need to split segment. Has case a == 0, a > 0, a < 0.
// Input: Long segment sum_value, a&b, min&max point, width , right endpoint
// Output: Sub segment sum_value, a&b, min&max point, width , right endpoint , *right_subsegment != nullptr
// date:200914
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
void APLA::split_burst_segment(const vector<T>& const original_time_series_vector, const int& const  point_dimension, DoublyLinkedList<Y>& const doubly_linked_list) {
	
#ifdef _DEBUG
	assert_endpoint_a_b(original_time_series_vector, doubly_linked_list);
	APLA::assertLinkedList(doubly_linked_list);
#endif
	
	int segment_id = 0;

	while (doubly_linked_list.size() < point_dimension) {

		if (segment_id == doubly_linked_list.size()) segment_id = 0;

		if (doubly_linked_list[segment_id].rectangle_width > 3) {
			auto& const splited_node = doubly_linked_list.getNode(segment_id);
			auto& const splited_node_segment = splited_node._value;
			DoublyListNode<Y>* newElement = new DoublyListNode<Y>;
			Y& const left_segment = newElement->_value;

			/*....................................*/
			left_segment.area_difference = left_segment.bound.upper_bound_diff = left_segment.bound.upper_bound_area = 0;
			/*....................................*/

			/*............................................................................................................................*/
#ifdef _DEBUG
			//200314 minmax point
			//assert(splited_node_segment.sum_value != INF && splited_node_segment.min_point.value == splited_node_segment.max_point.value);
#endif
			/*............................................................................................................................*/

			/*---------------------------------right end point------------------------*/
			left_segment.right_endpoint = findSegmentMiddleID(splited_node_segment);
			//200314 minmax point
			//left_segment.right_endpoint = left_segment.max_point.id = findSegmentMiddleID(splited_node_segment);
			/*------------------------------------------------------------------------*/

			/*-----------------------------------width--------------------------------*/
			left_segment.rectangle_width = splited_node_segment.rectangle_width;
			splited_node_segment.rectangle_width = splited_node_segment.right_endpoint - left_segment.right_endpoint;
			left_segment.rectangle_width -= splited_node_segment.rectangle_width;
			/*------------------------------------------------------------------------*/

			/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^       a&b / min max point     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
			/*-------------------------------            a&b                 ----------------------------*/
			left_segment.apla.a = splited_node_segment.apla.a;
			/*-------------------------------------------------------------------------------------------*/
			//200314 minmax point
			/*------------------------------   210203    min&max point b            ----------------------------*/
			if (left_segment.apla.a >= 0) {
				left_segment.apla.b = original_time_series_vector[int(left_segment.right_endpoint - left_segment.rectangle_width + 1)];
				splited_node_segment.apla.b = original_time_series_vector[int(splited_node_segment.right_endpoint - splited_node_segment.rectangle_width + 1)];
				//left_segment.min_point.id = int(left_segment.right_endpoint - left_segment.rectangle_width + 1);
				//left_segment.max_point.id = left_segment.right_endpoint;
				//left_segment.min_point.value = left_segment.apla.b = original_time_series_vector[left_segment.min_point.id];
				//left_segment.max_point.value = original_time_series_vector[left_segment.max_point.id];
				//splited_node_segment.min_point.id = int(splited_node_segment.right_endpoint - splited_node_segment.rectangle_width + 1);
				//splited_node_segment.max_point.id = splited_node_segment.right_endpoint;
				//splited_node_segment.min_point.value = splited_node_segment.apla.b = original_time_series_vector[splited_node_segment.min_point.id];
				//splited_node_segment.max_point.value = original_time_series_vector[splited_node_segment.max_point.id];
			}
			else if (left_segment.apla.a < 0) {
				left_segment.apla.b = original_time_series_vector[int(left_segment.right_endpoint - left_segment.rectangle_width + 1)];
				splited_node_segment.apla.b = original_time_series_vector[int(splited_node_segment.right_endpoint - splited_node_segment.rectangle_width + 1) ];

			/*	left_segment.max_point.id = int(left_segment.right_endpoint - left_segment.rectangle_width + 1);
				left_segment.min_point.id = left_segment.right_endpoint;
				left_segment.max_point.value = left_segment.apla.b = original_time_series_vector[left_segment.max_point.id];
				left_segment.min_point.value = original_time_series_vector[left_segment.min_point.id];
				splited_node_segment.max_point.id = int(splited_node_segment.right_endpoint - splited_node_segment.rectangle_width + 1);
				splited_node_segment.min_point.id = splited_node_segment.right_endpoint;
				splited_node_segment.max_point.value = splited_node_segment.apla.b = original_time_series_vector[splited_node_segment.max_point.id];
				splited_node_segment.min_point.value = original_time_series_vector[splited_node_segment.min_point.id];*/
			}
			else {
				assert(0);
			}
			/*-------------------------------------------------------------------------------------------*/
			/*left_segment.min_point.value = left_segment.max_point.value = original_time_series_vector[int(left_segment.right_endpoint)];
			left_segment.min_point.id = left_segment.right_endpoint - left_segment.rectangle_width + 1;
			splited_node_segment.min_point.id = left_segment.right_endpoint + 1;
			splited_node_segment.max_point.id = splited_node_segment.right_endpoint;*/
			/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

			/*............................................................................................................................*/
#ifdef _DEBUG
			//200314 minmax point
			//assert(splited_node_segment.min_point.value == splited_node_segment.max_point.value && splited_node_segment.max_point.value == left_segment.max_point.value);
			if (left_segment.apla.a == 0)
				assert(float(left_segment.apla.b) == float(splited_node_segment.apla.b));
#endif
			/*............................................................................................................................*/

			/*-----------------------------sum value ----------------------------------*/
			//200316 sum value
			/*left_segment.sum_value = left_segment.rectangle_width * left_segment.apla.b;
			splited_node_segment.sum_value - left_segment.sum_value;*/
			/*-------------------------------------------------------------------------*/

			get_apla_coefficients_segment(left_segment);
			get_apla_coefficients_segment(splited_node_segment);

			/*========================================    Insert Node(copy) in LinkedList   ======================================*/
			doubly_linked_list.insertNodeBeforeNode(*newElement, splited_node);
			segment_id++;
			/*====================================================================================================================*/
		}

		segment_id++;
	}

	/*..............................................................................................*/
#ifdef _DEBUG
	assert(doubly_linked_list.size() == point_dimension);
	APLA::assertLinkedList(doubly_linked_list);
#endif
	/*..............................................................................................*/
}

//190910
//************************************
// Method:mergeSegmentByDensity
// Qualifier: long segment Merge 2 short segments into .
// Input: Long segment sum_value, a&b, min&max point, width , right endpoint
// Output: Sub segment sum_value, a&b, min&max point, width , right endpoint , *right_subsegment != nullptr
// date:190830
// author:
//************************************
TEMPLATE
inline void APLA::mergeSegmentByDensity(DataType*& const original_time_series, multimap<double, DoublyListNode<AREA_COEFFICIENT>&, std::greater<double>>& const merge_segment_density_map, multimap<double, DoublyListNode<AREA_COEFFICIENT>&, std::greater<double>>& const split_area_difference_map, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list) {
#ifdef _DEBUG
	assert(!merge_segment_density_map.empty());

	assertLinkedListAndSubLinkedList(doubly_linked_list);


	//evaluate right point, min&max point, width. a&b, sum value
	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		assert(doubly_linked_list[segment_id].right_endpoint != INF && doubly_linked_list[segment_id].rectangle_width != INF && doubly_linked_list[segment_id].min_point.id != INF && doubly_linked_list[segment_id].min_point.value != INF && doubly_linked_list[segment_id].max_point.id != INF && doubly_linked_list[segment_id].max_point.value != INF && doubly_linked_list[segment_id].apla.a != INF && doubly_linked_list[segment_id].apla.b != INF);
		if (segment_id > 0) {
			assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint);
		}
		int segment_left_id = doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id].rectangle_width + 1;
		assert(doubly_linked_list[segment_id].min_point.id >= segment_left_id && doubly_linked_list[segment_id].max_point.id >= segment_left_id && doubly_linked_list[segment_id].min_point.id <= doubly_linked_list[segment_id].right_endpoint && doubly_linked_list[segment_id].max_point.id <= doubly_linked_list[segment_id].right_endpoint);
	}

	//cout << "Area Difference: ";
	for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
		//cout << doubly_linked_list[segment_id].right_endpoint << "," << doubly_linked_list[segment_id].rectangle_width << "; ";
		//cout << doubly_linked_list[segment_id].area_difference << " ";
		assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint && doubly_linked_list[segment_id].area_difference != INF);
		assert(doubly_linked_list[segment_id].right_subsegment->rectangle_width == doubly_linked_list[segment_id].rectangle_width + doubly_linked_list[segment_id - 1].rectangle_width && doubly_linked_list[segment_id].right_subsegment->area_difference != INF);
	}
	//cout << endl;
#endif

	auto& const merged_node = merge_segment_density_map.begin()->second;
	auto& const merged_node_segment = merged_node._value;

	/*--------------------------------------------- Area Difference & Density ------------------------------------------------------*/
	const auto left_area_difference = merged_node._prev->_value.area_difference;
	const auto& const left_segment_density = merged_node._prev->_value.right_subsegment->segment_density;
	const auto origial_merged_area_difference = merged_node_segment.area_difference;
	const auto origial_merged_segment_density = merged_node_segment.right_subsegment->segment_density;
	double right_original_segment_density = -1;
	//if tail node
	if (merged_node._next)
		right_original_segment_density = merged_node._next->_value.right_subsegment->segment_density;
	//if head node
	bool is_head_node = false;
	if (merged_node_segment.right_subsegment->right_endpoint + 1 == merged_node_segment.right_subsegment->rectangle_width)
		is_head_node = true;
	/*---------------------------------------------------------------------------------------------------------------------------*/

#ifdef _DEBUG
	assert(left_area_difference != INF && origial_merged_area_difference != INF);
	assert(merged_node_segment.right_subsegment != nullptr && merged_node_segment.apla.a != INF && merged_node_segment.apla.b != INF && merged_node_segment.right_endpoint != INF && merged_node_segment.rectangle_width != INF && merged_node_segment.sum_value != INF);
	for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
		//cout << doubly_linked_list[segment_id].right_endpoint << "," << doubly_linked_list[segment_id].rectangle_width << "; ";
		assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint);
		assert(doubly_linked_list[segment_id].right_subsegment->rectangle_width == doubly_linked_list[segment_id].rectangle_width + doubly_linked_list[segment_id - 1].rectangle_width);
	}

	if (left_area_difference > 0) {
		auto test_erased_segment_split = split_area_difference_map.find(left_area_difference);
		if (test_erased_segment_split == split_area_difference_map.end()) {
			std::cout << "Not found\n";
			assert(0);
		}
	}

	if (!is_head_node) {
		auto test_erased_segment_merge = merge_segment_density_map.find(left_segment_density);
		if (test_erased_segment_merge == merge_segment_density_map.end()) {
			std::cout << "Not found\n";
			assert(0);
		}
	}

	if (origial_merged_area_difference > 0) {
		auto test_merged_segment_split = split_area_difference_map.find(origial_merged_area_difference);
		if (test_merged_segment_split == split_area_difference_map.end()) {
			std::cout << "Not found\n";
			assert(0);
		}
	}
	auto test_merged_segment_merge = merge_segment_density_map.find(origial_merged_segment_density);
	if (test_merged_segment_merge == merge_segment_density_map.end()) {
		std::cout << "Not found\n";
		assert(0);
	}

	if (right_original_segment_density != -1) {
		auto test_right_merged_segment_merge = merge_segment_density_map.find(right_original_segment_density);
		if (test_right_merged_segment_merge == merge_segment_density_map.end()) {
			std::cout << "Not found\n";
			assert(0);
		}
	}
#endif

	/*-------------------------------------------1 MAP: Pop Split&Merge sub left node, 2 LinkedList: Remove sub left node-------------------------------------------*/
	/*----------Pop left node in Split Map--------------*/
	if (left_area_difference > 0) {
		eraseMapByKey(split_area_difference_map, merged_node._prev->_value.right_endpoint, left_area_difference);
	}
	/*..................................................*/
	/*---------Pop left node in Merge Map --------------*/
	if (!is_head_node) {
		eraseMapByKey(merge_segment_density_map, merged_node._prev->_value.right_endpoint, left_segment_density);
	}
	/*-------------------------------------------------*/
	/*---------Erase Node in Linked List--------------*/
	doubly_linked_list.removeNode(*merged_node._prev);
	/*-----------------------------------------------*/
	/*...................................................................................................................................................................*/

	/*=======================================  LinkedList Merge left and right segment  ================================================================================*/
	//max_density_node._value.right_subsegment->right_subsegment = &doubly_linked_list.removeNode(*max_density_node._prev);
	//merged_node_segment.right_subsegment->right_subsegment = new AREA_COEFFICIENT;
	merged_node_segment.right_subsegment->right_subsegment = merged_node_segment.right_subsegment;
	merged_node_segment = *merged_node_segment.right_subsegment;
	/*===================================================================================================================================================================*/

	/*---------------------- Split MAP update merged segment--------------*/
	if (merged_node_segment.area_difference > 0) {
		if (origial_merged_area_difference > 0) {
			updateMapByKey(split_area_difference_map, merged_node_segment.right_endpoint, origial_merged_area_difference, merged_node_segment.area_difference);
		}
		else {
			split_area_difference_map.emplace(merged_node_segment.area_difference, merged_node);
		}
	}
	else if (origial_merged_area_difference > 0) {
		eraseMapByKey(split_area_difference_map, merged_node_segment.right_endpoint, origial_merged_area_difference);
	}
	/*......................................................................*/
	/*-- 1 Merged MAP update merged segment, 2 Get merged Information-----*/

	if (!is_head_node) {
		updateMapByKey(merge_segment_density_map, merged_node_segment.right_endpoint, origial_merged_segment_density, getMergedSubSegmentInformation(original_time_series, merged_node));//200109 For Area DIfference
		//updateMapByKey(merge_segment_density_map, merged_node_segment.right_endpoint, origial_merged_segment_density, getMergedSubSegmentInformation(merged_node));
	}
	else {
		eraseMapByKey(merge_segment_density_map, merged_node_segment.right_endpoint, origial_merged_segment_density);
	}

	/*.......................................................................*/
	/*-- 1 Merged MAP update right merged segment, 2 Get right merged Information-----*/
	if (right_original_segment_density != -1) {
		updateMapByKey(merge_segment_density_map, merged_node._next->_value.right_endpoint, right_original_segment_density, getMergedSubSegmentInformation(original_time_series, *merged_node._next));
		//updateMapByKey(merge_segment_density_map, merged_node._next->_value.right_endpoint, right_original_segment_density, getMergedSubSegmentInformation(*merged_node._next));
	}
	/*..................................................................................*/

#ifdef _DEBUG
	assertLinkedListAndSubLinkedList(doubly_linked_list);
	for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
		//cout << doubly_linked_list[segment_id].right_endpoint << "," << doubly_linked_list[segment_id].rectangle_width << "; ";
		//cout << doubly_linked_list[segment_id].area_difference << " ";
		assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint && doubly_linked_list[segment_id].area_difference != INF);
		assert(doubly_linked_list[segment_id].right_subsegment->rectangle_width == doubly_linked_list[segment_id].rectangle_width + doubly_linked_list[segment_id - 1].rectangle_width && doubly_linked_list[segment_id].right_subsegment->area_difference != INF);
	}
	//cout << endl;
#endif
}

//200212 change original time series from pointer to vector. Add templatea
//************************************
// Method:mergeSegmentByDensity
// Qualifier: long segment Merge 2 short segments into .
// Input: Long segment sum_value, a&b, min&max point, width , right endpoint
// Output: Sub segment sum_value, a&b, min&max point, width , right endpoint , *right_subsegment != nullptr
// date:200212
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U, typename T1>
inline void APLA::mergeSegmentByDensity(const vector<T>& const original_time_series_vector, multimap<U, DoublyListNode<Y>&, std::greater<U>>& const merge_segment_density_map, multimap<U, DoublyListNode<Y>&, std::greater<U>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, T1& const output_argument) {

	/*.....................................................................................*/
#ifdef _DEBUG
	if (doubly_linked_list.size() > 1) { assert(!merge_segment_density_map.empty()); }
	else if (doubly_linked_list.size() == 1) {
		assert(merge_segment_density_map.empty());
		return;
	}
	//evaluate right point, min&max point, width. a&b, sum value
	assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
	assert_bound(original_time_series_vector, doubly_linked_list);
#endif
	/*.....................................................................................*/

	auto& const merged_node = merge_segment_density_map.begin()->second;
	auto& const merged_node_segment = merged_node._value;

	/*..............................................................................................................................*/
#ifdef _DEBUG
	//assert_segment_a_b_minmax(original_time_series_vector, merged_node_segment);// 210203
	assert_segment_a_b(original_time_series_vector, merged_node_segment);//
#endif
	/*..............................................................................................................................*/

	/*+++++++++++++++++++++++++++++++++++++           Area Difference & Density       ++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	const auto left_area_difference = merged_node._prev->_value.area_difference;
	const auto& const left_segment_density = merged_node._prev->_value.right_subsegment->segment_density;
	const auto origial_merged_area_difference = merged_node_segment.area_difference;
	const auto origial_merged_segment_density = merged_node_segment.right_subsegment->segment_density;
	const auto origial_merged_segment_rectangle_width = merged_node_segment.rectangle_width;
	double right_original_segment_density = -1;

	//if tail node
	if (merged_node._next)
		right_original_segment_density = merged_node._next->_value.right_subsegment->segment_density;

	//if head node
	bool is_head_node = false;
	if (merged_node_segment.right_subsegment->right_endpoint + 1 == merged_node_segment.right_subsegment->rectangle_width)
		is_head_node = true;
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*............................................................................................................................*/
#ifdef _DEBUG
	assert(left_area_difference != INF && origial_merged_area_difference != INF);
	assert(merged_node_segment.right_subsegment != nullptr && merged_node_segment.apla.a != INF && merged_node_segment.apla.b != INF && merged_node_segment.right_endpoint != INF && merged_node_segment.rectangle_width != INF);
	assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
	if (left_area_difference > 0 && merged_node._prev->_value.rectangle_width > 3) { find_if_in_multimap(left_area_difference, split_area_difference_map); }
	if (!is_head_node) { find_if_in_multimap(left_segment_density, merge_segment_density_map); }
	if (origial_merged_area_difference > 0 && origial_merged_segment_rectangle_width > 3) { find_if_in_multimap(origial_merged_area_difference, split_area_difference_map); }
	find_if_in_multimap(origial_merged_segment_density, merge_segment_density_map);
	if (right_original_segment_density != -1) { find_if_in_multimap(right_original_segment_density, merge_segment_density_map); }
#endif
	/*............................................................................................................................*/

	/*++++++++++++++++++++++++++++            1 MAP: Pop Split & Merge sub left node; 2 LinkedList: Remove sub left node           +++++++++++++++++++++++++++++++++*/
	/*----------Pop left node in Split Map--------------*/
	if (left_area_difference > 0 && merged_node._prev->_value.rectangle_width > 3) {
		eraseMapByKey(split_area_difference_map, merged_node._prev->_value.right_endpoint, left_area_difference);
	}
	/*--------------------------------------------------*/
	/*---------Pop left node in Merge Map --------------*/
	if (!is_head_node) {
		eraseMapByKey(merge_segment_density_map, merged_node._prev->_value.right_endpoint, left_segment_density);
	}
	/*-------------------------------------------------*/
	/*--------- Erase Node in Linked List--------------*/
	delete merged_node._prev->_value.right_subsegment;
	merged_node._prev->_value.right_subsegment = nullptr;
	doubly_linked_list.removeNode(*merged_node._prev);
	/*-------------------------------------------------*/
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*=======================================  LinkedList Merge left and right segment  ==============================================================================*/
	//max_density_node._value.right_subsegment->right_subsegment = &doubly_linked_list.removeNode(*max_density_node._prev);
	//merged_node_segment.right_subsegment->right_subsegment = new AREA_COEFFICIENT;
	merged_node_segment.right_subsegment->right_subsegment = merged_node_segment.right_subsegment;
	merged_node_segment = *merged_node_segment.right_subsegment;

	//evaluate_segment_upper_lower_bound(input_argument, original_time_series_vector, merged_node_segment);
	/*==================================================================================================================================================================*/

	/*++++++++++++++++++++++++++++++++++++++++              MAP: merge & split. update, erase             +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*---------------------- Current Segment Split MAP update merged segment---------------------------------------------------*/
	if (merged_node_segment.area_difference > 0) {
		if (origial_merged_area_difference > 0 && origial_merged_segment_rectangle_width > 3) {
			updateMapByKey(split_area_difference_map, merged_node_segment.right_endpoint, origial_merged_area_difference, merged_node_segment.area_difference);
		}
		else {
			split_area_difference_map.emplace(merged_node_segment.area_difference, merged_node);
		}
	}
	else if (origial_merged_area_difference > 0 && origial_merged_segment_rectangle_width > 3) {
		eraseMapByKey(split_area_difference_map, merged_node_segment.right_endpoint, origial_merged_area_difference);
	}
	/*----------------------------------------------------------------------------------------------------------------------------*/

	/*-------------------- 1 Current Segment Merged MAP update merged segment, 2 Get merged Information -------------------------*/
	if (!is_head_node) {
		updateMapByKey(merge_segment_density_map, merged_node_segment.right_endpoint, origial_merged_segment_density, getMergedSubSegmentInformation(original_time_series_vector, merged_node, output_argument));//200109 For Area DIfference
		//updateMapByKey(merge_segment_density_map, merged_node_segment.right_endpoint, origial_merged_segment_density, getMergedSubSegmentInformation(merged_node));
	}
	else {
		eraseMapByKey(merge_segment_density_map, merged_node_segment.right_endpoint, origial_merged_segment_density);
	}
	/*------------------------------------------------------------------------------------------------------------------------------*/

	/*-------------------- 1 Right Segment. Merged MAP update right merged segment, 2 Get right merged Information-----------------*/
	if (right_original_segment_density != -1) {
		updateMapByKey(merge_segment_density_map, merged_node._next->_value.right_endpoint, right_original_segment_density, getMergedSubSegmentInformation(original_time_series_vector, *merged_node._next, output_argument));
		//updateMapByKey(merge_segment_density_map, merged_node._next->_value.right_endpoint, right_original_segment_density, getMergedSubSegmentInformation(*merged_node._next));
	}
	/*-------------------------------------------------------------------------------------------------------------------------------*/

	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*..............................................................................................................................*/
#ifdef _DEBUG
	//200821 Print right endpoint
	//TOOL::print_each_segment_right_endpoint(doubly_linked_list);
	assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
	assert_bound(original_time_series_vector, doubly_linked_list);
	assert_merge_map_triangle_density(merge_segment_density_map);
#endif
	/*..............................................................................................................................*/
}

//************************************
// Method:mergeEndSegment
// Qualifier:  new segment is same with end vector, merge them.
// date:190712 18:15
// author:
//************************************
TEMPLATE
inline void APLA::mergeEndSegment(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& area_vector, AREA_COEFFICIENT& const temp_coefficient) {//190712 18:15 new segment is same with end vector, merge them.
#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width != INF && temp_coefficient.right_endpoint != INF);
#endif
	int segment_left_id = area_vector.back().right_endpoint - area_vector.back().rectangle_width + 1;

	double left_a = original_time_series[segment_left_id + 1] - original_time_series[segment_left_id];
	double right_a = original_time_series[int(temp_coefficient.right_endpoint)] - original_time_series[int(temp_coefficient.right_endpoint) - 1];

	double endpoint_value = (area_vector.back().rectangle_width + temp_coefficient.rectangle_width - 1) * left_a + original_time_series[segment_left_id];

	if (float(left_a) == float(right_a) && float(endpoint_value) == float(original_time_series[int(temp_coefficient.right_endpoint)])) {
#ifdef _DEBUG
		assert(temp_coefficient.right_endpoint == area_vector.back().right_endpoint + temp_coefficient.rectangle_width);
#endif
		area_vector.back().right_endpoint = temp_coefficient.right_endpoint;
		area_vector.back().rectangle_width += temp_coefficient.rectangle_width;

#ifdef _DEBUG
		assert(segment_left_id == area_vector.back().right_endpoint - area_vector.back().rectangle_width + 1);
#endif
		area_vector.back().deviation_point.value = -1;
		temp_coefficient.right_endpoint = INF;
		temp_coefficient.rectangle_width = INF;
	}
}

//************************************
// Method:split_merge_optimization
// Qualifier:   Split & Merge Operation iteration 
// date:200925 10:32
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U, typename T1>
inline void APLA::split_merge_optimization(const vector<T>& const original_time_series_vector, const int& const split_method_option, multimap<T1, DoublyListNode<Y>&, std::greater<T1>>& const merge_segment_density_map, multimap<T1, DoublyListNode<Y>&, std::greater<T1>>& const split_area_difference_map, DoublyLinkedList<Y>& const doubly_linked_list, U& const output_argument) {

	/*............................................................................................................................................................*/
#ifdef _DEBUG
	if (doubly_linked_list.size() > 1) { assert(!merge_segment_density_map.empty()); }
	else if (doubly_linked_list.size() == 1) {
		assert(merge_segment_density_map.empty());
		return;
	}

	assert(!merge_segment_density_map.empty() && split_method_option != int(INF) && split_method_option >= 0);

	//evaluate right point, min&max point, width. a&b, sum value
	assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
	/*............................................................................................................................................................*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!             Whether MAP Empty      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	// If MAP is empty, no need to split
	if (split_area_difference_map.empty()) {
		return;
	}
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*---------------------------------- Compute Sum area difference  ------------------------------------*/
	long double area_difference_sum_old = get_whole_area_difference(doubly_linked_list);
	long double area_difference_sum_new = INF;
	/*----------------------------------------------------------------------------------------------------*/

	/*#################################################### Coefficients of Spit #################################################################################*/

	/*========================================   Split Candidate Long segment  ========================================*/
	auto& const splited_node = split_area_difference_map.begin()->second;
	auto& const splited_node_segment = splited_node._value;
	/*-------------------------------Key of MAP--------------------------------------------*/
	// original long segment area difference
	const double origianl_splited_area_difference = splited_node_segment.area_difference;
	// original long segment and previous segment triangle density.
	const auto original_splited_density = splited_node_segment.right_subsegment->segment_density;
	/*-------------------------------------------------------------------------------------*/
	/*================================================================================================================*/

	/**********************************    new Sub left segment    **************************************/
	DoublyListNode<Y>* node_left_new = new DoublyListNode<Y>;
	//Y& const left_segment = node_left_new->_value;
	/****************************************************************************************************/

	/**************************    new long, sub left, sub right segment    *****************************/
	Y original_splited_segment = splited_node_segment, new_sub_segment_left, new_sub_segment_right;
	/****************************************************************************************************/

	/************************       If the splited segment is head segment      *************************/
	bool is_head_node_split = false;
	if (splited_node_segment.right_endpoint + 1 == splited_node_segment.rectangle_width)
		is_head_node_split = true;
	/*****************************************************************************************************/

	/*##########################################################################################################################################################*/

	/*#################################################### Coefficients of Merge ###############################################################################*/

	auto& const merged_node = merge_segment_density_map.begin()->second;
	auto& const merged_node_segment = merged_node._value;

	/*..............................................................................................................................*/
#ifdef _DEBUG
	Y test_merge_segment = merged_node_segment;
	get_ab_segment(original_time_series_vector, test_merge_segment);
	assert_two_segments_a_b(get_ab_segment(original_time_series_vector, test_merge_segment), merged_node_segment);
	//assert(fabs(test_merge_segment.apla.a - merged_node_segment.apla.a) <= 1 && fabs(test_merge_segment.apla.b - merged_node_segment.apla.b) <= 1);
#endif
	/*..............................................................................................................................*/

	/*+++++++++++++++++++++++++++++++++++++           Area Difference & Density       ++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	const auto left_area_difference = merged_node._prev->_value.area_difference;
	const auto& const left_segment_density = merged_node._prev->_value.right_subsegment->segment_density;
	const auto origial_merged_area_difference = merged_node_segment.area_difference;
	const auto origial_merged_segment_density = merged_node_segment.right_subsegment->segment_density;
	double right_original_segment_density = -1;
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/********************************       If the splited segment is head & tail segment       ****************************************/
	//if tail node
	if (merged_node._next)
		right_original_segment_density = merged_node._next->_value.right_subsegment->segment_density;

	//if head node
	bool is_head_node_merge = false;
	if (merged_node_segment.right_subsegment->right_endpoint + 1 == merged_node_segment.right_subsegment->rectangle_width)
		is_head_node_merge = true;
	/***********************************************************************************************************************************/

	/*............................................................................................................................*/
#ifdef _DEBUG
	assert(left_area_difference != INF && origial_merged_area_difference != INF);
	assert(merged_node_segment.right_subsegment != nullptr && merged_node_segment.apla.a != INF && merged_node_segment.apla.b != INF && merged_node_segment.right_endpoint != INF && merged_node_segment.rectangle_width != INF);
	assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
	if (left_area_difference > 0) { find_if_in_multimap(left_area_difference, split_area_difference_map); }
	if (!is_head_node_merge) { find_if_in_multimap(left_segment_density, merge_segment_density_map); }
	if (origial_merged_area_difference > 0) { find_if_in_multimap(origial_merged_area_difference, split_area_difference_map); }
	find_if_in_multimap(origial_merged_segment_density, merge_segment_density_map);
	if (right_original_segment_density != -1) { find_if_in_multimap(right_original_segment_density, merge_segment_density_map); }
#endif
	/*............................................................................................................................*/

	/*##########################################################################################################################################################*/

	/*...................................................................................................*/
#ifdef _DEBUG
	Y original_splited_segment_test = splited_node_segment;
	assert_two_segments_a_b(splited_node_segment, get_ab_segment(original_time_series_vector, original_splited_segment_test));
	assert(origianl_splited_area_difference > 0 && origianl_splited_area_difference != INF && splited_node_segment.right_subsegment != nullptr);
	assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
	/*...................................................................................................*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&      Find splited new segemnt right_id      &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	//left_segment.right_endpoint = findSplitSegmentByEndpoint2length(original_time_series_vector, splited_node_segment);
	//200214 Replace with fast find split point
	//left_segment.right_endpoint =  APLA::find_split_point_by_min_density_fast(original_time_series_vector, splited_node_segment);
	//200225 Instead fast split id. option is 0 is min density method, 1 is binary method, 2 is itersectio npoint method, 3  midlew method 4 besti id method
	//left_segment.right_endpoint = group_find_split_point_methods(original_time_series_vector, splited_node_segment, split_method_option, output_argument);
	/*############## Find Split Point; return sub left&right right endpoint, width, a&b. Long triangle ###################*/
	/**splited_node_segment.right_subsegment = splited_node_segment;
	left_segment.right_endpoint = group_find_split_point_methods(original_time_series_vector, split_method_option, left_segment, splited_node_segment, *splited_node_segment.right_subsegment, output_argument);*/
	new_sub_segment_left.right_endpoint = group_find_split_point_methods(original_time_series_vector, split_method_option, new_sub_segment_left, new_sub_segment_right, original_splited_segment, output_argument);
	/*####################################################################################################################*/
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   Has Spilt Point   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
	// Has split point, begin to split segment
	if (new_sub_segment_left.right_endpoint != INF) {

		/*............................................................................................................*/
#ifdef _DEBUG
		assert(new_sub_segment_left.rectangle_width + new_sub_segment_right.rectangle_width == original_splited_segment.rectangle_width);
		assert(new_sub_segment_left.right_endpoint > 0 && new_sub_segment_left.right_endpoint < new_sub_segment_right.right_endpoint);
		// evaluate already get sub a&b and density by min density split method
		Y test_sub_segment_left = new_sub_segment_left;
		Y test_sub_segment_right = splited_node_segment;
		Y test_temp_coefficient = *splited_node_segment.right_subsegment;

		assert_two_segments_a_b(get_ab_segment(original_time_series_vector, test_sub_segment_left), new_sub_segment_left);
		assert_two_segments_a_b(get_ab_segment(original_time_series_vector, test_sub_segment_right), splited_node_segment);
		assert_two_segments_a_b(get_ab_segment(original_time_series_vector, test_temp_coefficient), *splited_node_segment.right_subsegment);

		test_temp_coefficient = *splited_node_segment.right_subsegment;
		const auto test_density = getLineSegmentTriangleAreaDensity(new_sub_segment_left, splited_node_segment, test_temp_coefficient);
		if (splited_node_segment.right_subsegment->segment_density != INF)
			assert(fabs(test_density - splited_node_segment.right_subsegment->segment_density) <= MIN_D);
#endif
		/*............................................................................................................*/

		/*-------------------   210203      Min&Max points: sub left, right segment     --------------------------*/
		/*getSegmentMinMaxPoint(original_time_series_vector, new_sub_segment_left);
		getSegmentMinMaxPoint(original_time_series_vector, new_sub_segment_right);*/
		//200212 get min&max point of left&right segment by long segment, speed up
		//getSubMinMaxPoint(original_time_series_vector, new_sub_segment_left, new_sub_segment_right, original_splited_segment);
		/*-------------------------------------------------------------------------------------------------*/

		new_sub_segment_left.right_subsegment = new Y;

		/*======================================== Linked list: Insert sub left segment   ======================================*/
		doubly_linked_list.insertNodeBeforeNode(*node_left_new, splited_node);
		/*======================================================================================================================*/

		/*====================================================    Update Area MAP: get Area Difference & Emplace Split =================================================================*/

		/*--------------------------Split MAP: Insertion left segment----------------*/
		if (getAreaDifference(original_time_series_vector, new_sub_segment_left) > 0) {
			//if (getAreaDifference(left_segment) > 0) {
			split_area_difference_map.emplace(new_sub_segment_left.area_difference, *splited_node._prev);
		}
		/*---------------------------------------------------------------------------*/

		/*...........................................................................*/
#ifdef _DEBUG
		assert(new_sub_segment_left.area_difference == splited_node._prev->_value.area_difference && new_sub_segment_left.area_difference != INF);
		find_if_in_multimap(origianl_splited_area_difference, split_area_difference_map);
#endif
		/*...........................................................................*/

		/*------------------------Split MAP: Update current segment------------------*/
		if (getAreaDifference(original_time_series_vector, splited_node_segment) > 0) {
			//if (getAreaDifference(splited_node_segment) > 0) {
			updateMapByKey(split_area_difference_map, splited_node_segment.right_endpoint, origianl_splited_area_difference, splited_node_segment.area_difference);
		}
		else {
			//split_area_difference_map.erase(origianl_splited_area_difference);
			eraseMapByKey(split_area_difference_map, splited_node_segment.right_endpoint, origianl_splited_area_difference);
		}
		/*-----------------------------------------------------------------------------*/
		/*============================================================================================================================================================================*/


		/*==================================================================   Density MAP : left, current and right segment     ======================================================*/
		/*##########################################      Key of density MAP: Right long semgent      ################################*/
		long double right_splited_density = -1;
		if (splited_node._next) {
			right_splited_density = splited_node._next->_value.right_subsegment->segment_density;
		}
		/*############################################################################################################################*/
		/*..........................................................................................................................*/
#ifdef _DEBUG
		if (!is_head_node_split) { find_if_in_multimap(original_splited_density, merge_segment_density_map); }
		if (splited_node._next) { find_if_in_multimap(right_splited_density, merge_segment_density_map); }
#endif
		/*..........................................................................................................................*/

		if (split_method_option > 0) getMergedSubSegmentInformation(original_time_series_vector, splited_node);

		if (!is_head_node_split) {//middle node
			/*---------------------  Density MAP Insertion: the density between left segment and left's previous segment   -----------------------*/
			merge_segment_density_map.emplace(getMergedSubSegmentInformation(original_time_series_vector, *splited_node._prev), *splited_node._prev);//200109 For area difference
			//merge_segment_density_map.emplace(getMergedSubSegmentInformation(*splited_node._prev), *splited_node._prev);
			/*------------------------------------------------------------------------------------------------------------------------------------*/
			/*---------------------  Density MAP Update:     the density between current segment and left segment---------------------------------*/
			updateMapByKey(merge_segment_density_map, splited_node_segment.right_endpoint, original_splited_density, splited_node_segment.right_subsegment->segment_density);//200109 For area difference
			//updateMapByKey(merge_segment_density_map, splited_node_segment.right_endpoint, original_splited_density, getMergedSubSegmentInformation(splited_node));
			/*------------------------------------------------------------------------------------------------------------------------------------*/
		}
		else {//head node
			/*---------------------  Density MAP Update:     the density between current segment and left segment---------------------------------*/
			merge_segment_density_map.emplace(splited_node_segment.right_subsegment->segment_density, splited_node);//200109 for area difference
			//merge_segment_density_map.emplace(getMergedSubSegmentInformation(splited_node), splited_node);
			/*------------------------------------------------------------------------------------------------------------------------------------*/
		}
		/*---------------------  Density MAP Update:     the density between right segment and current segment   -----------------------------*/
		if (splited_node._next) {
			updateMapByKey(merge_segment_density_map, splited_node._next->_value.right_endpoint, right_splited_density, getMergedSubSegmentInformation(original_time_series_vector, *splited_node._next));//200109 For area difference
			//updateMapByKey(merge_segment_density_map, splited_node._next->_value.right_endpoint, right_splited_density, getMergedSubSegmentInformation(*splited_node._next));
		}
		/*------------------------------------------------------------------------------------------------------------------------------------*/
	/*==============================================================================================================================================================================*/

		/*..........................................................................................................................*/
#ifdef _DEBUG
		for_each_n(split_area_difference_map.begin(), split_area_difference_map.size(), [](auto&& au) {assert(au.first != INF); });
		assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
		/*..........................................................................................................................*/

	}
	/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

	/*..........................................................................................................................*/
#ifdef _DEBUG
	assert(!merge_segment_density_map.empty());
	//evaluate right point, min&max point, width. a&b, sum value
	assertLinkedListAndSubLinkedList(original_time_series_vector, doubly_linked_list);
#endif
	/*..........................................................................................................................*/
}

//************************************
// Method:isSymmetry
// Qualifier: Whether max point or min point in the middle
// date:181220
// author:
//************************************
TEMPLATE
bool APLA::isSymmetry(const AREA_COEFFICIENT& const temp_coefficient, DataType*& const original_time_series) {
#if _DEBUG
	assert(temp_coefficient.rectangle_width != NULL);
	//assert(temp_coefficient.minmax_distance != INF);
#endif

	if (temp_coefficient.rectangle_width < 3 || temp_coefficient.rectangle_height == 0) return false;

	int left_endpoint_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	int right_endpoint_id = temp_coefficient.right_endpoint;
	//cout << "left id: " << left_endpoint_id << " right id: " << right_endpoint_id << endl;

	//**************************** 1st get convex hull(self)********************************************
#if _DEBUG
	auto points_vec = getPointFromSeg(original_time_series, temp_coefficient);
	GEOMETRY::ClockwiseSortPoints(points_vec);
	typename GEOMETRY::POINT* points_array = new typename GEOMETRY::POINT[temp_coefficient.rectangle_width];
	std::vector <GEOMETRY::POINT> points_convex;

	int j = 0;
	for (auto&& i : points_vec) {
		points_array[j].id = i.id;
		points_array[j].value = i.value;
		j++;
	}

	//GEOMETRY::convexHull(points_array, temp_coefficient.rectangle_width, points_convex);
	TOOL::deleteArray(points_array);
	//auto hollow = typename GEOMETRY::isHollow(points_convex);
	//auto convex = typename GEOMETRY::isConvex(points_convex);
	//***************************************************************************************
	//auto hollow = typename GEOMETRY::isHollow(points_vec);
	//auto convex = typename GEOMETRY::isConvex(points_vec);
#endif

	//assert((hollow == true && convex == 1) || (hollow == false && convex == -1));
	/*if (temp_coefficient.minmax_distance / temp_coefficient.rectangle_width <= 0.7 || temp_coefficient.rectangle_height > fabs(original_time_series[right_endpoint_id] - original_time_series[left_endpoint_id])) {
		cout << "hollow: " << hollow << ",   convex " << convex << endl;
	}
*/
//cout <<"1 right_endpoint: "<< temp_coefficient.right_endpoint  << " minmax_distance: " << temp_coefficient.minmax_distance << " rectangle_width: " << temp_coefficient.rectangle_width<<" rectangle_height: " << temp_coefficient.rectangle_height<<" ABS: "<< fabs(original_time_series[right_endpoint_id] - original_time_series[left_endpoint_id]) << endl;
	return temp_coefficient.minmax_distance / temp_coefficient.rectangle_width <= 0.7 || temp_coefficient.rectangle_height > fabs(original_time_series[right_endpoint_id] - original_time_series[left_endpoint_id]) ? true : false;//190306
	//return temp_coefficient.minmax_distance / temp_coefficient.rectangle_width <= 0.5 ? true : false;
	//return temp_coefficient.rectangle_height < fabs(original_time_series[int(temp_coefficient.right_endpoint)]- original_time_series[int(temp_coefficient.right_endpoint- temp_coefficient.rectangle_width)]) ? true : false;
}

//************************************
// Method:getMergedInfo
// Qualifier: right rectangle merge left rectangle
// date:181129
// author:
//************************************
TEMPLATE
void APLA::getMergedInfo(DataType*& const original_time_series, const vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient) {//181129
	auto left_id = vector_id - 1;

#ifdef _DEBUG
	assert(vector_id > 0);
#endif

	int segment_left_id = 0;
	if (vector_id > 1 && vector_id < area_vector.size()) {
		segment_left_id = area_vector[left_id - 1].right_endpoint + 1;
	}
	else if (vector_id == 1) {
		segment_left_id = 0;
	}
	else
		assert(0);

	auto [mmin, mmax] = minmax_element(original_time_series + segment_left_id, original_time_series + int(area_vector[vector_id].right_endpoint + 1));

#ifdef _DEBUG
	assert(*mmax >= *mmin);
	assert(area_vector[vector_id].right_endpoint >= mmin - original_time_series && area_vector[vector_id].right_endpoint >= mmax - original_time_series);
#endif

	temp_coefficient.right_endpoint = area_vector[vector_id].right_endpoint;
	//Minimax value  &  Height value
	temp_coefficient.min_point.value = *mmin;
	temp_coefficient.max_point.value = *mmax;
	temp_coefficient.rectangle_height = temp_coefficient.max_point.value - temp_coefficient.min_point.value;

#ifdef _DEBUG
	assert(area_vector[vector_id].rectangle_height >= 0);
#endif

	//Width value
	getRecWidth(area_vector, vector_id, 2, temp_coefficient);

	//temp_coefficient.real_area = area_vector.at(left_id).real_area + area_vector.at(vector_id).real_area;
	//temp_vector.merged_percentage = (area_vector.begin() + vector_id)->rectangle_area / temp_vector.rectangle_area;

	//minimax id
	temp_coefficient.min_point.id = mmin - original_time_series;
	temp_coefficient.max_point.id = mmax - original_time_series;
	temp_coefficient.minmax_distance = fabs(temp_coefficient.max_point.id - temp_coefficient.min_point.id);
	temp_coefficient.minmax_distance = temp_coefficient.rectangle_height == 0 ? 0 : fabs(temp_coefficient.max_point.id - temp_coefficient.min_point.id);

	//Result

	temp_coefficient.real_area = temp_coefficient.rectangle_height * temp_coefficient.minmax_distance;
	temp_coefficient.rectangle_area = temp_coefficient.rectangle_height * temp_coefficient.rectangle_width;
	temp_coefficient.merge_count = area_vector.at(left_id).merge_count + area_vector.at(vector_id).merge_count + 1;
	//temp_coefficient.segment_density = temp_coefficient.minmax_distance / temp_coefficient.rectangle_width;

	/*------------------------------Compute Segment Area----------------------------------------------------------*/
	computeParallelogram(original_time_series, temp_coefficient);//get area of parallelogram for every segment
	//getPolygonArea(original_time_series, temp_coefficient);// get area of polygon for every segment
	//getConvexHullArea(original_time_series, temp_coefficient);// get area of convex hull for every segment
	//getCircleArea(original_time_series, temp_coefficient);// get area of circle for every segment
	/*-----------------------------------------------------------------------------------------------------------*/

	temp_coefficient.getSegmentDensity();

	/*------------------------------Get segment Deviation----------------------------------------------------------*/
	getSegmentDevByPLA(original_time_series, temp_coefficient);// get deviation of every segment
	/*-----------------------------------------------------------------------------------------------------------*/
	/*cout<< "min point:("<< temp_coefficient.min_point.id<<" "<< temp_coefficient.min_point.value<<"), max point:("<< temp_coefficient.max_point.id<<" " << temp_coefficient.max_point.value << ")\n";
	cout << "height: " << temp_coefficient.rectangle_height << endl;
	cout << "minmax_dist: " << temp_coefficient.minmax_distance << ", width: " << temp_coefficient.rectangle_width << endl;*/
	//cout<<"real area: "<<temp_coefficient.real_area<<endl;

	/*------------------------------------Evaluate refreshSegmentCoefficient()----------------------------------------------------------*/
#ifdef _DEBUG
	AREA_COEFFICIENT test_coefficient;
	test_coefficient.rectangle_width = temp_coefficient.rectangle_width;
	test_coefficient.right_endpoint = temp_coefficient.right_endpoint;
	refreshSegmentCoefficient(original_time_series, test_coefficient);
	test_coefficient.compareSegmentCoefficient(temp_coefficient);
#endif
	/*----------------------------------------------------------------------------------------------------------------------------------*/
}

//************************************
// Method:getMergedInfor0ForParallelogram
// Qualifier: right rectangle merge left rectangle
// date:190404
// author:
//************************************
TEMPLATE
void APLA::getMergedInfor0ForParallelogram(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, int& const vector_id, int& const segment_number, AREA_COEFFICIENT& const temp_coefficient) {
#ifdef _DEBUG
	//cout<<
	assert(vector_id > 0);
#endif
	auto left_id = vector_id - 1;
	segment_number = 2;
	//	while (vector_id + 1 < area_vector.size() && area_vector[vector_id].apla.a == area_vector[vector_id + 1].apla.a) {
	//#ifdef _DEBUG
	//		cout << "vector id: " << vector_id << " segment number: " << segment_number << endl;
	//#endif
	//
	//		vector_id++;
	//		segment_number++;
	//	}
	temp_coefficient.right_endpoint = area_vector[vector_id].right_endpoint;
	//Minimax value  &  Height value
	//Width valu
	getRecWidth(area_vector, vector_id, segment_number, temp_coefficient);
	//getRecWidthWidth(area_vector, vector_id, temp_coefficient);//190605
	//temp_coefficient.real_area = area_vector.at(left_id).real_area + area_vector.at(vector_id).real_area;
	//temp_vector.merged_percentage = (area_vector.begin() + vector_id)->rectangle_area / temp_vector.rectangle_area
	//temp_coefficient.merge_count = area_vector.at(left_id).merge_count + area_vector.at(vector_id).merge_count + 1;
	//temp_coefficient.segment_density = temp_coefficient.minmax_distance / temp_coefficient.rectangle_width;
	getAAndBByPLAShortSeg(original_time_series, area_vector, vector_id, temp_coefficient);//get long a&b from short a&b
	//refreshSegmentCoefficient0ForParallelogram(original_time_series, temp_coefficient);//190404

	/*===================Triangle & Trapezoid==================*/
	getLineSegmentTriangleArea(original_time_series, area_vector, vector_id, temp_coefficient);//190528
	getLineSegmentTriangleDensity(temp_coefficient);//190602 Test density.
#if _DEBUG
			//cout << temp_coefficient.rectangle_width<<" "<< temp_coefficient.increment_area <<" segment increment density: " <<temp_coefficient.segment_density << endl;
#endif
	/*.........................................................*/
}

//************************************
// Method:getMergedInfor0ForParallelogramImprove
// Qualifier: right rectangle merge left rectangle, get sum_value, apla, a, b width ,right endpoint, sum value
// Input: Sub left&right segment, right end point, width, a&b
// Output:
// date:190611
// author:
//************************************
TEMPLATE
void APLA::getMergedInfor0ForParallelogramImprove(vector<AREA_COEFFICIENT>& const area_vector, int& const vector_id, AREA_COEFFICIENT& const temp_coefficient) {//180611
#ifdef _DEBUG
	assert(vector_id > 0 && vector_id < area_vector.size() && area_vector[vector_id - 1].rectangle_width != INF && area_vector[vector_id].rectangle_width != INF && area_vector[vector_id - 1].sum_value != INF && area_vector[vector_id].sum_value != INF);
#endif
	/*------------------------------------------Right end point---------------------------------------------*/
	temp_coefficient.right_endpoint = area_vector[vector_id].right_endpoint;
	/*.......................................................................................................*/
	//Minimax value  &  Height value
	/*-------------------------------------------Width Value-------------------------------------------------*/

	if (vector_id < 2) {
		temp_coefficient.rectangle_width = area_vector[vector_id].right_endpoint + 1;
	}
	else {
		temp_coefficient.rectangle_width = area_vector[vector_id - 1].rectangle_width + area_vector[vector_id].rectangle_width;
	}

#ifdef _DEBUG
	double temp_width = INF;
	int rec_num = 2;
	if (vector_id - rec_num < 0) {
		temp_width = area_vector[vector_id].right_endpoint + 1;
	}
	else {
		assert(area_vector[vector_id].right_endpoint > 0 && area_vector[vector_id - rec_num].right_endpoint > 0);
		temp_width = area_vector[vector_id].right_endpoint - area_vector[vector_id - rec_num].right_endpoint;
	}
	assert(temp_width == temp_coefficient.rectangle_width);
#endif
	/*......................................................................................................................*/

	//getAAndBByPLAShortSeg(original_time_series, area_vector, vector_id, temp_coefficient);//get long a&b from short a&b

	//+++ Input: left & right & temp segment, 1 sum value, 2 a&b, 3 width, 4 right endpoint
	//+++ Output: temp segment a&b
	getAAndBByPLAShortSegSpeed(area_vector, vector_id, temp_coefficient);//get long a&b from short a&b and sum value
	//refreshSegmentCoefficient0ForParallelogram(original_time_series, temp_coefficient);//190404

	/*===========PLA, Rectangle PLA area difference, MinMax area difference================*/
	//+++ Input:  left & right & temp segment, a&b, (left & right)min max point, width, right endpoint,
	//+++ Output: PLA, minmax width area difference, temp segment min&max point
	getPLAMinMaxAreaDifference(area_vector, vector_id, temp_coefficient);//190724
	/*....................................................................................*/

	/*===================Triangle & Trapezoid==================*/
	//getLineSegmentTriangleArea(original_time_series, area_vector, vector_id, temp_coefficient);//190528
	//getLineSegmentTriangleDensity(temp_coefficient);//190602 Test density.

	//+++ Input: left & right & temp segment, apla coefficient, a&b, width,
	//+++ Output: Segment Triangle Area Density
	getLineSegmentTriangleAreaDensity(area_vector, vector_id, temp_coefficient);//190611
#if _DEBUG
			//cout << temp_coefficient.rectangle_width<<" "<< temp_coefficient.increment_area <<" segment increment density: " <<temp_coefficient.segment_density << endl;
#endif
	/*.........................................................*/
}

//190825 Use linked list to instead vector
//************************************
// Method:getMergedInfor0ForParallelogramImprove
// Qualifier: right rectangle merge left rectangle, get sum_value, apla, a, b width ,right endpoint, sum value
// Input: Sub left&right segment, right end point, width, a&b
// Output: Use linked list to instead Vector
// date:190825
// author:
//************************************
TEMPLATE
void APLA::getMergedInfor0ForParallelogramImprove(DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list, int& const vector_id, AREA_COEFFICIENT& const temp_coefficient) {//190825
#ifdef _DEBUG
	assert(vector_id > 0 && vector_id < doubly_linked_list.size() && doubly_linked_list[vector_id - 1].sum_value != INF && doubly_linked_list[vector_id].sum_value != INF && doubly_linked_list[vector_id - 1].rectangle_width != INF && doubly_linked_list[vector_id].rectangle_width != INF);
#endif
	/*------------------------------------------Right end point---------------------------------------------*/
	temp_coefficient.right_endpoint = doubly_linked_list[vector_id].right_endpoint;
	/*......................................................................................................*/
	//Minimax value  &  Height value
	/*=========================================Width Value==========================================================*/
	if (vector_id < 2) {
		temp_coefficient.rectangle_width = doubly_linked_list[vector_id].right_endpoint + 1;
	}
	else {
		temp_coefficient.rectangle_width = doubly_linked_list[vector_id - 1].rectangle_width + doubly_linked_list[vector_id].rectangle_width;
	}

#ifdef _DEBUG
	double temp_width = INF;
	int rec_num = 2;
	if (vector_id - rec_num < 0) {
		temp_width = doubly_linked_list[vector_id].right_endpoint + 1;
	}
	else {
		assert(doubly_linked_list[vector_id].right_endpoint > 0 && doubly_linked_list[vector_id - rec_num].right_endpoint > 0);
		temp_width = doubly_linked_list[vector_id].right_endpoint - doubly_linked_list[vector_id - rec_num].right_endpoint;
	}
	assert(temp_width == temp_coefficient.rectangle_width);
#endif
	/*......................................................................................................................*/

	//getAAndBByPLAShortSeg(original_time_series, area_vector, vector_id, temp_coefficient);//get long a&b from short a&b

	//+++ Input: left & right & temp segment, sum value, a&b, width, right endpoint
	//+++ Output: temp segment a & b
	getAAndBByPLAShortSegSpeed(doubly_linked_list, vector_id, temp_coefficient);//get long a&b from short a&b and sum value
	//refreshSegmentCoefficient0ForParallelogram(original_time_series, temp_coefficient);//190404

	/*===========PLA, Rectangle PLA area difference, MinMax area difference================*/
	//+++ Input:  left & right & temp segment, a&b, (left & right)min max point, width, right endpoint,
	//+++ Output: PLA, minmax width area difference, temp segment min&max point
	getPLAMinMaxAreaDifference(doubly_linked_list, vector_id, temp_coefficient);//190724
	/*....................................................................................*/

	/*===================Triangle & Trapezoid==================*/
	//getLineSegmentTriangleArea(original_time_series, area_vector, vector_id, temp_coefficient);//190528
	//getLineSegmentTriangleDensity(temp_coefficient);//190602 Test density.

	//+++ Input: left & right & temp segment, apla coefficient, a&b, width,
	//+++ Output: Segment Triangle Area Density
	getLineSegmentTriangleAreaDensity(doubly_linked_list, vector_id, temp_coefficient);//190611
#if _DEBUG
			//cout << temp_coefficient.rectangle_width<<" "<< temp_coefficient.increment_area <<" segment increment density: " <<temp_coefficient.segment_density << endl;
#endif
	/*.........................................................*/
}

//190904
//190825 Use linked list to instead vector
//************************************
// Method:getMergedSubSegmentInformation
// Qualifier: right rectangle merge left rectangle, get 1 sum_value, 2 a&b width, 3 right endpoint, 4 min&max point
// Input: Sub left&right segment: 1right end point, 2width, 3a&b
// Output: get 1 sum_value, 2 a&b width, 3 right endpoint, 4 min&max point 5 area difference, 6 segment density
// date:190904
// author:
//************************************
TEMPLATE
double APLA::getMergedSubSegmentInformation(DoublyListNode<AREA_COEFFICIENT>& const node) {
	if (!node._prev) return -INF;
#if _DEBUG
	assert(node._prev->_value.sum_value != INF && node._value.sum_value != INF && node._prev->_value.rectangle_width != INF && node._value.rectangle_width != INF);
#endif
	const auto& const left_segment = node._prev->_value;
	const auto& const right_segment = node._value;
	auto& const merged_segment = node._value.right_subsegment;

	merged_segment->right_endpoint = right_segment.right_endpoint;

	//Minimax value  &  Height value
	/*=========================================Width Value==========================================================*/
	if (node._prev->_prev == nullptr) {
		merged_segment->rectangle_width = right_segment.right_endpoint + 1;
	}
	else {
		merged_segment->rectangle_width = left_segment.rectangle_width + right_segment.rectangle_width;
	}


#ifdef _DEBUG
	double temp_width = INF;
	if (node._prev->_prev == nullptr) {
		temp_width = right_segment.right_endpoint + 1;
	}
	else {
		assert(right_segment.right_endpoint > 0 && node._prev->_prev->_value.right_endpoint > 0);
		temp_width = right_segment.right_endpoint - node._prev->_prev->_value.right_endpoint;
	}
	assert(temp_width == merged_segment->rectangle_width);
#endif
	/*===============================================================================================================*/

	//190905
	//+++ Input: left & right & temp segment, sum value, a&b, width, right endpoint
	//+++ Output: temp segment a & b
	getAAndBByPLAShortSegSpeed(left_segment, right_segment, *merged_segment);//get long a&b from short a&b and sum value

	/*===========PLA, Rectangle PLA area difference, MinMax area difference================*/
	//+++ Input:  left & right & temp segment, a&b, (left & right)min max point, width, right endpoint,
	//+++ Output: PLA, minmax width area difference, temp segment min&max point
	getPLAMinMaxAreaDifference(left_segment, right_segment, *merged_segment);//190905
	/*....................................................................................*/

	/*===================Triangle & Trapezoid==================*/
	//getLineSegmentTriangleArea(original_time_series, area_vector, vector_id, temp_coefficient);//190528
	//getLineSegmentTriangleDensity(temp_coefficient);//190602 Test density.

	//+++ Input: left & right & temp segment, apla coefficient, a&b, width,
	//+++ Output: Segment Triangle Area Density
	return getLineSegmentTriangleAreaDensity(left_segment, right_segment, *merged_segment);//190611
}

//190918
//190825 Use linked list to instead vector
//************************************
// Method:getMergedSubSegmentInformation
// Qualifier: right rectangle merge left rectangle, get 1 sum_value, 2 a&b width, 3 right endpoint, 4 min&max point
// Input: Sub left&right segment: 1right end point, 2width, 3a&b
// Output: get 1 sum_value, 2 a&b width, 3 right endpoint, 4 min&max point 5 area difference, 6 segment density
// date:190904
// author:
//************************************
TEMPLATE
double APLA::getMergedSubSegmentInformation(DataType*& const original_time_series, DoublyListNode<AREA_COEFFICIENT>& const node) {
	if (!node._prev) return -INF;
#if _DEBUG
	assert(node._prev->_value.sum_value != INF && node._value.sum_value != INF && node._prev->_value.rectangle_width != INF && node._value.rectangle_width != INF && node._value.right_endpoint != INF);
	assert(node._prev->_value.right_endpoint != INF && node._prev->_value.rectangle_width != INF && node._prev->_value.sum_value != INF);
#endif
	const auto& const left_segment = node._prev->_value;
	const auto& const right_segment = node._value;
	auto& const merged_segment = node._value.right_subsegment;

	merged_segment->right_endpoint = node._value.right_endpoint;

	/*=========================================Width Value==========================================================*/
	if (node._prev->_prev == nullptr) {
		merged_segment->rectangle_width = right_segment.right_endpoint + 1;
	}
	else {
		merged_segment->rectangle_width = left_segment.rectangle_width + right_segment.rectangle_width;
	}

#ifdef _DEBUG
	double temp_width = INF;
	if (node._prev->_prev == nullptr) {
		temp_width = right_segment.right_endpoint + 1;
	}
	else {
		assert(right_segment.right_endpoint > 0 && node._prev->_prev->_value.right_endpoint > 0);
		temp_width = right_segment.right_endpoint - node._prev->_prev->_value.right_endpoint;
	}
	assert(temp_width == merged_segment->rectangle_width);
	assert(left_segment.min_point.id != INF && left_segment.min_point.value != INF && right_segment.min_point.id != INF && right_segment.min_point.value != INF);
#endif
	/*================================================================================================================*/

	/*===================== 200109 Deflete in the future Min & Max Point====================*/
	//getSegmentMinMaxPoint(original_time_series, merged_segment);
	merged_segment->min_point = left_segment.min_point.value < right_segment.min_point.value ? left_segment.min_point : right_segment.min_point;
	merged_segment->max_point = left_segment.max_point.value > right_segment.max_point.value ? left_segment.max_point : right_segment.max_point;
#ifdef _DEBUG
	int merged_segment_left_id = merged_segment->right_endpoint - merged_segment->rectangle_width + 1;
	assert(merged_segment->min_point.value <= merged_segment->max_point.value && merged_segment->min_point.id <= merged_segment->right_endpoint && merged_segment->max_point.id <= merged_segment->right_endpoint && merged_segment->min_point.id >= merged_segment_left_id && merged_segment->max_point.id >= merged_segment_left_id);
	//if(merged_segment.min_point.value == merged_segment.max_point.value)assert(merged_segment.min_point.id < merged_segment.max_point.id);
#endif
	/*=====================================================================================*/
	//190905
	//+++ Input: left & right & temp segment, sum value, a&b, width, right endpoint
	//+++ Output: temp segment a & b
	getAAndBByPLAShortSegSpeed(left_segment, right_segment, *merged_segment);//get long a&b from short a&b and sum value

	/*===========PLA, Rectangle PLA area difference, MinMax area difference================*/
	//+++ Input:  left & right & temp segment, a&b, (left & right)min max point, width, right endpoint,
	//+++ Output: 1 PLA, minmax width area difference. 2 Temp segment min&max point
	//getPLAMinMaxAreaDifference(left_segment, right_segment, *merged_segment);//190905
	getAreaDifference(original_time_series, *merged_segment);
	/*....................................................................................*/

	/*===================Triangle & Trapezoid==================*/
	//getLineSegmentTriangleArea(original_time_series, area_vector, vector_id, temp_coefficient);//190528
	//getLineSegmentTriangleDensity(temp_coefficient);//190602 Test density.

	//+++ Input: left & right & temp segment, apla coefficient, a&b, width,
	//+++ Output: Segment Triangle Area Density
	return getLineSegmentTriangleAreaDensity(left_segment, right_segment, *merged_segment);//190611
}

//200212 time series from pointer to vector. Add template
//190825 Use linked list to instead vector
//************************************
// Method:getMergedSubSegmentInformation
// Qualifier: right rectangle merge left rectangle, get 1 sum_value, 2 a&b width, 3 right endpoint, 4 min&max point
// Input: Sub left&right segment: 1right end point, 2width, 3a&b
// Output: get 1 sum_value, 2 a&b width, 3 right endpoint, 4 min&max point 5 area difference, 6 segment density
// Notice:
// date:200212
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
double APLA::getMergedSubSegmentInformation(const vector<T>& const original_time_series_vector, DoublyListNode<Y>& const node, U& const output_argument) {
	if (!node._prev) return -INF;
#if _DEBUG
	//200316 sum value
	//assert(node._prev->_value.sum_value != INF && node._value.sum_value != INF && && node._prev->_value.sum_value != INF);
	assert(node._prev->_value.rectangle_width != INF && node._value.rectangle_width != INF && node._value.right_endpoint != INF);
	assert(node._prev->_value.right_endpoint != INF && node._prev->_value.rectangle_width != INF);
#endif
	const auto& const left_segment = node._prev->_value;
	const auto& const right_segment = node._value;
	auto& const merged_segment = node._value.right_subsegment;

	merged_segment->right_endpoint = right_segment.right_endpoint;

	/*=========================================Width Value==========================================================*/
	if (node._prev->_prev == nullptr) {
		merged_segment->rectangle_width = right_segment.right_endpoint + 1;
	}
	else {
		merged_segment->rectangle_width = left_segment.rectangle_width + right_segment.rectangle_width;
	}

#ifdef _DEBUG
	double temp_width = INF;
	if (node._prev->_prev == nullptr) {
		temp_width = right_segment.right_endpoint + 1;
	}
	else {
		assert(right_segment.right_endpoint > 0 && node._prev->_prev->_value.right_endpoint > 0);
		temp_width = right_segment.right_endpoint - node._prev->_prev->_value.right_endpoint;
	}
	assert(temp_width == merged_segment->rectangle_width);
	//200314 minmax point
	//assert(left_segment.min_point.id != INF && left_segment.min_point.value != INF && right_segment.min_point.id != INF && right_segment.min_point.value != INF);
#endif
	/*================================================================================================================*/

	/*=====================   200109 Long segment Min & Max Point      ====================*/
	//200314 minmax point 210203
	//get_long_segment_minmax_by_sub_segments(left_segment, right_segment, *merged_segment);
	/*======================================================================================*/

	/*=======================     200109 Long segment a&b         =========================*/
	//190905
	//+++ Input: left & right & temp segment, sum value, a&b, width, right endpoint
	//+++ Output: temp segment a & b
	getAAndBByPLAShortSegSpeed(left_segment, right_segment, *merged_segment);//get long a&b from short a&b and sum value
	/*=====================================================================================*/

	/*--------------------    210112 compute upper bound   --------------------------------*/
	get_line_segment_height_diference_with_original(original_time_series_vector, left_segment, right_segment, *merged_segment, output_argument);
	/*-------------------------------------------------------------------------------------*/

	/*===========PLA, Rectangle PLA area difference, MinMax area difference================*/
	//+++ Input:  left & right & temp segment, a&b, (left & right)min max point, width, right endpoint,
	//+++ Output: 1 PLA, minmax width area difference. 2 Temp segment min&max point
	//getPLAMinMaxAreaDifference(left_segment, right_segment, *merged_segment);//190905
	//getAreaDifference(original_time_series_vector, *merged_segment); //210203
	/*=====================================================================================*/

	/*===================       Triangle & Trapezoid Density/Area        ==================*/
	//getLineSegmentTriangleArea(original_time_series, area_vector, vector_id, temp_coefficient);//190528
	//getLineSegmentTriangleDensity(temp_coefficient);//190602 Test density.
	//+++ Input: left & right & temp segment, apla coefficient, a&b, width,
	//+++ Output: Segment Triangle Area Density
	//210119
	return getLineSegmentTriangleAreaDensity(left_segment, right_segment, *merged_segment);//190611
	//210120
	/*assert_merge_deviation(original_time_series_vector, left_segment, right_segment, *merged_segment);
	getLineSegmentTriangleAreaDensity(left_segment, right_segment, *merged_segment);
	return merged_segment->segment_density;*/
	//210119
	/*getLineSegmentTriangleAreaDensity(left_segment, right_segment, *merged_segment);
	assert(merged_segment->area_difference == merged_segment->bound.upper_bound_area);
	return merged_segment->segment_density = merged_segment->area_difference;*/
	/*=====================================================================================*/
}

//201030 time series from pointer to vector. Add template
//************************************
// Method:getMergedSubSegmentInformation
// Qualifier: right rectangle merge left rectangle, get 1 sum_value, 2 a&b width, 3 right endpoint, 4 min&max point
// Input: Sub left&right segment: 1right end point, 2width, 3a&b
// Output: get 1 sum_value, 2 a&b width, 3 right endpoint, 4 min&max point 5 area difference, 6 segment density
// Notice:
// date:200212
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
double APLA::getMergedSubSegmentInformation(const vector<T>& const original_time_series_vector, Y& const left_segment, Y& const right_segment, Y& const merged_segment, U& const output_argument) {

	if (right_segment.rectangle_width == right_segment.right_endpoint + 1) return -INF;

	/*....................................................................*/
#if _DEBUG
	/*assert_segment_a_b_minmax(original_time_series_vector, left_segment);
	assert_segment_a_b_minmax(original_time_series_vector, right_segment);*/
	assert_segment_a_b(original_time_series_vector, left_segment);
	assert_segment_a_b(original_time_series_vector, right_segment);
#endif
	/*....................................................................*/

	merged_segment.right_endpoint = right_segment.right_endpoint;

	/*=====================================        Width Value      =====================================*/
	if (left_segment.rectangle_width == left_segment.right_endpoint + 1) {
		merged_segment.rectangle_width = merged_segment.right_endpoint + 1;
	}
	else {
		merged_segment.rectangle_width = left_segment.rectangle_width + right_segment.rectangle_width;
	}
	/*===================================================================================================*/

	/*=====================   200109 Long segment Min & Max Point      ====================*/
	//200314 minmax point 210203
	//get_long_segment_minmax_by_sub_segments(left_segment, right_segment, merged_segment);
	/*======================================================================================*/

	/*=======================     200109 Long segment a&b         =========================*/
	//190905
	//+++ Input: left & right & temp segment, sum value, a&b, width, right endpoint
	//+++ Output: temp segment a & b
	getAAndBByPLAShortSegSpeed(left_segment, right_segment, merged_segment);//get long a&b from short a&b and sum value
	/*=====================================================================================*/

	/*------------------------------ 210113 compute upper bound ---------------------------*/
	get_line_segment_height_diference_with_original(original_time_series_vector, left_segment, right_segment, merged_segment, output_argument);
	/*-------------------------------------------------------------------------------------*/

	/*===========PLA, Rectangle PLA area difference, MinMax area difference================*/
	//+++ Input:  left & right & temp segment, a&b, (left & right)min max point, width, right endpoint,
	//+++ Output: 1 PLA, minmax width area difference. 2 Temp segment min&max point
	//getPLAMinMaxAreaDifference(left_segment, right_segment, *merged_segment);//190905

	//getAreaDifference(original_time_series_vector, merged_segment); //210203
	/*=====================================================================================*/

	/*===================       Triangle & Trapezoid Density/Area        ==================*/
	//getLineSegmentTriangleArea(original_time_series, area_vector, vector_id, temp_coefficient);//190528
	//getLineSegmentTriangleDensity(temp_coefficient);//190602 Test density.
	//+++ Input: left & right & temp segment, apla coefficient, a&b, width,
	//+++ Output: Segment Triangle Area Density
	//210119
	return getLineSegmentTriangleAreaDensity(left_segment, right_segment, merged_segment);//190611
	//210120
	//assert_merge_deviation(original_time_series_vector, left_segment, right_segment, merged_segment);
	//getLineSegmentTriangleAreaDensity(left_segment, right_segment, merged_segment);
	////evaluate_segment_sum_deviation_vs_triangle_area(original_time_series_vector, merged_segment);
	//return merged_segment.segment_density;
	//210119
	/*getLineSegmentTriangleAreaDensity(left_segment, right_segment, merged_segment);
	assert(merged_segment.area_difference == merged_segment.bound.upper_bound_area);
	return merged_segment.segment_density = merged_segment.area_difference;*/
	/*=====================================================================================*/
}

//************************************
// Method:getMergedInfor0ForParallelogramArray
// Qualifier: Use array to instead vector, speed algorithm
// date:190418
// author:
//************************************
TEMPLATE
void APLA::getMergedInfor0ForParallelogramArray(DataType*& const original_time_series, SEGMENT_COEFFICIENT*& area_vector, int& const vector_id, SEGMENT_COEFFICIENT& const temp_coefficient) {//190418
#ifdef _DEBUG
//cout<<
	assert(vector_id > 0);
#endif

	auto left_id = vector_id - 1;

	//	while (vector_id + 1 < area_vector.size() && area_vector[vector_id].apla.a == area_vector[vector_id + 1].apla.a) {
	//#ifdef _DEBUG
	//		cout << "vector id: " << vector_id << " segment number: " << segment_number << endl;
	//#endif
	//
	//		vector_id++;
	//		segment_number++;
	//	}

	temp_coefficient.right_endpoint = area_vector[vector_id].right_endpoint;
	//Minimax value  &  Height value
	//Width valu
	getRecWidth(area_vector, vector_id, temp_coefficient);

	//temp_coefficient.real_area = area_vector.at(left_id).real_area + area_vector.at(vector_id).real_area;
	//temp_vector.merged_percentage = (area_vector.begin() + vector_id)->rectangle_area / temp_vector.rectangle_area
	//temp_coefficient.merge_count = area_vector.at(left_id).merge_count + area_vector.at(vector_id).merge_count + 1;
	//temp_coefficient.segment_density = temp_coefficient.minmax_distance / temp_coefficient.rectangle_width;

	getAAndBByPLAShortSegArray(original_time_series, area_vector, vector_id, temp_coefficient);

	refreshSegmentCoefficient0ForParallelogram(original_time_series, temp_coefficient);//190404
}

//************************************
// Method:computeParallelogram
// Qualifier: Get PLA a&b, parallelogram area and deviation point of Parallelogram
// date:190102
// author:
//************************************
TEMPLATE
double& APLA::computeParallelogram(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient) {//190102
#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width != NULL);
#endif

	double b = NULL;//y=ax+b;
	int segment_left_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	auto right_endpoint_id = temp_coefficient.right_endpoint;

	if (temp_coefficient.rectangle_width == 2) {
		temp_coefficient.parallelogram_height = 0;
		temp_coefficient.segment_density = INF;
		//temp_coefficient.deviation_point.id = temp_coefficient.max_point.id;
		return temp_coefficient.rectangle_area = 0;
	}

	deque<DataType> left_y_array;
	deque<DataType> test_deviation_array;
	//deque<DataType> left_y_array0;
	//deque<DataType> right_y_array;
	typename GEOMETRY::POINT  up_deviation_point;
	typename GEOMETRY::POINT  down_deviation_point;

	//cout << "Original time series: ";
	//for (int i = segment_left_id; i <= right_endpoint_id; i++) {
		//cout <<i<<" "<< original_time_series[i] << "; ";
	//}
	//cout << endl;
	//cout << "Restruct: " << endl;
	//a = (temp_coefficient.max_point.value-temp_coefficient.min_point.value)/(temp_coefficient.max_point.id - temp_coefficient.min_point.id);
	auto a = getAAndBByPLA(original_time_series, temp_coefficient);//compute PLA a

#ifdef _DEBUG
	assert(a == temp_coefficient.apla.a);
#endif

	for (int array_id = segment_left_id, zero_id = 0; array_id <= right_endpoint_id; array_id++, zero_id++) {
		//b = original_time_series[array_id] - a * array_id;
		double left_y0 = a * (0 - zero_id) + original_time_series[array_id];
		double point_deviation = a * zero_id + temp_coefficient.apla.b - original_time_series[array_id];
#ifdef _DEBUG
		//cout << a * zero_id + temp_coefficient.apla.b << ",";
		double left_y = a * (segment_left_id - array_id) + original_time_series[array_id];//y_2=a*(x_2-x_1)+y_1
		assert(left_y == left_y0);
		assert(0 - zero_id == segment_left_id - array_id && left_y0 - original_time_series[array_id] == left_y - original_time_series[array_id]);
#endif
		//left_y_array0.push_back(left_y0);
		//cout <<"left_y: "<< left_y0 << endl;
		left_y_array.push_back(left_y0);
		test_deviation_array.push_back(point_deviation);
	}
	//cout << endl;
	auto left_projection_point = minmax_element(left_y_array.begin(), left_y_array.end());
	auto test_deviaion_point = minmax_element(test_deviation_array.begin(), test_deviation_array.end());

	//**get parallelogram height & base and area.
	//sort(left_y_array.begin(), left_y_array.end());
	//auto parallelogram_base_value0 = minmax_element(left_y_array0.begin(), left_y_array0.end());
	temp_coefficient.parallelogram_height = *test_deviaion_point.second - *test_deviaion_point.first;
	//cout << "!!!!!!!: " << *left_projection_point.second << " " << *left_projection_point.first << " " << original_time_series[segment_left_id] << endl;
#ifdef _DEBUG
	//assert(float(*test_deviaion_point.second) >= 0 && float(*test_deviaion_point.first) <= 0);
	double test_height = *left_projection_point.second - *left_projection_point.first;
	//assert(float(test_height) == float(temp_coefficient.parallelogram_height));
#endif
	//assert(temp_coefficient.parallelogram_height!=NULL);

	/*============================================================================================================================*/
	//get split point For some rectangle, we have to split it to two small rectangle to reduce deviation.
	up_deviation_point.id = left_projection_point.second - left_y_array.begin() + segment_left_id;
	up_deviation_point.value = fabs(*left_projection_point.second - original_time_series[int(segment_left_id)]);//height
	up_deviation_point.value = fabs(*left_projection_point.second - temp_coefficient.apla.b);//height
	down_deviation_point.id = left_projection_point.first - left_y_array.begin() + segment_left_id;
	down_deviation_point.value = fabs(*left_projection_point.first - original_time_series[int(segment_left_id)]);//height
	down_deviation_point.value = fabs(*left_projection_point.first - temp_coefficient.apla.b);//height
	temp_coefficient.deviation_point.id = down_deviation_point.value > up_deviation_point.value ? down_deviation_point.id : up_deviation_point.id;
	auto temp_left_deviation = max(up_deviation_point.value, down_deviation_point.value);
	//assert(temp_left_deviation == *test_deviaion_point.second);
	//cout << "ORI parallelogram_height:" << temp_coefficient.parallelogram_height<<"deviation point id: "<< temp_coefficient.deviation_point.id <<" down_deviation_point value: "<< down_deviation_point.value <<"up_deviation_point value"<< up_deviation_point.value << endl;
	//cout << "down_deviation_point.id: " << down_deviation_point.id << ";    up_deviation_point.id: " << up_deviation_point.id << ". down_deviation_point.value: " << down_deviation_point.value << ";    up_deviation_point.value: " << up_deviation_point.value << endl;
	/*.................................................................................................................................*/

	//assert(*parallelogram_base_value.second - *parallelogram_base_value.first == *parallelogram_base_value0.second - *parallelogram_base_value0.first);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//for (int array_id = left_endpoint_id; array_id <= right_endpoint_id; array_id++) {
	//	//b = original_time_series[array_id] - a * array_id;
	//	double right_y = a * (right_endpoint_id - array_id) + original_time_series[array_id];//y_2=a*(x_2-x_1)+y_1
	//	right_y_array.push_back(right_y);
	//}
	//sort(left_y_array.begin(), left_y_array.end());
	//auto parallelogram_base_value0 = minmax_element(right_y_array.begin(), right_y_array.end());
	//cout << *parallelogram_base_value.second << " " << *parallelogram_base_value.first << " "<< *parallelogram_base_value.second - *parallelogram_base_value.first << endl;
	//cout << *parallelogram_base_value0.second << " "<< *parallelogram_base_value0.first <<" " <<*parallelogram_base_value0.second - *parallelogram_base_value0.first <<endl;
	//assert(*parallelogram_base_value.second - *parallelogram_base_value.first == *parallelogram_base_value0.second -  *parallelogram_base_value0.first);
	//auto test = temp_coefficient.parallelogram_height * temp_coefficient.rectangle_width;

	return temp_coefficient.rectangle_area = temp_coefficient.parallelogram_height * temp_coefficient.rectangle_width;
}

//************************************
// Method:computeParallelogramNoProjection
// Qualifier: Get PLA a&b, parallelogram area and deviation point of Parallelogram not project the deviaiton point to the left segment endpoint
// date:190404
// author:
//************************************
TEMPLATE
double& APLA::computeParallelogramNoProjection(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient) {//190404 the funciton is the same with above, only improve the process, not project the deviaiton point to the left segment.
#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width != NULL);
	assert(temp_coefficient.rectangle_width >= 2);
#endif
	typename GEOMETRY::POINT deviation_point(NULL, NULL);
	double temp_deviation = INF;
	int original_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	//getAAndBByPLA(original_time_series, temp_coefficient);// get PLA: a & b of segment.

	if (temp_coefficient.rectangle_width == 2) {
		temp_coefficient.parallelogram_height = fabs(original_time_series[int(temp_coefficient.right_endpoint)] - original_time_series[original_id]);
		temp_coefficient.rec_deviation = 0;
		temp_coefficient.deviation_point.id = temp_coefficient.max_point.id;
		return temp_coefficient.rectangle_area = fabs(original_time_series[int(temp_coefficient.right_endpoint)] - original_time_series[original_id]);
	}

	//assert(temp_coefficient.apla.a >= 0 && temp_coefficient.apla.b >= 0);

	temp_coefficient.rec_deviation = 0;
	//temp_coefficient.sum_difference = 0;
	for (int i = 0; i < temp_coefficient.rectangle_width; i++) {
		temp_deviation = fabs(temp_coefficient.apla.a * i + temp_coefficient.apla.b - original_time_series[original_id + i]);
		//temp_coefficient.sum_difference += temp_coefficient.apla.a * i + temp_coefficient.apla.b - original_time_series[original_id + i];
		if (temp_deviation > deviation_point.value) {
			deviation_point.id = original_id + i;
			deviation_point.value = temp_deviation;
		}

		temp_coefficient.rec_deviation += temp_deviation * temp_deviation;
	}
	//cout << endl;

	temp_coefficient.deviation_point.id = deviation_point.id;
	temp_coefficient.parallelogram_height = deviation_point.value;
	temp_coefficient.rec_deviation = sqrt(temp_coefficient.rec_deviation);//Do not need deviaition

	/*======================================Test Part=============================================================*/
	double deviation_coefficient = temp_coefficient.rectangle_width * (temp_coefficient.rectangle_width - 1) / 2.0;//n*(n-1)/2
	//cout << deviation_coefficient << endl;
	double deviation_coefficient0 = temp_coefficient.apla.a * deviation_coefficient;
	//cout << deviation_coefficient0 << endl;
	double deviation_coefficient1 = temp_coefficient.apla.b * temp_coefficient.rectangle_width;
	//cout << deviation_coefficient1 << endl;
	double sum = deviation_coefficient0 + deviation_coefficient1;
	//cout << sum << endl;
	//cout << temp_coefficient.sum_value << endl;
	double segment_deviation = deviation_coefficient0 + deviation_coefficient1 - temp_coefficient.sum_value;//190523
	//cout << segment_deviation << endl;
	//assert(segment_deviation == temp_coefficient.sum_difference);
		//temp_coefficient.rec_deviation);
	/*...........................................................................................................*/
#ifdef _DEBUG
	//cout <<"Segment deviation: "<< temp_coefficient.rec_deviation << " parallelogram_height: " << temp_coefficient.parallelogram_height<< " deviation point id: " << temp_coefficient.deviation_point.id << endl;
#endif
	return temp_coefficient.rectangle_area = temp_coefficient.parallelogram_height * temp_coefficient.rectangle_width;
}

//************************************
// Method:computeParallelogramNoProjection
// Qualifier: Get PLA a&b, parallelogram area and deviation point of Parallelogram not project the deviaiton point to the left segment endpoint
// date:190404
// author:
//************************************
TEMPLATE
double& APLA::computeParallelogramNoProjection(DataType*& const original_time_series, SEGMENT_COEFFICIENT& const temp_coefficient) {//190419 the funciton is the same with above, only improve the process, not project the deviaiton point to the left segment.
#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width != NULL);
	assert(temp_coefficient.rectangle_width >= 2);
#endif
	typename GEOMETRY::POINT deviation_point(NULL, NULL);
	double temp_deviation = INF;
	int original_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	//getAAndBByPLA(original_time_series, temp_coefficient);// get PLA: a & b of segment.

	if (temp_coefficient.rectangle_width == 2) {
		temp_coefficient.parallelogram_height = fabs(original_time_series[int(temp_coefficient.right_endpoint)] - original_time_series[original_id]);
		temp_coefficient.rec_deviation = 0;
		temp_coefficient.deviation_point.id = temp_coefficient.max_point.id;
		return temp_coefficient.rectangle_area = fabs(original_time_series[int(temp_coefficient.right_endpoint)] - original_time_series[original_id]);
	}

	//assert(temp_coefficient.apla.a >= 0 && temp_coefficient.apla.b >= 0);

	temp_coefficient.rec_deviation = 0;
	for (int i = 0; i < temp_coefficient.rectangle_width; i++) {
		temp_deviation = fabs(temp_coefficient.apla.a * i + temp_coefficient.apla.b - original_time_series[original_id + i]);

		if (temp_deviation > deviation_point.value) {
			deviation_point.id = original_id + i;
			deviation_point.value = temp_deviation;
		}

		temp_coefficient.rec_deviation += temp_deviation * temp_deviation;
	}

	temp_coefficient.deviation_point.id = deviation_point.id;
	temp_coefficient.parallelogram_height = deviation_point.value;
	temp_coefficient.rec_deviation = sqrt(temp_coefficient.rec_deviation);//Do not need deviaition
#ifdef _DEBUG
	//cout <<"Segment deviation: "<< temp_coefficient.rec_deviation << " parallelogram_height: " << temp_coefficient.parallelogram_height<< " deviation point id: " << temp_coefficient.deviation_point.id << endl;
#endif
	return temp_coefficient.rectangle_area = temp_coefficient.parallelogram_height * temp_coefficient.rectangle_width;
}

//************************************
// Method:compareAreaPercentage
// Qualifier: right rectangle merge left rectangle
// date:181122
// author:
//************************************
//TEMPLATE
//void APLA::compareAreaPercentage(vector<AREA_COEFFICIENT>& area_vector, const int vector_id) {//181122
//	int left_id = vector_id - 1;
//	int right_id = vector_id + 1;
//	AREA_COEFFICIENT temp_left_vector, temp_right_vector;
//	double left_percentage=NULL;
//	double right_percentage=NULL;
//	double temp_right_area = NULL, temp_left_area = NULL;
//	double temp_left_heightest_value = NULL, temp_right_heightest_value = NULL, temp_left_lowest_value = NULL, temp_right_lowest_value = NULL;
//
//	double temp_left_heightest_id = NULL, temp_right_heightest_id = NULL, temp_left_lowest_id = NULL, temp_right_lowest_id = NULL;
//	//double temp_left_minimax_dist = NULL;
//	//double temp_right_minimax_dist = NULL;
//	double temp_minimax_dist = fabs((area_vector.begin() + vector_id)->heightest_id - (area_vector.begin() + vector_id)->lowest_id);
//
//
//	if (vector_id >= 1) {
//		//cout << "left id: " << left_id << ", right id: " << right_id << endl;
//		//Right percentage
//		temp_right_heightest_value = max((area_vector.begin() + right_id)->heightest_value, (area_vector.begin() + vector_id)->heightest_value);
//		temp_right_vector.heightest_value = max((area_vector.begin() + right_id)->heightest_value, (area_vector.begin() + vector_id)->heightest_value);
//		temp_right_lowest_value = min((area_vector.begin() + right_id)->lowest_value, (area_vector.begin() + vector_id)->lowest_value);
//		temp_right_area = (temp_right_heightest_value - temp_right_lowest_value) * ((area_vector.begin() + right_id)->right_endpoint - (area_vector.begin() + left_id)->right_endpoint - 1);
//		right_percentage = (area_vector.begin() + vector_id)->rectangle_area / temp_right_area;
//		//Left percentage
//		temp_left_heightest_value = max((area_vector.begin() + vector_id)->heightest_value, (area_vector.begin() + left_id)->heightest_value);
//		temp_left_lowest_value = min((area_vector.begin() + vector_id)->lowest_value, (area_vector.begin() + left_id)->lowest_value);
//		if(vector_id == 1)
//			temp_left_area = (temp_left_heightest_value - temp_left_lowest_value) * (area_vector.begin() + 1)->right_endpoint;
//		else
//			temp_left_area = (temp_left_heightest_value - temp_left_lowest_value) * ((area_vector.begin() + vector_id)->right_endpoint - (area_vector.begin() + left_id - 1)->right_endpoint - 1);
//
//		left_percentage = (area_vector.begin() + vector_id)->rectangle_area / temp_left_area;
//
//
//		//For the minimum and maximum id distance
//		if ((area_vector.begin() + right_id)->heightest_value >= (area_vector.begin() + vector_id)->heightest_value) {//max
//			temp_right_heightest_id = (area_vector.begin() + right_id)->heightest_id;
//		}
//		else {
//			temp_right_heightest_id = (area_vector.begin() + vector_id)->heightest_id;
//		}
//
//		if ((area_vector.begin() + right_id)->lowest_value <= (area_vector.begin() + vector_id)->lowest_value) {//lowest
//			temp_right_lowest_id = (area_vector.begin() + right_id)->lowest_id;
//		}
//		else {
//			temp_right_lowest_id = (area_vector.begin() + vector_id)->lowest_id;
//		}
//
//		temp_left_heightest_id = (area_vector.begin() + left_id)->heightest_value >= (area_vector.begin() + vector_id)->heightest_value ? (area_vector.begin() + left_id)->heightest_id : (area_vector.begin() + vector_id)->heightest_id;
//		temp_left_lowest_id = (area_vector.begin() + left_id)->lowest_value <= (area_vector.begin() + vector_id)->lowest_value ? (area_vector.begin() + left_id)->lowest_id : (area_vector.begin() + vector_id)->lowest_id;
//
//
//		if (left_percentage > right_percentage) {
//			//cout << "Merge left:" << left_id << endl;
//			mergeRectangle(area_vector, vector_id, temp_left_heightest_id, temp_left_lowest_id);
//		}
//		else if(left_percentage < right_percentage) {
//			//cout << "Merge right:" << right_id  << endl;
//			mergeRectangle(area_vector, right_id, temp_right_heightest_id, temp_right_lowest_id);
//		}
//		//area_vector.erase(area_vector.begin() + left_id);
//	}
//	else if (vector_id == 0) {
//		assert(0);
//		(area_vector.begin() + 1)->heightest_value = max(area_vector.begin()->heightest_value, (area_vector.begin() + 1)->heightest_value);
//		(area_vector.begin() + 1)->lowest_value = min(area_vector.begin()->lowest_value, (area_vector.begin() + 1)->lowest_value);
//		(area_vector.begin() + 1)->rectangle_area = ((area_vector.begin() + 1)->heightest_value - (area_vector.begin() + 1)->lowest_value) * (area_vector.begin() + 1)->right_endpoint;
//		area_vector.erase(area_vector.begin());
//	}
//	else if (right_id == area_vector.size()) {
//		assert(0);
//		//cout << "end id: " <<  vector_id << endl;
//		(area_vector.begin() + vector_id)->heightest_value = max((area_vector.begin() + vector_id)->heightest_value, (area_vector.begin() + left_id)->heightest_value);
//		(area_vector.begin() + vector_id)->lowest_value = min((area_vector.begin() + vector_id)->lowest_value, (area_vector.begin() + left_id)->lowest_value);
//		(area_vector.begin() + vector_id)->rectangle_area = ((area_vector.begin() + vector_id)->heightest_value - (area_vector.begin() + vector_id)->lowest_value) * ((area_vector.begin() + vector_id)->right_endpoint - (area_vector.begin() + left_id - 1)->right_endpoint - 1);
//		area_vector.erase(area_vector.end());
//	}
//	else {
//		assert(0);
//	}
//}

TEMPLATE
std::vector <typename GEOMETRY::POINT> APLA::getPointFromSeg(DataType*& const original_time_series, const AREA_COEFFICIENT& const temp_coefficient) {//190306
	auto left_endpoint_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	std::vector <typename GEOMETRY::POINT> points_vector;

	for (int array_id = left_endpoint_id; array_id <= temp_coefficient.right_endpoint; array_id++) {
		//cout<< original_time_series[array_id]<<", ";
		points_vector.push_back(GEOMETRY::POINT(array_id, original_time_series[array_id]));
	}

	assert(points_vector.size() > 0);
	return points_vector;
}

//************************************
// Method:getPolygonArea
// Qualifier: get polygon area
// date:190307
// author:
//************************************
TEMPLATE
double& APLA::getPolygonArea(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient) {//1900307
	assert(temp_coefficient.rectangle_width != NULL);

	double a = NULL, b = NULL;//y=ax+b;
	auto left_endpoint_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	auto right_endpoint_id = temp_coefficient.right_endpoint;
	deque<DataType> left_y_array;
	//deque<DataType> left_y_array0;
	//deque<DataType> right_y_array;
	typename GEOMETRY::POINT  up_deviation_point;
	typename GEOMETRY::POINT  down_deviation_point;
	typename GEOMETRY::COMPARE_POINTS	compare_points;
	GEOMETRY geo;

	std::vector <GEOMETRY::POINT> points;
	std::vector <GEOMETRY::POINT> points1;
	typedef bg::model::d2::point_xy<double> point_type;
	bg::model::polygon<point_type, true, true> poly;
	bg::model::polygon<point_type, true, true> poly1;
	//bg::model::polygon<point_type, true, true> polygon_disorder;//190307
	//bg::model::polygon<point_type, true, true> hull;//190301
	int temp_id = 0;

	/*****************************Print****************************************************/
	/*cout << "Original: ";
	for (int array_id = left_endpoint_id; array_id <= right_endpoint_id; array_id++) {
		cout << array_id <<" "<< original_time_series[array_id] << ", ";
	}
	cout << endl;*/
	/***************************************************************************************/

	for (int array_id = left_endpoint_id; array_id <= right_endpoint_id; array_id++, temp_id++) {
		//cout<< original_time_series[array_id]<<", ";
		points.push_back(GEOMETRY::POINT(array_id, original_time_series[array_id]));
		points1.push_back(GEOMETRY::POINT(array_id, original_time_series[array_id]));
		//bg::append(polygon_disorder.outer(), point_type(array_id, original_time_series[array_id]));//190307
	}

	/*****************************first clock wise function*******************************/
	GEOMETRY::ClockwiseSortPoints(points);
	/***************************************************************************************/

	/************************* Correct, it is not work for clockwise************************/
	//using boost::geometry::dsv;
	//std::cout << "polygon_disorder: " << dsv(polygon_disorder)<<endl;
	//boost::geometry::correct(polygon_disorder);
	//std::cout << "correct: " << dsv(polygon_disorder) << endl;
	/***************************************************************************************/

	//cout << "\nAfter sorting" << endl;
	for (auto&& i : points) {
		//cout <<i.id<<" "<<i.value <<", ";
		bg::append(poly.outer(), point_type(i.id, i.value));
	}
	//cout << endl;
	bg::append(poly.outer(), point_type(points[0].id, points[0].value));
	//***************************************************************************************

	//****************************get convex hull********************************************
	/*boost::geometry::convex_hull(poly, hull);

	std::cout << "polygon: " << dsv(poly) << std::endl << "hull: " << dsv(hull) << std::endl;*/
	//***************************************************************************************

	//**********************second clock wise function**************************************
	std::sort(points1.begin(), points1.end(), compare_points);
	//cout << "\nAfter sorting" << endl;
	for (auto&& i : points1) {
		//cout << i.id << " " << i.value << ", ";
		bg::append(poly1.outer(), point_type(i.id, i.value));
	}
	bg::append(poly1.outer(), point_type(points1[0].id, points1[0].value));
	//***************************************************************************************

	//cout <<"*****************************   " << bg::area(poly) << " " << bg::area(poly1)<<" "<< GEOMETRY::ComputePolygonArea(points)<<" "<< GEOMETRY::ComputePolygonArea(points1) << endl;
	//assert(bg::area(poly) == bg::area(poly1));
	auto area = fabs(bg::area(poly));
	//cout << "Area: " << area << " "<< GEOMETRY::ComputePolygonArea(points) <<endl;
	//assert(bg::area(poly) - GEOMETRY::ComputePolygonArea(points) < (numeric_limits<double>::min)());
	assert(fabs(area - GEOMETRY::ComputePolygonArea(points)) < FLT_EPSILON);

	return temp_coefficient.rectangle_area = area;
}

//************************************
// Method:getConvexHullArea
// Qualifier: get convex hull area
// date:190301
// author:
//************************************
TEMPLATE
double& APLA::getConvexHullArea(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient) {//190301
	assert(temp_coefficient.rectangle_width != NULL);

	auto left_endpoint_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	auto right_endpoint_id = temp_coefficient.right_endpoint;
	//deque<DataType> left_y_array;
	//deque<DataType> left_y_array0;
	//deque<DataType> right_y_array;
	//typename GEOMETRY::POINT  up_deviation_point;
	//typename GEOMETRY::POINT  down_deviation_point;
	//typename GEOMETRY::COMPARE_POINTS	compare_points;
	//GEOMETRY geo;

	//std::vector <GEOMETRY::POINT> points;
	//std::vector <GEOMETRY::POINT> points1;
	std::vector <GEOMETRY::POINT> points_convex;
	typename GEOMETRY::POINT temp_point;
	//using boost::geometry::get;

	typedef bg::model::d2::point_xy<double> point_type;
	//first self function to get convex hull
	//bg::model::polygon<point_type, true, true> poly_hull;
	//second boost function to get convex hull
	bg::model::polygon<point_type, true, true> polygon;
	bg::model::polygon<point_type, true, true> hull;//190301

	typename GEOMETRY::POINT* points_array = new POINT[temp_coefficient.rectangle_width];

	/**************************** Print    ********************************************/
	//cout << "Original: ";
	//for (int array_id = left_endpoint_id; array_id <= right_endpoint_id; array_id++) {
	//	cout << array_id <<" "<< original_time_series[array_id] << ", ";
	//}
	//cout << endl;
	/**********************************************************************************/

	//initial points
	for (int array_id = left_endpoint_id, point_array_id = 0; array_id <= right_endpoint_id; array_id++, point_array_id++) {
		//cout<< original_time_series[array_id]<<", ";
		//points.push_back(GEOMETRY::POINT(array_id, original_time_series[array_id]));
		//points1.push_back(GEOMETRY::POINT(array_id, original_time_series[array_id]));
		bg::append(polygon.outer(), point_type(array_id, original_time_series[array_id]));
		//points_array[point_array_id].id = array_id;
		//points_array[point_array_id].value = original_time_series[array_id];
	}

	/*cout << left_endpoint_id << " "<< right_endpoint_id <<endl;
	for (int i = 0; i < temp_coefficient.rectangle_width; i++) {
		cout << points_array[i].id << " " << points_array[i].value << endl;
	}*/

	//**************************** 1st get convex hull(self)********************************************
	//GEOMETRY::convexHull(points_array, temp_coefficient.rectangle_width, points_convex);

	//cout << "points_convex: ";
	//for (auto&&i:points_convex) {
	//	cout <<i.id<<" "<<i.value <<", ";
	//}
	//cout << endl;
	//***************************************************************************************

	//**************************** 2nd get convex hull(boost)********************************************
	boost::geometry::convex_hull(polygon, hull);
	//using boost::geometry::dsv;
	//std::cout << "polygon: " << dsv(polygon) << std::endl << "hull: " << dsv(hull) << std::endl;

	//***************************************************************************************

	std::vector<point_type> const& points_hull = hull.outer();

	for (auto&& i : points_hull) {
		temp_point.id = i.x();
		temp_point.value = i.y();
		points_convex.push_back(temp_point);
	}

	//**************************** Print    ********************************************
	/*cout << "points_hull: ";
	for (auto i : points_hull) {
		cout << i.x() << " " << i.y() << "; ";
	}
	cout << endl;*/
	//***************************************************************************************

	//**************************** Compare self convex hull and boost convex hull**********************************
	/*for (int i = 0; i < points_hull.size() - 1; i++) {
		if (int(points_hull[0].x()) == int(points_convex[i].id)) {
			std::rotate(points_convex.begin(), points_convex.begin() + i, points_convex.end());
			break;
		}
	}
	for (int i = 0; i < points_hull.size()-1;i++) {
		assert(points_hull[i].x() ==points_convex[i].id && points_hull[i].y() == points_convex[i].value);
	}*/
	//***********************************************************************************************************

	//first clock wise function
	//GEOMETRY::ClockwiseSortPoints(points, points.size());

	//cout << "\nAfter sorting" << endl;
	//for (auto&&i : points_convex) {
		//cout <<i.id<<" "<<i.value <<", ";
		//bg::append(poly_hull.outer(), point_type(i.id, i.value));
	//}
	//bg::append(poly_hull.outer(), point_type(points_convex[0].id, points_convex[0].value));

	//second clock wise function
	//std::sort(points1.begin(), points1.end(), compare_points);

	//cout << "\nAfter sorting" << endl;
	//for (auto&&i : points1) {
		//cout << i.id << " " << i.value << ", ";
		//bg::append(poly1.outer(), point_type(i.id, i.value));
	//}

	//bg::append(poly1.outer(), point_type(points1[0].id, points1[0].value));

	//cout <<"*****************************   " << bg::area(poly) << " " << bg::area(poly1)<<" "<< GEOMETRY::ComputePolygonArea(points)<<" "<< GEOMETRY::ComputePolygonArea(points1) << endl;
	//assert(bg::area(poly) == bg::area(poly1));
	//double area1 = fabs(bg::area(poly_hull));
	double area = fabs(bg::area(hull));
	assert(area >= 0);
	//cout << "Area: " << area << " "<< GEOMETRY::ComputePolygonArea(points) <<endl;
	//assert(bg::area(poly) - GEOMETRY::ComputePolygonArea(points) < (numeric_limits<double>::min)());

	assert(fabs(area - GEOMETRY::ComputePolygonArea(points_convex)) < FLT_EPSILON);
	//assert(area==area1);
	TOOL::deleteArray(points_array);

	return temp_coefficient.rectangle_area = area;
}

//************************************
// Method:getCircleArea
// Qualifier: get circle area from segment
// date:190308
// author:
//************************************
TEMPLATE
double& APLA::getCircleArea(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient) {//190308
	typename GEOMETRY::POINT center;
	double radius;


	Point_Enclose temp_point_encloing;//190311 from SmallestEnclosingCircle.h
	std::vector<Point_Enclose> points_encloing;//190311

	auto segment_points = getPointFromSeg(original_time_series, temp_coefficient);

	for (auto&& i : segment_points) {
		temp_point_encloing.x = i.id;
		temp_point_encloing.y = i.value;
		points_encloing.push_back(temp_point_encloing);
	}

	GEOMETRY::ClockwiseSortPoints(segment_points);

	/***********************************Option1 min_cover_circle *********************************/
	GEOMETRY::min_cover_circle(segment_points, center, radius);
	/*********************************************************************************************/

	/*********************************** Option2 SmallestEnclosingCircle *********************************/
	auto enclose_circle = makeSmallestEnclosingCircle(points_encloing);
	/****************************************************************************************************/

	temp_coefficient.circle_radius = enclose_circle.r;
	assert(temp_coefficient.circle_radius > 0);

	/*----------------------Assert---------------------------------------*/
	double intpart1 = NULL, intpart2 = NULL;
	modf(radius, &intpart1);
	modf(enclose_circle.r, &intpart2);
	//assert(fabs(center.id - enclose_circle.c.x) < (numeric_limits<double>::min)() && fabs(center.value - enclose_circle.c.y) < (numeric_limits<double>::min)());
	assert(intpart1 == intpart2);
	/*__________________________________________________________________*/

	/*********************************** Print *********************************/
	//cout << center.id << "     "<< enclose_circle.c.x<<",  "<< center.value<<"     "<< enclose_circle.c.y<<",  "<< radius<<"   "<< enclose_circle.r <<endl;
	/*for (auto&&i : segment_points) {
		cout << i.id << "," << i.value << ";";
	}
	cout << center.id << ", " << center.value << "  " << radius << endl;*/
	/****************************************************************************************************/
	return temp_coefficient.rectangle_area = GEOMETRY::area_of_a_circle(enclose_circle.r);
}

//************************************
// Method:getSegmentMinMaxRectangleAreaDensity
// Qualifier: Do not know min max point, Get rectangle area & density according to min max point
// date:190308
// author:
//************************************
TEMPLATE
void APLA::getSegmentMinMaxRectangleAreaDensity(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector) {//190701
	assert(0);
	for (auto&& au : area_vector) {
#ifdef _DEBUG
		assert(au.right_endpoint != INF && au.rectangle_width != INF);//n is even
#endif
		getSegmentMinMaxPoint(original_time_series, au);
		au.minmax_width_area = (au.max_point.value - au.min_point.value) * au.rectangle_width;
		au.minmax_distance_area = (au.max_point.value - au.min_point.value) * fabs(au.max_point.id - au.min_point.id);
#ifdef _DEBUG
		assert(au.rectangle_width >= fabs(au.max_point.id - au.min_point.id));//n is even
		assert(au.minmax_width_area >= 0 && au.minmax_distance_area >= 0);//n is even
#endif
	}
}

//190826
//************************************
// Method:getSegmentMinMaxRectangleAreaDensity
// Qualifier: Do not know min max point, Get rectangle area & density according to min max point
// date:190826
// author:
//************************************
TEMPLATE
void APLA::getSegmentMinMaxRectangleAreaDensity(DataType*& const original_time_series, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list) {//190826
	assert(0);
	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
#ifdef _DEBUG
		assert(doubly_linked_list[segment_id].right_endpoint != INF && doubly_linked_list[segment_id].rectangle_width != INF);//n is even
#endif
		getSegmentMinMaxPoint(original_time_series, doubly_linked_list[segment_id]);
		doubly_linked_list[segment_id].minmax_width_area = (doubly_linked_list[segment_id].max_point.value - doubly_linked_list[segment_id].min_point.value) * doubly_linked_list[segment_id].rectangle_width;
		doubly_linked_list[segment_id].minmax_distance_area = (doubly_linked_list[segment_id].max_point.value - doubly_linked_list[segment_id].min_point.value) * fabs(doubly_linked_list[segment_id].max_point.id - doubly_linked_list[segment_id].min_point.id);
#ifdef _DEBUG
		assert(doubly_linked_list[segment_id].rectangle_width >= fabs(doubly_linked_list[segment_id].max_point.id - doubly_linked_list[segment_id].min_point.id));//n is even
		assert(doubly_linked_list[segment_id].minmax_width_area >= 0 && doubly_linked_list[segment_id].minmax_distance_area >= 0);//n is even
#endif
	}
}

//************************************
// Method:computeParallelogramByPLA
// Qualifier: get a & b of segment PLA by original time series, only know width & right end point
// Input: 1width, 2right end point
// Output: a&b, apla coefficient, sum value
// date:190107
// author:
//************************************
TEMPLATE
double& APLA::getAAndBByPLA(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient) {//190107
	assert(0);
#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width > 0 && temp_coefficient.rectangle_width != INF && temp_coefficient.rectangle_height >= 0 && temp_coefficient.right_endpoint > 0 && temp_coefficient.right_endpoint != INF);
	double temp_a;
	double temp_b;
#endif

	if (temp_coefficient.rectangle_width == 1) {
		return getAandBSlopInterceptOnePoint(original_time_series, temp_coefficient);
	}

	if (temp_coefficient.rectangle_width == 2) {
		return getAandBSlopInterceptTwoPoint(original_time_series, temp_coefficient).apla.a;//190929(original_time_series, temp_coefficient);
	}

	//printf("getPLA()\n");
	//assert(temp_coefficient.size() == input_argument.point_dimension);

	temp_coefficient.apla.a_minuend = (temp_coefficient.rectangle_width - 1) / 2.0;//(l-1)/2
	temp_coefficient.apla.a_divisor = (temp_coefficient.rectangle_width - 1) * (temp_coefficient.rectangle_width + 1) * temp_coefficient.rectangle_width;//l(l-1)(l+1)
	temp_coefficient.apla.b_minuend = 2.0 * temp_coefficient.rectangle_width - 1;//2l-1
	temp_coefficient.apla.b_divisor = (temp_coefficient.rectangle_width + 1) * temp_coefficient.rectangle_width;//l(l+1)

	int segment_left_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;

	//	if (temp_coefficient.rectangle_width == 2) {
	//#ifdef _DEBUG
	//		assert(temp_coefficient.right_endpoint - segment_left_id == 1);
	//#endif
	//		temp_coefficient.apla.a = (original_time_series[int(temp_coefficient.right_endpoint)] - original_time_series[segment_left_id]);
	//		temp_coefficient.apla.b = original_time_series[segment_left_id];
	//
	//		temp_coefficient.sum_value = original_time_series[int(temp_coefficient.right_endpoint)] + original_time_series[segment_left_id];
	//		//temp_a = (original_time_series[int(temp_coefficient.right_endpoint)] - original_time_series[segment_left_id]);
	//		//temp_b = original_time_series[segment_left_id];
	//#ifdef _DEBUG
	//		assert(temp_coefficient.sum_value != INF && temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF && temp_coefficient.apla.a_minuend != INF && temp_coefficient.apla.a_divisor != INF && temp_coefficient.apla.b_minuend != INF && temp_coefficient.apla.b_divisor != INF);
	//#endif
	//		return temp_coefficient.apla.a;
	//	}
	//
		//coefficient of equation
		//a
		//double a_minuend = NULL; //(l-1)/2
		//double a_divisor = NULL; //l(l-1)(l+1)
		//b
		//double b_minuend = NULL; //2l-1
		//double b_divisor = NULL; //l(l+1)

	auto a_sum = 0.0;
	auto b_sum = 0.0;
	double variable_id = NULL; //[0-segment_length)
	int array_id = NULL;//time series id

#ifdef _DEBUG
	assert(temp_coefficient.apla.a_divisor != 0);
	assert(temp_coefficient.apla.b_divisor != 0);
#endif

	temp_coefficient.sum_value = 0;
	for (variable_id = 0, array_id = segment_left_id; array_id <= temp_coefficient.right_endpoint; array_id++, variable_id++) {
		temp_coefficient.sum_value += original_time_series[array_id];
		a_sum += (variable_id - temp_coefficient.apla.a_minuend) * original_time_series[array_id];
		b_sum += (temp_coefficient.apla.b_minuend - variable_id * 3.0) * original_time_series[array_id];
	}
	temp_coefficient.apla.a = 12.0 * a_sum / temp_coefficient.apla.a_divisor;
	temp_coefficient.apla.b = 2.0 * b_sum / temp_coefficient.apla.b_divisor;

#ifdef _DEBUG
	assert(temp_coefficient.sum_value != INF && temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF && temp_coefficient.apla.a_minuend != INF && temp_coefficient.apla.a_divisor != INF && temp_coefficient.apla.b_minuend != INF && temp_coefficient.apla.b_divisor != INF);
	if (temp_coefficient.rectangle_width == 2) {
		//assert(float(temp_coefficient.apla.a) == float(temp_a));
		//assert(float(temp_coefficient.apla.b) == float(temp_b));
	}
#endif

	return temp_coefficient.apla.a;
}

//************************************
// Method:computeParallelogramByPLA
// Qualifier: // 191114 add template vector. get a & b of segment PLA by original time series, only know width & right end point
// Input: 
//		1 width, 
//		2 right end point
// Output: a&b, apla coefficient, sum value
// date:190107
// author:
//************************************
TEMPLATE
template<typename T>
T& APLA::getAAndBByPLA(const vector<DataType>& const original_time_series, T& const temp_coefficient) {//190107 return a;
	//assert(0);
#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width > 0 && temp_coefficient.rectangle_width != INF && temp_coefficient.right_endpoint >= 0 && temp_coefficient.right_endpoint != INF);
	double temp_a;
	double temp_b;
#endif

	if (temp_coefficient.rectangle_width == 1) {
		getAandBSlopInterceptOnePoint(original_time_series[temp_coefficient.right_endpoint], temp_coefficient);
		//200316 sum value
		//temp_coefficient.sum_value = original_time_series[temp_coefficient.right_endpoint];
		return temp_coefficient;
	}
	if (temp_coefficient.rectangle_width == 2) {
		getAandBSlopInterceptTwoPoint(original_time_series[temp_coefficient.right_endpoint - 1], original_time_series[temp_coefficient.right_endpoint], temp_coefficient);//190929(original_time_series, temp_coefficient);
		//200316 sum value
		//temp_coefficient.sum_value = original_time_series[temp_coefficient.right_endpoint - 1] + original_time_series[temp_coefficient.right_endpoint];
		return temp_coefficient;
	}

	//printf("getPLA()\n");
	//assert(temp_coefficient.size() == input_argument.point_dimension);

	temp_coefficient.apla.a_minuend = (temp_coefficient.rectangle_width - 1) / 2.0;//(l-1)/2
	temp_coefficient.apla.a_divisor = (temp_coefficient.rectangle_width - 1) * (temp_coefficient.rectangle_width + 1) * temp_coefficient.rectangle_width;//l(l-1)(l+1)
	temp_coefficient.apla.b_minuend = 2.0 * temp_coefficient.rectangle_width - 1;//2l-1
	temp_coefficient.apla.b_divisor = (temp_coefficient.rectangle_width + 1) * temp_coefficient.rectangle_width;//l(l+1)

	int segment_left_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;

	auto a_sum = 0.0;
	auto b_sum = 0.0;
	double variable_id = NULL; //[0-segment_length)
	int array_id = NULL;//time series id

#ifdef _DEBUG
	assert(temp_coefficient.apla.a_divisor != 0);
	assert(temp_coefficient.apla.b_divisor != 0);
#endif
	//200316 sum value
	//temp_coefficient.sum_value = 0;
	for (variable_id = 0, array_id = segment_left_id; array_id <= temp_coefficient.right_endpoint; array_id++, variable_id++) {
		//temp_coefficient.sum_value += original_time_series[array_id];
		a_sum += (variable_id - temp_coefficient.apla.a_minuend) * original_time_series[array_id];
		b_sum += (temp_coefficient.apla.b_minuend - variable_id * 3.0) * original_time_series[array_id];
	}
	temp_coefficient.apla.a = 12.0 * a_sum / temp_coefficient.apla.a_divisor;
	temp_coefficient.apla.b = 2.0 * b_sum / temp_coefficient.apla.b_divisor;

#ifdef _DEBUG
	assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF && temp_coefficient.apla.a_minuend != INF && temp_coefficient.apla.a_divisor != INF && temp_coefficient.apla.b_minuend != INF && temp_coefficient.apla.b_divisor != INF);
	if (temp_coefficient.rectangle_width == 2) {
		//assert(float(temp_coefficient.apla.a) == float(temp_a));
		//assert(float(temp_coefficient.apla.b) == float(temp_b));
	}
#endif
	return temp_coefficient;
}

//200320 get apla coeffcient minus advisor
//************************************
// Method:get_apla_coefficients_segment
// Qualifier: 
// Input: width
// Output: a&b cofficient ab_minuend, ab_advisor
// date:200221
// author:
//************************************
TEMPLATE
template<typename T>
inline void APLA::get_apla_coefficients_segment(T& const temp_coefficient) {
#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width > 0 && temp_coefficient.rectangle_width != INF);
#endif
	temp_coefficient.apla.a_minuend = (temp_coefficient.rectangle_width - 1) / 2.0;//(l-1)/2
	temp_coefficient.apla.a_divisor = (temp_coefficient.rectangle_width - 1) * (temp_coefficient.rectangle_width + 1) * temp_coefficient.rectangle_width;//l(l-1)(l+1)
	temp_coefficient.apla.b_minuend = 2.0 * temp_coefficient.rectangle_width - 1;//2l-1
	temp_coefficient.apla.b_divisor = (temp_coefficient.rectangle_width + 1) * temp_coefficient.rectangle_width;//l(l+1)
}

//************************************
// Method:get_ab_minmax_flat_segment
// Qualifier: Aleady know is flat segment. get 1 a & b 2 min&max point of segment PLA by original time series, only know width & right end point
// Input: 1width, 2right end point
// Output: a&b, min&max point
// date:200504
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline void APLA::get_ab_minmax_flat_segment(const vector<T>& const original_time_series_vector, Y& const temp_coefficient) {
#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width > 0 && temp_coefficient.rectangle_width != INF && temp_coefficient.right_endpoint >= 0 && temp_coefficient.right_endpoint != INF);
#endif
	temp_coefficient.min_point.id = temp_coefficient.max_point.id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	temp_coefficient.apla.b = temp_coefficient.min_point.value = temp_coefficient.max_point.value = original_time_series_vector[temp_coefficient.right_endpoint];
	temp_coefficient.apla.a = 0;
	temp_coefficient.is_flat = true;
}

//************************************
// Method:get_segment_two_points_ab_minmax
// Qualifier: compute a&b min&max of two points segment
// Input: 1width, 2right end point
// Output: a&b, min&max point
// date:200730 
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline void APLA::get_segment_two_points_ab_minmax(const T& const left_value, const T& const right_value, Y& const temp_coefficient) {
#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width == 2 && temp_coefficient.right_endpoint != INF);
#endif

	getAandBSlopInterceptTwoPoint(left_value, right_value, temp_coefficient);
	get_segment_two_point_minmax(left_value, right_value, temp_coefficient);
}

//************************************
// Method:get_ab_minmax_segment_by_accumulation
// Qualifier: compute a&b min&max of accumulation segment from current segment.
// Input: 1width, 2right end point, 3 current segment
// Output: a&b, min&max of accumulation segment
// date:200731 
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline Y& APLA::get_ab_minmax_segment_by_accumulation(const T& const accumulate_point_value, const Y& const last_segment, Y& const temp_coefficient) {

	get_ab_segment_by_accumulation(accumulate_point_value, last_segment, temp_coefficient);
	//get_minmax_segment_by_accumulation(accumulate_point_value, last_segment, temp_coefficient);

	return temp_coefficient;
}

//200731 compute a&b, min&max of accumulation segment from current segment.
//************************************
// Method:get_ab_minmax_segment_by_accumulation
// Qualifier: compute a&b min&max of accumulation segment from current segment.
// Input: 1 original width, 2 original right end point, 3 current segment
// Output: a&b, min&max of accumulation segment, right endpoint & width + 1
// date:200731 
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline Y& APLA::get_ab_minmax_segment_by_accumulation(const T& const accumulate_point_value, Y& const current_segment) {

	get_ab_accumulation_segment(accumulate_point_value, current_segment);
	//get_minmax_segment_by_accumulation(accumulate_point_value, current_segment);

	return current_segment;
}

//200420 get 1 a & b 2 min&max point of segment PLA by original time series, only know width & right end point
//************************************
// Method:get_ab_segment
// Qualifier: // 200221 add template vector. get a & b of segment PLA by original time series, only know width & right end point
// Input: 1width, 2right end point
// Output: a&b
// date:200221
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
Y& APLA::get_ab_minmax_segment(const vector<T>& const original_time_series_vector, Y& const temp_coefficient) {
#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width > 0 && temp_coefficient.rectangle_width != INF && temp_coefficient.right_endpoint >= 0 && temp_coefficient.right_endpoint != INF);
	double temp_a;
	double temp_b;
#endif

	if (temp_coefficient.rectangle_width == 1) {

		/*++++++++++++++++++++++++++   get a&b for one point  ++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		getAandBSlopInterceptOnePoint(original_time_series_vector[temp_coefficient.right_endpoint], temp_coefficient);
		//temp_coefficient.sum_value = original_time_series[temp_coefficient.right_endpoint];
		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*+++++++++++++++++++++++  get min&max point for one point  ++++++++++++++++++++++++++++++++++++++++++++++++*/
		get_segment_one_point_minmax(original_time_series_vector[temp_coefficient.right_endpoint], temp_coefficient);
		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		return temp_coefficient;
	}
	else if (temp_coefficient.rectangle_width == 2) {

		/*++++++++++++++++++++++++++             get a&b for two points                     +++++++++++++++++++++++++++++++++++++++*/
		getAandBSlopInterceptTwoPoint(original_time_series_vector[temp_coefficient.right_endpoint - 1], original_time_series_vector[temp_coefficient.right_endpoint], temp_coefficient);//190929(original_time_series, temp_coefficient);
		//temp_coefficient.sum_value = original_time_series[temp_coefficient.right_endpoint - 1] + original_time_series[temp_coefficient.right_endpoint];
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*+++++++++++++++++++++++++++++++++++  get min&max point for two points  ++++++++++++++++++++++++++++++++++++++++++++++++++*/
		get_segment_two_point_minmax(original_time_series_vector, temp_coefficient);
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		return temp_coefficient;
	}

	//printf("getPLA()\n");
	//assert(temp_coefficient.size() == input_argument.point_dimension);
	// ab_minuend, ab_divisor
	get_apla_coefficients_segment(temp_coefficient);

	int segment_left_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;

	auto a_sum = 0.0;
	auto b_sum = 0.0;
	double variable_id = NULL; //[0-segment_length)
	int array_id = NULL;//time series id

#ifdef _DEBUG
	assert(temp_coefficient.apla.a_divisor != 0);
	assert(temp_coefficient.apla.b_divisor != 0);
#endif

	/*++++++++++++++++++++++++++++++++++                     get a&b, sum coefficients  and min&max points            ++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!     initial min&max point value        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	temp_coefficient.min_point.id = temp_coefficient.max_point.id = segment_left_id;
	temp_coefficient.min_point.value = temp_coefficient.max_point.value = original_time_series_vector[segment_left_id];
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	//200316 sum value
	//temp_coefficient.sum_value = 0;
	for (variable_id = 0, array_id = segment_left_id; array_id <= temp_coefficient.right_endpoint; array_id++, variable_id++) {

		/*==========================================================================================================================*/
		//200316 sum value
		//temp_coefficient.sum_value += original_time_series_vector[array_id];
		a_sum += (variable_id - temp_coefficient.apla.a_minuend) * original_time_series_vector[array_id];
		b_sum += (temp_coefficient.apla.b_minuend - variable_id * 3.0) * original_time_series_vector[array_id];
		/*==========================================================================================================================*/

		/*==============================     200420 get min&max point         ======================================================*/
		/*---------------------------MinMax point-----------------------------------------*/
		get_segment_minmax_point(array_id, original_time_series_vector[array_id], temp_coefficient);
		/*--------------------------------------------------------------------------------*/
		/*==========================================================================================================================*/

	}
	temp_coefficient.apla.a = 12.0 * a_sum / temp_coefficient.apla.a_divisor;
	temp_coefficient.apla.b = 2.0 * b_sum / temp_coefficient.apla.b_divisor;
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

#ifdef _DEBUG
	assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF && temp_coefficient.apla.a_minuend != INF && temp_coefficient.apla.a_divisor != INF && temp_coefficient.apla.b_minuend != INF && temp_coefficient.apla.b_divisor != INF);
	if (temp_coefficient.rectangle_width == 2) {
		//assert(float(temp_coefficient.apla.a) == float(temp_a));
		//assert(float(temp_coefficient.apla.b) == float(temp_b));
	}
#endif

	return temp_coefficient;
}

//************************************
// Method:get_ab_segment
// Qualifier: // 200221 add template vector. get a & b of segment PLA by original time series, only know width & right end point
// Input: 1 width, 2 right end point
// Output: a&b
// date:200221
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
Y& APLA::get_ab_segment(const vector<T>& const original_time_series_vector, Y& const temp_coefficient) {
#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width > 0 && temp_coefficient.rectangle_width != INF && temp_coefficient.right_endpoint >= 0 && temp_coefficient.right_endpoint != INF);
	double temp_a;
	double temp_b;
#endif

	if (temp_coefficient.rectangle_width == 1) {
		//temp_coefficient.sum_value = original_time_series[temp_coefficient.right_endpoint];
		return getAandBSlopInterceptOnePoint(original_time_series_vector[temp_coefficient.right_endpoint], temp_coefficient);;
	}
	if (temp_coefficient.rectangle_width == 2) {
		getAandBSlopInterceptTwoPoint(original_time_series_vector[temp_coefficient.right_endpoint - 1], original_time_series_vector[temp_coefficient.right_endpoint], temp_coefficient);//190929(original_time_series, temp_coefficient);
		//temp_coefficient.sum_value = original_time_series[temp_coefficient.right_endpoint - 1] + original_time_series[temp_coefficient.right_endpoint];
		return temp_coefficient;
	}

	//printf("getPLA()\n");
	//assert(temp_coefficient.size() == input_argument.point_dimension);

	/*###########################################################################################################*/
	//temp_coefficient.apla.a_minuend = (temp_coefficient.rectangle_width - 1) / 2.0;//(l-1)/2
	//temp_coefficient.apla.a_divisor = (temp_coefficient.rectangle_width - 1) * (temp_coefficient.rectangle_width + 1) * temp_coefficient.rectangle_width;//l(l-1)(l+1)
	//temp_coefficient.apla.b_minuend = 2.0 * temp_coefficient.rectangle_width - 1;//2l-1
	//temp_coefficient.apla.b_divisor = (temp_coefficient.rectangle_width + 1) * temp_coefficient.rectangle_width;//l(l+1)
	// ab_minuend, ab_divisor
	get_apla_coefficients_segment(temp_coefficient);
	/*###########################################################################################################*/

	const int segment_left_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;

	auto a_sum = 0.0;
	auto b_sum = 0.0;
	double variable_id = NULL; //[0-segment_length)
	int array_id = NULL;//time series id

#ifdef _DEBUG
	assert(temp_coefficient.apla.a_divisor != 0);
	assert(temp_coefficient.apla.b_divisor != 0);
#endif
	//200316 sum value
	//temp_coefficient.sum_value = 0;
	for (variable_id = 0, array_id = segment_left_id; array_id <= temp_coefficient.right_endpoint; array_id++, variable_id++) {
		//200316 sum value
		//temp_coefficient.sum_value += original_time_series_vector[array_id];
		a_sum += (variable_id - temp_coefficient.apla.a_minuend) * original_time_series_vector[array_id];
		b_sum += (temp_coefficient.apla.b_minuend - variable_id * 3.0) * original_time_series_vector[array_id];
	}
	temp_coefficient.apla.a = 12.0 * a_sum / temp_coefficient.apla.a_divisor;
	temp_coefficient.apla.b = 2.0 * b_sum / temp_coefficient.apla.b_divisor;

#ifdef _DEBUG
	assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF && temp_coefficient.apla.a_minuend != INF && temp_coefficient.apla.a_divisor != INF && temp_coefficient.apla.b_minuend != INF && temp_coefficient.apla.b_divisor != INF);
	if (temp_coefficient.rectangle_width == 2) {
		//assert(float(temp_coefficient.apla.a) == float(temp_a));
		//assert(float(temp_coefficient.apla.b) == float(temp_b));
	}
#endif
	return temp_coefficient;
}

// 200228
//************************************
// Method:get_ab_segment_accumulation
// Qualifier: get a&b of long segment by one point and old segment
// Input: last segment, a&b right endpoint , width
//        new point value
// Output: a&b of temp segment
// date:200228
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline Y& APLA::get_ab_segment_by_accumulation(const vector<T>& const original_time_series_vector, const Y& const last_segment, Y& const temp_coefficient) {

	/*........................................................................................................................*/
#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width > 0 && temp_coefficient.rectangle_width != INF && temp_coefficient.right_endpoint > 0 && temp_coefficient.right_endpoint != INF);
	APLA::assert_segment_a_b(original_time_series_vector, last_segment);
#endif
	/*........................................................................................................................*/

	/*======================================================    if segment length < 3    ================================================================================================*/
	if (temp_coefficient.rectangle_width < 3) {


		if (temp_coefficient.rectangle_width == 1) {
			//assert(0);
			return getAandBSlopInterceptOnePoint(original_time_series_vector[temp_coefficient.right_endpoint], temp_coefficient);//190115;
		}
		if (temp_coefficient.rectangle_width == 2) {
			//assert(0);
			//const int segment_left_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
			/*........................................................................................................................*/
#ifdef _DEBUG
			assert(last_segment.right_endpoint == INF && last_segment.rectangle_width == INF && last_segment.apla.a == INF && last_segment.apla.b == INF);
#endif
			/*........................................................................................................................*/

			getAandBSlopInterceptTwoPoint(original_time_series_vector[temp_coefficient.right_endpoint - 1], original_time_series_vector[temp_coefficient.right_endpoint], temp_coefficient);//190115

			/*........................................................................................................................*/
#ifdef _DEBUG
			assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF);
#endif
			/*........................................................................................................................*/

			return temp_coefficient;
		}

		/*........................................................................................................................*/
#ifdef _DEBUG
		assert(last_segment.rectangle_width > 1 && last_segment.rectangle_width == temp_coefficient.rectangle_width - 1 && last_segment.rectangle_width > 0 && last_segment.rectangle_width != INF && last_segment.right_endpoint > 0 && last_segment.right_endpoint != INF && last_segment.apla.a != INF && last_segment.apla.b != INF);
#endif
		/*........................................................................................................................*/
	}
	/*===============================================================================================================================================================================*/

	/*........................................................................................................................*/
#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width - 1 == last_segment.rectangle_width && temp_coefficient.right_endpoint - 1 == last_segment.right_endpoint);
#endif
	/*........................................................................................................................*/

	//200314 sum value
	//temp_coefficient.sum_value = last_segment.sum_value + original_time_series_vector[temp_coefficient.right_endpoint];// sum value

	get_apla_coefficients_segment(temp_coefficient);

	//double temp_length = temp_coefficient.rectangle_width + 1;//l + 1
	long double temp_coefficient0 = last_segment.rectangle_width - 1;// l1 - 1
	//double temp_coefficient1 = last_segment.rectangle_width / temp_length;// l1 / l+1
	//double temp_coefficient2 = temp_length * temp_coefficient.rectangle_width; // l*(l+1)
	//temp_coefficient.apla.a = last_segment.apla.a * (temp_coefficient0 / temp_length) + 6 * (last_segment.rectangle_width * original_time_series_vector[temp_coefficient.right_endpoint] - last_segment.sum_value) / (last_segment.rectangle_width * temp_coefficient2);
	//temp_coefficient.apla.b = last_segment.apla.b * temp_coefficient1 + (4 * last_segment.sum_value + 2 * (1 - last_segment.rectangle_width) * original_time_series_vector[temp_coefficient.right_endpoint]) / temp_coefficient2;

	//double divide_coefficients = temp_coefficient.rectangle_width * (temp_coefficient.rectangle_width + 1);
	temp_coefficient.apla.a = ((temp_coefficient.rectangle_width - 3) * temp_coefficient0 * last_segment.apla.a + 6 * (original_time_series_vector[temp_coefficient.right_endpoint] - last_segment.apla.b)) / temp_coefficient.apla.b_divisor;
	temp_coefficient.apla.b = (2 * temp_coefficient0 * (last_segment.apla.a * last_segment.rectangle_width - original_time_series_vector[temp_coefficient.right_endpoint]) + (temp_coefficient.rectangle_width + 4) * last_segment.rectangle_width * last_segment.apla.b) / temp_coefficient.apla.b_divisor;

	/*...............................................................*/
#ifdef _DEBUG
	assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF);
	assert_segment_a_b(original_time_series_vector, temp_coefficient);
	//Y test_coefficient = temp_coefficient;
	////test_coefficient.right_endpoint = temp_coefficient.right_endpoint;
	////test_coefficient.rectangle_width = temp_coefficient.rectangle_width;
	//PLA_QUAL::getAAndBByPLASegment(original_time_series_vector, test_coefficient);
	////cout << *temp_coefficient.apla.a << " : " << temp_a << "      " << *temp_coefficient.apla.b << " : " << temp_b << endl;
	//assert(fabs(float(temp_coefficient.apla.a) - float(test_coefficient.apla.a)) <= 0.01 && fabs(float(temp_coefficient.apla.b) - float(test_coefficient.apla.b)) <= 0.1);
#endif
	/*...............................................................*/

	return temp_coefficient;
}

//************************************
// Method:get_ab_segment_by_accumulation
// Qualifier: get a&b of long segment by one point and old short segment
// Input: last segment, a&b right endpoint , width
//        new point value
// Output: a&b of temp segment
// date:200731 
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline Y& APLA::get_ab_segment_by_accumulation(const T& const accumulate_point_value, const Y& const last_segment, Y& const temp_coefficient) {
	/*........................................................................................................................*/
#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width > 0 && temp_coefficient.rectangle_width != INF && temp_coefficient.right_endpoint > 0 && temp_coefficient.right_endpoint != INF);
	assert(temp_coefficient.rectangle_width - 1 == last_segment.rectangle_width && temp_coefficient.right_endpoint - 1 == last_segment.right_endpoint);
#endif
	/*........................................................................................................................*/

	/*======================================================    if segment length < 3    ================================================================================================*/
	//if (temp_coefficient.rectangle_width < 3) {

	if (temp_coefficient.rectangle_width == 1) {
		//assert(0);
		return getAandBSlopInterceptOnePoint(accumulate_point_value, temp_coefficient);//190115
	}
	//		if (temp_coefficient.rectangle_width == 2) {
	//			assert(0);
	//			const int segment_left_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	//#ifdef _DEBUG
	//			assert(temp_coefficient.right_endpoint - segment_left_id == 1 && last_segment.right_endpoint == INF && last_segment.rectangle_width == INF && last_segment.apla.a == INF && last_segment.apla.b == INF);
	//#endif
	//
	//			//getAandBSlopInterceptTwoPoint(original_time_series_vector[temp_coefficient.right_endpoint - 1], original_time_series_vector[temp_coefficient.right_endpoint], temp_coefficient);//190115
	//
	//#ifdef _DEBUG
	//			assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF);
	//#endif
	//			return temp_coefficient;
	//		}

#ifdef _DEBUG
	assert(last_segment.rectangle_width > 1 && last_segment.rectangle_width == temp_coefficient.rectangle_width - 1 && last_segment.rectangle_width > 0 && last_segment.rectangle_width != INF && last_segment.right_endpoint > 0 && last_segment.right_endpoint != INF && last_segment.apla.a != INF && last_segment.apla.b != INF);
#endif
	//}
	/*===============================================================================================================================================================================*/
	//200314 sum value
	//temp_coefficient.sum_value = last_segment.sum_value + original_time_series_vector[temp_coefficient.right_endpoint];// sum value

	get_apla_coefficients_segment(temp_coefficient);

	if (accumulate_point_value == last_segment.apla.b && last_segment.apla.a == 0) {
		temp_coefficient.apla.a = 0;
		temp_coefficient.apla.b = accumulate_point_value;
		return temp_coefficient;
	}


	//double temp_length = temp_coefficient.rectangle_width + 1;//l + 1
	long double temp_coefficient0 = last_segment.rectangle_width - 1;// l1 - 1
	//double temp_coefficient1 = last_segment.rectangle_width / temp_length;// l1 / l+1
	//double temp_coefficient2 = temp_length * temp_coefficient.rectangle_width; // l*(l+1)
	//temp_coefficient.apla.a = last_segment.apla.a * (temp_coefficient0 / temp_length) + 6 * (last_segment.rectangle_width * original_time_series_vector[temp_coefficient.right_endpoint] - last_segment.sum_value) / (last_segment.rectangle_width * temp_coefficient2);
	//temp_coefficient.apla.b = last_segment.apla.b * temp_coefficient1 + (4 * last_segment.sum_value + 2 * (1 - last_segment.rectangle_width) * original_time_series_vector[temp_coefficient.right_endpoint]) / temp_coefficient2;

	//double divide_coefficients = temp_coefficient.rectangle_width * (temp_coefficient.rectangle_width + 1);
	temp_coefficient.apla.a = ((temp_coefficient.rectangle_width - 3) * temp_coefficient0 * last_segment.apla.a + 6 * (accumulate_point_value - last_segment.apla.b)) / temp_coefficient.apla.b_divisor;
	temp_coefficient.apla.b = (2 * temp_coefficient0 * (last_segment.apla.a * last_segment.rectangle_width - accumulate_point_value) + (temp_coefficient.rectangle_width + 4) * last_segment.rectangle_width * last_segment.apla.b) / temp_coefficient.apla.b_divisor;

	/*...............................................................*/
#ifdef _DEBUG
	assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF);
	//assert_segment_a_b(original_time_series_vector, temp_coefficient);
	//Y test_coefficient = temp_coefficient;
	////test_coefficient.right_endpoint = temp_coefficient.right_endpoint;
	////test_coefficient.rectangle_width = temp_coefficient.rectangle_width;
	//PLA_QUAL::getAAndBByPLASegment(original_time_series_vector, test_coefficient);
	////cout << *temp_coefficient.apla.a << " : " << temp_a << "      " << *temp_coefficient.apla.b << " : " << temp_b << endl;
	//assert(fabs(float(temp_coefficient.apla.a) - float(test_coefficient.apla.a)) <= 0.01 && fabs(float(temp_coefficient.apla.b) - float(test_coefficient.apla.b)) <= 0.1);
#endif
	/*...............................................................*/

	return temp_coefficient;
}

//************************************
// Method: get_ab_accumulation_segment
// Qualifier: get a&b of long segment by one point and old short segment
// Input: current segment, a&b, original right endpoint, width.
//        new point value
// Output: a&b, right endpoint, segment width of accumulate segment, right enpoint & width + 1
// date:200731
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline void APLA::get_ab_accumulation_segment(const T& const accumulate_point_value, Y& const current_segment) {
	/*........................................................................................................................*/
#ifdef _DEBUG
	assert(current_segment.rectangle_width > 1 && current_segment.rectangle_width != INF && current_segment.right_endpoint > 0 && current_segment.right_endpoint != INF);
#endif
	/*........................................................................................................................*/

	/*======================================================    if segment length < 3    ================================================================================================*/
//	if (current_segment.rectangle_width < 3) {
//		int segment_left_id = current_segment.right_endpoint - current_segment.rectangle_width + 1;
//
//		if (current_segment.rectangle_width == 1) {
//			assert(0);
//			getAandBSlopInterceptOnePoint(accumulate_point_value, current_segment);//190115
//			//return current_segment;
//			return;
//		}
//		if (current_segment.rectangle_width == 2) {
//			assert(0);
//#ifdef _DEBUG
//			assert(current_segment.right_endpoint - segment_left_id == 1 && last_segment.right_endpoint == INF && last_segment.rectangle_width == INF && last_segment.apla.a == INF && last_segment.apla.b == INF);
//#endif
//
//			//getAandBSlopInterceptTwoPoint(original_time_series_vector[temp_coefficient.right_endpoint - 1], original_time_series_vector[temp_coefficient.right_endpoint], temp_coefficient);//190115
//
//#ifdef _DEBUG
//			assert(current_segment.apla.a != INF && current_segment.apla.b != INF);
//#endif
//			return current_segment;
//		}
//
//#ifdef _DEBUG
//		assert(last_segment.rectangle_width > 1 && last_segment.rectangle_width == current_segment.rectangle_width - 1 && last_segment.rectangle_width > 0 && last_segment.rectangle_width != INF && last_segment.right_endpoint > 0 && last_segment.right_endpoint != INF && last_segment.apla.a != INF && last_segment.apla.b != INF);
//#endif
//	}
	/*===============================================================================================================================================================================*/
	//200314 sum value
	//temp_coefficient.sum_value = last_segment.sum_value + original_time_series_vector[temp_coefficient.right_endpoint];// sum value
	const long double a_current = current_segment.apla.a;
	const long double b_current = current_segment.apla.b;

	current_segment.right_endpoint++;
	current_segment.rectangle_width++;

	get_apla_coefficients_segment(current_segment);

	//double temp_length = temp_coefficient.rectangle_width + 1;//l + 1
	long double temp_coefficient0 = current_segment.rectangle_width - 2;// l1 - 1
	//double temp_coefficient1 = last_segment.rectangle_width / temp_length;// l1 / l+1
	//double temp_coefficient2 = temp_length * temp_coefficient.rectangle_width; // l*(l+1)
	//temp_coefficient.apla.a = last_segment.apla.a * (temp_coefficient0 / temp_length) + 6 * (last_segment.rectangle_width * original_time_series_vector[temp_coefficient.right_endpoint] - last_segment.sum_value) / (last_segment.rectangle_width * temp_coefficient2);
	//temp_coefficient.apla.b = last_segment.apla.b * temp_coefficient1 + (4 * last_segment.sum_value + 2 * (1 - last_segment.rectangle_width) * original_time_series_vector[temp_coefficient.right_endpoint]) / temp_coefficient2;

	//double divide_coefficients = temp_coefficient.rectangle_width * (temp_coefficient.rectangle_width + 1);
	current_segment.apla.a = ((current_segment.rectangle_width - 3) * temp_coefficient0 * a_current + 6 * (accumulate_point_value - b_current)) / current_segment.apla.b_divisor;
	current_segment.apla.b = (2.0 * temp_coefficient0 * (a_current * (current_segment.rectangle_width - 1) - accumulate_point_value) + (current_segment.rectangle_width + 4) * (current_segment.rectangle_width - 1) * b_current) / current_segment.apla.b_divisor;

	/*...............................................................*/
#ifdef _DEBUG
	assert(current_segment.apla.a != INF && current_segment.apla.b != INF);
	//assert_segment_a_b(original_time_series_vector, current_segment);
	//Y test_coefficient = temp_coefficient;
	////test_coefficient.right_endpoint = temp_coefficient.right_endpoint;
	////test_coefficient.rectangle_width = temp_coefficient.rectangle_width;
	//PLA_QUAL::getAAndBByPLASegment(original_time_series_vector, test_coefficient);
	////cout << *temp_coefficient.apla.a << " : " << temp_a << "      " << *temp_coefficient.apla.b << " : " << temp_b << endl;
	//assert(fabs(float(temp_coefficient.apla.a) - float(test_coefficient.apla.a)) <= 0.01 && fabs(float(temp_coefficient.apla.b) - float(test_coefficient.apla.b)) <= 0.1);
#endif
	/*...............................................................*/
}

// 20907 get average of accumulate segment by one point and current segment
TEMPLATE
template<typename T, typename Y>
inline void APLA::get_ab_accumulation_segment_average(const T& const accumulate_point_value, Y& const current_segment) {
	/*........................................................................................................................*/
#ifdef _DEBUG
	assert(current_segment.rectangle_width > 1 && current_segment.rectangle_width != INF && current_segment.right_endpoint > 0 && current_segment.right_endpoint != INF);
	assert_segment_average(current_segment);
#endif
	/*........................................................................................................................*/

	const long double a_current = current_segment.apla.a;
	const long double b_current = current_segment.apla.b;

	Y sub_left_segment = current_segment;

	current_segment.right_endpoint++;
	current_segment.rectangle_width++;

	get_apla_coefficients_segment(current_segment);

	current_segment.apla.b = (sub_left_segment.apla.b * sub_left_segment.rectangle_width + accumulate_point_value) / current_segment.rectangle_width;

	/*...............................................................*/
#ifdef _DEBUG
	assert_segment_average(current_segment);
#endif
	/*...............................................................*/
}

//201021 get a& b of long segment by left one pointand old short segment
//************************************
// Method:get_ab_segment_by_accumulation_left
// Qualifier: get a&b of short segment by one point and right sub segment
// Input: sub right segment, a2&b2 right endpoint , widht
//        new point value
// Output: long segemnt a&b
// date:201021
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline Y& APLA::get_ab_segment_by_accumulation_left(const T& const point_value_left, const Y& const sub_right_segment, Y& const temp_coefficient) {
	/*........................................................................................................................*/
#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width > 0 && temp_coefficient.rectangle_width != INF && temp_coefficient.right_endpoint > 0 && temp_coefficient.right_endpoint != INF);
	assert(temp_coefficient.rectangle_width - 1 == sub_right_segment.rectangle_width && temp_coefficient.right_endpoint == sub_right_segment.right_endpoint);
#endif
	/*........................................................................................................................*/

	/*======================================================    if segment length < 3    ================================================================================================*/
	//if (temp_coefficient.rectangle_width < 2) {

	if (temp_coefficient.rectangle_width == 1) {
		assert(0);
		return getAandBSlopInterceptOnePoint(point_value_left, temp_coefficient);//190115
	}
	//		if (temp_coefficient.rectangle_width == 2) {
	//			const int segment_left_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	//			assert(0);
	//#ifdef _DEBUG
	//			assert(temp_coefficient.right_endpoint - segment_left_id == 1 && sub_right_segment.right_endpoint == INF && sub_right_segment.rectangle_width == INF && sub_right_segment.apla.a == INF && sub_right_segment.apla.b == INF);
	//#endif
	//
	//			//getAandBSlopInterceptTwoPoint(original_time_series_vector[temp_coefficient.right_endpoint - 1], original_time_series_vector[temp_coefficient.right_endpoint], temp_coefficient);//190115
	//
	//#ifdef _DEBUG
	//			assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF);
	//#endif
	//			return temp_coefficient;
	//		}

#ifdef _DEBUG
	assert(sub_right_segment.rectangle_width > 1 && sub_right_segment.rectangle_width == temp_coefficient.rectangle_width - 1 && sub_right_segment.rectangle_width > 0 && sub_right_segment.rectangle_width != INF && sub_right_segment.right_endpoint > 0 && sub_right_segment.right_endpoint != INF && sub_right_segment.apla.a != INF && sub_right_segment.apla.b != INF);
#endif
	//}
	/*===============================================================================================================================================================================*/
	//200314 sum value
	//temp_coefficient.sum_value = sub_right_segment.sum_value + original_time_series_vector[temp_coefficient.right_endpoint];// sum value

	get_apla_coefficients_segment(temp_coefficient);

	//double divide_coefficients = temp_coefficient.rectangle_width * (temp_coefficient.rectangle_width + 1);
	temp_coefficient.apla.a = (sub_right_segment.apla.a * (sub_right_segment.rectangle_width - 1) * (sub_right_segment.rectangle_width + 4) + 6 * (sub_right_segment.apla.b - point_value_left)) / ((sub_right_segment.rectangle_width + 1) * (sub_right_segment.rectangle_width + 2));
	temp_coefficient.apla.b = (2 * (2 * sub_right_segment.rectangle_width + 1) * point_value_left + sub_right_segment.rectangle_width * (sub_right_segment.rectangle_width - 1) * (sub_right_segment.apla.b - sub_right_segment.apla.a)) / ((sub_right_segment.rectangle_width + 1) * (sub_right_segment.rectangle_width + 2));

	/*...............................................................*/
#ifdef _DEBUG
	assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF);
	//assert_segment_a_b(original_time_series_vector, temp_coefficient);
	//Y test_coefficient = temp_coefficient;
	////test_coefficient.right_endpoint = temp_coefficient.right_endpoint;
	////test_coefficient.rectangle_width = temp_coefficient.rectangle_width;
	//PLA_QUAL::getAAndBByPLASegment(original_time_series_vector, test_coefficient);
	////cout << *temp_coefficient.apla.a << " : " << temp_a << "      " << *temp_coefficient.apla.b << " : " << temp_b << endl;
	//assert(fabs(float(temp_coefficient.apla.a) - float(test_coefficient.apla.a)) <= 0.01 && fabs(float(temp_coefficient.apla.b) - float(test_coefficient.apla.b)) <= 0.1);
#endif
	/*...............................................................*/

	return temp_coefficient;
}

//201901 get a& b of long segment by left one pointand old short segment
TEMPLATE
template<typename T, typename Y>
inline Y& APLA::get_ab_segment_by_accumulation_left(const T& const point_value_left, Y& const temp_coefficient) {
	Y sub_right_segment = temp_coefficient;
	temp_coefficient.rectangle_width++;

	return get_ab_segment_by_accumulation_left(point_value_left, sub_right_segment, temp_coefficient);
}


//210907 get average of long segment by left one pointand old short segment
TEMPLATE
template<typename T, typename Y>
inline Y& APLA::get_ab_segment_by_accumulation_left_average(const T& const point_value_left, Y& const temp_coefficient) {
	Y sub_right_segment = temp_coefficient;
	temp_coefficient.rectangle_width++;

	/*........................................................................................................................*/
#ifdef _DEBUG
	assert_segment_average(temp_coefficient);
	assert(temp_coefficient.rectangle_width > 0 && temp_coefficient.rectangle_width != INF && temp_coefficient.right_endpoint > 0 && temp_coefficient.right_endpoint != INF);
	assert(temp_coefficient.rectangle_width - 1 == sub_right_segment.rectangle_width && temp_coefficient.right_endpoint == sub_right_segment.right_endpoint);
#endif
	/*........................................................................................................................*/

	/*======================================================    if segment length < 3    ================================================================================================*/

	if (temp_coefficient.rectangle_width == 1) {
		assert(0);
		return getAandBSlopInterceptOnePoint(point_value_left, temp_coefficient);//190115
	}
	
#ifdef _DEBUG
	assert(sub_right_segment.rectangle_width > 1 && sub_right_segment.rectangle_width == temp_coefficient.rectangle_width - 1 && sub_right_segment.rectangle_width > 0 && sub_right_segment.rectangle_width != INF && sub_right_segment.right_endpoint > 0 && sub_right_segment.right_endpoint != INF && sub_right_segment.apla.a != INF && sub_right_segment.apla.b != INF);
#endif

	get_apla_coefficients_segment(temp_coefficient);

	temp_coefficient.apla.b = (sub_right_segment.apla.b * sub_right_segment.rectangle_width + point_value_left) / temp_coefficient.rectangle_width;

	/*...............................................................*/
#ifdef _DEBUG
	assert_segment_average(temp_coefficient);
#endif
	/*...............................................................*/

	return temp_coefficient;

}

// 200228 get a1&b1 of short segment by one point and old long segment
//************************************
// Method:get_ab_segment_by_decrement
// Qualifier: get a&b of short segment by one point and long segment
// Input: old segment, a&b right endpoint , widht
//        new point value
// Output: a1&b1 of sub right segment
// date:200229
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline Y& APLA::get_ab_segment_by_decrement(const vector<T>& const original_time_series_vector, const Y& const last_segment, Y& const temp_coefficient) {

	/*........................................................................................................................................*/
#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width > 0 && temp_coefficient.rectangle_width != INF && temp_coefficient.right_endpoint > 0 && temp_coefficient.right_endpoint != INF);
	assert(temp_coefficient.rectangle_width + 1 == last_segment.rectangle_width && temp_coefficient.right_endpoint + 1 == last_segment.right_endpoint);
	assert_segment_a_b(original_time_series_vector, last_segment);
#endif
	/*........................................................................................................................................*/

	/*.................................................width == 1 or 2........................................................................*/
	if (temp_coefficient.rectangle_width == 1) {
		//assert(0);
		getAandBSlopInterceptOnePoint(original_time_series_vector[temp_coefficient.right_endpoint], temp_coefficient);//190115

		return temp_coefficient;
	}
	else if (temp_coefficient.rectangle_width == 2) {
		//assert(0);
		const int segment_left_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
#ifdef _DEBUG
		assert(temp_coefficient.right_endpoint - segment_left_id == 1 && last_segment.right_endpoint != INF && last_segment.rectangle_width == 3 && last_segment.apla.a != INF && last_segment.apla.b != INF);
#endif
		getAandBSlopInterceptTwoPoint(original_time_series_vector[temp_coefficient.right_endpoint - 1], original_time_series_vector[temp_coefficient.right_endpoint], temp_coefficient);//190115
#ifdef _DEBUG
		assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF);
#endif
		return temp_coefficient;
	}
	/*.........................................................................................................................................*/

#ifdef _DEBUG
	assert(last_segment.rectangle_width > 1 && last_segment.rectangle_width == temp_coefficient.rectangle_width + 1 && last_segment.rectangle_width > 0 && last_segment.rectangle_width != INF && last_segment.right_endpoint > 0 && last_segment.right_endpoint != INF && last_segment.apla.a != INF && last_segment.apla.b != INF);
#endif

	/*=========================================================================================================================*/
	//200316 sum value
	//temp_coefficient.sum_value = last_segment.sum_value - original_time_series_vector[last_segment.right_endpoint];// sum value

	get_apla_coefficients_segment(temp_coefficient);

	const long double divide_coefficients_minus = temp_coefficient.rectangle_width - 1;//l1-1
	const long double divide_coefficients = temp_coefficient.rectangle_width * (temp_coefficient.rectangle_width - 1);// l1(l1-1)

	temp_coefficient.apla.a = (last_segment.rectangle_width + 4) * last_segment.apla.a / divide_coefficients_minus + 6 * (last_segment.apla.b - original_time_series_vector[last_segment.right_endpoint]) / divide_coefficients;
	temp_coefficient.apla.b = last_segment.apla.b * (temp_coefficient.rectangle_width - 2) / temp_coefficient.rectangle_width + 2 * original_time_series_vector[last_segment.right_endpoint] / temp_coefficient.rectangle_width - 2 * last_segment.apla.a;
	//temp_coefficient.apla.b = (last_segment.apla.b * (temp_coefficient.rectangle_width - 2) + 2 * original_time_series_vector[last_segment.right_endpoint]) / temp_coefficient.rectangle_width - 2 * last_segment.apla.a;

#ifdef _DEBUG
	assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF);
	assert_segment_a_b(original_time_series_vector, temp_coefficient);
#endif

	return temp_coefficient;
}

// 201021 
//************************************
// Method:get_ab_segment_by_decrement_right
// Qualifier: get a1&b1 of short left segment by right one point and old long segment
// Input: old segment, a&b right endpoint , widht
//        new point value
// Output: a&b of short segment
// date:200229
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline Y& APLA::get_ab_segment_by_decrement_right(const T& const point_value_right, const Y& const long_segment, Y& const sub_left_segment) {
	/*........................................................................................................................................*/
#ifdef _DEBUG
	assert(sub_left_segment.rectangle_width > 0 && sub_left_segment.rectangle_width != INF && sub_left_segment.right_endpoint > 0 && sub_left_segment.right_endpoint != INF);
	assert(sub_left_segment.rectangle_width + 1 == long_segment.rectangle_width && sub_left_segment.right_endpoint + 1 == long_segment.right_endpoint);
	assert_segment_a_b(long_segment);
#endif
	/*........................................................................................................................................*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&                width == 1 or 2                    &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	if (sub_left_segment.rectangle_width == 1) {
		//assert(0);
		getAandBSlopInterceptOnePoint(point_value_right, sub_left_segment);//190115

		return sub_left_segment;
	}
	//	else if (sub_left_segment.rectangle_width == 2) {
	//		assert(0);
	//		const int segment_left_id = sub_left_segment.right_endpoint - sub_left_segment.rectangle_width + 1;
	//#ifdef _DEBUG
	//		assert(sub_left_segment.right_endpoint - segment_left_id == 1 && long_segment.right_endpoint != INF && long_segment.rectangle_width == 3 && long_segment.apla.a != INF && long_segment.apla.b != INF);
	//#endif
	//		//getAandBSlopInterceptTwoPoint(original_time_series_vector[sub_left_segment.right_endpoint - 1], original_time_series_vector[sub_left_segment.right_endpoint], sub_left_segment);//190115
	//#ifdef _DEBUG
	//		assert(sub_left_segment.apla.a != INF && sub_left_segment.apla.b != INF);
	//#endif
	//		return sub_left_segment;
	//	}
		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
		/*........................................................................................................................................*/
#ifdef _DEBUG
	assert(long_segment.rectangle_width > 1 && long_segment.rectangle_width == sub_left_segment.rectangle_width + 1 && long_segment.rectangle_width > 0 && long_segment.rectangle_width != INF && long_segment.right_endpoint > 0 && long_segment.right_endpoint != INF && long_segment.apla.a != INF && long_segment.apla.b != INF);
#endif
	/*........................................................................................................................................*/
	//200316 sum value
	//sub_left_segment.sum_value = long_segment.sum_value - original_time_series_vector[long_segment.right_endpoint];// sum value


	get_apla_coefficients_segment(sub_left_segment);

	const long double divide_coefficients_minus = sub_left_segment.rectangle_width - 1;//l1-1
	const long double divide_coefficients = sub_left_segment.rectangle_width * (sub_left_segment.rectangle_width - 1);// l1(l1-1)

	sub_left_segment.apla.a = (long_segment.rectangle_width + 4) * long_segment.apla.a / divide_coefficients_minus + 6 * (long_segment.apla.b - point_value_right) / divide_coefficients;
	sub_left_segment.apla.b = long_segment.apla.b * (sub_left_segment.rectangle_width - 2) / sub_left_segment.rectangle_width + 2 * point_value_right / sub_left_segment.rectangle_width - 2 * long_segment.apla.a;
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	/*........................................................................................................................................*/
#ifdef _DEBUG
	assert_segment_a_b(sub_left_segment);
	//Y test_coefficient = sub_left_segment;
	//test_coefficient.right_endpoint = sub_left_segment.right_endpoint;
	//test_coefficient.rectangle_width = sub_left_segment.rectangle_width;
	//get_ab_segment(original_time_series_vector, test_coefficient);
	//cout << *sub_left_segment.apla.a << " : " << temp_a << "      " << *sub_left_segment.apla.b << " : " << temp_b << endl;
	//assert(fabs(float(sub_left_segment.apla.a) - float(test_coefficient.apla.a)) <= 0.1 && fabs(float(sub_left_segment.apla.b) - float(test_coefficient.apla.b)) <= 0.1);
#endif
	/*........................................................................................................................................*/
	return sub_left_segment;
}

// 201901 get a1&b1 of short left segment by right one point and old long segment
TEMPLATE
template<typename T, typename Y>
inline Y& APLA::get_ab_segment_by_decrement_right(const T& const point_value_right, Y& const temp_coefficient) {
	Y long_segment = temp_coefficient;
	temp_coefficient.right_endpoint--;
	temp_coefficient.rectangle_width--;
	return get_ab_segment_by_decrement_right(point_value_right, long_segment, temp_coefficient);
}

// 210907 get average of short left segment by right one point and old long segment
TEMPLATE
template<typename T, typename Y>
inline Y& APLA::get_ab_segment_by_decrement_right_average(const T& const point_value_right, Y& const sub_left_segment) {
	Y long_segment = sub_left_segment;
	sub_left_segment.right_endpoint--;
	sub_left_segment.rectangle_width--;

	/*........................................................................................................................................*/
#ifdef _DEBUG
	assert_segment_average(sub_left_segment);
	assert(sub_left_segment.rectangle_width > 0 && sub_left_segment.rectangle_width != INF && sub_left_segment.right_endpoint > 0 && sub_left_segment.right_endpoint != INF);
	assert(sub_left_segment.rectangle_width + 1 == long_segment.rectangle_width && sub_left_segment.right_endpoint + 1 == long_segment.right_endpoint);
#endif
	/*........................................................................................................................................*/

	if (sub_left_segment.rectangle_width == 1) {
		//assert(0);
		getAandBSlopInterceptOnePoint(point_value_right, sub_left_segment);//190115

		return sub_left_segment;
	}

	/*........................................................................................................................................*/
#ifdef _DEBUG
	assert(long_segment.rectangle_width > 1 && long_segment.rectangle_width == sub_left_segment.rectangle_width + 1 && long_segment.rectangle_width > 0 && long_segment.rectangle_width != INF && long_segment.right_endpoint > 0 && long_segment.right_endpoint != INF && long_segment.apla.a != INF && long_segment.apla.b != INF);
#endif
	/*........................................................................................................................................*/
	//200316 sum value
	//sub_left_segment.sum_value = long_segment.sum_value - original_time_series_vector[long_segment.right_endpoint];// sum value


	get_apla_coefficients_segment(sub_left_segment);

	sub_left_segment.apla.b = (long_segment.apla.b * long_segment.rectangle_width - point_value_right) / sub_left_segment.rectangle_width;
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	/*........................................................................................................................................*/
#ifdef _DEBUG
	assert_segment_average(sub_left_segment);
#endif
	/*........................................................................................................................................*/
	return sub_left_segment;
}

//************************************
// Method:get_ab_segment_by_decrement_left
// Qualifier:   get a2&b2 of short right segment by left one point and old long segment
// Input: long segment, a&b right endpoint , widht. left point value of long segment. Right endpoint, width of short segment
// Output: a2&b2 of right sub segment
// date:201022
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline Y& APLA::get_ab_segment_by_decrement_left(const vector<T>& const original_time_series_vector, const Y& const long_segment, Y& const sub_right_segment) {
	/*........................................................................................................................................*/
#ifdef _DEBUG
	assert(sub_right_segment.rectangle_width > 0 && sub_right_segment.rectangle_width != INF && sub_right_segment.right_endpoint > 0 && sub_right_segment.right_endpoint != INF);
	assert(sub_right_segment.rectangle_width + 1 == long_segment.rectangle_width && sub_right_segment.right_endpoint == long_segment.right_endpoint);
	assert_segment_a_b(long_segment);
#endif
	/*........................................................................................................................................*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&               Segment Width == 1 or 2                 &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	if (sub_right_segment.rectangle_width == 1) {
		//assert(0);
		return getAandBSlopInterceptOnePoint(original_time_series_vector[sub_right_segment.right_endpoint], sub_right_segment);//190115;
	}
	else if (sub_right_segment.rectangle_width == 2) {

#ifdef _DEBUG
		assert(long_segment.right_endpoint != INF && long_segment.rectangle_width == 3 && long_segment.apla.a != INF && long_segment.apla.b != INF);
#endif
		getAandBSlopInterceptTwoPoint(original_time_series_vector[sub_right_segment.right_endpoint - 1], original_time_series_vector[sub_right_segment.right_endpoint], sub_right_segment);//190115
#ifdef _DEBUG
		assert(sub_right_segment.apla.a != INF && sub_right_segment.apla.b != INF);
#endif
		return sub_right_segment;
	}
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&						Segment Width >= 3       &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
		/*........................................................................................................................................*/
#ifdef _DEBUG
	assert(long_segment.rectangle_width > 1 && long_segment.rectangle_width == sub_right_segment.rectangle_width + 1 && long_segment.rectangle_width > 0 && long_segment.rectangle_width != INF && long_segment.right_endpoint > 0 && long_segment.right_endpoint != INF && long_segment.apla.a != INF && long_segment.apla.b != INF);
#endif
	/*........................................................................................................................................*/
	//200316 sum value
	//sub_right_segment.sum_value = long_segment.sum_value - original_time_series_vector[long_segment.right_endpoint];// sum value

	const size_t id_point_left = sub_right_segment.right_endpoint - sub_right_segment.rectangle_width;
	get_apla_coefficients_segment(sub_right_segment);

	//const long double test_a = long_segment.apla.a * (long_segment.rectangle_width - 2) / (long_segment.rectangle_width - 1) + 6 * (original_time_series_vector[id_point_left] - long_segment.apla.b) / ((long_segment.rectangle_width - 1) * (long_segment.rectangle_width - 2));
	//const long double test_b = (long_segment.apla.a * (long_segment.rectangle_width - 2) + long_segment.apla.b * (long_segment.rectangle_width + 3) - 4 * original_time_series_vector[id_point_left]) / (long_segment.rectangle_width - 1);

	sub_right_segment.apla.a = long_segment.apla.a + 6 * (original_time_series_vector[id_point_left] - long_segment.apla.b) / ((long_segment.rectangle_width - 1) * (long_segment.rectangle_width - 2));
	sub_right_segment.apla.b = long_segment.apla.a + (long_segment.apla.b * (long_segment.rectangle_width + 3) - 4 * original_time_series_vector[id_point_left]) / (long_segment.rectangle_width - 1);
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*........................................................................................................................................*/
#ifdef _DEBUG
	assert_segment_a_b(original_time_series_vector, sub_right_segment);
	//Y test_coefficient = sub_right_segment;
	//test_coefficient.right_endpoint = sub_right_segment.right_endpoint;
	//test_coefficient.rectangle_width = sub_right_segment.rectangle_width;
	//get_ab_segment(original_time_series_vector, test_coefficient);
	//cout << *sub_right_segment.apla.a << " : " << temp_a << "      " << *sub_right_segment.apla.b << " : " << temp_b << endl;
	//assert(fabs(float(sub_right_segment.apla.a) - float(test_coefficient.apla.a)) <= 0.1 && fabs(float(sub_right_segment.apla.b) - float(test_coefficient.apla.b)) <= 0.1);
#endif
	/*........................................................................................................................................*/

	return sub_right_segment;
}

//************************************
// Method:get_ab_segment_by_decrement_left
// Qualifier:  get a2&b2 of short right segment by left one point and old long segment
// Input: long segment, a&b right endpoint , widht. left point value of long segment
// Output: a2&b2 of right sub segment
// date:201022
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline Y& APLA::get_ab_segment_by_decrement_left(const T& const point_value_left, const Y& const long_segment, Y& const sub_right_segment) {

	/*........................................................................................................................................*/
#ifdef _DEBUG
	assert(sub_right_segment.rectangle_width > 0 && sub_right_segment.rectangle_width != INF && sub_right_segment.right_endpoint > 0 && sub_right_segment.right_endpoint != INF);
	assert(sub_right_segment.rectangle_width + 1 == long_segment.rectangle_width && sub_right_segment.right_endpoint == long_segment.right_endpoint);
	assert_segment_a_b(long_segment);
#endif
	/*........................................................................................................................................*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&               Segment Width == 1 or 2                 &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	if (sub_right_segment.rectangle_width == 1) {
		//assert(0);
		return getAandBSlopInterceptOnePoint(point_value_left, sub_right_segment);//190115;
	}
	//	else if (sub_right_segment.rectangle_width == 2) {
	//	
	//		const int segment_left_id = sub_right_segment.right_endpoint - sub_right_segment.rectangle_width + 1;
	//#ifdef _DEBUG
	//		assert(sub_right_segment.right_endpoint - segment_left_id == 1 && long_segment.right_endpoint != INF && long_segment.rectangle_width == 3 && long_segment.apla.a != INF && long_segment.apla.b != INF);
	//#endif
	//		getAandBSlopInterceptTwoPoint(original_time_series_vector[sub_right_segment.right_endpoint - 1], original_time_series_vector[sub_right_segment.right_endpoint], sub_right_segment);//190115
	//#ifdef _DEBUG
	//		assert(sub_right_segment.apla.a != INF && sub_right_segment.apla.b != INF);
	//#endif
	//		return sub_right_segment;
	//	}
		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&						Segment Width >= 3       &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
		/*........................................................................................................................................*/
#ifdef _DEBUG
	assert(long_segment.rectangle_width > 1 && long_segment.rectangle_width == sub_right_segment.rectangle_width + 1 && long_segment.rectangle_width > 0 && long_segment.rectangle_width != INF && long_segment.right_endpoint > 0 && long_segment.right_endpoint != INF && long_segment.apla.a != INF && long_segment.apla.b != INF);
#endif
	/*........................................................................................................................................*/
	//200316 sum value
	//sub_right_segment.sum_value = long_segment.sum_value - original_time_series_vector[long_segment.right_endpoint];// sum value

	get_apla_coefficients_segment(sub_right_segment);

	/*sub_right_segment.apla.a = long_segment.apla.a * (long_segment.rectangle_width - 2) / (long_segment.rectangle_width - 1) + 6 * (point_value_left - long_segment.apla.b) / ((long_segment.rectangle_width - 1) * (long_segment.rectangle_width - 2));
	sub_right_segment.apla.b = (long_segment.apla.a * (long_segment.rectangle_width - 2) + long_segment.apla.b * (long_segment.rectangle_width + 3) - 4 * point_value_left) / (long_segment.rectangle_width - 1);
	*/
	sub_right_segment.apla.a = long_segment.apla.a + 6 * (point_value_left - long_segment.apla.b) / ((long_segment.rectangle_width - 1) * (long_segment.rectangle_width - 2));
	sub_right_segment.apla.b = long_segment.apla.a + (long_segment.apla.b * (long_segment.rectangle_width + 3) - 4 * point_value_left) / (long_segment.rectangle_width - 1);
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*........................................................................................................................................*/
#ifdef _DEBUG
	assert_segment_a_b(sub_right_segment);
	//Y test_coefficient = sub_right_segment;
	//test_coefficient.right_endpoint = sub_right_segment.right_endpoint;
	//test_coefficient.rectangle_width = sub_right_segment.rectangle_width;
	//get_ab_segment(original_time_series_vector, test_coefficient);
	//cout << *sub_right_segment.apla.a << " : " << temp_a << "      " << *sub_right_segment.apla.b << " : " << temp_b << endl;
	//assert(fabs(float(sub_right_segment.apla.a) - float(test_coefficient.apla.a)) <= 0.1 && fabs(float(sub_right_segment.apla.b) - float(test_coefficient.apla.b)) <= 0.1);
#endif
	/*........................................................................................................................................*/

	return sub_right_segment;
}

// 2010901 get a2&b2 of short right segment by left one point and old long segment
TEMPLATE
template<typename T, typename Y>
inline Y& APLA::get_ab_segment_by_decrement_left(const T& const point_value_left, Y& const long_segment) {
	Y segment_original_long_temp = long_segment;
	long_segment.rectangle_width--;

	get_ab_segment_by_decrement_left(point_value_left, segment_original_long_temp, long_segment);

	return long_segment;
}

// 2010907 get average of short right segment by left one point and old long segment
TEMPLATE
template<typename T, typename Y>
inline Y& APLA::get_ab_segment_by_decrement_left_average(const T& const point_value_left, Y& const sub_right_segment) {
	Y long_segment = sub_right_segment;
	sub_right_segment.rectangle_width--;

	/*........................................................................................................................................*/
#ifdef _DEBUG
	assert(sub_right_segment.rectangle_width > 0 && sub_right_segment.rectangle_width != INF && sub_right_segment.right_endpoint > 0 && sub_right_segment.right_endpoint != INF);
	assert(sub_right_segment.rectangle_width + 1 == long_segment.rectangle_width && sub_right_segment.right_endpoint == long_segment.right_endpoint);
	assert_segment_average(sub_right_segment);
#endif
	/*........................................................................................................................................*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&               Segment Width == 1 or 2                 &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	if (sub_right_segment.rectangle_width == 1) {
		//assert(0);
		return getAandBSlopInterceptOnePoint(point_value_left, sub_right_segment);//190115;
	}
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&						Segment Width >= 3       &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	/*........................................................................................................................................*/
#ifdef _DEBUG
	assert(long_segment.rectangle_width > 1 && long_segment.rectangle_width == sub_right_segment.rectangle_width + 1 && long_segment.rectangle_width > 0 && long_segment.rectangle_width != INF && long_segment.right_endpoint > 0 && long_segment.right_endpoint != INF && long_segment.apla.a != INF && long_segment.apla.b != INF);
#endif
	/*........................................................................................................................................*/

	get_apla_coefficients_segment(sub_right_segment);

	sub_right_segment.apla.b = (long_segment.apla.b * long_segment.rectangle_width - point_value_left) / sub_right_segment.rectangle_width;
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*........................................................................................................................................*/
#ifdef _DEBUG
	assert_segment_average(sub_right_segment);
#endif
	/*........................................................................................................................................*/

	return sub_right_segment;
}

//************************************
// Method:getABSlopeInterceptOriginal
// Qualifier: get slope a & intercept b by original time series
// date:190716
// author:
//************************************
TEMPLATE
double& APLA::getABSlopeInterceptOriginal(DataType*& const original_time_series, const int& const left_id, const int& const right_id, double& const slope_a, double& const intercept_b) {//190716 get slope a & intercept b by original time series
#ifdef _DEBUG
	assert(right_id - left_id > 0 && left_id > -1 && right_id > 0 && left_id != right_id);
	double sum_value = 0;
	for (int array_id = left_id; array_id <= right_id; array_id++) {
		sum_value += original_time_series[array_id];
	}
	//double test_sum_value = accumulate(&original_time_series[left_id], &original_time_series[right_id + 1], 0);
	//assert(test_sum_value == sum_value);
#endif
	double point_number = right_id - left_id + 1;

	/*=======================1 Point==================================================*/
	/*if (left_id == right_id) {
		assert(0);
	}*/
	/*..............................................................................*/

	/*======================2 Points================================================*/
	if (left_id + 1 == right_id) {
		slope_a = (original_time_series[right_id] - original_time_series[left_id]);
		intercept_b = original_time_series[left_id];
		return slope_a;
	}
	/*.............................................................................*/

	//a
	double a_minuend = (point_number - 1) / 2.0;//(l-1)/2
	double a_divisor = (point_number - 1) * (point_number + 1) * point_number;//l(l-1)(l+1)
	//b
	double b_minuend = 2.0 * point_number - 1;//2l-1
	double b_divisor = (point_number + 1) * point_number;//l(l+1)

#ifdef _DEBUG
	assert(a_divisor != 0 && b_divisor != 0);
	double sum_id_value = 0.0;
	for (int array_id = 1, original_id = left_id + 1; original_id <= right_id; array_id++, original_id++) {
		sum_id_value += array_id * original_time_series[original_id];
	}
	double temp_a = 12.0 * (sum_id_value - a_minuend * sum_value) / a_divisor;
	double temp_b = 2.0 * (b_minuend * sum_value - 3.0 * sum_id_value) / b_divisor;

#endif

	//coefficient of equation
	auto a_sum = 0.0;
	auto b_sum = 0.0;
	//array id
	double variable_id = NULL; //[0-segment_length)
	int array_id = NULL;//time series id

	for (variable_id = 0, array_id = left_id; array_id <= right_id; array_id++, variable_id++) {
		a_sum += (variable_id - a_minuend) * original_time_series[array_id];
		b_sum += (b_minuend - variable_id * 3.0) * original_time_series[array_id];
	}
	slope_a = 12.0 * a_sum / a_divisor;
	intercept_b = 2.0 * b_sum / b_divisor;

#ifdef _DEBUG
	//if(temp_a!=0)
	//assert(fabs(float(slope_a) - float(temp_a)) < (std::numeric_limits<float>::min)() && float(intercept_b) == float(temp_b));
#endif

	return slope_a;
}

//************************************
// Method:getABSlopeInterceptOriginal
// Qualifier: get slope a & intercept b by original time series. vector to instead pointer
// date:191231
// author:
//************************************
TEMPLATE
template<typename T>//191231 
double& APLA::getABSlopeInterceptOriginal(const vector<T>& const original_time_series, const int& const left_id, const int& const right_id, double& const slope_a, double& const intercept_b) {//191231 get slope a & intercept b by original time series
#ifdef _DEBUG
	assert(right_id - left_id > 0 && left_id > -1 && right_id > 0 && left_id != right_id && !original_time_series.empty());
	double sum_value = 0;
	for (int array_id = left_id; array_id <= right_id; array_id++) {
		sum_value += original_time_series[array_id];
	}
	//double test_sum_value = accumulate(&original_time_series[left_id], &original_time_series[right_id + 1], 0);
	//assert(test_sum_value == sum_value);
#endif
	double point_number = right_id - left_id + 1;

	/*=======================1 Point==================================================*/
	/*if (left_id == right_id) {
		assert(0);
	}*/
	/*..............................................................................*/

	/*======================2 Points================================================*/
	if (left_id + 1 == right_id) {
		slope_a = (original_time_series[right_id] - original_time_series[left_id]);
		intercept_b = original_time_series[left_id];
		return slope_a;
	}
	/*.............................................................................*/

	//a
	double a_minuend = (point_number - 1) / 2.0;//(l-1)/2
	double a_divisor = (point_number - 1) * (point_number + 1) * point_number;//l(l-1)(l+1)
	//b
	double b_minuend = 2.0 * point_number - 1;//2l-1
	double b_divisor = (point_number + 1) * point_number;//l(l+1)

#ifdef _DEBUG
	assert(a_divisor != 0 && b_divisor != 0);
	double sum_id_value = 0.0;
	for (int array_id = 1, original_id = left_id + 1; original_id <= right_id; array_id++, original_id++) {
		sum_id_value += array_id * original_time_series[original_id];
	}
	double temp_a = 12.0 * (sum_id_value - a_minuend * sum_value) / a_divisor;
	double temp_b = 2.0 * (b_minuend * sum_value - 3.0 * sum_id_value) / b_divisor;

#endif

	//coefficient of equation
	auto a_sum = 0.0;
	auto b_sum = 0.0;
	//array id
	double variable_id = NULL; //[0-segment_length)
	int array_id = NULL;//time series id

	for (variable_id = 0, array_id = left_id; array_id <= right_id; array_id++, variable_id++) {
		a_sum += (variable_id - a_minuend) * original_time_series[array_id];
		b_sum += (b_minuend - variable_id * 3.0) * original_time_series[array_id];
	}
	slope_a = 12.0 * a_sum / a_divisor;
	intercept_b = 2.0 * b_sum / b_divisor;

#ifdef _DEBUG
	//if(temp_a!=0)
	//assert(fabs(float(slope_a) - float(temp_a)) < (std::numeric_limits<float>::min)() && float(intercept_b) == float(temp_b));
#endif

	return slope_a;
}

//************************************
// Method:getAAndBByPLAShortSeg
// Qualifier: get a & b of segment PLA from sub short segment, No need original time series
// date:190412 return a&b from short segment;
// author:
//************************************
TEMPLATE
double& APLA::getAAndBByPLAShortSeg(DataType*& const original_time_series, const vector<AREA_COEFFICIENT>& const area_vector, int& const vector_id, AREA_COEFFICIENT& const temp_coefficient) {//190412 return a&b from short segment;
	auto left_id = vector_id - 1;
#ifdef _DEBUG
	assert(vector_id > 0 && area_vector[vector_id].apla.a != INF && area_vector[left_id].apla.a != INF && area_vector[vector_id].apla.b != INF && area_vector[left_id].apla.b != INF && area_vector[left_id].sum_value != INF && area_vector[vector_id].sum_value);
	assert(temp_coefficient.rectangle_width > 0 && temp_coefficient.rectangle_width != INF && temp_coefficient.rectangle_height >= 0 && temp_coefficient.right_endpoint > 0 && temp_coefficient.right_endpoint != INF);
	/*==========Print==============*/
	//cout << area_vector[left_id].apla.a <<" "<< area_vector[vector_id].apla.a <<" "<< area_vector[left_id].sum_value << " " << area_vector[vector_id].sum_value << endl;

#endif

	temp_coefficient.sum_value = area_vector[left_id].sum_value + area_vector[vector_id].sum_value;

	if (temp_coefficient.rectangle_width == 1) {
#ifdef _DEBUG
		assert(0);
#endif
		return getAandBSlopInterceptOnePoint(original_time_series, temp_coefficient);
	}

	//printf("getPLA()\n");
	//assert(temp_coefficient.size() == input_argument.point_dimension);

	int segment_left_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	//coefficient of equation
	//a
	double a_minuend = NULL; //(l-1)/2
	double a_divisor = NULL; //l(l-1)(l+1)
	//b
	double b_minuend = NULL; //2l-1
	double b_divisor = NULL; //l(l+1)

	auto a_sum = 0.0;
	auto b_sum = 0.0;
	double variable_id = NULL; //[0-segment_length)
	int array_id = NULL;//time series id

	/*...............................................................................*/
	temp_coefficient.apla.a_minuend = a_minuend = (temp_coefficient.rectangle_width - 1) / 2.0;//(l-1)/2
	temp_coefficient.apla.a_divisor = a_divisor = (temp_coefficient.rectangle_width - 1) * (temp_coefficient.rectangle_width + 1) * temp_coefficient.rectangle_width;//l(l-1)(l+1)

	temp_coefficient.apla.b_minuend = b_minuend = 2.0 * temp_coefficient.rectangle_width - 1;//2l-1
	temp_coefficient.apla.b_divisor = b_divisor = (temp_coefficient.rectangle_width + 1) * temp_coefficient.rectangle_width;//l(l+1)

#ifdef _DEBUG
	assert(a_divisor != 0);
	assert(b_divisor != 0);
#endif
	double tempp_a = NULL;
	double tempp_b = NULL;

	//190412
	double coefficient_a1 = area_vector[left_id].apla.a_divisor / temp_coefficient.apla.a_divisor;
	double coefficient_a2 = area_vector[vector_id].apla.a_divisor / temp_coefficient.apla.a_divisor;
	double difference_a1 = area_vector[left_id].apla.a_minuend - temp_coefficient.apla.a_minuend;
	double difference_a2 = area_vector[vector_id].apla.a_minuend - temp_coefficient.apla.a_minuend;
	//190415
	double coefficient_b1 = area_vector[left_id].apla.b_divisor / temp_coefficient.apla.b_divisor;
	double coefficient_b2 = area_vector[vector_id].apla.b_divisor / temp_coefficient.apla.b_divisor;
	double difference_b1 = temp_coefficient.apla.b_minuend - area_vector[left_id].apla.b_minuend;
	double difference_b2 = temp_coefficient.apla.b_minuend - area_vector[vector_id].apla.b_minuend;

	//auto temp_a = coefficient1 * area_vector[left_id].apla.a + coefficient2 * area_vector[vector_id].apla.a + 12.0/ temp_coefficient.apla.a_divisor*(difference1 * area_vector[left_id].sum_value + difference2 * area_vector[vector_id].sum_value);

	temp_coefficient.apla.a = coefficient_a1 * area_vector[left_id].apla.a + (12.0 / temp_coefficient.apla.a_divisor) * difference_a1 * area_vector[left_id].sum_value + coefficient_a2 * area_vector[vector_id].apla.a + (12.0 / temp_coefficient.apla.a_divisor) * (area_vector[left_id].rectangle_width + difference_a2) * area_vector[vector_id].sum_value;
	temp_coefficient.apla.b = coefficient_b1 * area_vector[left_id].apla.b + 2.0 / temp_coefficient.apla.b_divisor * difference_b1 * area_vector[left_id].sum_value + coefficient_b2 * area_vector[vector_id].apla.b + 2.0 / temp_coefficient.apla.b_divisor * (difference_b2 - 3 * area_vector[left_id].rectangle_width) * area_vector[vector_id].sum_value;
#ifdef _DEBUG
	//cout << float(temp_coefficient.apla.b) << " "<<float(temp_b) <<endl;
	for (variable_id = 0, array_id = segment_left_id; array_id <= temp_coefficient.right_endpoint; array_id++, variable_id++) {
		//#ifdef _DEBUG
		//		cout << "Original T: " << original_time_series[array_id] <<" "<< endl;
		//#endif
		a_sum += (variable_id - a_minuend) * original_time_series[array_id];
		b_sum += (b_minuend - variable_id * 3.0) * original_time_series[array_id];
	}
	auto temp_a = 12.0 * a_sum / a_divisor;
	auto temp_b = 2.0 * b_sum / b_divisor;
	assert(fabs(float(temp_coefficient.apla.b) - float(temp_b)) < (std::numeric_limits<float>::min)());
	assert(fabs(float(temp_coefficient.apla.a) - float(temp_a)) < (std::numeric_limits<float>::min)());
#endif
	return temp_coefficient.apla.a;
}

//************************************
// Method:getAAndBByPLAShortSegSpeed
// Qualifier: get a & b of segment PLA and sum value
// Input left segment, right segment, left a&b, right a&b, left sum value, right sum value, left width, right width, segment width, segment right endpoint
// date:190611 return a&b from short segment;
// author:
//************************************
TEMPLATE
void APLA::getAAndBByPLAShortSegSpeed(const vector<AREA_COEFFICIENT>& const area_vector, int& const vector_id, AREA_COEFFICIENT& const temp_coefficient) {//190611 No evaluation method
	auto left_id = vector_id - 1;
#ifdef _DEBUG
	assert(vector_id > 0 && area_vector[vector_id].apla.a != INF && area_vector[left_id].apla.a != INF && area_vector[vector_id].apla.b != INF && area_vector[left_id].apla.b != INF && area_vector[left_id].sum_value != INF && area_vector[vector_id].sum_value != INF);
	assert(temp_coefficient.rectangle_width > 0 && temp_coefficient.rectangle_width != INF && temp_coefficient.rectangle_height >= 0 && temp_coefficient.right_endpoint > 0 && temp_coefficient.right_endpoint != INF);
	assert(area_vector[left_id].sum_value != INF && area_vector[vector_id].sum_value != INF);
	/*==========Print==============*/
	//cout << area_vector[left_id].apla.a <<" "<< area_vector[vector_id].apla.a <<" "<< area_vector[left_id].sum_value << " " << area_vector[vector_id].sum_value << endl;

#endif

	temp_coefficient.sum_value = area_vector[left_id].sum_value + area_vector[vector_id].sum_value;

	//if (temp_coefficient.rectangle_width == 1) {
#ifdef _DEBUG
		//assert(0);
	assert(temp_coefficient.rectangle_width > 1);
#endif

	//return getAandB(original_time_series, temp_coefficient);
//}

//printf("getPLA()\n");
//assert(temp_coefficient.size() == input_argument.point_dimension);

	int segment_left_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	//coefficient of equation
	//a
	double a_minuend = NULL; //(l-1)/2
	double a_divisor = NULL; //l(l-1)(l+1)
	//b
	double b_minuend = NULL; //2l-1
	double b_divisor = NULL; //l(l+1)

	auto a_sum = 0.0;
	auto b_sum = 0.0;
	double variable_id = NULL; //[0-segment_length)
	int array_id = NULL;//time series id

	/*...............................................................................*/
	temp_coefficient.apla.a_minuend = a_minuend = (temp_coefficient.rectangle_width - 1) / 2.0;//(l-1)/2
	temp_coefficient.apla.a_divisor = a_divisor = (temp_coefficient.rectangle_width - 1) * (temp_coefficient.rectangle_width + 1) * temp_coefficient.rectangle_width;//l(l-1)(l+1)

	temp_coefficient.apla.b_minuend = b_minuend = 2.0 * temp_coefficient.rectangle_width - 1;//2l-1
	temp_coefficient.apla.b_divisor = b_divisor = (temp_coefficient.rectangle_width + 1) * temp_coefficient.rectangle_width;//l(l+1)

#ifdef _DEBUG
	assert(a_divisor != 0);
	assert(b_divisor != 0);
#endif
	double tempp_a = NULL;
	double tempp_b = NULL;

	//190412
	double coefficient_a1 = area_vector[left_id].apla.a_divisor / temp_coefficient.apla.a_divisor;
	double coefficient_a2 = area_vector[vector_id].apla.a_divisor / temp_coefficient.apla.a_divisor;
	double difference_a1 = area_vector[left_id].apla.a_minuend - temp_coefficient.apla.a_minuend;
	double difference_a2 = area_vector[vector_id].apla.a_minuend - temp_coefficient.apla.a_minuend;
	//190415
	double coefficient_b1 = area_vector[left_id].apla.b_divisor / temp_coefficient.apla.b_divisor;
	double coefficient_b2 = area_vector[vector_id].apla.b_divisor / temp_coefficient.apla.b_divisor;
	double difference_b1 = temp_coefficient.apla.b_minuend - area_vector[left_id].apla.b_minuend;
	double difference_b2 = temp_coefficient.apla.b_minuend - area_vector[vector_id].apla.b_minuend;

	//auto temp_a = coefficient1 * area_vector[left_id].apla.a + coefficient2 * area_vector[vector_id].apla.a + 12.0/ temp_coefficient.apla.a_divisor*(difference1 * area_vector[left_id].sum_value + difference2 * area_vector[vector_id].sum_value);

	temp_coefficient.apla.a = coefficient_a1 * area_vector[left_id].apla.a + (12.0 / temp_coefficient.apla.a_divisor) * difference_a1 * area_vector[left_id].sum_value + coefficient_a2 * area_vector[vector_id].apla.a + (12.0 / temp_coefficient.apla.a_divisor) * (area_vector[left_id].rectangle_width + difference_a2) * area_vector[vector_id].sum_value;
	temp_coefficient.apla.b = coefficient_b1 * area_vector[left_id].apla.b + 2.0 / temp_coefficient.apla.b_divisor * difference_b1 * area_vector[left_id].sum_value + coefficient_b2 * area_vector[vector_id].apla.b + 2.0 / temp_coefficient.apla.b_divisor * (difference_b2 - 3 * area_vector[left_id].rectangle_width) * area_vector[vector_id].sum_value;
#ifdef _DEBUG
	auto temp_a = area_vector[left_id].apla.a_divisor * area_vector[left_id].apla.a + area_vector[vector_id].apla.a_divisor * area_vector[vector_id].apla.a + 6 * (area_vector[left_id].rectangle_width * area_vector[vector_id].sum_value - area_vector[vector_id].rectangle_width * area_vector[left_id].sum_value);
	temp_a /= temp_coefficient.apla.a_divisor;
	auto temp_b = area_vector[left_id].apla.b_divisor * area_vector[left_id].apla.b + area_vector[vector_id].apla.b_divisor * area_vector[vector_id].apla.b + 4 * area_vector[vector_id].rectangle_width * area_vector[left_id].sum_value - 2 * area_vector[left_id].rectangle_width * area_vector[vector_id].sum_value;
	temp_b /= temp_coefficient.apla.b_divisor;
	//assert(float(temp_a) == float(temp_coefficient.apla.a) && float(temp_b) == float(temp_coefficient.apla.b));
//	//cout << float(temp_coefficient.apla.b) << " "<<float(temp_b) <<endl;
//	for (variable_id = 0, array_id = segment_left_id; array_id <= temp_coefficient.right_endpoint; array_id++, variable_id++) {
//		//#ifdef _DEBUG
//		//		cout << "Original T: " << original_time_series[array_id] <<" "<< endl;
//		//#endif
//		a_sum += (variable_id - a_minuend) * original_time_series[array_id];
//		b_sum += (b_minuend - variable_id * 3.0) * original_time_series[array_id];
//	}
//	auto temp_a = 12.0 * a_sum / a_divisor;
//	auto temp_b = 2.0 * b_sum / b_divisor;
	//assert(fabs(float(temp_coefficient.apla.b) - float(temp_b)) < (std::numeric_limits<float>::min)());
	//assert(fabs(float(temp_coefficient.apla.a) - float(temp_a)) < (std::numeric_limits<float>::min)());
	assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF && temp_coefficient.apla.a_minuend != INF && temp_coefficient.apla.b_minuend != INF && temp_coefficient.apla.a_divisor != INF && temp_coefficient.apla.b_divisor != INF);
#endif
	//return temp_coefficient.apla.a;
}

//************************************
// Method:getAAndBByPLAShortSegSpeed
// Qualifier: get a & b of segment PLA and sum value
// Input: left segment, right segment, left a&b, right a&b, left sum value, right sum value, left width, right width, segment width, segment right endpoint
// Output: 1 a&b, 2 sum value
// date:190611 return a&b from short segment;
// author:
//************************************
TEMPLATE
inline void APLA::getAAndBByPLAShortSegSpeed(DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list, int& const vector_id, AREA_COEFFICIENT& const temp_coefficient) {//190825 No evaluation method and sum value and a b
	auto left_id = vector_id - 1;
#ifdef _DEBUG
	assert(vector_id > 0 && doubly_linked_list[vector_id].apla.a != INF && doubly_linked_list[left_id].apla.a != INF && doubly_linked_list[vector_id].apla.b != INF && doubly_linked_list[left_id].apla.b != INF && doubly_linked_list[left_id].sum_value != INF && doubly_linked_list[vector_id].sum_value != INF);
	assert(temp_coefficient.rectangle_width > 1 && temp_coefficient.rectangle_width != INF && temp_coefficient.rectangle_height >= 0 && temp_coefficient.right_endpoint > 0 && temp_coefficient.right_endpoint != INF);
	assert(doubly_linked_list[left_id].sum_value != INF && doubly_linked_list[vector_id].sum_value != INF);
	/*==========Print==============*/
	//cout << area_vector[left_id].apla.a <<" "<< area_vector[vector_id].apla.a <<" "<< area_vector[left_id].sum_value << " " << area_vector[vector_id].sum_value << endl;
#endif
	/*---------------------------------------------   Sum Value   ---------------------------------------------*/
	temp_coefficient.sum_value = doubly_linked_list[left_id].sum_value + doubly_linked_list[vector_id].sum_value;
	/*.........................................................................................................*/

	//if (temp_coefficient.rectangle_width == 1) {
//#ifdef _DEBUG
//	assert(temp_coefficient.rectangle_width > 1);
//#endif
	//return getAandB(original_time_series, temp_coefficient);
//}

//printf("getPLA()\n");
//assert(temp_coefficient.size() == input_argument.point_dimension);

	int segment_left_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	//coefficient of equation
	//a
	double a_minuend = NULL; //(l-1)/2
	double a_divisor = NULL; //l(l-1)(l+1)
	//b
	double b_minuend = NULL; //2l-1
	double b_divisor = NULL; //l(l+1)

	auto a_sum = 0.0;
	auto b_sum = 0.0;
	double variable_id = NULL; //[0-segment_length)
	int array_id = NULL;//time series id

	/*...............................................................................*/
	temp_coefficient.apla.a_minuend = a_minuend = (temp_coefficient.rectangle_width - 1) / 2.0;//(l-1)/2
	temp_coefficient.apla.a_divisor = a_divisor = (temp_coefficient.rectangle_width - 1) * (temp_coefficient.rectangle_width + 1) * temp_coefficient.rectangle_width;//l(l-1)(l+1)

	temp_coefficient.apla.b_minuend = b_minuend = 2.0 * temp_coefficient.rectangle_width - 1;//2l-1
	temp_coefficient.apla.b_divisor = b_divisor = (temp_coefficient.rectangle_width + 1) * temp_coefficient.rectangle_width;//l(l+1)

#ifdef _DEBUG
	assert(a_divisor != 0);
	assert(b_divisor != 0);
#endif
	double tempp_a = NULL;
	double tempp_b = NULL;

	//190412
	double coefficient_a1 = doubly_linked_list[left_id].apla.a_divisor / temp_coefficient.apla.a_divisor;
	double coefficient_a2 = doubly_linked_list[vector_id].apla.a_divisor / temp_coefficient.apla.a_divisor;
	double difference_a1 = doubly_linked_list[left_id].apla.a_minuend - temp_coefficient.apla.a_minuend;
	double difference_a2 = doubly_linked_list[vector_id].apla.a_minuend - temp_coefficient.apla.a_minuend;
	//190415
	double coefficient_b1 = doubly_linked_list[left_id].apla.b_divisor / temp_coefficient.apla.b_divisor;
	double coefficient_b2 = doubly_linked_list[vector_id].apla.b_divisor / temp_coefficient.apla.b_divisor;
	double difference_b1 = temp_coefficient.apla.b_minuend - doubly_linked_list[left_id].apla.b_minuend;
	double difference_b2 = temp_coefficient.apla.b_minuend - doubly_linked_list[vector_id].apla.b_minuend;

	//auto temp_a = coefficient1 * area_vector[left_id].apla.a + coefficient2 * area_vector[vector_id].apla.a + 12.0/ temp_coefficient.apla.a_divisor*(difference1 * area_vector[left_id].sum_value + difference2 * area_vector[vector_id].sum_value);

	temp_coefficient.apla.a = coefficient_a1 * doubly_linked_list[left_id].apla.a + (12.0 / temp_coefficient.apla.a_divisor) * difference_a1 * doubly_linked_list[left_id].sum_value + coefficient_a2 * doubly_linked_list[vector_id].apla.a + (12.0 / temp_coefficient.apla.a_divisor) * (doubly_linked_list[left_id].rectangle_width + difference_a2) * doubly_linked_list[vector_id].sum_value;
	temp_coefficient.apla.b = coefficient_b1 * doubly_linked_list[left_id].apla.b + 2.0 / temp_coefficient.apla.b_divisor * difference_b1 * doubly_linked_list[left_id].sum_value + coefficient_b2 * doubly_linked_list[vector_id].apla.b + 2.0 / temp_coefficient.apla.b_divisor * (difference_b2 - 3 * doubly_linked_list[left_id].rectangle_width) * doubly_linked_list[vector_id].sum_value;
#ifdef _DEBUG
	auto temp_a = doubly_linked_list[left_id].apla.a_divisor * doubly_linked_list[left_id].apla.a + doubly_linked_list[vector_id].apla.a_divisor * doubly_linked_list[vector_id].apla.a + 6 * (doubly_linked_list[left_id].rectangle_width * doubly_linked_list[vector_id].sum_value - doubly_linked_list[vector_id].rectangle_width * doubly_linked_list[left_id].sum_value);
	temp_a /= temp_coefficient.apla.a_divisor;
	auto temp_b = doubly_linked_list[left_id].apla.b_divisor * doubly_linked_list[left_id].apla.b + doubly_linked_list[vector_id].apla.b_divisor * doubly_linked_list[vector_id].apla.b + 4 * doubly_linked_list[vector_id].rectangle_width * doubly_linked_list[left_id].sum_value - 2 * doubly_linked_list[left_id].rectangle_width * doubly_linked_list[vector_id].sum_value;
	temp_b /= temp_coefficient.apla.b_divisor;
	//assert(float(temp_a) == float(temp_coefficient.apla.a) && float(temp_b) == float(temp_coefficient.apla.b));
//	//cout << float(temp_coefficient.apla.b) << " "<<float(temp_b) <<endl;
//	for (variable_id = 0, array_id = segment_left_id; array_id <= temp_coefficient.right_endpoint; array_id++, variable_id++) {
//		//#ifdef _DEBUG
//		//		cout << "Original T: " << original_time_series[array_id] <<" "<< endl;
//		//#endif
//		a_sum += (variable_id - a_minuend) * original_time_series[array_id];
//		b_sum += (b_minuend - variable_id * 3.0) * original_time_series[array_id];
//	}
//	auto temp_a = 12.0 * a_sum / a_divisor;
//	auto temp_b = 2.0 * b_sum / b_divisor;
	//assert(fabs(float(temp_coefficient.apla.b) - float(temp_b)) < (std::numeric_limits<float>::min)());
	//assert(fabs(float(temp_coefficient.apla.a) - float(temp_a)) < (std::numeric_limits<float>::min)());
	assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF && temp_coefficient.apla.a_minuend != INF && temp_coefficient.apla.b_minuend != INF && temp_coefficient.apla.a_divisor != INF && temp_coefficient.apla.b_divisor != INF);
#endif
	//return temp_coefficient.apla.a;
}

//************************************
// Method:getAAndBByPLAShortSegSpeed
// Qualifier: get a & b of segment PLA and sum value
// Input: 1 left a&b, right a&b, 2 left width, right width,  3 segment width, 4 segment right endpoint
// Output: 1 a&b
// date:190904 return merged long segment a&b from short segment;
// Note:200311 No need sum value, according to new formula
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline void APLA::getAAndBByPLAShortSegSpeed(const T& const left_segment, const T& const right_segment, Y& const merged_segment) {
	/*..................................................................................................................................................*/
#ifdef _DEBUG
	assert(merged_segment.rectangle_width > 2 && merged_segment.rectangle_width != INF && merged_segment.right_endpoint > 0 && merged_segment.right_endpoint != INF);
	assert(merged_segment.rectangle_width == left_segment.rectangle_width + right_segment.rectangle_width && right_segment.right_endpoint == merged_segment.right_endpoint);
	//cout << area_vector[left_id].apla.a <<" "<< area_vector[vector_id].apla.a <<" "<< area_vector[left_id].sum_value << " " << area_vector[vector_id].sum_value << endl;
	assert_segment_a_b(left_segment);
	assert_segment_a_b(right_segment);
#endif
	/*..................................................................................................................................................*/

	/*.............................................   Sum Value   .............................................*/
	//200316 sum value
	//merged_segment.sum_value = left_segment.sum_value + right_segment.sum_value;
	/*.........................................................................................................*/

	//if (temp_coefficient.rectangle_width == 1) {
//#ifdef _DEBUG
//	assert(temp_coefficient.rectangle_width > 1);
//#endif
	//return getAandB(original_time_series, temp_coefficient);
//}

//printf("getPLA()\n");
//assert(temp_coefficient.size() == input_argument.point_dimension);
	/*........................................................................................................................................*/
	//coefficient of equation
	get_apla_coefficients_segment(merged_segment);
	/*........................................................................................................................................*/

	/*...............................Do not need sum value..........................................*/
	const long double coefficient_long0 = merged_segment.rectangle_width - 1;// l - 1
	const long double coefficient_left0 = left_segment.rectangle_width - 1;// l1 - 1 
	const long double coefficient_right0 = right_segment.rectangle_width - 1;//  l2 - 1 
	const long double coefficient_long1 = merged_segment.rectangle_width + 1;// l + 1
	const long double coefficient_left1 = left_segment.rectangle_width + 1;// l1 + 1 
	const long double coefficient_right1 = right_segment.rectangle_width + 1;// l2 + 1 
	const long double coefficient_long2 = merged_segment.rectangle_width * coefficient_long1;// l * ( l + 1)
	const long double coefficient_long3 = coefficient_long2 * coefficient_long0;// l * ( l + 1) * ( l - 1 )
	const long double b_coefficient_for_a = (right_segment.apla.b - left_segment.apla.b) * 6 * left_segment.rectangle_width * right_segment.rectangle_width / coefficient_long3;
	const long double b_coefficient_for_b = (4 * left_segment.apla.b - 2 * right_segment.apla.b) * left_segment.rectangle_width * right_segment.rectangle_width / coefficient_long2;
	merged_segment.apla.a = left_segment.apla.a * left_segment.rectangle_width * coefficient_left0 * (coefficient_left1 - 3 * right_segment.rectangle_width) / coefficient_long3 + right_segment.apla.a * right_segment.rectangle_width * coefficient_right0 * (coefficient_right1 + 3 * left_segment.rectangle_width) / coefficient_long3 + b_coefficient_for_a;
	merged_segment.apla.b = left_segment.apla.b * left_segment.rectangle_width * coefficient_left1 / coefficient_long2 + 2 * left_segment.apla.a * right_segment.rectangle_width * left_segment.rectangle_width * coefficient_left0 / coefficient_long2 + right_segment.apla.b * right_segment.rectangle_width * coefficient_right1 / coefficient_long2 - right_segment.apla.a * left_segment.rectangle_width * right_segment.rectangle_width * coefficient_right0 / coefficient_long2 + b_coefficient_for_b;
	/*..............................................................................................*/

	/*............................................................... DEBUG  .....................................................................................*/
#ifdef _DEBUG
	assert_segment_a_b(merged_segment);
	const long double sum_value_left_segment = get_sum_value(left_segment.apla.a, left_segment.apla.b, left_segment.rectangle_width);
	const long double sum_value_right_segment = get_sum_value(right_segment.apla.a, right_segment.apla.b, right_segment.rectangle_width);
	const long double sum_value_test = get_sum_value(merged_segment.apla.a, merged_segment.apla.b, merged_segment.rectangle_width);
	assert(fabs(sum_value_left_segment + sum_value_right_segment - sum_value_test) <= MIN_D);
	/*.................................    Need sum value    .......................................*/
	//190412
	double coefficient_a1 = left_segment.apla.a_divisor / merged_segment.apla.a_divisor;
	double coefficient_a2 = right_segment.apla.a_divisor / merged_segment.apla.a_divisor;
	double difference_a1 = left_segment.apla.a_minuend - merged_segment.apla.a_minuend;
	double difference_a2 = right_segment.apla.a_minuend - merged_segment.apla.a_minuend;
	//190415
	double coefficient_b1 = left_segment.apla.b_divisor / merged_segment.apla.b_divisor;
	double coefficient_b2 = right_segment.apla.b_divisor / merged_segment.apla.b_divisor;
	double difference_b1 = merged_segment.apla.b_minuend - left_segment.apla.b_minuend;
	double difference_b2 = merged_segment.apla.b_minuend - right_segment.apla.b_minuend;

	float a_test = coefficient_a1 * left_segment.apla.a + (12.0 / merged_segment.apla.a_divisor) * difference_a1 * sum_value_left_segment + coefficient_a2 * right_segment.apla.a + (12.0 / merged_segment.apla.a_divisor) * (left_segment.rectangle_width + difference_a2) * sum_value_right_segment;
	float b_test = coefficient_b1 * left_segment.apla.b + 2.0 / merged_segment.apla.b_divisor * difference_b1 * sum_value_left_segment + coefficient_b2 * right_segment.apla.b + 2.0 / merged_segment.apla.b_divisor * (difference_b2 - 3 * left_segment.rectangle_width) * sum_value_right_segment;

	auto temp_a = left_segment.apla.a_divisor * left_segment.apla.a + right_segment.apla.a_divisor * right_segment.apla.a + 6 * (left_segment.rectangle_width * sum_value_right_segment - right_segment.rectangle_width * sum_value_left_segment);
	temp_a /= merged_segment.apla.a_divisor;
	auto temp_b = left_segment.apla.b_divisor * left_segment.apla.b + right_segment.apla.b_divisor * right_segment.apla.b + 4 * right_segment.rectangle_width * sum_value_left_segment - 2 * left_segment.rectangle_width * sum_value_right_segment;
	temp_b /= merged_segment.apla.b_divisor;


	assert(fabs(float(merged_segment.apla.a) - float(temp_a)) <= 0.1 && fabs(float(merged_segment.apla.b) - float(temp_b)) <= 0.1);
	/*..............................................................................................*/

	//auto a_sum = 0.0;
	//auto b_sum = 0.0;
	//double variable_id = NULL; //[0-segment_length)
	//int array_id = NULL;//time series id
	//int segment_left_id = merged_segment.right_endpoint - merged_segment.rectangle_width + 1;
	//assert(float(temp_a) == float(merged_segment.apla.a) && float(temp_b) == float(merged_segment.apla.b));
//	//cout << float(merged_segment.apla.b) << " "<<float(temp_b) <<endl;
//	for (variable_id = 0, array_id = segment_left_id; array_id <= merged_segment.right_endpoint; array_id++, variable_id++) {
//		//#ifdef _DEBUG
//		//		cout << "Original T: " << original_time_series[array_id] <<" "<< endl;
//		//#endif
//		a_sum += (variable_id - a_minuend) * original_time_series[array_id];
//		b_sum += (b_minuend - variable_id * 3.0) * original_time_series[array_id];
//	}
//	auto temp_a = 12.0 * a_sum / a_divisor;
//	auto temp_b = 2.0 * b_sum / b_divisor;
	//assert(fabs(float(merged_segment.apla.b) - float(temp_b)) < (std::numeric_limits<float>::min)());
	//assert(fabs(float(merged_segment.apla.a) - float(temp_a)) < (std::numeric_limits<float>::min)());

#endif
	/*............................................................................................................................................................*/

	//return merged_segment.apla.a;
}

//210907 get merged average value of left segment & right segment
TEMPLATE
template<typename T, typename Y>
inline void APLA::getAAndBByPLAShortSegSpeed_average(const T& const left_segment, const T& const right_segment, Y& const merged_segment) {
	/*..................................................................................................................................................*/
#ifdef _DEBUG
	assert(merged_segment.rectangle_width >= 2 && merged_segment.rectangle_width != INF && merged_segment.right_endpoint > 0 && merged_segment.right_endpoint != INF);
	assert(merged_segment.rectangle_width == left_segment.rectangle_width + right_segment.rectangle_width && right_segment.right_endpoint == merged_segment.right_endpoint);
	assert_segment_average(left_segment);
	assert_segment_average(right_segment);
#endif
	/*..................................................................................................................................................*/

	/*------------- apla coefficient ------------*/
	//coefficient of equation
	get_apla_coefficients_segment(merged_segment);
	/*-------------------------------------------*/

	/*...............................Do not need sum value..........................................*/
	merged_segment.apla.a = 0;
	merged_segment.apla.b = (left_segment.apla.b * left_segment.rectangle_width + right_segment.apla.b * right_segment.rectangle_width) / merged_segment.rectangle_width;
	/*..............................................................................................*/

}

//190920
//************************************
// Method:getRightSubAAndBByPLA
// Qualifier: get a & b of segment PLA and sum value
// Input: 1 left sub segment a&b, width, sum; 2 merged segment a&b, width, sum.
// Output: 1 right sub segment a&b, sum value;
// date:190920 return a&b from long segment;
// author:
//************************************
//TEMPLATE
//inline typename APLA::AREA_COEFFICIENT& APLA::getSubRightAAndBByPLA(const AREA_COEFFICIENT& const left_segment, const AREA_COEFFICIENT& const merged_segment, AREA_COEFFICIENT& const right_segment) {
//#ifdef _DEBUG
//	assert(left_segment.apla.a != INF && merged_segment.apla.a != INF && left_segment.apla.b != INF && merged_segment.apla.b != INF && left_segment.sum_value != INF && merged_segment.sum_value != INF);
//	assert(merged_segment.rectangle_width > 3 && merged_segment.rectangle_width != INF && merged_segment.rectangle_height >= 0 && merged_segment.right_endpoint > 0 && merged_segment.right_endpoint != INF);
//	assert(left_segment.rectangle_width > 1 && left_segment.rectangle_width != INF && left_segment.rectangle_height >= 0 && left_segment.right_endpoint > 0 && left_segment.right_endpoint != INF);
//	assert(left_segment.apla.a_minuend != INF && left_segment.apla.a_divisor != INF && left_segment.apla.b_minuend != INF && left_segment.apla.b_divisor != INF);
//	assert(merged_segment.apla.a_minuend != INF && merged_segment.apla.a_divisor != INF && merged_segment.apla.b_minuend != INF && merged_segment.apla.b_divisor != INF);
//	assert(right_segment.rectangle_width > 1 && right_segment.rectangle_width != INF && merged_segment.rectangle_width == left_segment.rectangle_width + right_segment.rectangle_width);
//
//	// left a coefficient
//	assert(left_segment.apla.a_minuend == (left_segment.rectangle_width - 1) / 2.0);//(l-1)/2
//	assert(left_segment.apla.a_divisor == (left_segment.rectangle_width - 1) * (left_segment.rectangle_width + 1) * left_segment.rectangle_width);//l(l-1)(l+1)
//	// left b coefficient
//	assert(left_segment.apla.b_minuend == 2.0 * left_segment.rectangle_width - 1);//2l-1
//	assert(left_segment.apla.b_divisor == (left_segment.rectangle_width + 1) * left_segment.rectangle_width);//l(l+1)
//
//	// merged a coefficient
//	assert(merged_segment.apla.a_minuend == (merged_segment.rectangle_width - 1) / 2.0);//(l-1)/2
//	assert(merged_segment.apla.a_divisor == (merged_segment.rectangle_width - 1) * (merged_segment.rectangle_width + 1) * merged_segment.rectangle_width);//l(l-1)(l+1)
//	// merged b coefficient
//	assert(merged_segment.apla.b_minuend == 2.0 * merged_segment.rectangle_width - 1);//2l-1
//	assert(merged_segment.apla.b_divisor == (merged_segment.rectangle_width + 1) * merged_segment.rectangle_width);//l(l+1)
//
//#endif
//
//	/*--------------------------------------------- sub Sum Value   ---------------------------------------------*/
//	right_segment.sum_value = merged_segment.sum_value - left_segment.sum_value;
//	/*.........................................................................................................*/
//
//	//if (temp_coefficient.rectangle_width == 1) {
////#ifdef _DEBUG
////	assert(temp_coefficient.rectangle_width > 1);
////#endif
//	//return getAandB(original_time_series, temp_coefficient);
////}
//
////printf("getPLA()\n");
////assert(temp_coefficient.size() == input_argument.point_dimension);
//
//	/*...................................get pla coefficients of right segment............................................*/
//	//a
//	right_segment.apla.a_minuend = (right_segment.rectangle_width - 1) / 2.0;//(l-1)/2
//	right_segment.apla.a_divisor = (right_segment.rectangle_width - 1) * (right_segment.rectangle_width + 1) * right_segment.rectangle_width;//l(l-1)(l+1)
//	//b
//	right_segment.apla.b_minuend = 2.0 * right_segment.rectangle_width - 1;//2l-1
//	right_segment.apla.b_divisor = (right_segment.rectangle_width + 1) * right_segment.rectangle_width;//l(l+1)
//	/*......................................................................................................................*/
//
//	/*-----------------------------------get pla a & b of right segment-------------------------------------------------------------------------------------------------------------------------------------------------------------*/
//	right_segment.apla.a = (merged_segment.apla.a * merged_segment.apla.a_divisor + 6 * right_segment.rectangle_width * left_segment.sum_value - 6 * left_segment.rectangle_width * right_segment.sum_value - left_segment.apla.a_divisor * left_segment.apla.a) / right_segment.apla.a_divisor;
//	right_segment.apla.b = (merged_segment.apla.b * merged_segment.apla.b_divisor + 2 * left_segment.rectangle_width * right_segment.sum_value - 4 * right_segment.rectangle_width * left_segment.sum_value - left_segment.apla.b_divisor * left_segment.apla.b) / right_segment.apla.b_divisor;
//#ifdef _DEBUG
//	auto temp_a2 = merged_segment.apla.a * merged_segment.apla.a_divisor / right_segment.apla.a_divisor + 6.0 * left_segment.sum_value / (right_segment.rectangle_width * right_segment.rectangle_width - 1) - 6.0 * left_segment.rectangle_width * right_segment.sum_value / right_segment.apla.a_divisor - left_segment.apla.a * left_segment.apla.a_divisor / right_segment.apla.a_divisor;
//	auto temp_b2 = merged_segment.apla.b * merged_segment.apla.b_divisor / right_segment.apla.b_divisor + 2 * left_segment.rectangle_width * right_segment.sum_value / right_segment.apla.b_divisor - 4 * left_segment.sum_value / (right_segment.rectangle_width + 1) - left_segment.apla.b * left_segment.apla.b_divisor / right_segment.apla.b_divisor;
//	/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
//	//assert(float(temp_a2) == float(right_segment.apla.a) && float(temp_b2) == float(right_segment.apla.b));
//	//auto a_sum = 0.0;
//	//auto b_sum = 0.0;
//	//double variable_id = NULL; //[0-segment_length)
//	//int array_id = NULL;//time series id
//	//int segment_left_id = merged_segment.right_endpoint - merged_segment.rectangle_width + 1;
//
////	//cout << float(merged_segment.apla.b) << " "<<float(temp_b) <<endl;
////	for (variable_id = 0, array_id = segment_left_id; array_id <= merged_segment.right_endpoint; array_id++, variable_id++) {
////		//#ifdef _DEBUG
////		//		cout << "Original T: " << original_time_series[array_id] <<" "<< endl;
////		//#endif
////		a_sum += (variable_id - a_minuend) * original_time_series[array_id];
////		b_sum += (b_minuend - variable_id * 3.0) * original_time_series[array_id];
////	}
////	auto temp_a = 12.0 * a_sum / a_divisor;
////	auto temp_b = 2.0 * b_sum / b_divisor;
//	//assert(fabs(float(merged_segment.apla.b) - float(temp_b)) < (std::numeric_limits<float>::min)());
//	//assert(fabs(float(merged_segment.apla.a) - float(temp_a)) < (std::numeric_limits<float>::min)());
//	assert(right_segment.apla.a != INF && right_segment.apla.b != INF && right_segment.apla.a_minuend != INF && right_segment.apla.b_minuend != INF && right_segment.apla.a_divisor != INF && right_segment.apla.b_divisor != INF);
//#endif
//	return right_segment;
//}

//200211
	// Input: 1 left sub segment a&b, width, sum; 2 merged segment a&b, width, sum.
	// Output: 1 merged segment a&b, width, sum;
TEMPLATE
template<typename T>
inline T& APLA::getSubRightAAndBByPLA(const T& const left_segment, const T& const merged_segment, T& const right_segment) {
#ifdef _DEBUG
	assert(left_segment.apla.a != INF && merged_segment.apla.a != INF && left_segment.apla.b != INF && merged_segment.apla.b != INF);
	assert(merged_segment.rectangle_width > 3 && merged_segment.rectangle_width != INF && merged_segment.right_endpoint > 0 && merged_segment.right_endpoint != INF);
	assert(left_segment.rectangle_width > 1 && left_segment.rectangle_width != INF && left_segment.right_endpoint > 0 && left_segment.right_endpoint != INF);
	assert(left_segment.apla.a_minuend != INF && left_segment.apla.a_divisor != INF && left_segment.apla.b_minuend != INF && left_segment.apla.b_divisor != INF);
	assert(merged_segment.apla.a_minuend != INF && merged_segment.apla.a_divisor != INF && merged_segment.apla.b_minuend != INF && merged_segment.apla.b_divisor != INF);
	assert(right_segment.rectangle_width > 1 && right_segment.rectangle_width != INF && merged_segment.rectangle_width == left_segment.rectangle_width + right_segment.rectangle_width);

	// left a coefficient
	assert(left_segment.apla.a_minuend == (left_segment.rectangle_width - 1) / 2.0);//(l-1)/2
	assert(left_segment.apla.a_divisor == (left_segment.rectangle_width - 1) * (left_segment.rectangle_width + 1) * left_segment.rectangle_width);//l(l-1)(l+1)
	// left b coefficient
	assert(left_segment.apla.b_minuend == 2.0 * left_segment.rectangle_width - 1);//2l-1
	assert(left_segment.apla.b_divisor == (left_segment.rectangle_width + 1) * left_segment.rectangle_width);//l(l+1)

	// merged a coefficient
	assert(merged_segment.apla.a_minuend == (merged_segment.rectangle_width - 1) / 2.0);//(l-1)/2
	assert(merged_segment.apla.a_divisor == (merged_segment.rectangle_width - 1) * (merged_segment.rectangle_width + 1) * merged_segment.rectangle_width);//l(l-1)(l+1)
	// merged b coefficient
	assert(merged_segment.apla.b_minuend == 2.0 * merged_segment.rectangle_width - 1);//2l-1
	assert(merged_segment.apla.b_divisor == (merged_segment.rectangle_width + 1) * merged_segment.rectangle_width);//l(l+1)

	double temp_merged_sum_value = get_sum_value(merged_segment.apla.a, merged_segment.apla.b, merged_segment.rectangle_width);
	//assert(fabs(float(merged_segment.sum_value) - temp_merged_sum_value) <= MIN_D);
	double temp_left_sum_value = get_sum_value(left_segment.apla.a, left_segment.apla.b, left_segment.rectangle_width);
	//assert(fabs(float(left_segment.sum_value) - temp_left_sum_value) <= MIN_D);
	double temp_right_sum_value = temp_merged_sum_value - temp_left_sum_value;
#endif

	/*---------------------------------------------get sub right a&b without sum value--------------------------*/
	/*--------------------------------------------- sub Sum Value   ---------------------------------------------*/
	//200316 sum value
	//right_segment.sum_value = merged_segment.sum_value - left_segment.sum_value;
	/*...........................................................................................................*/

	/*...................................get pla coefficients of right segment............................................*/
	//a
	right_segment.apla.a_minuend = (right_segment.rectangle_width - 1) / 2.0;//(l-1)/2
	right_segment.apla.a_divisor = (right_segment.rectangle_width - 1) * (right_segment.rectangle_width + 1) * right_segment.rectangle_width;//l(l-1)(l+1)
	//b
	right_segment.apla.b_minuend = 2.0 * right_segment.rectangle_width - 1;//2l-1
	right_segment.apla.b_divisor = (right_segment.rectangle_width + 1) * right_segment.rectangle_width;//l(l+1)
	/*......................................................................................................................*/
	/*.........................................  a&b coefficient  .................................*/
	const long double coefficient_long0 = merged_segment.rectangle_width - 1;// l - 1
	const long double coefficient_left0 = left_segment.rectangle_width - 1;// l1 - 1 
	const long double coefficient_right0 = right_segment.rectangle_width - 1;//  l2 - 1 

	const long double coefficient_long1 = merged_segment.rectangle_width + 1;// l + 1
	const long double coefficient_left1 = left_segment.rectangle_width + 1;// l1 + 1 
	const long double coefficient_right1 = right_segment.rectangle_width + 1;// l2 + 1 

	const long double coefficient_long2 = merged_segment.rectangle_width * coefficient_long0;// l * ( l - 1)
	const long double coefficient_left2 = left_segment.rectangle_width * coefficient_left0;// l1 * ( l1 - 1)
	const long double coefficient_right2 = right_segment.rectangle_width * coefficient_right0;// l2 * ( l2 - 1)

	const long double coefficient_long3 = merged_segment.rectangle_width * coefficient_long1;// l * ( l + 1)
	const long double coefficient_left3 = left_segment.rectangle_width * coefficient_left1;// l1 * ( l1 + 1)
	const long double coefficient_right3 = right_segment.rectangle_width * coefficient_right1;// l2 * ( l2 + 1)

	const long double coefficient_long4 = coefficient_long2 * coefficient_long1;// l * ( l + 1) * ( l - 1 )
	const long double coefficient_left4 = coefficient_left2 * coefficient_left1;// l1 * ( l1 + 1) * ( l1 - 1 )
	const long double coefficient_right4 = coefficient_right2 * coefficient_right1;// l2 * ( l2 + 1) * ( l2 - 1 )
	/*..............................................................................................*/
	right_segment.apla.a = merged_segment.apla.a * coefficient_long2 * (coefficient_long1 - 3 * left_segment.rectangle_width) / coefficient_right4 + left_segment.apla.a * coefficient_left2 * (2 * merged_segment.rectangle_width + coefficient_right0) / coefficient_right4 + 6 * left_segment.rectangle_width * merged_segment.rectangle_width * (left_segment.apla.b - merged_segment.apla.b) / coefficient_right4;
	right_segment.apla.b = merged_segment.apla.a * left_segment.rectangle_width * coefficient_long2 / coefficient_right3 + merged_segment.apla.b * merged_segment.rectangle_width * (coefficient_long1 + 2 * left_segment.rectangle_width) / coefficient_right3 - left_segment.apla.a * coefficient_left2 * (merged_segment.rectangle_width + right_segment.rectangle_width) / coefficient_right3 - left_segment.apla.b * left_segment.rectangle_width * (3 * merged_segment.rectangle_width + coefficient_right1) / coefficient_right3;

	/*-----------------------------------------------------------------------------------------------------------*/


#ifdef _DEBUG
	/*-----------------------------------get pla a & b of right segment-------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	const double temp0_a2 = (merged_segment.apla.a * merged_segment.apla.a_divisor + 6 * right_segment.rectangle_width * temp_left_sum_value - 6 * left_segment.rectangle_width * temp_right_sum_value - left_segment.apla.a_divisor * left_segment.apla.a) / right_segment.apla.a_divisor;
	const double temp0_b2 = (merged_segment.apla.b * merged_segment.apla.b_divisor + 2 * left_segment.rectangle_width * temp_right_sum_value - 4 * right_segment.rectangle_width * temp_left_sum_value - left_segment.apla.b_divisor * left_segment.apla.b) / right_segment.apla.b_divisor;

	const double temp_a2 = merged_segment.apla.a * merged_segment.apla.a_divisor / right_segment.apla.a_divisor + 6.0 * temp_left_sum_value / (right_segment.rectangle_width * right_segment.rectangle_width - 1) - 6.0 * left_segment.rectangle_width * temp_right_sum_value / right_segment.apla.a_divisor - left_segment.apla.a * left_segment.apla.a_divisor / right_segment.apla.a_divisor;
	const double temp_b2 = merged_segment.apla.b * merged_segment.apla.b_divisor / right_segment.apla.b_divisor + 2 * left_segment.rectangle_width * temp_right_sum_value / right_segment.apla.b_divisor - 4 * temp_left_sum_value / (right_segment.rectangle_width + 1) - left_segment.apla.b * left_segment.apla.b_divisor / right_segment.apla.b_divisor;
	///*------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	assert(fabs(float(temp_a2) - float(right_segment.apla.a)) <= MIN_D && fabs(float(temp_b2) - float(right_segment.apla.b)) <= MIN_D);
	//auto a_sum = 0.0;
	//auto b_sum = 0.0;
	//double variable_id = NULL; //[0-segment_length)
	//int array_id = NULL;//time series id
	//int segment_left_id = merged_segment.right_endpoint - merged_segment.rectangle_width + 1;

//	//cout << float(merged_segment.apla.b) << " "<<float(temp_b) <<endl;
//	for (variable_id = 0, array_id = segment_left_id; array_id <= merged_segment.right_endpoint; array_id++, variable_id++) {
//		//#ifdef _DEBUG
//		//		cout << "Original T: " << original_time_series[array_id] <<" "<< endl;
//		//#endif
//		a_sum += (variable_id - a_minuend) * original_time_series[array_id];
//		b_sum += (b_minuend - variable_id * 3.0) * original_time_series[array_id];
//	}
//	auto temp_a = 12.0 * a_sum / a_divisor;
//	auto temp_b = 2.0 * b_sum / b_divisor;
	//assert(fabs(float(merged_segment.apla.b) - float(temp_b)) < (std::numeric_limits<float>::min)());
	//assert(fabs(float(merged_segment.apla.a) - float(temp_a)) < (std::numeric_limits<float>::min)());
	assert(right_segment.apla.a != INF && right_segment.apla.b != INF && right_segment.apla.a_minuend != INF && right_segment.apla.b_minuend != INF && right_segment.apla.a_divisor != INF && right_segment.apla.b_divisor != INF);
#endif
	return right_segment;
}

//190926
	// Input: 1 left sub segment a&b, width, sum; 2 merged segment a&b, width, sum.
	// Output: 1 merged segment a&b, width, sum;
//190926
//************************************
// Method:getSubLeftAAndBByPLA
// Qualifier: get sub left segment a&b according sub right segment & merged segment a&b, sum value , right endpoint , width
// Input: 1 left sub segment a&b, width, sum; 2 merged segment a&b, width, sum.
// Output: sub left segment a&b, width, sum;
// date:190920 return a&b from sub left segmet a&b;
// author:
//************************************
//TEMPLATE
//inline typename APLA::AREA_COEFFICIENT& APLA::getSubLeftAAndBByPLA(const AREA_COEFFICIENT& const right_segment, const AREA_COEFFICIENT& const merged_segment, AREA_COEFFICIENT& const left_segment) {
//#ifdef _DEBUG
//	assert(0);
//	assert(right_segment.apla.a != INF && merged_segment.apla.a != INF && right_segment.apla.b != INF && merged_segment.apla.b != INF && right_segment.sum_value != INF && merged_segment.sum_value != INF);
//	assert(merged_segment.rectangle_width > 3 && merged_segment.rectangle_width != INF && merged_segment.rectangle_height >= 0 && merged_segment.right_endpoint > 0 && merged_segment.right_endpoint != INF && merged_segment.right_endpoint == right_segment.right_endpoint);
//	assert(left_segment.rectangle_width > 2 && left_segment.rectangle_width != INF && right_segment.rectangle_width > 1 && right_segment.rectangle_width != INF && right_segment.rectangle_height >= 0 && right_segment.right_endpoint > 0 && right_segment.right_endpoint != INF);
//	assert(right_segment.apla.a_minuend != INF && right_segment.apla.a_divisor != INF && right_segment.apla.b_minuend != INF && right_segment.apla.b_divisor != INF);
//	assert(merged_segment.apla.a_minuend != INF && merged_segment.apla.a_divisor != INF && merged_segment.apla.b_minuend != INF && merged_segment.apla.b_divisor != INF);
//	assert(merged_segment.rectangle_width == left_segment.rectangle_width + right_segment.rectangle_width);
//
//	// right a coefficient
//	assert(right_segment.apla.a_minuend == (right_segment.rectangle_width - 1) / 2.0);//(l-1)/2
//	assert(right_segment.apla.a_divisor == (right_segment.rectangle_width - 1) * (right_segment.rectangle_width + 1) * right_segment.rectangle_width);//l(l-1)(l+1)
//	// right b coefficient
//	assert(right_segment.apla.b_minuend == 2.0 * right_segment.rectangle_width - 1);//2l-1
//	assert(right_segment.apla.b_divisor == (right_segment.rectangle_width + 1) * right_segment.rectangle_width);//l(l+1)
//
//	// merged a coefficient
//	assert(merged_segment.apla.a_minuend == (merged_segment.rectangle_width - 1) / 2.0);//(l-1)/2
//	assert(merged_segment.apla.a_divisor == (merged_segment.rectangle_width - 1) * (merged_segment.rectangle_width + 1) * merged_segment.rectangle_width);//l(l-1)(l+1)
//	// merged b coefficient
//	assert(merged_segment.apla.b_minuend == 2.0 * merged_segment.rectangle_width - 1);//2l-1
//	assert(merged_segment.apla.b_divisor == (merged_segment.rectangle_width + 1) * merged_segment.rectangle_width);//l(l+1)
//
//	//assert sum value of segment
//	assert(merged_segment.sum_value == 0.5 * merged_segment.rectangle_width * (merged_segment.rectangle_width - 1) * merged_segment.apla.a + merged_segment.rectangle_width * merged_segment.apla.b);
//	assert(right_segment.sum_value == 0.5 * right_segment.rectangle_width * (right_segment.rectangle_width - 1) * right_segment.apla.a + right_segment.rectangle_width * right_segment.apla.b);
//#endif
//	/*--------------------------------------------- sub left Sum Value   ---------------------------------------------*/
//	left_segment.sum_value = merged_segment.sum_value - right_segment.sum_value;
//	/*.........................................................................................................*/
//
//	//if (temp_coefficient.rectangle_width == 1) {
////#ifdef _DEBUG
////	assert(temp_coefficient.rectangle_width > 1);
////#endif
//	//return getAandB(original_time_series, temp_coefficient);
////}
//
////printf("getPLA()\n");
////assert(temp_coefficient.size() == input_argument.point_dimension);
//
//	/*........................................sub left pla coefficients.......................................*/
//	//coefficient of equation
//	//a
//	left_segment.apla.a_minuend = (left_segment.rectangle_width - 1) / 2.0;//(l-1)/2
//	left_segment.apla.a_divisor = (left_segment.rectangle_width - 1) * (left_segment.rectangle_width + 1) * left_segment.rectangle_width;//l(l-1)(l+1)
//	//b
//	left_segment.apla.b_minuend = 2.0 * left_segment.rectangle_width - 1;//2l-1
//	left_segment.apla.b_divisor = (left_segment.rectangle_width + 1) * left_segment.rectangle_width;//l(l+1)
//	/*........................................................................................................*/
//
//	/*---------------------------------------get sub left pla a & b---------------------------------------------------------------------------------------------------------------------------------------------------------*/
//	left_segment.apla.a = (merged_segment.apla.a * merged_segment.apla.a_divisor + 6 * right_segment.rectangle_width * left_segment.sum_value - 6 * left_segment.rectangle_width * right_segment.sum_value - right_segment.apla.a_divisor * right_segment.apla.a) / left_segment.apla.a_divisor;
//	left_segment.apla.b = (merged_segment.apla.b * merged_segment.apla.b_divisor + 2 * left_segment.rectangle_width * right_segment.sum_value - 4 * right_segment.rectangle_width * left_segment.sum_value - right_segment.apla.b_divisor * right_segment.apla.b) / left_segment.apla.b_divisor;
//	/*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
//#ifdef _DEBUG
//	auto temp_a1 = merged_segment.apla.a * merged_segment.apla.a_divisor / left_segment.apla.a_divisor + 6.0 * right_segment.rectangle_width * left_segment.sum_value / left_segment.apla.a_divisor - 6.0 * right_segment.sum_value / (left_segment.rectangle_width * left_segment.rectangle_width - 1) - right_segment.apla.a * right_segment.apla.a_divisor / left_segment.apla.a_divisor;
//	auto temp_b1 = merged_segment.apla.b * merged_segment.apla.b_divisor / left_segment.apla.b_divisor + 2 * right_segment.sum_value / (left_segment.rectangle_width + 1) - 4 * right_segment.rectangle_width * left_segment.sum_value / left_segment.apla.b_divisor - right_segment.apla.b * right_segment.apla.b_divisor / left_segment.apla.b_divisor;
//
//	//assert(float(temp_a1) == float(left_segment.apla.a) && float(temp_b1) == float(left_segment.apla.b));
//	//auto a_sum = 0.0;
//	//auto b_sum = 0.0;
//	//double variable_id = NULL; //[0-segment_length)
//	//int array_id = NULL;//time series id
//	//int segment_left_id = merged_segment.right_endpoint - merged_segment.rectangle_width + 1;
//
////	//cout << float(merged_segment.apla.b) << " "<<float(temp_b) <<endl;
////	for (variable_id = 0, array_id = segment_left_id; array_id <= merged_segment.right_endpoint; array_id++, variable_id++) {
////		//#ifdef _DEBUG
////		//		cout << "Original T: " << original_time_series[array_id] <<" "<< endl;
////		//#endif
////		a_sum += (variable_id - a_minuend) * original_time_series[array_id];
////		b_sum += (b_minuend - variable_id * 3.0) * original_time_series[array_id];
////	}
////	auto temp_a = 12.0 * a_sum / a_divisor;
////	auto temp_b = 2.0 * b_sum / b_divisor;
//	//assert(fabs(float(merged_segment.apla.b) - float(temp_b)) < (std::numeric_limits<float>::min)());
//	//assert(fabs(float(merged_segment.apla.a) - float(temp_a)) < (std::numeric_limits<float>::min)());
//	assert(left_segment.apla.a != INF && left_segment.apla.b != INF && left_segment.apla.a_minuend != INF && left_segment.apla.b_minuend != INF && left_segment.apla.a_divisor != INF && left_segment.apla.b_divisor != INF);
//#endif
//	return left_segment;
//}

//************************************
// Method:getSubLeftAAndBByPLA
// Qualifier: get a & b of segment PLA and sum value
// Input: 1 left sub segment a&b, width, sum; 2 merged segment a&b, width, sum.
// Output: 1 merged segment a&b, width, sum;
// date:200211 return a&b from long segment;
// author:
//************************************
TEMPLATE
template<typename T>
inline T& APLA::getSubLeftAAndBByPLA(const T& const right_segment, const T& const merged_segment, T& const left_segment) {
	/*.........................................................................................................*/
#ifdef _DEBUG
	assert(right_segment.apla.a != INF && merged_segment.apla.a != INF && right_segment.apla.b != INF && merged_segment.apla.b != INF);
	assert(merged_segment.rectangle_width > 3 && merged_segment.rectangle_width != INF && merged_segment.right_endpoint > 0 && merged_segment.right_endpoint != INF && merged_segment.right_endpoint == right_segment.right_endpoint);
	assert(left_segment.rectangle_width > 2 && left_segment.rectangle_width != INF && right_segment.rectangle_width > 0 && right_segment.rectangle_width != INF && right_segment.right_endpoint > 0 && right_segment.right_endpoint != INF);
	assert(right_segment.apla.a_minuend != INF && right_segment.apla.a_divisor != INF && right_segment.apla.b_minuend != INF && right_segment.apla.b_divisor != INF);
	assert(merged_segment.apla.a_minuend != INF && merged_segment.apla.a_divisor != INF && merged_segment.apla.b_minuend != INF && merged_segment.apla.b_divisor != INF);
	assert(merged_segment.rectangle_width == left_segment.rectangle_width + right_segment.rectangle_width);

	// right a coefficient
	assert(right_segment.apla.a_minuend == (right_segment.rectangle_width - 1) / 2.0);//(l-1)/2
	assert(right_segment.apla.a_divisor == (right_segment.rectangle_width - 1) * (right_segment.rectangle_width + 1) * right_segment.rectangle_width);//l(l-1)(l+1)
	// right b coefficient
	assert(right_segment.apla.b_minuend == 2.0 * right_segment.rectangle_width - 1);//2l-1
	assert(right_segment.apla.b_divisor == (right_segment.rectangle_width + 1) * right_segment.rectangle_width);//l(l+1)

	// merged a coefficient
	assert(merged_segment.apla.a_minuend == (merged_segment.rectangle_width - 1) / 2.0);//(l-1)/2
	assert(merged_segment.apla.a_divisor == (merged_segment.rectangle_width - 1) * (merged_segment.rectangle_width + 1) * merged_segment.rectangle_width);//l(l-1)(l+1)
	// merged b coefficient
	assert(merged_segment.apla.b_minuend == 2.0 * merged_segment.rectangle_width - 1);//2l-1
	assert(merged_segment.apla.b_divisor == (merged_segment.rectangle_width + 1) * merged_segment.rectangle_width);//l(l+1)

#endif
	/*.........................................................................................................*/


	/*................................     sub left Sum Value   ..............................................*/
	//200316 sum value
	//left_segment.sum_value = merged_segment.sum_value - right_segment.sum_value;
	/*.........................................................................................................*/
	/*=========================================================== get sub left a&b ========================================================================================================================================*/
	/*........................................sub left pla coefficients.......................................*/
	//coefficient of equation
	//a
	left_segment.apla.a_minuend = (left_segment.rectangle_width - 1) / 2.0;//(l-1)/2
	left_segment.apla.a_divisor = (left_segment.rectangle_width - 1) * (left_segment.rectangle_width + 1) * left_segment.rectangle_width;//l(l-1)(l+1)
	//b
	left_segment.apla.b_minuend = 2.0 * left_segment.rectangle_width - 1;//2l-1
	left_segment.apla.b_divisor = (left_segment.rectangle_width + 1) * left_segment.rectangle_width;//l(l+1)
	/*........................................................................................................*/

	/*.........................................  a&b coefficient  .................................*/
	const long double coefficient_long0 = merged_segment.rectangle_width - 1;// l - 1
	const long double coefficient_left0 = left_segment.rectangle_width - 1;// l1 - 1 
	const long double coefficient_right0 = right_segment.rectangle_width - 1;//  l2 - 1 

	const long double coefficient_long1 = merged_segment.rectangle_width + 1;// l + 1
	const long double coefficient_left1 = left_segment.rectangle_width + 1;// l1 + 1 
	const long double coefficient_right1 = right_segment.rectangle_width + 1;// l2 + 1 

	const long double coefficient_long2 = merged_segment.rectangle_width * coefficient_long0;// l * ( l - 1)
	const long double coefficient_left2 = left_segment.rectangle_width * coefficient_left0;// l1 * ( l1 - 1)
	const long double coefficient_right2 = right_segment.rectangle_width * coefficient_right0;// l2 * ( l2 - 1)

	const long double coefficient_long3 = merged_segment.rectangle_width * coefficient_long1;// l * ( l + 1)
	const long double coefficient_left3 = left_segment.rectangle_width * coefficient_left1;// l1 * ( l1 + 1)
	const long double coefficient_right3 = right_segment.rectangle_width * coefficient_right1;// l2 * ( l2 + 1)

	const long double coefficient_long4 = coefficient_long2 * coefficient_long1;// l * ( l + 1) * ( l - 1 )
	const long double coefficient_left4 = coefficient_left2 * coefficient_left1;// l1 * ( l1 + 1) * ( l1 - 1 )
	const long double coefficient_right4 = coefficient_right2 * coefficient_right0 * coefficient_right1;// l2 * ( l2 + 1) * ( l2 - 1 )
	/*..............................................................................................*/

	/*---------------------------------------get sub left pla a & b without sum value---------------------------------------------------------------------------------------------------------------------------------------------------------*/
	left_segment.apla.a = merged_segment.apla.a * coefficient_long2 * (coefficient_long1 + 3 * right_segment.rectangle_width) / coefficient_left4 - right_segment.apla.a * coefficient_right2 * (coefficient_right1 + 3 * merged_segment.rectangle_width) / coefficient_left4 + 6 * right_segment.rectangle_width * merged_segment.rectangle_width * (merged_segment.apla.b - right_segment.apla.b) / coefficient_left4;
	left_segment.apla.b = merged_segment.apla.b * merged_segment.rectangle_width * (coefficient_long1 - 4 * right_segment.rectangle_width) / coefficient_left3 + right_segment.apla.b * right_segment.rectangle_width * (2 * merged_segment.rectangle_width + coefficient_right0) / coefficient_left3 + right_segment.apla.a * (merged_segment.rectangle_width + right_segment.rectangle_width) * coefficient_right2 / coefficient_left3 - merged_segment.apla.a * 2 * right_segment.rectangle_width * coefficient_long2 / coefficient_left3;
	/*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/*======================================================================================================================================================================================================*/


	/*...................................................................................*/
#ifdef _DEBUG
	//assert sum value of segment
	const long double test_merged_sum_value = get_sum_value(merged_segment.apla.a, merged_segment.apla.b, merged_segment.rectangle_width);
	//assert(fabs(float(merged_segment.sum_value) - test_merged_sum_value) <= MIN_D);
	const long double test_right_sum_value = get_sum_value(right_segment.apla.a, right_segment.apla.b, right_segment.rectangle_width);
	//assert(fabs(float(test_right_sum_value) - test_right_sum_value) <= MIN_D);
	const long double test_left_sum_value = test_merged_sum_value - test_right_sum_value;
	/*---------------------------------------get sub left pla a & b---------------------------------------------------------------------------------------------------------------------------------------------------------*/
	const long double temp0_a1 = (merged_segment.apla.a * merged_segment.apla.a_divisor + 6 * right_segment.rectangle_width * test_left_sum_value - 6 * left_segment.rectangle_width * test_right_sum_value - right_segment.apla.a_divisor * right_segment.apla.a) / left_segment.apla.a_divisor;
	const long double temp0_b1 = (merged_segment.apla.b * merged_segment.apla.b_divisor + 2 * left_segment.rectangle_width * test_right_sum_value - 4 * right_segment.rectangle_width * test_left_sum_value - right_segment.apla.b_divisor * right_segment.apla.b) / left_segment.apla.b_divisor;
	/*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

	//assert(float(test_merged_sum_value) == float(test_left_sum_value + test_right_sum_value));

	const double temp_a1 = merged_segment.apla.a * merged_segment.apla.a_divisor / left_segment.apla.a_divisor + 6.0 * right_segment.rectangle_width * test_left_sum_value / left_segment.apla.a_divisor - 6.0 * test_right_sum_value / (left_segment.rectangle_width * left_segment.rectangle_width - 1) - right_segment.apla.a * right_segment.apla.a_divisor / left_segment.apla.a_divisor;
	const double temp_b1 = merged_segment.apla.b * merged_segment.apla.b_divisor / left_segment.apla.b_divisor + 2 * test_right_sum_value / (left_segment.rectangle_width + 1) - 4 * right_segment.rectangle_width * test_left_sum_value / left_segment.apla.b_divisor - right_segment.apla.b * right_segment.apla.b_divisor / left_segment.apla.b_divisor;

	assert(fabs(float(temp_a1 - left_segment.apla.a)) <= MIN_D && fabs(float(temp_b1 - left_segment.apla.b)) <= MIN_D);
	assert(fabs(float(temp0_a1 - left_segment.apla.a)) <= MIN_D && fabs(float(temp0_b1 - left_segment.apla.b)) <= MIN_D);

	assert(left_segment.apla.a != INF && left_segment.apla.b != INF && left_segment.apla.a_minuend != INF && left_segment.apla.b_minuend != INF && left_segment.apla.a_divisor != INF && left_segment.apla.b_divisor != INF);
#endif
	/*...................................................................................*/

	return left_segment;
}


//************************************
// Method:getRightSubAAndBByPLA
// Qualifier: get a & b of segment PLA and sum value
// Input: 1 Original time series: long segment a&b, sum, width, right endpoint; 2 left(right) sub segment: a&b, sum, width, right endopint;
// Output: right(left) sub segment: 1 a&b, 2 sum, 3 min&max point.
// date:190926 return a&b from long segment;
// author:
//************************************
TEMPLATE
template<typename T>
void APLA::getSubAAndBByPLA(DataType*& const original_time_series, T& const left_segment, T& const right_segment, const T& const merged_segment) {
#ifdef _DEBUG
	assert(left_segment.rectangle_width != INF && right_segment.rectangle_width != INF && merged_segment.rectangle_width != INF && left_segment.rectangle_width + right_segment.rectangle_width == merged_segment.rectangle_width);
	assert(merged_segment.apla.a != INF && merged_segment.apla.b != INF && right_segment.right_endpoint == merged_segment.right_endpoint && left_segment.right_endpoint < merged_segment.right_endpoint);
	T test_left_segment = left_segment;
	T test_right_segment = right_segment;
	getAAndBByPLA(original_time_series, test_left_segment);//get a&b slope intercept
	getAAndBByPLA(original_time_series, test_right_segment);//get a&b slope intercept
#endif
	/*=====================     get sum value, a & b slope intercept    ==================================================*/
		////** Input: 1 width, 2 right endpoint
		////** Output: 1 sum value, 2 a&b
	if (left_segment.rectangle_width <= right_segment.rectangle_width) {
		getAAndBByPLA(original_time_series, left_segment);//get a&b slope intercept
		if (right_segment.rectangle_width < 3) {
			getAAndBByPLA(original_time_series, right_segment);//get a&b slope intercept
		}
		else {
			getSubRightAAndBByPLA(left_segment, merged_segment, right_segment);
		}
	}
	else {
		getAAndBByPLA(original_time_series, right_segment);//get a&b slope intercept
		if (left_segment.rectangle_width < 3) {
			getAAndBByPLA(original_time_series, left_segment);//get a&b slope intercept
		}
		else {
			getSubLeftAAndBByPLA(right_segment, merged_segment, left_segment);
		}
	}

	//getSegmentMinMaxPoint(original_time_series, left_segment);
	//getSegmentMinMaxPoint(original_time_series, right_segment);
	//191104 get min&max point of left&right segment by long segment, speed up
	//200314 minmax point
	//getSubMinMaxPoint(original_time_series, left_segment, right_segment, merged_segment);
	/*===================================================================================================================*/
	/*================================Evaluated===================================================================================*/
#ifdef _DEBUG
	//assert(float(test_left_segment.apla.a) == float(left_segment.apla.a) && float(test_left_segment.apla.b) == float(left_segment.apla.b));
	//assert(float(test_right_segment.apla.a) == float(right_segment.apla.a) && float(test_right_segment.apla.b) == float(right_segment.apla.b));
#endif
	/*===================================================================================================================*/
}


//************************************
// Method:getSubAAndBByPLA
// Qualifier: get a & b of segment PLA sub left segment and sub right segment a&b
// date:200210
// Input: 1 Original time series vector;2 long segment a&b,  width, right endpoint; 3 left(right) sub segment: width, right endopint;
// Output: right(left) sub segment: a&b, sum value
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
void APLA::getSubAAndBByPLA(const vector<T>& const original_time_series, Y& const left_segment, Y& const right_segment, const Y& const merged_segment) {
#ifdef _DEBUG
	assert(left_segment.rectangle_width != INF && right_segment.rectangle_width != INF && merged_segment.rectangle_width != INF && left_segment.rectangle_width + right_segment.rectangle_width == merged_segment.rectangle_width);
	assert(merged_segment.apla.a != INF && merged_segment.apla.b != INF && right_segment.right_endpoint == merged_segment.right_endpoint && left_segment.right_endpoint < merged_segment.right_endpoint);
#endif
	/*=====================     get sum value, a & b slope intercept    ==================================================*/
		////** Input: 1 width, 2 right endpoint
		////** Output: 1 sum value, 2 a&b
	if (left_segment.rectangle_width <= right_segment.rectangle_width) {// left segment is short
		get_ab_segment(original_time_series, left_segment);//get a&b slope intercept

		if (left_segment.rectangle_width == 1) {//left segment is one point
			get_ab_segment_by_decrement_left(original_time_series, merged_segment, right_segment);
		}
		else if (right_segment.rectangle_width < 3) {
			get_ab_segment(original_time_series, right_segment);//get a&b slope intercept
		}
		else {
			getSubRightAAndBByPLA(left_segment, merged_segment, right_segment);
		}
	}
	else { // right segment is short
		get_ab_segment(original_time_series, right_segment);//get a&b slope intercept

		if (right_segment.rectangle_width == 1) {//right_segment is one point
			get_ab_segment_by_decrement(original_time_series, merged_segment, left_segment);
		}
		else if (left_segment.rectangle_width < 3) {
			get_ab_segment(original_time_series, left_segment);//get a&b slope intercept
		}
		else {
			getSubLeftAAndBByPLA(right_segment, merged_segment, left_segment);
		}
	}

	//getSegmentMinMaxPoint(original_time_series, left_segment);
	//getSegmentMinMaxPoint(original_time_series, right_segment);
	//191104 get min&max point of left&right segment by long segment, speed up
	//getSubMinMaxPoint(original_time_series, left_segment, right_segment, merged_segment);
	/*===================================================================================================================*/
	/*================================Evaluated==========================================================================*/
#ifdef _DEBUG
	Y test_left_segment = left_segment;
	Y test_right_segment = right_segment;
	Y test_long_segment = merged_segment;
	get_ab_segment(original_time_series, test_left_segment);//get a&b slope intercept
	get_ab_segment(original_time_series, test_right_segment);//get a&b slope intercept
	get_ab_segment(original_time_series, test_long_segment);
	assert_two_segments_a_b(test_left_segment, left_segment);
	assert_two_segments_a_b(test_right_segment, right_segment);
	assert_two_segments_a_b(test_long_segment, merged_segment);

	float sum_value_left = get_sum_value(left_segment.apla.a, left_segment.apla.b, left_segment.rectangle_width);
	float sum_value_right = get_sum_value(right_segment.apla.a, right_segment.apla.b, right_segment.rectangle_width);
	float sum_value_long = get_sum_value(merged_segment.apla.a, merged_segment.apla.b, merged_segment.rectangle_width);
	assert(fabs(sum_value_left + sum_value_right - sum_value_long) <= 1);
#endif
	/*===================================================================================================================*/
}

//210907
TEMPLATE
template<typename T, typename Y>
void APLA::getSubAAndBByPLA_average(const vector<T>& const original_time_series, Y& const left_segment, Y& const right_segment, const Y& const merged_segment) {
#ifdef _DEBUG
	assert(left_segment.rectangle_width != INF && right_segment.rectangle_width != INF && merged_segment.rectangle_width != INF && left_segment.rectangle_width + right_segment.rectangle_width == merged_segment.rectangle_width);
	assert(merged_segment.apla.a == 0 && merged_segment.apla.b != INF && right_segment.right_endpoint == merged_segment.right_endpoint && left_segment.right_endpoint < merged_segment.right_endpoint);
	assert_segment_average(original_time_series, merged_segment);
#endif
	/*=====================     get sum value, a & b slope intercept    ==================================================*/
		////** Input: 1 width, 2 right endpoint
		////** Output: 1 sum value, 2 a&b
	if (left_segment.rectangle_width <= right_segment.rectangle_width) {// left segment is short
		get_average_segment(original_time_series, left_segment);//get a&b slope intercept
		get_sub_average_by_long_segment(merged_segment, left_segment, right_segment);
	}
	else { // right segment is short
		get_average_segment(original_time_series, right_segment);//get a&b slope intercept
		get_sub_average_by_long_segment(merged_segment, right_segment, left_segment);
	}

	/*===================================================================================================================*/
	/*================================Evaluated==========================================================================*/
#ifdef _DEBUG
	assert_segment_average(original_time_series, left_segment);
	assert_segment_average(original_time_series, right_segment);
#endif
	/*===================================================================================================================*/
}

//210601 : Consider one point segment
// Input: 1 Original time series vector: long segment a&b, width, right endpoint; 2 left(right) sub segment: a&b, width, right endopint;
// Output: right(left) sub segment: a&b.
//************************************
// Method:get_sub_ab_by_long_one_point
// Qualifier: get a & b of segment PLA sub left segment and sub right segment a&b. Consider one point segment
// date:210601
// Input: 1 Original time series vector;2 long segment a&b,  width, right endpoint; 3 left(right) sub segment: width, right endopint;
// Output: right(left) sub segment: a&b,
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
void APLA::get_sub_ab_by_long_one_point(const vector<T>& const original_time_series, Y& const left_segment, Y& const right_segment, const Y& const merged_segment) {
#ifdef _DEBUG
	assert(left_segment.rectangle_width != INF && right_segment.rectangle_width != INF && merged_segment.rectangle_width != INF && left_segment.rectangle_width + right_segment.rectangle_width == merged_segment.rectangle_width);
	assert(merged_segment.apla.a != INF && merged_segment.apla.b != INF && right_segment.right_endpoint == merged_segment.right_endpoint && left_segment.right_endpoint < merged_segment.right_endpoint);
#endif
	/*=====================     get sum value, a & b slope intercept    ==================================================*/
		////** Input: 1 width, 2 right endpoint
		////** Output: 1 sum value, 2 a&b
	if (left_segment.rectangle_width <= right_segment.rectangle_width) {
		get_ab_segment(original_time_series, left_segment);//get a&b slope intercept
		if (right_segment.rectangle_width < 3) {
			get_ab_segment(original_time_series, right_segment);//get a&b slope intercept
		}
		else {
			getSubRightAAndBByPLA(left_segment, merged_segment, right_segment);
		}
	}
	else {
		get_ab_segment(original_time_series, right_segment);//get a&b slope intercept
		if (left_segment.rectangle_width < 3) {
			get_ab_segment(original_time_series, left_segment);//get a&b slope intercept
		}
		else {
			getSubLeftAAndBByPLA(right_segment, merged_segment, left_segment);
		}
	}

	//getSegmentMinMaxPoint(original_time_series, left_segment);
	//getSegmentMinMaxPoint(original_time_series, right_segment);
	//191104 get min&max point of left&right segment by long segment, speed up
	//getSubMinMaxPoint(original_time_series, left_segment, right_segment, merged_segment);
	/*===================================================================================================================*/
	/*================================Evaluated==========================================================================*/
#ifdef _DEBUG
	Y test_left_segment = left_segment;
	Y test_right_segment = right_segment;
	Y test_long_segment = merged_segment;
	get_ab_segment(original_time_series, test_left_segment);//get a&b slope intercept
	get_ab_segment(original_time_series, test_right_segment);//get a&b slope intercept
	get_ab_segment(original_time_series, test_long_segment);
	assert_two_segments_a_b(test_left_segment, left_segment);
	assert_two_segments_a_b(test_right_segment, right_segment);
	assert_two_segments_a_b(test_long_segment, merged_segment);
#endif
	/*===================================================================================================================*/
}

//************************************
// Method:getAAndBByPLAShortSegArray
// Qualifier: get a & b of segment PLA
// date:190418 Use array to stead vector, return a&b from short segment;
// author:
//************************************
TEMPLATE
double& APLA::getAAndBByPLAShortSegArray(DataType*& const original_time_series, SEGMENT_COEFFICIENT*& area_vector, int& const vector_id, SEGMENT_COEFFICIENT& const temp_coefficient) {//190418 return a&b from short segment;
	auto left_id = vector_id - 1;
#ifdef _DEBUG
	assert(vector_id > 0 && area_vector[vector_id].apla.a != INF && area_vector[left_id].apla.a != INF && area_vector[vector_id].apla.b != INF && area_vector[left_id].apla.b != INF && area_vector[left_id].sum_value != INF && area_vector[vector_id].sum_value);
	assert(temp_coefficient.rectangle_width > 0 && temp_coefficient.rectangle_width != INF && temp_coefficient.rectangle_height >= 0 && temp_coefficient.right_endpoint > 0 && temp_coefficient.right_endpoint != INF);
	/*==========Print==============*/
	//cout << area_vector[left_id].apla.a <<" "<< area_vector[vector_id].apla.a <<" "<< area_vector[left_id].sum_value << " " << area_vector[vector_id].sum_value << endl;

#endif

//	if (temp_coefficient.rectangle_width == 1) {
//#ifdef _DEBUG
//		assert(0);
//#endif
//		return getAandB(original_time_series, temp_coefficient);
//	}
//
	//printf("getPLA()\n");
	//assert(temp_coefficient.size() == input_argument.point_dimension);

	int segment_left_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	temp_coefficient.sum_value = area_vector[left_id].sum_value + area_vector[vector_id].sum_value;

	//coefficient of equation
	//a
	double a_minuend = NULL; //(l-1)/2
	double a_divisor = NULL; //l(l-1)(l+1)
	//b
	double b_minuend = NULL; //2l-1
	double b_divisor = NULL; //l(l+1)

	auto a_sum = 0.0;
	auto b_sum = 0.0;
	double variable_id = NULL; //[0-segment_length)
	int array_id = NULL;//time series id

	/*...............................................................................*/
	temp_coefficient.apla.a_minuend = a_minuend = (temp_coefficient.rectangle_width - 1) / 2.0;//(l-1)/2
	temp_coefficient.apla.a_divisor = a_divisor = (temp_coefficient.rectangle_width - 1) * (temp_coefficient.rectangle_width + 1) * temp_coefficient.rectangle_width;//l(l-1)(l+1)

	temp_coefficient.apla.b_minuend = b_minuend = 2.0 * temp_coefficient.rectangle_width - 1;//2l-1
	temp_coefficient.apla.b_divisor = b_divisor = (temp_coefficient.rectangle_width + 1) * temp_coefficient.rectangle_width;//l(l+1)

#ifdef _DEBUG
	assert(a_divisor != 0);
	assert(b_divisor != 0);
#endif

	//190412
	double coefficient_a1 = area_vector[left_id].apla.a_divisor / temp_coefficient.apla.a_divisor;
	double coefficient_a2 = area_vector[vector_id].apla.a_divisor / temp_coefficient.apla.a_divisor;
	double difference_a1 = area_vector[left_id].apla.a_minuend - temp_coefficient.apla.a_minuend;
	double difference_a2 = area_vector[vector_id].apla.a_minuend - temp_coefficient.apla.a_minuend;
	//190415
	double coefficient_b1 = area_vector[left_id].apla.b_divisor / temp_coefficient.apla.b_divisor;
	double coefficient_b2 = area_vector[vector_id].apla.b_divisor / temp_coefficient.apla.b_divisor;
	double difference_b1 = temp_coefficient.apla.b_minuend - area_vector[left_id].apla.b_minuend;
	double difference_b2 = temp_coefficient.apla.b_minuend - area_vector[vector_id].apla.b_minuend;

	//auto temp_a = coefficient1 * area_vector[left_id].apla.a + coefficient2 * area_vector[vector_id].apla.a + 12.0/ temp_coefficient.apla.a_divisor*(difference1 * area_vector[left_id].sum_value + difference2 * area_vector[vector_id].sum_value);

	auto temp_a = temp_coefficient.apla.a = coefficient_a1 * area_vector[left_id].apla.a + (12.0 / temp_coefficient.apla.a_divisor) * difference_a1 * area_vector[left_id].sum_value + coefficient_a2 * area_vector[vector_id].apla.a + (12.0 / temp_coefficient.apla.a_divisor) * (area_vector[left_id].rectangle_width + difference_a2) * area_vector[vector_id].sum_value;
	auto temp_b = temp_coefficient.apla.b = coefficient_b1 * area_vector[left_id].apla.b + 2.0 / temp_coefficient.apla.b_divisor * difference_b1 * area_vector[left_id].sum_value + coefficient_b2 * area_vector[vector_id].apla.b + 2.0 / temp_coefficient.apla.b_divisor * (difference_b2 - 3 * area_vector[left_id].rectangle_width) * area_vector[vector_id].sum_value;

#ifdef _DEBUG
	//cout << float(temp_coefficient.apla.b) << " "<<float(temp_b) <<endl;
	for (variable_id = 0, array_id = segment_left_id; array_id <= temp_coefficient.right_endpoint; array_id++, variable_id++) {
		//#ifdef _DEBUG
		//		cout << "Original T: " << original_time_series[array_id] <<" "<< endl;
		//#endif
		a_sum += (variable_id - a_minuend) * original_time_series[array_id];
		b_sum += (b_minuend - variable_id * 3.0) * original_time_series[array_id];
	}
	temp_coefficient.apla.a = 12.0 * a_sum / a_divisor;
	temp_coefficient.apla.b = 2.0 * b_sum / b_divisor;
	assert(fabs(float(temp_coefficient.apla.b) - float(temp_b)) < (std::numeric_limits<float>::min)());
	assert(fabs(float(temp_coefficient.apla.a) - float(temp_a)) < (std::numeric_limits<float>::min)());
#endif

	return temp_coefficient.apla.a;
}

//************************************
// Method:get_sum_value
// Qualifier: compute sum value of one segment
// Input: Know the 
// date:190115
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline long double APLA::get_sum_value(const T& const a, const T& const b, const Y& const segment_length) {
#ifdef _DEBUG
	assert(a != INF && b != INF && segment_length != INF && segment_length > 0);
#endif
	return 0.5 * segment_length * (segment_length - 1) * a + segment_length * b;
}

//************************************
// Method:getSegmentDevByPLA
// Qualifier: Get deviation of segment
// Input: Only know right endpoint and width of every segment.
// date:190115
// author:
//************************************
TEMPLATE
double& APLA::getSegmentDevByPLA(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient) {//190115 return deviation
	//cout<<"width: "<<temp_coefficient.rectangle_width<<endl;
	//DataType* reconstructed_time_series = new DataType[temp_coefficient.rectangle_width];
	int original_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;

	getAAndBByPLA(original_time_series, temp_coefficient);// get PLA: a & b of segment.
	//assert(temp_coefficient.apla.a >= 0 && temp_coefficient.apla.b >= 0);

	temp_coefficient.rec_deviation = 0;
	for (int i = 0; i < temp_coefficient.rectangle_width; i++) {
		temp_coefficient.rec_deviation += pow(temp_coefficient.apla.a * i + temp_coefficient.apla.b - original_time_series[original_id + i], 2.0);
	}

	return temp_coefficient.rec_deviation = sqrt(temp_coefficient.rec_deviation);
	//TOOL::delete_array(reconstructed_time_series);
}

// 200113   
//************************************
// Method:get_segment_sum_deviation
// Qualifier: get segment sum deviaiton,
// Input: Know right endpoint, width, a & b of every segment
// date:200113
// author:
//************************************
//TEMPLATE
//template<typename T, typename Y>
//double& APLA::get_segment_sum_deviation(const vector<T>& const original_time_series, Y& const temp_coefficient) {//200113
//	assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF && temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF);
//	// cout << "width: " << temp_coefficient.rectangle_width << endl;
//	//DataType* reconstructed_time_series = new DataType[temp_coefficient.rectangle_width];
//	int original_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
//	//getAAndBByPLA(original_time_series, temp_coefficient);// get PLA: a & b of segment.
//
//	temp_coefficient.rec_deviation = 0;
//	for (int i = 0; i < temp_coefficient.rectangle_width; i++) {
//		temp_coefficient.rec_deviation += pow(temp_coefficient.apla.a * i + temp_coefficient.apla.b - original_time_series[original_id + i], 2.0);
//	}
//
//	return temp_coefficient.rec_deviation = sqrt(temp_coefficient.rec_deviation);
//}

// 200220 Only return sum value.  get segment sum deviaiton,  Know right endpoint, width, a & b of every segment
// 200113   
//************************************
// Method:get_segment_sum_deviation
// Qualifier: sqrt!!!!!!!  get segment sum deviaiton,
// Input: Know right endpoint, width, a & b of every segment
// date:210120
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
long double APLA::get_segment_sum_deviation(const vector<T>& const original_time_series_vector, const Y& const temp_coefficient) {
	/*............................................................................................*/
#if _DEBUG
	assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF && temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF && !original_time_series_vector.empty());
#endif
	/*............................................................................................*/

	// cout << "width: " << temp_coefficient.rectangle_width << endl;
	//DataType* reconstructed_time_series = new DataType[temp_coefficient.rectangle_width];
	const size_t begin_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	//getAAndBByPLA(original_time_series, temp_coefficient);// get PLA: a & b of segment.
	long double segment_sum_deviation = 0;

	for (int i = 0; i < temp_coefficient.rectangle_width; i++) {
		//segment_sum_deviation += pow(temp_coefficient.apla.a * i + temp_coefficient.apla.b - original_time_series_vector[begin_id + i], 2.0);
		segment_sum_deviation += fabs(temp_coefficient.apla.a * i + temp_coefficient.apla.b - original_time_series_vector[begin_id + i]);
	}

	//Sqrt
	//return sqrt(segment_sum_deviation);
	return segment_sum_deviation;
}

//************************************
// Method:evaluate_segment_sum_deviation_vs_triangle_area
// Qualifier: evaluate triangle area lower bound sum deviation of segment
// date:210120
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
bool APLA::evaluate_segment_sum_deviation_vs_triangle_area(const vector<T>& const original_time_series_vector, const Y& const temp_coefficient) {
	long double sum_deviation_segment = get_segment_sum_deviation(original_time_series_vector, temp_coefficient);
	long double triangle_area_segment = 1.0 / temp_coefficient.segment_density;
	assert(sum_deviation_segment >= triangle_area_segment);
	return true;
}

// 200220  get segment sum deviaiton by split point
//************************************
// Method:compareAreaPercentage0
// Qualifier: right rectangle merge left rectangle mergeRectangle(area_vector, right_id);
// date:181128
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
double APLA::get_segment_sum_deviation_by_split_id(const vector<T>& const original_time_series_vector, const Y& const temp_coefficient, const U& const split_id) {//200220

	assert(split_id != INF && temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF && !original_time_series_vector.empty());
	int begin_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	int end_id = temp_coefficient.right_endpoint;

	assert(split_id > begin_id && split_id < end_id - 1);

	Y test_temp_coefficient = temp_coefficient;

	/*....................... segment does not have a&b ..................*/
	if (temp_coefficient.apla.a == INF || temp_coefficient.apla.b == INF) {
		get_ab_segment(original_time_series_vector, test_temp_coefficient);
	}
	/*....................................................................*/

	assert(test_temp_coefficient.apla.a != INF && test_temp_coefficient.apla.b != INF);

	if (split_id <= begin_id || split_id >= end_id) {
		assert(0);
		return get_segment_sum_deviation(original_time_series_vector, test_temp_coefficient);
	}

	assert(split_id > begin_id && split_id < end_id);
	Y segment_left;
	Y segment_right;
	vector<T> part_original_time_series_vector(original_time_series_vector.begin() + begin_id, original_time_series_vector.begin() + end_id + 1);
	assert(part_original_time_series_vector.size() == temp_coefficient.rectangle_width && part_original_time_series_vector.front() == original_time_series_vector[begin_id]);
	vector<T> reconstruct_time_series_left_vector;
	vector<T> reconstruct_time_series_right_vector;

	/*...................................get right endpoint & width...................................*/
	segment_left.right_endpoint = split_id;
	segment_right.right_endpoint = temp_coefficient.right_endpoint;
	segment_right.rectangle_width = temp_coefficient.right_endpoint - segment_left.right_endpoint;
	segment_left.rectangle_width = temp_coefficient.rectangle_width - segment_right.rectangle_width;
	/*................................................................................................*/

	getSubAAndBByPLA(original_time_series_vector, segment_left, segment_right, test_temp_coefficient);

#if _DEBUG
	assert(segment_left.right_endpoint != INF && segment_right.right_endpoint != INF && segment_left.rectangle_width != INF && segment_right.rectangle_width != INF);
	assert(segment_left.apla.a != INF && segment_right.apla.a != INF && segment_left.apla.b != INF && segment_right.apla.b != INF);
	//assert(segment_left.sum_value != INF && segment_right.sum_value != INF && float(segment_left.sum_value + segment_right.sum_value) == float(test_temp_coefficient.sum_value));
	assert(segment_left.rectangle_width + segment_right.rectangle_width == temp_coefficient.rectangle_width);
#endif

	get_PLA_reconstruct_series_by_segment(original_time_series_vector, segment_left, reconstruct_time_series_left_vector);
	get_PLA_reconstruct_series_by_segment(original_time_series_vector, segment_right, reconstruct_time_series_right_vector);
	reconstruct_time_series_left_vector.insert(reconstruct_time_series_left_vector.cend(), reconstruct_time_series_right_vector.cbegin(), reconstruct_time_series_right_vector.cend());

#if _DEBUG
	assert(reconstruct_time_series_left_vector.size() == temp_coefficient.rectangle_width && part_original_time_series_vector.size() == reconstruct_time_series_left_vector.size());
#endif

	double sum_deviation = TOOL::distanceEUC(part_original_time_series_vector, reconstruct_time_series_left_vector);

	part_original_time_series_vector.clear();
	part_original_time_series_vector.shrink_to_fit();
	reconstruct_time_series_left_vector.clear();
	reconstruct_time_series_left_vector.shrink_to_fit();
	reconstruct_time_series_right_vector.clear();
	reconstruct_time_series_right_vector.shrink_to_fit();

	return sum_deviation;
}

//************************************
// Method:get_segment_sum_max_deviation
// Qualifier: Return Sum & Max deviation. Know right endpoint, width, a & b of one segment
// date:201023
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
long double APLA::get_segment_sum_max_deviation(const vector<T>& const original_time_series_vector, const Y& const temp_coefficient, U& const sum_deviation, U& const max_deviation) {
#if _DEBUG
	assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF && temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF && !original_time_series_vector.empty());
#endif
	// cout << "width: " << temp_coefficient.rectangle_width << endl;
	//DataType* reconstructed_time_series = new DataType[temp_coefficient.rectangle_width];
	const size_t begin_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	//getAAndBByPLA(original_time_series, temp_coefficient);// get PLA: a & b of segment.
	sum_deviation = 0;
	max_deviation = -INF;
	long double point_difference = INF;

	long double difference_no_fabs = 0;

	for (int i = 0; i < temp_coefficient.rectangle_width; i++) {
		difference_no_fabs += temp_coefficient.apla.a * i + temp_coefficient.apla.b - original_time_series_vector[begin_id + i];

		point_difference = fabs(temp_coefficient.apla.a * i + temp_coefficient.apla.b - original_time_series_vector[begin_id + i]);
		sum_deviation += pow(point_difference, 2.0);
		max_deviation = max(max_deviation, point_difference);
	}

	assert(fabs(difference_no_fabs) < 0.00000001);

	return sum_deviation = sqrt(sum_deviation);
}

//210120
TEMPLATE
template<typename T, typename Y>
bool APLA::assert_merge_deviation(const vector<T>& const original_time_series_vector, const Y& const left_segment, const Y& const right_segment, const Y& const merged_segment) {
	vector<T> reconstruct_time_series_vector_left;
	get_PLA_reconstruct_series_by_segment(original_time_series_vector, left_segment, reconstruct_time_series_vector_left);
	cout << "L: ";
	TOOL::print_vector(reconstruct_time_series_vector_left);

	vector<T> reconstruct_time_series_vector_right;
	get_PLA_reconstruct_series_by_segment(original_time_series_vector, right_segment, reconstruct_time_series_vector_right);
	cout << "R: ";
	TOOL::print_vector(reconstruct_time_series_vector_right);

	reconstruct_time_series_vector_left.insert(reconstruct_time_series_vector_left.end(), reconstruct_time_series_vector_right.begin(), reconstruct_time_series_vector_right.end());

	auto merged_segment_copy = merged_segment;
	get_ab_segment(original_time_series_vector, merged_segment_copy);

	vector<T> reconstruct_time_series_vector_merge;
	get_PLA_reconstruct_series_by_segment(original_time_series_vector, merged_segment_copy, reconstruct_time_series_vector_merge);
	cout << "M: ";
	TOOL::print_vector(reconstruct_time_series_vector_merge);

	const size_t left_id = merged_segment.right_endpoint - merged_segment.rectangle_width + 1;
	vector<T> original_time_series_part(original_time_series_vector.begin() + left_id, original_time_series_vector.begin() + merged_segment.right_endpoint + 1);
	cout << "O: ";
	TOOL::print_vector(original_time_series_part);

	assert(reconstruct_time_series_vector_left.size() == reconstruct_time_series_vector_merge.size() && original_time_series_part.size() == reconstruct_time_series_vector_merge.size());

	long double sum_difference_original = 0;
	long double sum_difference_pla = 0;
	for (int i = 0; i < merged_segment.rectangle_width; i++) {
		sum_difference_original += fabs(reconstruct_time_series_vector_merge[i] - original_time_series_part[i]);
		sum_difference_pla += fabs(reconstruct_time_series_vector_merge[i] - reconstruct_time_series_vector_left[i]);
	}
	assert(fabs(sum_difference_original - sum_difference_pla) < 0.1);

	return true;
}

//210327
//TEMPLATE
//template<typename T, typename Y, typename U, typename W, typename T1>
//long double get_sum_max_deviation(const vector<T>& const original_time_series_vector, const DoublyLinkedList<Y>& const linked_list, U& const sum_deviation, W& const max_deviation, T1& const max_deviation_multiple_width) {
//
//}

/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

// 200220 scan segment to get absolute difference
	// Input: 1 segment right endpoint, width.
	// Output: sum absolute segment y vlaue difference
//************************************
// Method:get_sum_segment_absolute_difference
// Qualifier: right rectangle merge left rectangle mergeRectangle(area_vector, right_id);
// date:181128
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
long double& APLA::get_sum_segment_absolute_difference(const vector<T>& const original_time_series_vector, Y& const temp_coefficient) {
#if _DEBUG
	assert(!original_time_series_vector.empty() && temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF && temp_coefficient.rectangle_width > 1 && temp_coefficient.right_endpoint < original_time_series_vector.size() && temp_coefficient.right_endpoint > 0);
#endif

	//const int id_segment_begin = ;
	temp_coefficient.sum_difference_absolute = 0;
	for (int id_point = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1; id_point < temp_coefficient.right_endpoint; id_point++) {
		temp_coefficient.sum_difference_absolute += fabs(original_time_series_vector[id_point + 1] - original_time_series_vector[id_point]);
	}

#if _DEBUG
	assert(temp_coefficient.sum_difference_absolute >= 0);
#endif

	return temp_coefficient.sum_difference_absolute;
}

//************************************
// Method:compareAreaPercentage0
// Qualifier: right rectangle merge left rectangle mergeRectangle(area_vector, right_id);
// date:181128
// author:
//************************************
TEMPLATE
void APLA::compareAreaPercentage0(vector<AREA_COEFFICIENT>& area_vector, const int vector_id) {//181128
	int left_id = vector_id - 1;
	int right_id = vector_id + 1;
	double left_percentage = NULL;
	double right_percentage = NULL;
	double temp_right_area = NULL, temp_left_area = NULL;
	double temp_left_heightest_value = NULL, temp_right_heightest_value = NULL, temp_left_lowest_value = NULL, temp_right_lowest_value = NULL;
	double temp_left_heightest_id = NULL, temp_right_heightest_id = NULL, temp_left_lowest_id = NULL, temp_right_lowest_id = NULL;
	//double temp_left_minimax_dist = NULL;
	//double temp_right_minimax_dist = NULL;
	double temp_minimax_dist = fabs((area_vector.begin() + vector_id)->heightest_id - (area_vector.begin() + vector_id)->lowest_id);

	if (vector_id >= 1) {
		//cout << "left id: " << left_id << ", right id: " << right_id << endl;

		//right percentage

		temp_right_heightest_value = max((area_vector.begin() + right_id)->heightest_value, (area_vector.begin() + vector_id)->heightest_value);
		temp_right_lowest_value = min((area_vector.begin() + right_id)->lowest_value, (area_vector.begin() + vector_id)->lowest_value);
		temp_right_area = (temp_right_heightest_value - temp_right_lowest_value) * ((area_vector.begin() + right_id)->right_endpoint - (area_vector.begin() + left_id)->right_endpoint - 1);
		right_percentage = (area_vector.begin() + vector_id)->rectangle_area / temp_right_area;

		//left percentage

		temp_left_heightest_value = max((area_vector.begin() + vector_id)->heightest_value, (area_vector.begin() + left_id)->heightest_value);
		temp_left_lowest_value = min((area_vector.begin() + vector_id)->lowest_value, (area_vector.begin() + left_id)->lowest_value);
		if (vector_id == 1)
			temp_left_area = (temp_left_heightest_value - temp_left_lowest_value) * (area_vector.begin() + 1)->right_endpoint;
		else
			temp_left_area = (temp_left_heightest_value - temp_left_lowest_value) * ((area_vector.begin() + vector_id)->right_endpoint - (area_vector.begin() + left_id - 1)->right_endpoint - 1);
		left_percentage = (area_vector.begin() + vector_id)->rectangle_area / temp_left_area;

		if (left_percentage > right_percentage) {
			//cout << "Merge left:" << left_id << endl;
			mergeRectangle(area_vector, vector_id);
		}
		else if (left_percentage < right_percentage) {
			//cout << "Merge right:" << right_id  << endl;
			mergeRectangle(area_vector, right_id);
		}
		//area_vector.erase(area_vector.begin() + left_id);
	}
	//else if (vector_id == 0) {
	//	assert(0);
	//	(area_vector.begin() + 1)->heightest_value = max(area_vector.begin()->heightest_value, (area_vector.begin() + 1)->heightest_value);
	//	(area_vector.begin() + 1)->lowest_value = min(area_vector.begin()->lowest_value, (area_vector.begin() + 1)->lowest_value);
	//	(area_vector.begin() + 1)->rectangle_area = ((area_vector.begin() + 1)->heightest_value - (area_vector.begin() + 1)->lowest_value) * (area_vector.begin() + 1)->right_endpoint;
	//	area_vector.erase(area_vector.begin());
	//}
	//else if (right_id == area_vector.size()) {
	//	assert(0);
	//	//cout << "end id: " <<  vector_id << endl;
	//	(area_vector.begin() + vector_id)->heightest_value = max((area_vector.begin() + vector_id)->heightest_value, (area_vector.begin() + left_id)->heightest_value);
	//	(area_vector.begin() + vector_id)->lowest_value = min((area_vector.begin() + vector_id)->lowest_value, (area_vector.begin() + left_id)->lowest_value);
	//	(area_vector.begin() + vector_id)->rectangle_area = ((area_vector.begin() + vector_id)->heightest_value - (area_vector.begin() + vector_id)->lowest_value) * ((area_vector.begin() + vector_id)->right_endpoint - (area_vector.begin() + left_id - 1)->right_endpoint - 1);
	//	area_vector.erase(area_vector.end());
	//}
	else {
		assert(0);
	}
}

//************************************
// Method:compareAreaPercentage
// Qualifier: right rectangle merge left rectangle
// date:181205
// author:
//************************************
TEMPLATE
void APLA::compareAreaPercentage(vector<AREA_COEFFICIENT>& area_vector, int& vector_id, DataType*& const original_time_series) {//181205
	cout << "Begin compareAreaPercentage()" << endl;

	int right_id = vector_id + 1;
	int left_id = vector_id - 1;
	assert(left_id >= 0);

	AREA_COEFFICIENT temp_left_coefficient, temp_right_coefficient;
	double left_percentage = NULL, right_percentage = NULL;

	if (vector_id >= 1) {
		//cout << "left id: " << left_id << ", right id: " << right_id << endl;

		//Right percentage of area
		getMergedInfo(area_vector, right_id, temp_right_coefficient);

		if (area_vector.at(vector_id).rectangle_area <= area_vector.at(right_id).rectangle_area)
			right_percentage = area_vector.at(vector_id).rectangle_area / temp_right_coefficient.rectangle_area;
		else
			right_percentage = area_vector.at(right_id).rectangle_area / temp_right_coefficient.rectangle_area;

		//Left percentage of area
		getMergedInfo(area_vector, vector_id, temp_left_coefficient);
		//temp_left_vector.heightest_value = max((area_vector.begin() + vector_id)->heightest_value, (area_vector.begin() + left_id)->heightest_value);
		//temp_left_vector.lowest_value = min((area_vector.begin() + vector_id)->lowest_value, (area_vector.begin() + left_id)->lowest_value);

		//if (vector_id == 1)
		//	temp_left_vector.rectangle_area = (temp_left_vector.heightest_value - temp_left_vector.lowest_value) * (area_vector.begin() + 1)->right_endpoint;
		//else
		//	temp_left_vector.rectangle_area = (temp_left_vector.heightest_value - temp_left_vector.lowest_value) * ((area_vector.begin() + vector_id)->right_endpoint - (area_vector.begin() + left_id - 1)->right_endpoint - 1);
		//

		if (area_vector.at(vector_id).rectangle_area <= area_vector.at(left_id).rectangle_area)
			left_percentage = (area_vector.begin() + vector_id)->rectangle_area / temp_left_coefficient.rectangle_area;
		else
			left_percentage = (area_vector.begin() + left_id)->rectangle_area / temp_left_coefficient.rectangle_area;

		////right minimax id
		//if ((area_vector.begin() + right_id)->heightest_value >= (area_vector.begin() + vector_id)->heightest_value) {//max
		//	temp_right_vector.heightest_id = (area_vector.begin() + right_id)->heightest_id;
		//}
		//else {
		//	temp_right_vector.heightest_id = (area_vector.begin() + vector_id)->heightest_id;
		//}

		//if ((area_vector.begin() + right_id)->lowest_value <= (area_vector.begin() + vector_id)->lowest_value) {//lowest
		//	temp_right_vector.lowest_id = (area_vector.begin() + right_id)->lowest_id;
		//}
		//else {
		//	temp_right_vector.lowest_id = (area_vector.begin() + vector_id)->lowest_id;
		//}

		////left minimax id
		//temp_left_vector.heightest_id = (area_vector.begin() + left_id)->heightest_value >= (area_vector.begin() + vector_id)->heightest_value ? (area_vector.begin() + left_id)->heightest_id : (area_vector.begin() + vector_id)->heightest_id;
		//temp_left_vector.lowest_id = (area_vector.begin() + left_id)->lowest_value <= (area_vector.begin() + vector_id)->lowest_value ? (area_vector.begin() + left_id)->lowest_id : (area_vector.begin() + vector_id)->lowest_id;

		if (left_percentage >= right_percentage) {
			//cout << "Merge left:" << left_id << endl;
			//mergeRectangle(area_vector, vector_id, temp_left_coefficient, original_time_series);
			mergeRectangle2(area_vector, vector_id, temp_left_coefficient, original_time_series);
		}
		else if (left_percentage < right_percentage) {
			//cout << "Merge right:" << right_id  << endl;
			//mergeRectangle(area_vector, right_id, temp_right_coefficient, original_time_series);
			mergeRectangle2(area_vector, right_id, temp_right_coefficient, original_time_series);
		}
		else {
			assert(0);
		}
	}
	else if (vector_id == 0) {
		assert(0);
		(area_vector.begin() + 1)->heightest_value = max(area_vector.begin()->heightest_value, (area_vector.begin() + 1)->heightest_value);
		(area_vector.begin() + 1)->lowest_value = min(area_vector.begin()->lowest_value, (area_vector.begin() + 1)->lowest_value);
		(area_vector.begin() + 1)->rectangle_area = ((area_vector.begin() + 1)->heightest_value - (area_vector.begin() + 1)->lowest_value) * (area_vector.begin() + 1)->right_endpoint;
		area_vector.erase(area_vector.begin());
	}
	else if (right_id == area_vector.size()) {
		assert(0);
		//cout << "end id: " <<  vector_id << endl;
		(area_vector.begin() + vector_id)->heightest_value = max((area_vector.begin() + vector_id)->heightest_value, (area_vector.begin() + left_id)->heightest_value);
		(area_vector.begin() + vector_id)->lowest_value = min((area_vector.begin() + vector_id)->lowest_value, (area_vector.begin() + left_id)->lowest_value);
		(area_vector.begin() + vector_id)->rectangle_area = ((area_vector.begin() + vector_id)->heightest_value - (area_vector.begin() + vector_id)->lowest_value) * ((area_vector.begin() + vector_id)->right_endpoint - (area_vector.begin() + left_id - 1)->right_endpoint - 1);
		area_vector.erase(area_vector.end());
	}
	else {
		assert(0);
	}
}

//************************************
// Method:compareAreaPercentageMinMaxDist
// Qualifier: Q:Is it better that new rectangle_height*minmax_dist / old rectanle_height*minmax_dist, Not rectangle width
// date:181211
// author:
//************************************
TEMPLATE
void APLA::compareAreaPercentageMinMaxDist(vector<AREA_COEFFICIENT>& area_vector, int& vector_id, DataType*& const original_time_series) {//181211
	//cout << "Begin compareAreaPercentageMinMaxDist()" << endl;

	int right_id = vector_id + 1;
	int left_id = vector_id - 1;
	//assert(left_id >= 0);

	AREA_COEFFICIENT temp_left_coefficient, temp_right_coefficient;
	double left_percentage = NULL, right_percentage = NULL;

	if (vector_id >= 1 && right_id < area_vector.size()) {
		//cout << "left id: " << left_id << ", right id: " << right_id << endl;
		//cout << "current id: " << area_vector.at(vector_id).right_endpoint << " current area: " << area_vector.at(vector_id).real_area << endl;

		//Left percentage of area
		getMergedInfo(original_time_series, area_vector, vector_id, temp_left_coefficient);
		//left_percentage = temp_left_coefficient.rectangle_width /temp_left_coefficient.rectangle_area;
		//left_percentage = (area_vector.at(vector_id).real_area + area_vector.at(left_id).real_area) / temp_left_coefficient.rectangle_area;
		//left_percentage = temp_left_coefficient.real_area / max(area_vector.at(left_id).real_area, area_vector.at(vector_id).real_area);
		left_percentage = 1.0 / temp_left_coefficient.rec_deviation;//190115
		left_percentage = (area_vector[vector_id].rectangle_area + area_vector[left_id].rectangle_area) / temp_left_coefficient.rectangle_area;//190116
		//left_percentage = 1.0/fabs(area_vector[vector_id].apla.a - area_vector[left_id].apla.a);
		//cout << "left end id: " << area_vector.at(left_id).right_endpoint << " left real area: " << temp_left_coefficient.real_area << " left area:" << temp_left_coefficient.rectangle_area << endl;

		/*----------------------------------------------------------------------------------------------------------------------*/
		//Right percentage of area
		getMergedInfo(original_time_series, area_vector, right_id, temp_right_coefficient);
		//right_percentage = temp_right_coefficient.rectangle_width / temp_right_coefficient.rectangle_area;
		//right_percentage = (area_vector.at(vector_id).real_area + area_vector.at(right_id).real_area) / temp_right_coefficient.rectangle_area;
		//right_percentage = temp_right_coefficient.real_area / max(area_vector.at(right_id).real_area, area_vector.at(vector_id).real_area);
		right_percentage = 1.0 / temp_right_coefficient.rec_deviation;//190115
		right_percentage = (area_vector[vector_id].rectangle_area + area_vector[right_id].rectangle_area) / temp_right_coefficient.rectangle_area;//190116
		//right_percentage = 1.0/fabs(area_vector[vector_id].apla.a - area_vector[right_id].apla.a);
		//cout << "right end id: "<< area_vector.at(right_id).right_endpoint<<" right real area: " << temp_right_coefficient.real_area << " right area:"<< temp_right_coefficient.rectangle_area << endl;

		//cout << "Percentage: " << left_percentage << " vs "<< right_percentage <<endl;

		//if (left_percentage >= right_percentage && area_vector.size() > input_argument.point_dimension) {
		if (left_percentage >= right_percentage) {
			//cout << "Merge left:" << left_id << endl;
			//mergeRectangle(area_vector, vector_id, temp_left_coefficient, original_time_series);
			mergeRectangle2(area_vector, vector_id, temp_left_coefficient, original_time_series);
		}
		//else if (left_percentage < right_percentage && area_vector.size() > input_argument.point_dimension) {
		else if (left_percentage < right_percentage) {
			//cout << "Merge right:" << right_id  << endl;
			//mergeRectangle(area_vector, right_id, temp_right_coefficient, original_time_series);
			mergeRectangle2(area_vector, right_id, temp_right_coefficient, original_time_series);
		}
		else {
			assert(0);
			vector_id++;
		}
	}
	else if (vector_id == 0) {
		getMergedInfo(original_time_series, area_vector, right_id, temp_right_coefficient);
		mergeRectangle2(area_vector, right_id, temp_right_coefficient, original_time_series);
		//assert(0);
	}
	else if (right_id == area_vector.size()) {
		getMergedInfo(original_time_series, area_vector, vector_id, temp_left_coefficient);
		mergeRectangle2(area_vector, vector_id, temp_left_coefficient, original_time_series);
		//	assert(0);
	}
	else {
		assert(0);
	}
}

//************************************
// Method:compareAreaPercentageMinMaxDistNoMove
// Qualifier:
// date:181211
// author:
//************************************
TEMPLATE
void APLA::compareAreaPercentageMinMaxDistNoMove(vector<AREA_COEFFICIENT>& area_vector, int& vector_id, DataType*& const original_time_series) {//181211
	cout << "Begin compareAreaPercentageMinMaxDist()" << endl;

	int right_id = vector_id + 1;
	int left_id = vector_id - 1;
	assert(left_id >= 0);

	AREA_COEFFICIENT temp_left_coefficient, temp_right_coefficient;
	double left_percentage = NULL, right_percentage = NULL;

	if (vector_id >= 1) {
		//cout << "left id: " << left_id << ", right id: " << right_id << endl;

		//Right percentage of area
		getMergedInfo(area_vector, right_id, temp_right_coefficient);
		right_percentage = (area_vector.at(vector_id).rectangle_area + area_vector.at(right_id).rectangle_area) / temp_right_coefficient.rectangle_area;

		//Left percentage of area
		getMergedInfo(area_vector, vector_id, temp_left_coefficient);
		left_percentage = (area_vector.at(vector_id).rectangle_area + area_vector.at(left_id).rectangle_area) / temp_left_coefficient.rectangle_area;

		if (left_percentage >= right_percentage) {
			//cout << "Merge left:" << left_id << endl;
			//mergeRectangle(area_vector, vector_id, temp_left_coefficient, original_time_series);
			mergeRectangle(area_vector, vector_id);
		}
		else if (left_percentage < right_percentage) {
			//cout << "Merge right:" << right_id  << endl;
			//mergeRectangle(area_vector, right_id, temp_right_coefficient, original_time_series);
			mergeRectangle(area_vector, right_id);
		}
		else {
			assert(0);
		}
	}
	//else if (vector_id == 0) {
	//	assert(0);
	//	(area_vector.begin() + 1)->heightest_value = max(area_vector.begin()->heightest_value, (area_vector.begin() + 1)->heightest_value);
	//	(area_vector.begin() + 1)->lowest_value = min(area_vector.begin()->lowest_value, (area_vector.begin() + 1)->lowest_value);
	//	(area_vector.begin() + 1)->rectangle_area = ((area_vector.begin() + 1)->heightest_value - (area_vector.begin() + 1)->lowest_value) * (area_vector.begin() + 1)->right_endpoint;
	//	area_vector.erase(area_vector.begin());
	//}
	//else if (right_id == area_vector.size()) {
	//	assert(0);
	//	//cout << "end id: " <<  vector_id << endl;
	//	(area_vector.begin() + vector_id)->heightest_value = max((area_vector.begin() + vector_id)->heightest_value, (area_vector.begin() + left_id)->heightest_value);
	//	(area_vector.begin() + vector_id)->lowest_value = min((area_vector.begin() + vector_id)->lowest_value, (area_vector.begin() + left_id)->lowest_value);
	//	(area_vector.begin() + vector_id)->rectangle_area = ((area_vector.begin() + vector_id)->heightest_value - (area_vector.begin() + vector_id)->lowest_value) * ((area_vector.begin() + vector_id)->right_endpoint - (area_vector.begin() + left_id - 1)->right_endpoint - 1);
	//	area_vector.erase(area_vector.end());
	//}
	else {
		assert(0);
	}
}

//************************************
// Method:getAPLAArea
// Qualifier:for n^2 Area
// date:181126
// author:
//************************************
TEMPLATE
void APLA::compareMiniMaxDist(vector<AREA_COEFFICIENT>& area_vector, const int vector_id) {//181126
	double temp_left_heightest_id = NULL, temp_right_heightest_id = NULL, temp_left_lowest_id = NULL, temp_right_lowest_id = NULL;
	double temp_left_minimax_dist = NULL;
	double temp_right_minimax_dist = NULL;
	double temp_minimax_dist = fabs((area_vector.begin() + vector_id)->heightest_id - (area_vector.begin() + vector_id)->lowest_id);

	int left_id = vector_id - 1;
	int right_id = vector_id + 1;

	if (vector_id >= 1) {
		if ((area_vector.begin() + right_id)->heightest_value >= (area_vector.begin() + vector_id)->heightest_value) {//max
			temp_right_heightest_id = (area_vector.begin() + right_id)->heightest_id;
		}
		else {
			temp_right_heightest_id = (area_vector.begin() + vector_id)->heightest_id;
		}

		if ((area_vector.begin() + right_id)->lowest_value <= (area_vector.begin() + vector_id)->lowest_value) {//lowest
			temp_right_lowest_id = (area_vector.begin() + right_id)->lowest_id;
		}
		else {
			temp_right_lowest_id = (area_vector.begin() + vector_id)->lowest_id;
		}

		temp_left_heightest_id = (area_vector.begin() + left_id)->heightest_value >= (area_vector.begin() + vector_id)->heightest_value ? (area_vector.begin() + left_id)->heightest_id : (area_vector.begin() + vector_id)->heightest_id;
		temp_left_lowest_id = (area_vector.begin() + left_id)->lowest_value <= (area_vector.begin() + vector_id)->lowest_value ? (area_vector.begin() + left_id)->lowest_id : (area_vector.begin() + vector_id)->lowest_id;

		temp_right_minimax_dist = fabs(temp_right_heightest_id - temp_right_lowest_id);
		temp_left_minimax_dist = fabs(temp_left_heightest_id - temp_left_lowest_id);

		if (temp_right_minimax_dist > temp_left_minimax_dist) {
			if (temp_right_minimax_dist > temp_minimax_dist) {
				mergeRectangle(area_vector, right_id, temp_right_heightest_id, temp_right_lowest_id);
			}
			/*else {
				assert(0);
			}*/
		}
		else if (temp_right_minimax_dist < temp_left_minimax_dist) {
			if (temp_left_minimax_dist > temp_minimax_dist) {
				mergeRectangle(area_vector, vector_id, temp_left_heightest_id, temp_left_lowest_id);
			}
		}
		else {
			if (temp_right_minimax_dist > temp_minimax_dist) {
			}
			else if (temp_right_minimax_dist <= temp_minimax_dist) {
			}
		}
	}
	else if (vector_id == 0) {
		//assert(0);
		(area_vector.begin() + 1)->heightest_value = max(area_vector.begin()->heightest_value, (area_vector.begin() + 1)->heightest_value);
		(area_vector.begin() + 1)->lowest_value = min(area_vector.begin()->lowest_value, (area_vector.begin() + 1)->lowest_value);
		(area_vector.begin() + 1)->rectangle_area = ((area_vector.begin() + 1)->heightest_value - (area_vector.begin() + 1)->lowest_value) * (area_vector.begin() + 1)->right_endpoint;
		area_vector.erase(area_vector.begin());
	}
	else if (right_id == area_vector.size()) {
		//assert(0);
		//cout << "end id: " <<  vector_id << endl;
		(area_vector.begin() + vector_id)->heightest_value = max((area_vector.begin() + vector_id)->heightest_value, (area_vector.begin() + left_id)->heightest_value);
		(area_vector.begin() + vector_id)->lowest_value = min((area_vector.begin() + vector_id)->lowest_value, (area_vector.begin() + left_id)->lowest_value);
		(area_vector.begin() + vector_id)->rectangle_area = ((area_vector.begin() + vector_id)->heightest_value - (area_vector.begin() + vector_id)->lowest_value) * ((area_vector.begin() + vector_id)->right_endpoint - (area_vector.begin() + left_id - 1)->right_endpoint - 1);
		area_vector.erase(area_vector.end());
	}
	else {
		assert(0);
	}
}

//************************************
// Method:compareDeviation
// Qualifier:
// date:190115
// author:
//************************************
TEMPLATE
void APLA::compareDeviation(vector<AREA_COEFFICIENT>& area_vector, int& vector_id, DataType*& const original_time_series) {//190115
	//cout << "Begin compareAreaPercentageMinMaxDist()" << endl;

	int right_id = vector_id + 1;
	int left_id = vector_id - 1;
	//assert(left_id >= 0);

	AREA_COEFFICIENT temp_left_coefficient, temp_right_coefficient;
	double left_percentage = NULL, right_percentage = NULL;

	if (vector_id >= 1 && right_id < area_vector.size()) {
		//cout << "left id: " << left_id << ", right id: " << right_id << endl;
		//cout << "current id: " << area_vector.at(vector_id).right_endpoint << " current area: " << area_vector.at(vector_id).real_area << endl;

		//Left percentage of area
		getMergedInfo(original_time_series, area_vector, vector_id, temp_left_coefficient);
		//left_percentage = temp_left_coefficient.rectangle_width /temp_left_coefficient.rectangle_area;
		//left_percentage = (area_vector.at(vector_id).real_area + area_vector.at(left_id).real_area) / temp_left_coefficient.rectangle_area;
		//left_percentage = temp_left_coefficient.real_area / max(area_vector.at(left_id).real_area, area_vector.at(vector_id).real_area);
		left_percentage = (area_vector.at(vector_id).rectangle_area + area_vector.at(left_id).rectangle_area) / temp_left_coefficient.rectangle_area;//190116
		left_percentage = 1.0 / temp_left_coefficient.rec_deviation;//190116
		//cout << "left end id: " << area_vector.at(left_id).right_endpoint << " left real area: " << temp_left_coefficient.real_area << " left area:" << temp_left_coefficient.rectangle_area << endl;

		//Right percentage of area
		getMergedInfo(original_time_series, area_vector, right_id, temp_right_coefficient);

		//right_percentage = temp_right_coefficient.rectangle_width / temp_right_coefficient.rectangle_area;
		//right_percentage = (area_vector.at(vector_id).real_area + area_vector.at(right_id).real_area) / temp_right_coefficient.rectangle_area;
		//right_percentage = temp_right_coefficient.real_area / max(area_vector.at(right_id).real_area, area_vector.at(vector_id).real_area);
		right_percentage = (area_vector.at(vector_id).rectangle_area + area_vector.at(right_id).rectangle_area) / temp_right_coefficient.rectangle_area;//190116
		right_percentage = 1.0 / temp_right_coefficient.rec_deviation;//190116
		//cout << "right end id: "<< area_vector.at(right_id).right_endpoint<<" right real area: " << temp_right_coefficient.real_area << " right area:"<< temp_right_coefficient.rectangle_area << endl;

		//cout << "Percentage: " << left_percentage << " vs "<< right_percentage <<endl;

		//if (left_percentage >= right_percentage && area_vector.size() > input_argument.point_dimension) {
		if (left_percentage >= right_percentage) {
			cout << "Merge left:" << left_id << endl;
			//mergeRectangle(area_vector, vector_id, temp_left_coefficient, original_time_series);
			mergeRectangle2(area_vector, vector_id, temp_left_coefficient, original_time_series);
		}
		//else if (left_percentage < right_percentage && area_vector.size() > input_argument.point_dimension) {
		else if (left_percentage < right_percentage) {
			cout << "Merge right:" << right_id << endl;
			//mergeRectangle(area_vector, right_id, temp_right_coefficient, original_time_series);
			mergeRectangle2(area_vector, right_id, temp_right_coefficient, original_time_series);
		}
		else {
			assert(0);
			vector_id++;
		}
	}
	else if (vector_id == 0) {
		getMergedInfo(original_time_series, area_vector, right_id, temp_right_coefficient);
		mergeRectangle2(area_vector, right_id, temp_right_coefficient, original_time_series);
		//assert(0);
	}
	else if (right_id == area_vector.size()) {
		getMergedInfo(original_time_series, area_vector, vector_id, temp_left_coefficient);
		mergeRectangle2(area_vector, vector_id, temp_left_coefficient, original_time_series);
		//	assert(0);
	}
	else {
		assert(0);
	}
}

//************************************
// Method:getAPLAArea
// Qualifier:for n^2 Area
// date:181119
// author:
//************************************
TEMPLATE
void APLA::getAPLAArea(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series) {//181119
	assert(input_argument.time_series_length % 2 == 0);//n is even

	int initial_rectangle_num = input_argument.time_series_length / 2;

	AREA_COEFFICIENT* area_coefficient = new AREA_COEFFICIENT[initial_rectangle_num];
	vector<AREA_COEFFICIENT> area_vector;
	AreaIncreasing areaIncreasing;

	int iterator_times = initial_rectangle_num - input_argument.point_dimension;
	int iterator_length = initial_rectangle_num;

	for (int array_id = 0; array_id < initial_rectangle_num; array_id++) {
		area_coefficient[array_id].right_endpoint = array_id * 2 + 1;
		area_coefficient[array_id].rectangle_width = 1;
		area_coefficient[array_id].heightest_value = max(original_time_series[array_id * 2], original_time_series[array_id * 2 + 1]);
		area_coefficient[array_id].lowest_value = min(original_time_series[array_id * 2], original_time_series[array_id * 2 + 1]);
		area_coefficient[array_id].rectangle_area = (area_coefficient[array_id].heightest_value - area_coefficient[array_id].lowest_value);
		area_vector.push_back(area_coefficient[array_id]);
	}

	for (int i = 0; i < initial_rectangle_num; i++) {
		cout << area_coefficient[i].rectangle_area << " ";
	}

	cout << endl << min_element(area_vector.begin(), area_vector.end(), areaIncreasing)->rectangle_area << " " << min_element(area_vector.begin(), area_vector.end(), areaIncreasing)->right_endpoint << endl;
	auto result0 = min_element(area_vector.begin(), area_vector.end(), areaIncreasing);
	//cout << min_element(area_coefficient, area_coefficient + initial_rectangle_num, areaIncreasing) - area_coefficient << endl;
	cout << "id: " << distance(area_vector.begin(), result0) << endl;

	while (area_vector.size() > input_argument.point_dimension) {
		auto result = min_element(area_vector.begin(), area_vector.end(), areaIncreasing);
		int vector_id = distance(area_vector.begin(), result);

		if (vector_id == 0) {
			cout << "first: " << vector_id << endl;
			/*(area_vector.begin() + 1)->heightest_value = max(area_vector.begin()->heightest_value, (area_vector.begin() + 1)->heightest_value);
			(area_vector.begin() + 1)->lowest_value = min(area_vector.begin()->lowest_value, (area_vector.begin() + 1)->lowest_value);
			(area_vector.begin() + 1)->rectangle_area = ((area_vector.begin() + 1)->heightest_value - (area_vector.begin() + 1)->lowest_value) * (area_vector.begin() + 1)->right_endpoint;
			area_vector.erase(area_vector.begin());*/

			mergeRectangle(area_vector, vector_id);
		}
		else if (vector_id == area_vector.size() - 1) {
			cout << "end: " << vector_id << endl;
			mergeRectangle(area_vector, vector_id);
		}
		else {
			//auto min_area = min_element(area_vector.begin()+vector_id - 1, area_vector.begin() + vector_id + 1, areaIncreasing);
			if (area_vector[vector_id - 1].rectangle_area <= area_vector[vector_id + 1].rectangle_area) {
				cout << "left<=right: " << vector_id << endl;
				mergeRectangle(area_vector, vector_id);
			}
			else {
				cout << "left > right: " << vector_id + 1 << endl;
				mergeRectangle(area_vector, vector_id + 1);
			}
		}
	}
	cout << "size: " << area_vector.size() << endl;
	cout << "right end point: ";
	for (auto&& i : area_vector) {
		cout << i.right_endpoint << " ";
	}
	//delete[] area_coefficient;
}

//************************************
// Method:getAPLAArea0
// Qualifier:for n^2 percentage
// date:181122
// author:
//************************************
TEMPLATE
void APLA::getAPLAArea0(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series) {//181122
	assert(input_argument.time_series_length % 2 == 0);//n is even

	int initial_rectangle_num = input_argument.time_series_length / 2;

	AREA_COEFFICIENT* area_coefficient = new AREA_COEFFICIENT[initial_rectangle_num];
	vector<AREA_COEFFICIENT> area_vector;
	AreaIncreasing areaIncreasing;

	int iterator_times = initial_rectangle_num - input_argument.point_dimension;
	int iterator_length = initial_rectangle_num;

	for (int array_id = 0; array_id < initial_rectangle_num; array_id++) {
		area_coefficient[array_id].right_endpoint = array_id * 2 + 1;
		area_coefficient[array_id].rectangle_width = 1;
		area_coefficient[array_id].heightest_value = max(original_time_series[array_id * 2], original_time_series[array_id * 2 + 1]);
		area_coefficient[array_id].lowest_value = min(original_time_series[array_id * 2], original_time_series[array_id * 2 + 1]);
		area_coefficient[array_id].rectangle_area = (area_coefficient[array_id].heightest_value - area_coefficient[array_id].lowest_value);
		area_vector.push_back(area_coefficient[array_id]);
	}

	/*for (int i = 0; i < initial_rectangle_num; i++) {
		cout << area_coefficient[i].rectangle_area << " ";
	}*/

	cout << endl << min_element(area_vector.begin(), area_vector.end(), areaIncreasing)->rectangle_area << " " << min_element(area_vector.begin(), area_vector.end(), areaIncreasing)->right_endpoint << endl;
	auto result0 = min_element(area_vector.begin(), area_vector.end(), areaIncreasing);
	//cout << min_element(area_coefficient, area_coefficient + initial_rectangle_num, areaIncreasing) - area_coefficient << endl;
	cout << "id: " << distance(area_vector.begin(), result0) << endl;

	while (area_vector.size() > input_argument.point_dimension) {
		auto result = min_element(area_vector.begin(), area_vector.end(), areaIncreasing);
		int vector_id = distance(area_vector.begin(), result);

		if (vector_id == 0) {
			cout << "first: " << vector_id << endl;
			(area_vector.begin() + 1)->heightest_value = max(area_vector.begin()->heightest_value, (area_vector.begin() + 1)->heightest_value);
			(area_vector.begin() + 1)->lowest_value = min(area_vector.begin()->lowest_value, (area_vector.begin() + 1)->lowest_value);
			(area_vector.begin() + 1)->rectangle_area = ((area_vector.begin() + 1)->heightest_value - (area_vector.begin() + 1)->lowest_value) * (area_vector.begin() + 1)->right_endpoint;
			area_vector.erase(area_vector.begin());
		}
		else if (vector_id == area_vector.size() - 1) {
			cout << "end: " << vector_id << endl;
			mergeRectangle(area_vector, vector_id);
		}
		else {
			//auto min_area = min_element(area_vector.begin()+vector_id - 1, area_vector.begin() + vector_id + 1, areaIncreasing);
			compareAreaPercentage(area_vector, vector_id);
		}
	}
	cout << "size: " << area_vector.size() << endl;
	cout << "right end point: ";
	for (auto&& i : area_vector) {
		cout << i.right_endpoint << " ";
	}
	delete[] area_coefficient;
}

//************************************
// Method:getAPLAArea1
// Qualifier:for logn percentage
// date:181210
// author:
//************************************
TEMPLATE
void APLA::getAPLAArea1(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series) {//181122
	assert(input_argument.time_series_length % 2 == 0);//n is even

	int initial_rectangle_num = input_argument.time_series_length / 2;

	AREA_COEFFICIENT area_coefficient;
	vector<AREA_COEFFICIENT> area_vector;

	initialRecArea(input_argument, original_time_series, area_vector);//181211

	TOOL::recordStartTime(TOOL::time_record[0]);//compare percentage time
	//
	while (area_vector.size() > input_argument.point_dimension) {
		for (int vector_id = 1; vector_id < area_vector.size() - 1 && area_vector.size() > input_argument.point_dimension; vector_id += 3) {
			compareAreaPercentage(area_vector, vector_id, original_time_series);//**********************
			//compareAreaPercentage0(area_vector, vector_id);
		}
		//cout << "size: " << area_vector.size() << endl;
	}
	cout << "Time: " << TOOL::recordFinishTime(TOOL::time_record[0]) << endl;// compare percentage time

	//Print vector result
	cout << "Finish! \n size: " << area_vector.size() << endl;
	cout << "right end point: ";

	for (auto&& i : area_vector) {
		cout << i.right_endpoint << " ";
	}
	cout << endl << "Min: ";
	for (auto&& i : area_vector) {
		cout << i.lowest_id << " ";
	}
	cout << endl << "Max: ";
	for (auto&& i : area_vector) {
		cout << i.heightest_id << " ";
	}
	cout << endl;
}

//************************************
// Method:getAPLAAreaMinMaxDist
// Qualifier:Compare Min Max Distance
// date:181123
// author:
//************************************
TEMPLATE
void APLA::getAPLAAreaMinMaxDist(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series) {//181123
	assert(input_argument.time_series_length % 2 == 0);//n is even

	int initial_rectangle_num = input_argument.time_series_length / 2;

	AREA_COEFFICIENT area_coefficient;
	vector<AREA_COEFFICIENT> area_vector;
	AreaIncreasing areaIncreasing;

	int iterator_times = initial_rectangle_num - input_argument.point_dimension;
	int iterator_length = initial_rectangle_num;

	for (int array_id = 0; array_id < initial_rectangle_num; array_id++) {//get area of pairwise points
		area_coefficient.right_endpoint = array_id * 2 + 1;
		//area_coefficient.rectangle_width = 1;
		area_coefficient.heightest_value = max(original_time_series[array_id * 2], original_time_series[array_id * 2 + 1]);
		area_coefficient.lowest_value = min(original_time_series[array_id * 2], original_time_series[array_id * 2 + 1]);

		if (original_time_series[array_id * 2 + 1] >= original_time_series[array_id * 2]) {
			area_coefficient.heightest_id = array_id * 2 + 1;
			area_coefficient.lowest_id = array_id * 2;
		}
		else {
			area_coefficient.heightest_id = array_id * 2;
			area_coefficient.lowest_id = array_id * 2 + 1;
		}

		area_coefficient.rectangle_area = (area_coefficient.heightest_value - area_coefficient.lowest_value);
		area_vector.push_back(area_coefficient);
	}

	////////////////////////////////////////////////////////////////////////////
	while (area_vector.size() > input_argument.point_dimension) {//Find brakpoint
		for (int vector_id = 1; vector_id < area_vector.size() - 1; vector_id += 2) {
			compareMiniMaxDist(area_vector, vector_id);//********************
		}
		cout << "size: " << area_vector.size() << endl;
		for (auto&& i : area_vector) {
			cout << i.right_endpoint << " ";
		}
		cout << endl;
		for (auto&& i : area_vector) {
			cout << i.lowest_id << " ";
		}
		cout << endl;
		for (auto&& i : area_vector) {
			cout << i.heightest_id << " ";
		}
		cout << endl;
	}

	cout << "size: " << area_vector.size() << endl;
	cout << "right end point: ";

	for (auto&& i : area_vector) {
		cout << i.right_endpoint << " ";
	}
}

//************************************
// Method:getAPLAArea3
// Qualifier:181211 try initialRecArea() and compareAreaPercentageMinMaxDist()
// date:181211
// author:
//************************************
TEMPLATE
void APLA::getAPLAArea3(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series) {
	assert(input_argument.time_series_length % 2 == 0);//n is even
	int array_id = 0;
	vector<AREA_COEFFICIENT> area_vector;
	vector<AREA_COEFFICIENT> temp_area_vector(input_argument.point_dimension);
	vector<AREA_COEFFICIENT> insert_area_rec;
	AREA_COEFFICIENT insert_temp;

	AreaIncreasing area_increase;//get min value
	ParallelogramHeightIncrease height_increase;//190114
	WidthIncreasing width_increase;//190104
	DensityIncrease density_increase;//190313
	DeviationIncreasing deviation_increase;//190115
	Width_Divide_Radius_Increase width_divide_radius_increase;//190315

	//initial
	initialRecArea(input_argument, original_time_series, area_vector);//181211
	/*for (auto&&i : area_vector) {
		assert(i.rectangle_area != NULL);
	}*/

	//compare and merge
	TOOL::recordStartTime(TOOL::time_record[0]);//compare percentage time
	while (area_vector.size() > input_argument.point_dimension) {
		//for (int vector_id = 1; vector_id < area_vector.size() && area_vector.size() > input_argument.point_dimension; vector_id += 1) {
			//if (vector_id == area_vector.size()-1) vector_id = area_vector.size() - 2;
			//cout << "vector_id: " << vector_id<<endl;// << " vector size: " << area_vector.size() << endl;
			//compareAreaPercentageMinMaxDist(area_vector, vector_id, original_time_series);//181211
			//compareAreaPercentageMinMaxDistNoMove(area_vector, vector_id, original_time_series);//181211
			//compareAreaPercentage(area_vector, vector_id, original_time_series);//**********************
			//compareAreaPercentage0(area_vector, vector_id);
		//}
		/*for (auto&&i : area_vector) {
			assert(i.rectangle_area != NULL);
		}*/

		/*--------------------------------Choosing minimum segment id---------------------------*/
		int min_area_id = INF;
		//min_area_id = minmax_element(area_vector.begin(), area_vector.end(), height_increase).first - area_vector.begin();
		//min_area_id = minmax_element(area_vector.begin(), area_vector.end(), area_increase).first - area_vector.begin();
		//min_area_id = minmax_element(area_vector.begin(), area_vector.end(), width_divide_radius_increase).second - area_vector.begin();
		min_area_id = minmax_element(area_vector.begin(), area_vector.end(), density_increase).second - area_vector.begin();
		/*___________________________________________________________________________________*/

		/*----------------------------------Merge segment-----------------------------------*/
		//cout<<"Min ID: " << min_area_id << endl;
		compareAreaPercentageMinMaxDist(area_vector, min_area_id, original_time_series);
		/*___________________________________________________________________________________*/

		/*----------------------------Choosing maximum segment id to Split---------------------------*/
		int max_area_id = minmax_element(area_vector.begin(), area_vector.end(), density_increase).first - area_vector.begin();
		//auto[min, max] = minmax_element(area_vector.begin(), area_vector.end(), density_increase);
		//cout << "min: " << min->segment_density<<" max: "<< max->segment_density<<endl;
		if (isSymmetry(area_vector[max_area_id], original_time_series))
			//moveRecEndpoint(area_vector, max_area_id, original_time_series);
			moveRectagnleEndpoint(original_time_series, area_vector, max_area_id);
		/*____________________________________________________________________________________________*/

		/*for (auto&& i : area_vector) {
			cout << i.rectangle_width << " ";
		}
		cout << endl;
		cout << "rec_area: ";
		for (auto&& i : area_vector) {
			cout << i.rectangle_area << " ";
		}
		cout << endl;
		for (auto&& i : area_vector) {
			cout << i.merge_count << " ";
		}
		cout << endl;
		for (auto&& i : area_vector) {
			cout << i.area_density << " ";
		}
		cout << endl;*/
		//cout << "size: " << area_vector.size() << endl;
	}

	output_argument.run_time = TOOL::recordFinishTime(TOOL::time_record[0]);
	//cout << "APLA0 Time: " << output_argument.run_time << endl;// compare percentage time

	/*cout << "vector size: " << area_vector.size() << endl;
	assert(area_vector.size() == input_argument.point_dimension);

	array_id = 0;
	cout << "parallelogram_height: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.parallelogram_height << ", ";
		array_id++;
	}
	cout << endl;
	array_id = 0;
	cout << "rectangle_width: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.rectangle_width << ", ";
		array_id++;
	}
	cout << endl;*/

	/*int min_width_id = minmax_element(area_vector.begin(), area_vector.end(), density_increase).first - area_vector.begin();
	cout <<"merge id: " << min_width_id << endl;
	compareAreaPercentageMinMaxDist(area_vector, min_width_id, original_time_series);*/
	//cout <<"vector size: " <<area_vector.size() << endl;

	/***********************************Split the maximum parallelogram_height rectangle id*********************************/
	//int max_width_id = minmax_element(area_vector.begin(), area_vector.end(), density_increase).second - area_vector.begin();
	//cout <<"split id: " <<max_width_id << endl;
	//splitRectangle( original_time_series, area_vector, max_width_id);
	//cout << "vector size: " << area_vector.size() << endl;
	/***************************************************************************************************/

	/*cout << "right end point: ";
	for (auto&& i : area_vector) {
		cout << i.right_endpoint << " ";
	}*/

	//*********************************************write result********************************************
	double* temp_endpoint = new double[area_vector.size()];
	array_id = 0;
	for (auto&& i : area_vector) {
		temp_endpoint[array_id] = i.right_endpoint;
		array_id++;
	}
	TOOL::writeSingleResult("./200706AllAPLAEvaluation/APLAEndPoint181218", temp_endpoint, area_vector.size());

	array_id = 0;
	for (auto&& i : area_vector) {
		temp_endpoint[array_id] = i.min_point.id;
		array_id++;
	}
	TOOL::writeSingleResult("APLAMinId181221", temp_endpoint, area_vector.size());

	array_id = 0;
	for (auto&& i : area_vector) {
		temp_endpoint[array_id] = i.max_point.id;
		array_id++;
	}
	TOOL::writeSingleResult("APLAMaxId181221", temp_endpoint, area_vector.size());
	TOOL::deleteArray(temp_endpoint);
	//********************************************************************************

	//************************************************************Print vector result
	//cout << "Finish! \n size: " << area_vector.size() << endl;
	/*cout << "right end point: ";
	for (auto&& i : area_vector) {
		cout << i.right_endpoint << " ";
	}
	cout << endl << "Min: ";
	for (auto&& i : area_vector) {
		cout << i.min_point.id << " ";
	}
	cout << endl << "Max: ";
	for (auto&& i : area_vector) {
		cout << i.max_point.id << " ";
	}
	cout << endl << "Area: ";
	for (auto&& i : area_vector) {
		cout << i.rectangle_area << " ";
	}
	cout << endl;*/
	//***************************************************************************

	/*========================Reconstruction====================================*/
	getAPLA(input_argument, original_time_series, area_vector);
	/*..........................................................................*/

	/*array_id = 0;
	cout << "APLA deviation: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.rec_deviation << ", ";
		array_id++;
	}
	cout << endl;
	array_id = 0;
	cout << "parallelogram_height: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.parallelogram_height << ", ";
		array_id++;
	}
	cout << endl;
	array_id = 0;
	cout << "rectangle_width: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.rectangle_width << ", ";
		array_id++;
	}
	cout << endl;*/
}

//************************************
// Method:etAPLAArea4LogLoop
// Qualifier:190326 try compare with deviation
// date:190326
// author:
//************************************
TEMPLATE
void APLA::getAPLAArea4LogLoop(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series) {//190326 Improve speed. Every loop, merge adjacent segment.
	assert(input_argument.time_series_length % 2 == 0);//n is even
	int array_id = 0;
	vector<AREA_COEFFICIENT> area_vector;
	vector<AREA_COEFFICIENT> temp_area_vector(input_argument.point_dimension);
	vector<AREA_COEFFICIENT> insert_area_rec;
	AREA_COEFFICIENT insert_temp;
	AREA_COEFFICIENT temp_coefficient;

	AreaIncreasing area_increase;//get min value
	ParallelogramHeightIncrease height_increase;//190114
	WidthIncreasing width_increase;//190104
	DensityIncrease density_increase;//190313
	DeviationIncreasing deviation_increase;//190115
	Width_Divide_Radius_Increase width_divide_radius_increase;//190315

	//initial
	initialRecArea(input_argument, original_time_series, area_vector);//181211
	/*for (auto&&i : area_vector) {
		assert(i.rectangle_area != NULL);
	}*/

	//compare and merge
	TOOL::recordStartTime(TOOL::time_record[0]);//compare percentage time
	while (area_vector.size() > input_argument.point_dimension) {
		for (int vector_id = 1; vector_id < area_vector.size() - 1 && area_vector.size() > input_argument.point_dimension; vector_id += 2) {
			//for (int vector_id = 1; vector_id < area_vector.size() && area_vector.size() > input_argument.point_dimension; vector_id += 1) {
				//if (vector_id == area_vector.size()-1) vector_id = area_vector.size() - 2;
				//cout << "vector_id: " << vector_id<<endl;// << " vector size: " << area_vector.size() << endl;
				//compareAreaPercentageMinMaxDist(area_vector, vector_id, original_time_series);//181211
				//compareAreaPercentageMinMaxDistNoMove(area_vector, vector_id, original_time_series);//181211
				//compareAreaPercentage(area_vector, vector_id, original_time_series);//**********************
				//compareAreaPercentage0(area_vector, vector_id);
			//}
			/*for (auto&&i : area_vector) {
				assert(i.rectangle_area != NULL);
			}*/

			/*--------------------------------Choosing minimum segment id---------------------------*/
			int min_area_id = INF;
			min_area_id = minmax_element(area_vector.begin(), area_vector.end(), height_increase).first - area_vector.begin();
			min_area_id = minmax_element(area_vector.begin(), area_vector.end(), area_increase).first - area_vector.begin();
			//min_area_id = minmax_element(area_vector.begin(), area_vector.end(), width_divide_radius_increase).second - area_vector.begin();
			min_area_id = minmax_element(area_vector.begin(), area_vector.end(), density_increase).second - area_vector.begin();
			/*___________________________________________________________________________________*/

			/*----------------------------------Merge segment-----------------------------------*/
			//cout<<"Min ID: " << min_area_id << endl;
			getMergedInfo(original_time_series, area_vector, vector_id, temp_coefficient);
			mergeRectangle2(area_vector, vector_id, temp_coefficient, original_time_series);
			/*___________________________________________________________________________________*/

			/*----------------------------Choosing maximum segment id to Split---------------------------*/
			int max_area_id = minmax_element(area_vector.begin(), area_vector.end(), density_increase).first - area_vector.begin();
			auto [min, max] = minmax_element(area_vector.begin(), area_vector.end(), density_increase);
			//cout << "min: " << min->segment_density<<" max: "<< max->segment_density<<endl;
			if (isSymmetry(area_vector[max_area_id], original_time_series)) {
				//moveRecEndpoint(area_vector, max_area_id, original_time_series);
				//moveRectagnleEndpoint(original_time_series, area_vector, max_area_id);
				//cout <<"2 max_id: " <<max_area_id<<" right_end_point: "<< area_vector[max_area_id].right_endpoint << endl;
				cout << "Split!!!!!!!!!!!!!!!!!" << endl;
				//moveRectagnleSplitpoint(original_time_series, area_vector, max_area_id);
				splitRectangle(original_time_series, area_vector, max_area_id);
			}
			/*____________________________________________________________________________________________*/
		}

		/*for (auto&& i : area_vector) {
			cout << i.rectangle_width << " ";
		}
		cout << endl;
		cout << "rec_area: ";
		for (auto&& i : area_vector) {
			cout << i.rectangle_area << " ";
		}
		cout << endl;
		for (auto&& i : area_vector) {
			cout << i.merge_count << " ";
		}
		cout << endl;
		for (auto&& i : area_vector) {
			cout << i.area_density << " ";
		}
		cout << endl;*/
		//cout << "size: " << area_vector.size() << endl;
	}

	cout << "vector size: " << area_vector.size() << endl;
	assert(area_vector.size() == input_argument.point_dimension);

	array_id = 0;
	cout << "parallelogram_height: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.parallelogram_height << ", ";
		array_id++;
	}
	cout << endl;
	array_id = 0;
	cout << "rectangle_width: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.rectangle_width << ", ";
		array_id++;
	}
	cout << endl;

	/*int min_width_id = minmax_element(area_vector.begin(), area_vector.end(), density_increase).first - area_vector.begin();
	cout <<"merge id: " << min_width_id << endl;
	compareAreaPercentageMinMaxDist(area_vector, min_width_id, original_time_series);*/
	//cout <<"vector size: " <<area_vector.size() << endl;

	/***********************************Split the maximum parallelogram_height rectangle id*********************************/
	//int max_width_id = minmax_element(area_vector.begin(), area_vector.end(), density_increase).second - area_vector.begin();
	//cout <<"split id: " <<max_width_id << endl;
	//splitRectangle( original_time_series, area_vector, max_width_id);
	//cout << "vector size: " << area_vector.size() << endl;
	/***************************************************************************************************/

	assert(area_vector.size() == input_argument.point_dimension);
	cout << "Time: " << TOOL::recordFinishTime(TOOL::time_record[0]) << endl;// compare percentage time

	/*cout << "right end point: ";
	for (auto&& i : area_vector) {
		cout << i.right_endpoint << " ";
	}*/

	//*********************************************write result
	double* temp_endpoint = new double[area_vector.size()];
	array_id = 0;
	for (auto&& i : area_vector) {
		temp_endpoint[array_id] = i.right_endpoint;
		array_id++;
	}
	TOOL::writeSingleResult("./200706AllAPLAEvaluation/APLAEndPoint181218", temp_endpoint, area_vector.size());

	array_id = 0;
	for (auto&& i : area_vector) {
		temp_endpoint[array_id] = i.min_point.id;
		array_id++;
	}
	TOOL::writeSingleResult("APLAMinId181221", temp_endpoint, area_vector.size());

	array_id = 0;
	for (auto&& i : area_vector) {
		temp_endpoint[array_id] = i.max_point.id;
		array_id++;
	}
	TOOL::writeSingleResult("APLAMaxId181221", temp_endpoint, area_vector.size());
	TOOL::deleteArray(temp_endpoint);
	//********************************************************************************

	//************************************************************Print vector result
	//cout << "Finish! \n size: " << area_vector.size() << endl;
	cout << "right end point: ";
	for (auto&& i : area_vector) {
		cout << i.right_endpoint << " ";
	}
	cout << endl << "Min: ";
	for (auto&& i : area_vector) {
		cout << i.min_point.id << " ";
	}
	cout << endl << "Max: ";
	for (auto&& i : area_vector) {
		cout << i.max_point.id << " ";
	}
	cout << endl << "Area: ";
	for (auto&& i : area_vector) {
		cout << i.rectangle_area << " ";
	}
	cout << endl;
	//***************************************************************************

	/*========================Reconstruction====================================*/
	getAPLA(input_argument, original_time_series, area_vector);
	/*..........................................................................*/

	array_id = 0;
	cout << "APLA deviation: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.rec_deviation << ", ";
		array_id++;
	}
	cout << endl;
	array_id = 0;
	cout << "parallelogram_height: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.parallelogram_height << ", ";
		array_id++;
	}
	cout << endl;
	array_id = 0;
	cout << "rectangle_width: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.rectangle_width << ", ";
		array_id++;
	}
	cout << endl;
}

//************************************
// Method:getAPLAArea5LowerBound
// Qualifier:190327 try compare with deviation
// date:190327
// author:
//************************************
TEMPLATE
void APLA::getAPLAArea5LowerBound(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series) {
#ifdef _DEBUG
	assert(input_argument.time_series_length % 2 == 0);//n is even
#endif

	int array_id = 0;
	long double lower_bound_density = INF;
	//long double max_density = INF;
	vector<AREA_COEFFICIENT> area_vector;
	//vector<AREA_COEFFICIENT> temp_area_vector(input_argument.point_dimension);
	//vector<AREA_COEFFICIENT> insert_area_rec;
	//AREA_COEFFICIENT insert_temp;
	AREA_COEFFICIENT temp_coefficient;
	//priority_queue<AREA_COEFFICIENT, vector<AREA_COEFFICIENT>, DensityIncrease > up_lower_bound_density_queue;//190328
	//priority_queue<double, std::vector<double>,std::greater<double>> up_lower_bound_density_queue;//190328
	priority_queue<double> up_lower_bound_density_queue;//190328
	priority_queue<double*> pointer_up_lower_bound_density_queue;
	//priority_queue<double> down_lower_bound_density_queue;//190328
	std::set<double> density_max_set;//190328
	//priority_queue<AREA_COEFFICIENT*, vector<AREA_COEFFICIENT*>, DensityIncrease_Pointer > up_lower_bound_density_queue;

	//AreaIncreasing area_increase;//get min value
	//ParallelogramHeightIncrease height_increase;//190114
	//WidthIncreasing width_increase;//190104
	DensityIncrease density_increase;//190313
	//DeviationIncreasing deviation_increase;//190115
	//Width_Divide_Radius_Increase width_divide_radius_increase;//190315

	//initial
	initialRecArea(input_argument, original_time_series, area_vector);//181211
	auto [min, max] = minmax_element(area_vector.begin(), area_vector.end(), density_increase);
	cout << min->segment_density << " " << max->segment_density << endl;
	lower_bound_density = min->segment_density;

	//cout << "size: " << area_vector.size() << endl;
	//merge
	TOOL::recordStartTime(TOOL::time_record[1]);//compare percentage time
	/*for (auto&& au : area_vector) {
		if (up_lower_bound_density_queue.size() <= input_argument.point_dimension) {
			up_lower_bound_density_queue.push(au.segment_density);
		}
		else if (up_lower_bound_density_queue.top() > au.segment_density) {
			up_lower_bound_density_queue.pop();
			up_lower_bound_density_queue.push(au.segment_density);
		}
	}
	lower_bound_density = up_lower_bound_density_queue.top();*/

	while (area_vector.size() > input_argument.point_dimension) {
		auto original_size = area_vector.size();
		density_max_set.clear();
		for (int vector_id = 1; vector_id < area_vector.size() && area_vector.size() > input_argument.point_dimension; vector_id += 1) {
#if _DEBUG
			cout << "1 current id: " << vector_id << ", vector size: " << area_vector.size() << endl;
#endif

			//for (int vector_id = 1; vector_id < area_vector.size() && area_vector.size() > input_argument.point_dimension; vector_id += 1) {
				//if (vector_id == area_vector.size()-1) vector_id = area_vector.size() - 2;
				//cout << "vector_id: " << vector_id<<endl;// << " vector size: " << area_vector.size() << endl;
				//compareAreaPercentageMinMaxDist(area_vector, vector_id, original_time_series);//181211
				//compareAreaPercentageMinMaxDistNoMove(area_vector, vector_id, original_time_series);//181211
				//compareAreaPercentage(area_vector, vector_id, original_time_series);//**********************
				//compareAreaPercentage0(area_vector, vector_id);
			//}
			/*for (auto&&i : area_vector) {
				assert(i.rectangle_area != NULL);
			}*/

			/*--------------------------------Choosing minimum segment id---------------------------*/
			//int min_area_id = INF;
			//min_area_id = minmax_element(area_vector.begin(), area_vector.end(), height_increase).first - area_vector.begin();
			//min_area_id = minmax_element(area_vector.begin(), area_vector.end(), area_increase).first - area_vector.begin();
			////min_area_id = minmax_element(area_vector.begin(), area_vector.end(), width_divide_radius_increase).second - area_vector.begin();
			//min_area_id = minmax_element(area_vector.begin(), area_vector.end(), density_increase).second - area_vector.begin();//get max density segment
			/*___________________________________________________________________________________*/

			/*----------------------------------Merge segment-----------------------------------*/
			//cout<<"Min ID: " << min_area_id << endl;
			//cout << "id: " << vector_id << endl;

			getMergedInfo(original_time_series, area_vector, vector_id, temp_coefficient);
			if (temp_coefficient.segment_density > lower_bound_density) {
#if _DEBUG
				cout << "2 pre merge id: " << vector_id << endl;
#endif
				mergeRectangle2(area_vector, vector_id, temp_coefficient, original_time_series);
#if _DEBUG
				cout << "3 after merge id: " << vector_id << " " << temp_coefficient.right_endpoint << endl;
#endif
				vector_id++;

				/*if (up_lower_bound_density_queue.size() < input_argument.point_dimension) {
					up_lower_bound_density_queue.push(temp_coefficient.segment_density);
				}
				else if (up_lower_bound_density_queue.top() > temp_coefficient.segment_density) {
					up_lower_bound_density_queue.pop();
					up_lower_bound_density_queue.push(temp_coefficient.segment_density);
				}*/
				if (!up_lower_bound_density_queue.empty())
					if (up_lower_bound_density_queue.top() > temp_coefficient.segment_density) {
						up_lower_bound_density_queue.pop();
						up_lower_bound_density_queue.push(temp_coefficient.segment_density);
					}
			}
			else {
				density_max_set.insert(temp_coefficient.segment_density);
			}

			/*for (auto&& i : area_vector) {
				cout << i.segment_density << " ";
			}
			cout << endl;*/

			//cout << "			size: " << area_vector.size()<<" id: "<< vector_id <<" right end point: "<< area_vector[vector_id].right_endpoint << endl;
			/*___________________________________________________________________________________*/

			/*----------------------------Choosing maximum segment id to Split---------------------------*/
			int min_density_id = minmax_element(area_vector.begin(), area_vector.end(), density_increase).first - area_vector.begin();//get min density segment
			//auto[min, max] = minmax_element(area_vector.begin(), area_vector.end(), density_increase);
			//cout << "min: " << min->segment_density<<" max: "<< max->segment_density<<endl;
//			if (isSymmetry(area_vector[min_density_id], original_time_series)) {
//				//assert(area_vector[max_area_id].segment_density> up_lower_bound_density_queue.top()&& area_vector[max_area_id].segment_density > lower_bound_density);
//				//moveRecEndpoint(area_vector, max_area_id, original_time_series);
//				//moveRectagnleEndpoint(original_time_series, area_vector, max_area_id);
//
//				//cout <<"2 max_id: " <<max_area_id<<" right_end_point: "<< area_vector[max_area_id].right_endpoint << endl;
//				//cout << "			Split!!!!!!!!!!!!!!!!!" << endl;
//				//moveRectagnleSplitpoint(original_time_series, area_vector, max_area_id);
//#if _DEBUG
//				cout << "4 before split  queue size: " << up_lower_bound_density_queue.size() << " id:" << min_density_id << endl;
//#endif
//				splitRectangle(original_time_series, area_vector, min_density_id);
//#if _DEBUG
//				cout << "5 after split  queue size: " << up_lower_bound_density_queue.size()<<" id:"<< min_density_id << endl;
//#endif
//				if (!up_lower_bound_density_queue.empty()) {
//					if (area_vector[min_density_id].segment_density < up_lower_bound_density_queue.top()) {
//#if _DEBUG
//						cout << "6 max_area_id Smaller density: " << area_vector[min_density_id].segment_density << endl;
//#endif
//						up_lower_bound_density_queue.pop();
//						up_lower_bound_density_queue.push(area_vector[min_density_id].segment_density);
//					}
//
//					if (area_vector[min_density_id + 1].segment_density < up_lower_bound_density_queue.top()) {
//#if _DEBUG
//						cout << "7 max_area_id+1 Smaller density: " << area_vector[min_density_id+1].segment_density << endl;
//#endif
//						up_lower_bound_density_queue.pop();
//						up_lower_bound_density_queue.push(area_vector[min_density_id + 1].segment_density);
//					}
//				}
//
//				if (area_vector[min_density_id].segment_density < lower_bound_density) {
//					density_max_set.insert(area_vector[min_density_id].segment_density);
//				}
//				if (area_vector[min_density_id + 1].segment_density < lower_bound_density) {
//					density_max_set.insert(area_vector[min_density_id + 1].segment_density);
//				}
//
//
//				//vector_id= max_area_id + 1;
//			}
//			/*____________________________________________________________________________________________*/
		}

		if (!up_lower_bound_density_queue.empty()) {
			lower_bound_density = up_lower_bound_density_queue.top();
			//up_lower_bound_density_queue.pop();
#if _DEBUG
			cout << "8 queue size: " << up_lower_bound_density_queue.size() << endl;
#endif
		}

		/*if (original_size == area_vector.size()) {
			cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << endl;
			lower_bound_density = *(density_max_set.cbegin());
		}*/
		if (original_size <= area_vector.size() || area_vector.size() <= density_max_set.size() + 1) {
			//assert(area_vector.size() == density_max_set.size() + 1);
			//cout << "*********************************************" << endl;
			if (!up_lower_bound_density_queue.empty()) {
				up_lower_bound_density_queue.pop();
				//lower_bound_density = up_lower_bound_density_queue.top();
			}
			else {
				//cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << endl;
				lower_bound_density = *(density_max_set.cbegin());
				for (auto it = density_max_set.rbegin(); up_lower_bound_density_queue.size() <= input_argument.point_dimension && it != density_max_set.rend(); ++it) {
					up_lower_bound_density_queue.push(*it);
				}
			}
		}

#if _DEBUG
		auto [min, max] = minmax_element(area_vector.begin(), area_vector.end(), density_increase);
		cout << lower_bound_density << " " << min->segment_density << " " << max->segment_density << endl;
		cout << " 9 vector old size: " << original_size << " vector new size: " << area_vector.size() << " queue size: " << up_lower_bound_density_queue.size() << " set size: " << density_max_set.size() << endl;
#endif
		//auto[min, max] = minmax_element(area_vector.begin(), area_vector.end(), density_increase);
		//cout << lower_bound_density <<" "<<min->segment_density << " " << max->segment_density << endl;
		//lower_bound_density = max->segment_density;

		/*for (auto&& i : area_vector) {
			cout << i.rectangle_width << " ";
		}
		cout << endl;
		cout << "rec_area: ";
		for (auto&& i : area_vector) {
			cout << i.rectangle_area << " ";
		}
		cout << endl;
		for (auto&& i : area_vector) {
			cout << i.merge_count << " ";
		}
		cout << endl;
		for (auto&& i : area_vector) {
			cout << i.area_density << " ";
		}
		cout << endl;*/
		//cout << "size: " << area_vector.size() << endl;
	}

	output_argument.run_time = TOOL::recordFinishTime(TOOL::time_record[1]);
	//cout << "APLA running Time: " << output_argument.run_time << endl;// compare percentage time
	//cout << "vector size: " << area_vector.size() << endl;
	assert(area_vector.size() == input_argument.point_dimension);

	array_id = 0;
	cout << "parallelogram_height: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.parallelogram_height << ", ";
		array_id++;
	}
	cout << endl;
	array_id = 0;
	cout << "rectangle_width: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.rectangle_width << ", ";
		array_id++;
	}
	cout << endl;

	/*int min_width_id = minmax_element(area_vector.begin(), area_vector.end(), density_increase).first - area_vector.begin();
	cout <<"merge id: " << min_width_id << endl;
	compareAreaPercentageMinMaxDist(area_vector, min_width_id, original_time_series);*/
	//cout <<"vector size: " <<area_vector.size() << endl;

	/***********************************Split the maximum parallelogram_height rectangle id*********************************/
	//int max_width_id = minmax_element(area_vector.begin(), area_vector.end(), density_increase).second - area_vector.begin();
	//cout <<"split id: " <<max_width_id << endl;
	//splitRectangle( original_time_series, area_vector, max_width_id);
	//cout << "vector size: " << area_vector.size() << endl;
	/***************************************************************************************************/

	assert(area_vector.size() == input_argument.point_dimension);

	/*cout << "right end point: ";
	for (auto&& i : area_vector) {
		cout << i.right_endpoint << " ";
	}*/

	//*********************************************write result
	double* temp_endpoint = new double[area_vector.size()];
	array_id = 0;
	for (auto&& i : area_vector) {
		temp_endpoint[array_id] = i.right_endpoint;
		array_id++;
	}
	TOOL::writeSingleResult("./200706AllAPLAEvaluation/APLAEndPoint181218", temp_endpoint, area_vector.size());

	array_id = 0;
	for (auto&& i : area_vector) {
		temp_endpoint[array_id] = i.min_point.id;
		array_id++;
	}
	TOOL::writeSingleResult("APLAMinId181221", temp_endpoint, area_vector.size());

	array_id = 0;
	for (auto&& i : area_vector) {
		temp_endpoint[array_id] = i.max_point.id;
		array_id++;
	}
	TOOL::writeSingleResult("APLAMaxId181221", temp_endpoint, area_vector.size());
	TOOL::deleteArray(temp_endpoint);
	//********************************************************************************

	//************************************************************Print vector result
	//cout << "Finish! \n size: " << area_vector.size() << endl;
	cout << "right end point: ";
	for (auto&& i : area_vector) {
		cout << i.right_endpoint << " ";
	}
	cout << endl << "Min: ";
	for (auto&& i : area_vector) {
		cout << i.min_point.id << " ";
	}
	cout << endl << "Max: ";
	for (auto&& i : area_vector) {
		cout << i.max_point.id << " ";
	}
	cout << endl << "Area: ";
	for (auto&& i : area_vector) {
		cout << i.rectangle_area << " ";
	}
	cout << endl;
	//***************************************************************************

	/*========================Reconstruction====================================*/
	getAPLA(input_argument, original_time_series, area_vector);
	/*..........................................................................*/

	array_id = 0;
	cout << "APLA deviation: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.rec_deviation << ", ";
		array_id++;
	}
	cout << endl;
	array_id = 0;
	cout << "parallelogram_height: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.parallelogram_height << ", ";
		array_id++;
	}
	cout << endl;
	array_id = 0;
	cout << "rectangle_width: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.rectangle_width << ", ";
		array_id++;
	}
	cout << endl;
}

//************************************
// Method:getAPLAArea5LowerBoundSpeed
// Qualifier:190404 Speed up above algorithm
// date:190404
// author:
//************************************
TEMPLATE
void APLA::getAPLAArea5LowerBoundSpeed(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series) {//190404 Speed up above algorithm
#ifdef _DEBUG
	assert(input_argument.time_series_length % 2 == 0);//n is even
#endif

	/*===================time & count====================*/
	double loop_time = NULL;
	double time1 = NULL;
	double time2 = NULL;
	double time3 = NULL;
	double time4 = NULL;
	double time5 = 0;
	double time6 = 0;
	double time7 = 0;
	double time8 = 0;

	int while_count = 0;
	int for_count = 0;
	/*...................................................*/

	int segment_number = 2;
	int array_id = 0;
	long double lower_bound_density = INF;
	//long double max_density = INF;
	vector<AREA_COEFFICIENT> area_vector;

	//vector<AREA_COEFFICIENT> temp_area_vector(input_argument.point_dimension);
	//vector<AREA_COEFFICIENT> insert_area_rec;
	//AREA_COEFFICIENT insert_temp;
	AREA_COEFFICIENT temp_coefficient;
	//priority_queue<AREA_COEFFICIENT, vector<AREA_COEFFICIENT>, DensityIncrease > up_lower_bound_density_queue;//190328
	//priority_queue<double, std::vector<double>,std::greater<double>> up_lower_bound_density_queue;//190328
	priority_queue<double> up_lower_bound_density_queue;//190328
	priority_queue<double*> pointer_up_lower_bound_density_queue;
	//priority_queue<double> down_lower_bound_density_queue;//190328
	std::set<double> density_max_set;//190328
	//priority_queue<AREA_COEFFICIENT*, vector<AREA_COEFFICIENT*>, DensityIncrease_Pointer > up_lower_bound_density_queue;

	//AreaIncreasing area_increase;//get min value
	//ParallelogramHeightIncrease height_increase;//190114
	//WidthIncreasing width_increase;//190104
	DensityIncrease density_increase;//190313
	//DeviationIncreasing deviation_increase;//190115
	//Width_Divide_Radius_Increase width_divide_radius_increase;//190315

	//initial
	//initialRecArea(input_argument, original_time_series, area_vector);//181211
	initialRecArea0ForParallelogram(input_argument, original_time_series, area_vector);//190404
	//auto[min, max] = minmax_element(area_vector.begin(), area_vector.end(), density_increase);
	//cout << min->segment_density << " " << max->segment_density << endl;
	//lower_bound_density = min->segment_density;
	lower_bound_density = output_argument.min_density_segment.value;
	output_argument.min_density_segment.id;

	//cout << "size: " << area_vector.size() << endl;
	//merge
	TOOL::recordStartTime(TOOL::time_record[1]);//compare percentage time
	/*for (auto&& au : area_vector) {
		if (up_lower_bound_density_queue.size() <= input_argument.point_dimension) {
			up_lower_bound_density_queue.push(au.segment_density);
		}
		else if (up_lower_bound_density_queue.top() > au.segment_density) {
			up_lower_bound_density_queue.pop();
			up_lower_bound_density_queue.push(au.segment_density);
		}
	}
	lower_bound_density = up_lower_bound_density_queue.top();*/

	/*===========================================Loop==========================================================================*/
	while (area_vector.size() > input_argument.point_dimension) {
		while_count++;
		auto original_size = area_vector.size();
		density_max_set.clear();
		TOOL::recordStartTime(TOOL::time_record[10]);
		for (int vector_id = 1; vector_id < area_vector.size() && area_vector.size() > input_argument.point_dimension; vector_id += 1) {
			for_count++;
#if _DEBUG
			//cout << "1 current id: " << vector_id << ", vector size: " << area_vector.size() << endl;
#endif

			//for (int vector_id = 1; vector_id < area_vector.size() && area_vector.size() > input_argument.point_dimension; vector_id += 1) {
				//if (vector_id == area_vector.size()-1) vector_id = area_vector.size() - 2;
				//cout << "vector_id: " << vector_id<<endl;// << " vector size: " << area_vector.size() << endl;
				//compareAreaPercentageMinMaxDist(area_vector, vector_id, original_time_series);//181211
				//compareAreaPercentageMinMaxDistNoMove(area_vector, vector_id, original_time_series);//181211
				//compareAreaPercentage(area_vector, vector_id, original_time_series);//**********************
				//compareAreaPercentage0(area_vector, vector_id);
			//}
			/*for (auto&&i : area_vector) {
				assert(i.rectangle_area != NULL);
			}*/

			/*--------------------------------Choosing minimum segment id---------------------------*/
			//int min_area_id = INF;
			//min_area_id = minmax_element(area_vector.begin(), area_vector.end(), height_increase).first - area_vector.begin();
			//min_area_id = minmax_element(area_vector.begin(), area_vector.end(), area_increase).first - area_vector.begin();
			////min_area_id = minmax_element(area_vector.begin(), area_vector.end(), width_divide_radius_increase).second - area_vector.begin();
			//min_area_id = minmax_element(area_vector.begin(), area_vector.end(), density_increase).second - area_vector.begin();//get max density segment
			/*___________________________________________________________________________________*/

			/*----------------------------------Merge segment-----------------------------------*/
			//cout<<"Min ID: " << min_area_id << endl;
			//cout << "id: " << vector_id << endl;

			//getMergedInfo(original_time_series, area_vector, vector_id, temp_coefficient);
			TOOL::recordStartTime(TOOL::time_record[11]);
			AREA_COEFFICIENT test_coefficient;
			getMergedInfor0ForParallelogram(original_time_series, area_vector, vector_id, segment_number, temp_coefficient);
			time3 += TOOL::recordFinishTime(TOOL::time_record[11]);
			/*assert(temp_coefficient.right_endpoint== test_coefficient.right_endpoint);
			assert(temp_coefficient.rectangle_width == test_coefficient.rectangle_width);
			assert(temp_coefficient.apla.a == test_coefficient.apla.a);
			assert(temp_coefficient.apla.b == test_coefficient.apla.b);
			assert(temp_coefficient.deviation_point.id == test_coefficient.deviation_point.id);
			assert(temp_coefficient.parallelogram_height == test_coefficient.parallelogram_height);
			assert(temp_coefficient.rectangle_area == test_coefficient.rectangle_area);
			assert(temp_coefficient.segment_density == test_coefficient.segment_density);*/
			//assert(deviation_point.value == compared_segment.deviation_point.value);
			//assert(temp_coefficient.rec_deviation == test_coefficient.rec_deviation);

			TOOL::recordStartTime(TOOL::time_record[12]);

			if (temp_coefficient.segment_density > lower_bound_density) {
#if _DEBUG
				//cout << "2 pre merge id: " << vector_id << endl;
#endif
				//mergeRectangle2(area_vector, vector_id, temp_coefficient, original_time_series);
				TOOL::recordStartTime(TOOL::time_record[14]);
				//mergeRectangle0ForParallelogram(area_vector, vector_id, temp_coefficient, original_time_series);

				int left_id = vector_id - 1;
				vector<AREA_COEFFICIENT> temp_vector{ temp_coefficient };
				//vector<AREA_COEFFICIENT> temp_copy(area_vector.size()- vector_id);

				/*----------------------------------------------------------*Megrge Process*------------------------------------------------------------*/
				TOOL::recordStartTime(TOOL::time_record[15]);
				area_vector[vector_id] = temp_vector.front();// .at(0);
				time5 += TOOL::recordFinishTime(TOOL::time_record[15]);
				TOOL::recordStartTime(TOOL::time_record[16]);
				/*copy(area_vector.begin()+ vector_id, area_vector.end(), temp_copy.begin());
				temp_copy.front() = temp_vector.front();
				area_vector.pop_back();
				copy_backward(temp_copy.begin(), temp_copy.end(), area_vector.end());
*/
//area_vector[left_id] = std::move(area_vector.back());
//area_vector.pop_back();
				area_vector.erase(area_vector.begin() + left_id);
				/*std::copy_n(area_vector.begin()+ left_id, area_vector.end());
				area_vector.pop_back();
				std::reverse(area_vector.begin() + left_id, area_vector.end());*/
				time6 += TOOL::recordFinishTime(TOOL::time_record[16]);
				left_id--;
				vector_id--;

				time4 += TOOL::recordFinishTime(TOOL::time_record[14]);
#if _DEBUG
				//cout << "3 after merge id: " << vector_id << " " << temp_coefficient.right_endpoint << endl;
#endif
				TOOL::recordStartTime(TOOL::time_record[17]);
				vector_id++;

				/*if (up_lower_bound_density_queue.size() < input_argument.point_dimension) {
					up_lower_bound_density_queue.push(temp_coefficient.segment_density);
				}
				else if (up_lower_bound_density_queue.top() > temp_coefficient.segment_density) {
					up_lower_bound_density_queue.pop();
					up_lower_bound_density_queue.push(temp_coefficient.segment_density);
				}*/
				if (!up_lower_bound_density_queue.empty()) {
					if (up_lower_bound_density_queue.top() > temp_coefficient.segment_density) {
						up_lower_bound_density_queue.pop();
						up_lower_bound_density_queue.push(temp_coefficient.segment_density);
					}
				}

				time7 += TOOL::recordFinishTime(TOOL::time_record[17]);
			}
			else {
				TOOL::recordStartTime(TOOL::time_record[18]);
				density_max_set.insert(temp_coefficient.segment_density);
				time8 += TOOL::recordFinishTime(TOOL::time_record[18]);
			}
			time1 += TOOL::recordFinishTime(TOOL::time_record[12]);

			/*for (auto&& i : area_vector) {
				cout << i.segment_density << " ";
			}
			cout << endl;*/

			//cout << "			size: " << area_vector.size()<<" id: "<< vector_id <<" right end point: "<< area_vector[vector_id].right_endpoint << endl;
			/*___________________________________________________________________________________*/

			/*===========================================Split Segment==========================================================================*/

//			int min_density_id = minmax_element(area_vector.begin(), area_vector.end(), density_increase).first - area_vector.begin();//get min density segment
//			//auto[min, max] = minmax_element(area_vector.begin(), area_vector.end(), density_increase);
//			//cout << "min: " << min->segment_density<<" max: "<< max->segment_density<<endl;
//			if (isSymmetry(area_vector[vector_id], original_time_series)) {
//				//assert(area_vector[max_area_id].segment_density> up_lower_bound_density_queue.top()&& area_vector[max_area_id].segment_density > lower_bound_density);
//				//moveRecEndpoint(area_vector, max_area_id, original_time_series);
//				//moveRectagnleEndpoint(original_time_series, area_vector, max_area_id);
//
//				//cout <<"2 max_id: " <<max_area_id<<" right_end_point: "<< area_vector[max_area_id].right_endpoint << endl;
//				//cout << "			Split!!!!!!!!!!!!!!!!!" << endl;
//				//moveRectagnleSplitpoint(original_time_series, area_vector, max_area_id);
//#if _DEBUG
//				cout << "4 before split  queue size: " << up_lower_bound_density_queue.size() << " id:" << vector_id << endl;
//#endif
//				splitRectangle(original_time_series, area_vector, vector_id);
//#if _DEBUG
//				cout << "5 after split  queue size: " << up_lower_bound_density_queue.size() << " id:" << vector_id << endl;
//#endif
//				if (!up_lower_bound_density_queue.empty()) {
//					if (area_vector[vector_id].segment_density < up_lower_bound_density_queue.top()) {
//#if _DEBUG
//						cout << "6 max_area_id Smaller density: " << area_vector[vector_id].segment_density << endl;
//#endif
//						up_lower_bound_density_queue.pop();
//						up_lower_bound_density_queue.push(area_vector[vector_id].segment_density);
//					}
//
//					if (area_vector[vector_id + 1].segment_density < up_lower_bound_density_queue.top()) {
//#if _DEBUG
//						cout << "7 max_area_id+1 Smaller density: " << area_vector[vector_id + 1].segment_density << endl;
//#endif
//						up_lower_bound_density_queue.pop();
//						up_lower_bound_density_queue.push(area_vector[vector_id + 1].segment_density);
//					}
//				}
//
//				if (area_vector[vector_id].segment_density < lower_bound_density) {
//					density_max_set.insert(area_vector[vector_id].segment_density);
//				}
//				if (area_vector[vector_id + 1].segment_density < lower_bound_density) {
//					density_max_set.insert(area_vector[vector_id + 1].segment_density);
//				}
//
//
//				//vector_id= max_area_id + 1;
//			}
/*___________________________________________________________________________________________________________________________________*/
		}
		loop_time += TOOL::recordFinishTime(TOOL::time_record[10]);

		TOOL::recordStartTime(TOOL::time_record[13]);
		if (!up_lower_bound_density_queue.empty()) {
			lower_bound_density = up_lower_bound_density_queue.top();
			//up_lower_bound_density_queue.pop();
#if _DEBUG
			cout << "8 queue size: " << up_lower_bound_density_queue.size() << endl;
#endif
		}

		/*if (original_size == area_vector.size()) {
			cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << endl;
			lower_bound_density = *(density_max_set.cbegin());
		}*/
		if (original_size <= area_vector.size() || area_vector.size() <= density_max_set.size() + 1) {
			//assert(area_vector.size() == density_max_set.size() + 1);
			//cout << "*********************************************" << endl;
			if (!up_lower_bound_density_queue.empty()) {
				up_lower_bound_density_queue.pop();
				//lower_bound_density = up_lower_bound_density_queue.top();
			}
			else {
				//cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << endl;
				lower_bound_density = *(density_max_set.cbegin());
				for (auto it = density_max_set.rbegin(); up_lower_bound_density_queue.size() <= 2 && it != density_max_set.rend(); ++it) {
					up_lower_bound_density_queue.push(*it);
				}
			}
		}

		time2 += TOOL::recordFinishTime(TOOL::time_record[13]);

#if _DEBUG
		auto [min, max] = minmax_element(area_vector.begin(), area_vector.end(), density_increase);
		cout << lower_bound_density << " " << min->segment_density << " " << max->segment_density << endl;
		cout << " 9 vector old size: " << original_size << " vector new size: " << area_vector.size() << " queue size: " << up_lower_bound_density_queue.size() << " set size: " << density_max_set.size() << endl;
#endif
		//auto[min, max] = minmax_element(area_vector.begin(), area_vector.end(), density_increase);
		//cout << lower_bound_density <<" "<<min->segment_density << " " << max->segment_density << endl;
		//lower_bound_density = max->segment_density;

		/*for (auto&& i : area_vector) {
			cout << i.rectangle_width << " ";
		}
		cout << endl;
		cout << "rec_area: ";
		for (auto&& i : area_vector) {
			cout << i.rectangle_area << " ";
		}
		cout << endl;
		for (auto&& i : area_vector) {
			cout << i.merge_count << " ";
		}
		cout << endl;
		for (auto&& i : area_vector) {
			cout << i.area_density << " ";
		}
		cout << endl;*/
		//cout << "size: " << area_vector.size() << endl;
	}
	output_argument.run_time = TOOL::recordFinishTime(TOOL::time_record[1]);
	/*...........................................................................................................*/
		//cout << "APLA running Time: " << output_argument.run_time << endl;// compare percentage time
		//cout << "vector size: " << area_vector.size() << endl;
	assert(area_vector.size() == input_argument.point_dimension);

	cout << "<<<<< loop time: " << loop_time << " Merge segmnet time: " << time1 << " Change threshold id time: " << time2 << " mergerd information time: " << time3 << " merge operation: " << time4 << " while count: " << while_count << " for count: " << for_count << " == operation time: " << time5 << " erease time: " << time6 << " merged id time: " << time7 << " not merge time: " << time8 << endl;

	array_id = 0;
	cout << "parallelogram_height: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.parallelogram_height << ", ";
		array_id++;
	}
	cout << endl;
	array_id = 0;
	cout << "rectangle_width: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.rectangle_width << ", ";
		array_id++;
	}
	cout << endl;

	/*int min_width_id = minmax_element(area_vector.begin(), area_vector.end(), density_increase).first - area_vector.begin();
	cout <<"merge id: " << min_width_id << endl;
	compareAreaPercentageMinMaxDist(area_vector, min_width_id, original_time_series);*/
	//cout <<"vector size: " <<area_vector.size() << endl;

	/***********************************Split the maximum parallelogram_height rectangle id*********************************/
	//int max_width_id = minmax_element(area_vector.begin(), area_vector.end(), density_increase).second - area_vector.begin();
	//cout <<"split id: " <<max_width_id << endl;
	//splitRectangle( original_time_series, area_vector, max_width_id);
	//cout << "vector size: " << area_vector.size() << endl;
	/***************************************************************************************************/

	assert(area_vector.size() == input_argument.point_dimension);

	/*cout << "right end point: ";
	for (auto&& i : area_vector) {
		cout << i.right_endpoint << " ";
	}*/

	//*********************************************write result
	double* temp_endpoint = new double[area_vector.size()];
	array_id = 0;
	for (auto&& i : area_vector) {
		temp_endpoint[array_id] = i.right_endpoint;
		array_id++;
	}
	TOOL::writeSingleResult("./200706AllAPLAEvaluation/APLAEndPoint181218", temp_endpoint, area_vector.size());
	//********************************************************************************

	//************************************************************Print vector result
	//cout << "Finish! \n size: " << area_vector.size() << endl;
	cout << "right end point: ";
	for (auto&& i : area_vector) {
		cout << i.right_endpoint << " ";
	}
	cout << endl << "Min: ";
	for (auto&& i : area_vector) {
		cout << i.min_point.id << " ";
	}
	cout << endl << "Max: ";
	for (auto&& i : area_vector) {
		cout << i.max_point.id << " ";
	}
	cout << endl << "Area: ";
	for (auto&& i : area_vector) {
		cout << i.rectangle_area << " ";
	}
	cout << endl;
	cout << "APLA deviation: ";
	array_id = 0;
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.rec_deviation << ", ";
		array_id++;
	}
	//***************************************************************************

	/*========================Reconstruction====================================*/
	getAPLA(input_argument, original_time_series, area_vector);
	/*..........................................................................*/

	array_id = 0;
	cout << "APLA deviation: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.rec_deviation << ", ";
		array_id++;
	}
	cout << endl;
	array_id = 0;
	cout << "parallelogram_height: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.parallelogram_height << ", ";
		array_id++;
	}
	cout << endl;
	array_id = 0;
	cout << "rectangle_width: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.rectangle_width << ", ";
		array_id++;
	}
	cout << endl;
}

//************************************
// Method:getAPLAArea5LowerBoundSpeedNoErase
// Qualifier:190409 Speed up above algorithm
// date:190409
// author:
//************************************
TEMPLATE
void APLA::getAPLAArea5LowerBoundSpeedNoErase(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series) {
#ifdef _DEBUG
	assert(input_argument.time_series_length % 2 == 0);//n is even
#endif
	/*====================Test parameter===========================*/
	vector<int> count_break_point_vector;//190613 11:16
	count_break_point_vector.resize(input_argument.time_series_length, 0);//190613 11:16
	/*.............................................................*/

	/*===================time & count====================*/
	double loop_time = 0;
	double time1 = 0;
	double time2 = 0;
	double time3 = 0;
	double time4 = 0;
	double time5 = 0;
	double time6 = 0;
	double time7 = 0;
	double time8 = 0;
	double time9 = 0;
	double time10 = 0;//update queue time
	double time11 = 0;
	double time12 = 0;
	double time13 = 0;
	double time14 = 0;

	int while_count = 0;
	int for_count = 0;
	/*...................................................*/

	/*===================Test parameter====================*/
	int same_deviation_id_count = 0;//190515
	int diff_deviation_id_count = 0;//190515
	int total_merge_infor_count = 0;
	int deviaiton_min_max_count = 0;
	int deviation_all_count = 0;
	/*...................................................*/

	int segment_number = 2;
	int array_id = 0;
	long double lower_bound_density = INF;
	//long double max_density = INF;
	vector<AREA_COEFFICIENT> area_vector;
	AREA_COEFFICIENT temp_coefficient;

	priority_queue<double> up_lower_bound_density_queue;//190328
	priority_queue<double*> pointer_up_lower_bound_density_queue;
	std::set<double> density_max_set;//190328
	DensityIncrease density_increase;//190313

	area_vector.resize(input_argument.time_series_length / 2, AREA_COEFFICIENT());
	output_argument.min_density_segment.value = INF;
	output_argument.min_density_segment.id = INF;

	//merge
	TOOL::recordStartTime(TOOL::time_record[1]);//compare percentage time
	//initial
	//initialRecArea(input_argument, original_time_series, area_vector);//181211
	/*===================Initial====================*/

	//initialRecArea0ForParallelogram(input_argument, original_time_series, area_vector);//190404
	//initialRecArea0ForParallelogramNoPush(input_argument, original_time_series, area_vector);//190417
#ifdef TIME_H
	TOOL::recordStartTime(TOOL::time_record[19]);//compare percentage time
#endif
	initialRecArea0ForParallelogramArrayVector(input_argument, original_time_series, area_vector);//190430
#ifdef TIME_H
	time9 = TOOL::recordFinishTime(TOOL::time_record[19]);
#endif

	/*...................................................*/
	lower_bound_density = output_argument.min_density_segment.value;
	//output_argument.min_density_segment.id;
#if _DEBUG
	//cout << "initial threshhold: " << lower_bound_density << endl;
#endif
	/*===========================================Loop==========================================================================*/
	while (area_vector.size() > input_argument.point_dimension) {
		int merge_count = 0;//decide when to finish for loop to erase extra vector
		while_count++;
		auto original_size = area_vector.size();
		//density_max_set.clear();
#ifdef TIME_H
		TOOL::recordStartTime(TOOL::time_record[10]);
#endif
		temp_coefficient.segment_magnitude = NULL;
		for (int vector_id = 1; vector_id < area_vector.size() && area_vector.size() > input_argument.point_dimension; vector_id++) {
			for_count++;
#if _DEBUG
			//cout << "1 current id: " << vector_id << ", vector size: " << area_vector.size() << endl;
			//if(up_lower_bound_density_queue.size()>0)
			//cout <<" queue size: " << up_lower_bound_density_queue.size() << " set size: " << density_max_set.size() << endl;
#endif

#ifdef TIME_H
			TOOL::recordStartTime(TOOL::time_record[11]);
#endif
			getMergedInfor0ForParallelogram(original_time_series, area_vector, vector_id, segment_number, temp_coefficient);
#ifdef TIME_H
			time3 += TOOL::recordFinishTime(TOOL::time_record[11]);
#endif
			/*============================================Test section================================================*/
			//if (temp_coefficient.rectangle_width > 4) {
				//area_vector[vector_id - 1].segment_magnitude += fabs(temp_coefficient.apla.a - area_vector[vector_id - 1].apla.a - (area_vector[vector_id].sum_value - area_vector[vector_id - 1].sum_value)/(4* area_vector[vector_id - 1].rectangle_width*area_vector[vector_id - 1].rectangle_width));
				//area_vector[vector_id].segment_magnitude += fabs(temp_coefficient.apla.a - area_vector[vector_id].apla.a - (area_vector[vector_id].sum_value - area_vector[vector_id - 1].sum_value) / (4 * area_vector[vector_id - 1].rectangle_width*area_vector[vector_id - 1].rectangle_width));

				//area_vector[vector_id - 1].segment_magnitude += fabs(temp_coefficient.apla.a - area_vector[vector_id - 1].apla.a);
				//area_vector[vector_id].segment_magnitude += fabs(temp_coefficient.apla.a - area_vector[vector_id].apla.a );
				//temp_coefficient.segment_magnitude += max(area_vector[vector_id - 1].segment_magnitude , area_vector[vector_id].segment_magnitude);
			//}
			//else {
				//area_vector[vector_id - 1].segment_magnitude = INF;
				//area_vector[vector_id].segment_magnitude = INF;
			//}
				//temp_coefficient.left_subsegment = new AREA_COEFFICIENT;
				//temp_coefficient.right_subsegment = new AREA_COEFFICIENT;
				//*temp_coefficient.left_subsegment = area_vector[vector_id - 1];
				//*temp_coefficient.right_subsegment = area_vector[vector_id];

				//if (temp_coefficient.rectangle_width > 2) {
					//testAChange(original_time_series, area_vector, vector_id, temp_coefficient);//190521
					//testAChange0(original_time_series, area_vector, vector_id, temp_coefficient);//190522
					//cout << "****" << getMaxMagnitude(temp_coefficient).right_endpoint - getMaxMagnitude(temp_coefficient).rectangle_width << " " << temp_coefficient.deviation_point.id << " " << getMaxMagnitude(temp_coefficient).right_endpoint << endl;
				//}
			/*.........................................................................................................*/
#if _DEBUG
			assert(temp_coefficient.min_point.id == area_vector[vector_id - 1].min_point.id || temp_coefficient.min_point.id == area_vector[vector_id].min_point.id);
			assert(temp_coefficient.max_point.id == area_vector[vector_id - 1].max_point.id || temp_coefficient.max_point.id == area_vector[vector_id].max_point.id);
#endif
#ifdef TIME_H
			TOOL::recordStartTime(TOOL::time_record[12]);
#endif
			//if (isSymmetry(temp_coefficient, original_time_series)) continue;
			/*if (area_vector[vector_id].apla.a / area_vector[vector_id - 1].apla.a < 0) {
				cout << area_vector[vector_id].apla.a << "    " << area_vector[vector_id - 1].apla.a << endl;
				continue;
			}*/
			/*=============================================================N=============================================================*/
			if (area_vector.size() - merge_count <= input_argument.point_dimension) {
				//area_vector.erase(area_vector.begin() + left_id);
#if _DEBUG
				//cout << "End loop!!!!!!!!!!!!!!" << endl;
#endif
				break;
			}
			/*..............................................................................................................................*/
#ifdef TIME_H
			//TOOL::recordStartTime(TOOL::time_record[15]);
#endif
			/*============================================Begin merge================================================*/
			if (temp_coefficient.segment_density > lower_bound_density) {
				merge_count++;
				/*============================================Test section================================================*/
				//set <int> deviation_id;
				//if (!testDeviationPoint(temp_coefficient, 4, deviation_id)) {
				//typename GEOMETRY::POINT intersection_point1, intersection_point2;
				//getLineSegmentIntersectionPoint(area_vector, vector_id, temp_coefficient, intersection_point1, intersection_point2);

				//if(temp_coefficient.rectangle_width==4)
					//printSpecialPoint1(original_time_series, area_vector, vector_id, temp_coefficient);
				//}
				//deviation_id.clear();
				//testAChange1(original_time_series, area_vector, vector_id, temp_coefficient);
				/*----------------------------------------------------------------------------------------------------------------*/

				//mergeRectangle2(area_vector, vector_id, temp_coefficient, original_time_series);
#ifdef TIME_H
				//TOOL::recordStartTime(TOOL::time_record[14]);
#endif
				//mergeRectangle0ForParallelogram(area_vector, vector_id, temp_coefficient, original_time_series);
				/*----------------------------------------------------------*Megrge Process*------------------------------------------------------------*/

				mergeRectangle0ForParallelogramNoErase(area_vector, vector_id, segment_number, temp_coefficient, original_time_series);
				//int left_id = vector_id - 1;
				//vector<AREA_COEFFICIENT> temp_vector{ temp_coefficient };
				//area_vector[vector_id] = temp_vector.front();// .at(0);
				//area_vector[left_id].right_endpoint = INF;// .at(0);
				//area_vector[left_id].rectangle_width = INF;// .at(0);
				vector_id++;
#ifdef TIME_H
				//area_vector.erase(area_vector.begin() + left_id);
				//time4 += TOOL::recordFinishTime(TOOL::time_record[14]);
#endif
#if _DEBUG
				//cout << "3 after merge id: " << vector_id << " " << temp_coefficient.right_endpoint << endl;
#endif
#ifdef TIME_H
				//TOOL::recordStartTime(TOOL::time_record[17]);
#endif
				/*****************************update queue***************************************/
				if (!up_lower_bound_density_queue.empty()) {
					if (up_lower_bound_density_queue.top() > temp_coefficient.segment_density) {
						up_lower_bound_density_queue.pop();
						//up_lower_bound_density_queue.push(temp_coefficient.segment_density);
#if _DEBUG
						//assert(0);
						//cout << "Segment Density: " << temp_coefficient.segment_density << endl;
#endif
						up_lower_bound_density_queue.emplace(temp_coefficient.segment_density);
					}
				}
				/*.................................................................*/
#ifdef TIME_H
				//time7 += TOOL::recordFinishTime(TOOL::time_record[17]);
#endif
			}
			else {
#ifdef TIME_H
				//TOOL::recordStartTime(TOOL::time_record[18]);
#endif
				//if(density_max_set.size()< input_argument.point_dimension)
				//density_max_set.insert(temp_coefficient.segment_density);
				//density_max_set.emplace(temp_coefficient.segment_density);//need clear() function at loop begin.
				/*=====================================================================================================*/
				countBreakPoint(area_vector, vector_id, count_break_point_vector);//190613
				/*...................................................................................................*/
				density_max_set.emplace_hint(density_max_set.begin(), temp_coefficient.segment_density);
				//else {
					//density_max_set.erase(density_max_set.begin());
					//density_max_set.emplace(temp_coefficient.segment_density);
				//}
#if _DEBUG
				//cout << "2 not merge, set size: " << density_max_set.size()<<" inserted density: "<< temp_coefficient.segment_density  << endl;
#endif
#ifdef TIME_H
				//time8 += TOOL::recordFinishTime(TOOL::time_record[18]);
#endif
			}
#ifdef TIME_H
			//time11 += TOOL::recordFinishTime(TOOL::time_record[15]);
#endif
#ifdef TIME_H
			time1 += TOOL::recordFinishTime(TOOL::time_record[12]);
#endif
			/*.............................................................................................*/
		}
#if _DEBUG
		//cout << "before erase: " << area_vector.size() << endl;
#endif
#ifdef TIME_H
		loop_time += TOOL::recordFinishTime(TOOL::time_record[10]);
		TOOL::recordStartTime(TOOL::time_record[20]);//compare percentage time
		TOOL::recordStartTime(TOOL::time_record[16]);
#endif
		area_vector.erase(std::remove_if(area_vector.begin(), area_vector.end(), [](AREA_COEFFICIENT& i) { return i.right_endpoint == INF && i.rectangle_width == INF; }), area_vector.end());
#ifdef TIME_H
		time6 += TOOL::recordFinishTime(TOOL::time_record[16]);
#endif

#if _DEBUG
		//cout << "after erase: " << area_vector.size() << endl;
#endif
#ifdef TIME_H
		TOOL::recordStartTime(TOOL::time_record[13]);
#endif
		if (!up_lower_bound_density_queue.empty()) {
			lower_bound_density = up_lower_bound_density_queue.top();
			//up_lower_bound_density_queue.pop();
#if _DEBUG
			//cout << "8 queue size: " << up_lower_bound_density_queue.size() << endl;
#endif
		}

		/*if (original_size == area_vector.size()) {
			cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << endl;
			lower_bound_density = *(density_max_set.cbegin());
		}*/
		if (original_size <= area_vector.size() || area_vector.size() <= density_max_set.size() + 1) {
			//assert(area_vector.size() == density_max_set.size() + 1);
			//cout << "*********************************************" << endl;
			if (!up_lower_bound_density_queue.empty()) {
				up_lower_bound_density_queue.pop();
				//lower_bound_density = up_lower_bound_density_queue.top();
			}
			else {
				//cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << endl;
				lower_bound_density = *(density_max_set.cbegin());
				for (auto it = density_max_set.rbegin(); up_lower_bound_density_queue.size() <= input_argument.point_dimension && it != density_max_set.rend(); ++it) {
					//up_lower_bound_density_queue.push(*it);
					up_lower_bound_density_queue.emplace(*it);
				}
			}
		}
#ifdef TIME_H
		time2 += TOOL::recordFinishTime(TOOL::time_record[13]);
		time10 += TOOL::recordFinishTime(TOOL::time_record[20]);
#endif
#if _DEBUG
		auto [min, max] = minmax_element(area_vector.begin(), area_vector.end(), density_increase);
		//cout <<"Threshhold: " <<lower_bound_density << " min density: " << min->segment_density << " max density" << max->segment_density << endl;
		//cout << " 9 vector old size: " << original_size << " vector new size: " << area_vector.size() << " queue size: " << up_lower_bound_density_queue.size() << " set size: " << density_max_set.size() << endl;
#endif
	}
	output_argument.run_time = TOOL::recordFinishTime(TOOL::time_record[1]);
	/*...........................................................................................................*/
		//cout << "APLA running Time: " << output_argument.run_time << endl;// compare percentage time
		//cout << "vector size: " << area_vector.size() << endl;
	assert(area_vector.size() == input_argument.point_dimension);
	/*========================Reconstruction====================================*/
	getAPLA(input_argument, original_time_series, area_vector);
	/*..........................................................................*/

	/*========================Write Result=================================*/
	double* temp_endpoint = new double[area_vector.size()];
	array_id = 0;
	for (auto&& i : area_vector) {
		temp_endpoint[array_id] = i.right_endpoint;
		array_id++;
	}
	TOOL::writeSingleResult("./200706AllAPLAEvaluation/APLAEndPoint181218", temp_endpoint, area_vector.size());
	array_id = 0;
	for (auto&& i : area_vector) {
		//temp_endpoint[array_id] = i.lowest_id;
		temp_endpoint[array_id] = 0;
		array_id++;
	}
	TOOL::writeSingleResult("APLAMinId181221", temp_endpoint, area_vector.size());

	array_id = 0;
	for (auto&& i : area_vector) {
		//temp_endpoint[array_id] = i.heightest_id;
		temp_endpoint[array_id] = 0;
		array_id++;
	}
	TOOL::writeSingleResult("APLAMaxId181221", temp_endpoint, area_vector.size());
	TOOL::deleteArray(temp_endpoint);
	/*..............................................................................*/

	/*====================Print vector result=======================*/
	//cout << "initial time: " << time9 << "< ***<<<< loop time: " << loop_time << " mergerd information time: " << time3 << " Merge segmnet time: " << time1 << " Change threshold id time: " << time2 << " merge operation: " << time4 << " while count: " << while_count << " for count: " << for_count << " == operation time: " << time5 << " erease time: " << time6 << " merged id time: " << time7 << " not merge time: " << time8 << endl;
	cout << "============Test================" << endl;
	cout << "Total merge count: " << total_merge_infor_count << endl;
	cout << "deviation minmax, deviation, endpoint id: " << deviation_all_count << endl;
	cout << "same deviation id: " << same_deviation_id_count << endl;
	cout << "different deviation id: " << diff_deviation_id_count << endl;
	cout << "deviation minmax id: " << deviaiton_min_max_count << endl;
	cout << "................................" << endl;
	cout << "Whole time: " << output_argument.run_time
		<< "\n 1 initial time: " << time9
		<< "\n 2 loop time: " << loop_time
		<< "\n 3 Threshhold time: " << time10
		<< "\n 2.1 mergerd information time: " << time3
		<< "\n 2.1.1 get width: " << time12
		<< "\n 2.1.2 get a&b time: " << time13
		<< "\n 2.1.3 mergerd information time: " << time14
		<< "\n 2.2 Whole merge segmnet time: " << time1
		<< "\n 2.2.0 Whole merge segmnet time: " << time11
		<< "\n 2.2.1 merge operation time: " << time4
		<< "\n 2.2.2 change queue time: " << time7
		<< "\n 2.2.3 not merge time: " << time8
		<< "\n 3.1 erease time: " << time6
		<< "\n 3.2 Change threshold time: " << time2 << endl;

	//cout << "Finish! \n size: " << area_vector.size() << endl;

	/*cout << endl << "Min: ";
	for (auto&& i : area_vector) {
		cout << i.min_point.id << " ";
	}
	cout << endl << "Max: ";
	for (auto&& i : area_vector) {
		cout << i.max_point.id << " ";
	}
	cout << endl << "Area: ";
	for (auto&& i : area_vector) {
		cout << i.rectangle_area << " ";
	}
	cout << endl;*/
	cout << "right end point: ";
	for (auto&& i : area_vector) {
		cout << i.right_endpoint << " ";
	}
	/*array_id = 0;
	cout << "parallelogram_height: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.parallelogram_height << ", ";
		array_id++;
	}
	cout << endl;*/
	/*array_id = 0;
	cout << "rectangle_width: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.rectangle_width << ", ";
		array_id++;
	}
	cout << endl;*/
	array_id = 0;
	cout << "APLA deviation: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.rec_deviation << ", ";
		array_id++;
	}
	cout << endl;
	/*............................................................*/
	/*=======================Print Test============================*/
	cout << "Original time: " << endl;
	for (int i = 0; i < input_argument.time_series_length; i++) {
		cout << original_time_series[i] << ", ";
	}
	cout << endl;

	array_id = 0;
	cout << "Break point count: " << endl;
	for (auto&& au : count_break_point_vector) {
		cout << au << ", ";
		//cout << array_id << ": " << au << ", ";
		//array_id++;
	}
	cout << endl;
	/*............................................................*/
}

//************************************
// Method:mergeOperation0
// Qualifier:190609  APLA merge operation
// date:190609
// author:
//************************************
TEMPLATE
void APLA::mergeOperation0(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, AREA_COEFFICIENT& const temp_coefficient) {//190609
	typename GEOMETRY::POINT pair_density;
	int segment_number = 2;
	vector<AREA_COEFFICIENT> max_density_vector = { temp_coefficient };
	//AREA_COEFFICIENT max_density_coefficient;

	while (area_vector.size() > input_argument.point_dimension) {
		pair_density.id = 0;
		pair_density.value = 0;
		for (int vector_id = 1; vector_id < area_vector.size(); vector_id++) {
			getMergedInfor0ForParallelogram(original_time_series, area_vector, vector_id, segment_number, temp_coefficient);
			//temp_coefficient_vector[vector_id] = temp_coefficient;
			if (pair_density.value < temp_coefficient.segment_density) {
				pair_density.id = vector_id;
				pair_density.value = temp_coefficient.segment_density;
				max_density_vector[0] = temp_coefficient;
			}

			//min_segment_density_queue.push(pair_density);
		}
		int left_id = pair_density.id - 1;
		//cout << "erase id: " << left_id << endl;
		//area_vector[pair_density.id] = temp_coefficient_vector[pair_density.id];
		area_vector[pair_density.id] = max_density_vector[0];
		area_vector.erase(area_vector.begin() + left_id);
		//area_vector[left_id].right_endpoint = INF;// .at(0);
		//area_vector[left_id].rectangle_width = INF;// .at(0);
		//min_segment_density_queue.clear();
	}
	//cout <<"vector size: " <<area_vector.size() << endl;

	//area_vector.erase(std::remove_if(area_vector.begin(), area_vector.end(), [](AREA_COEFFICIENT& i) { return i.right_endpoint == INF && i.rectangle_width == INF; }), area_vector.end());
	/*for (auto&& i : area_vector) {
		cout << i.right_endpoint << " "<<i.rectangle_width << endl;
	}*/
}

//************************************
// Method:mergeOperationBatch2
// Qualifier:190610  Improve mergeOperation0, use batch to speed up
// date:190610
// author:
//************************************
TEMPLATE
void APLA::mergeOperationBatch2(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, vector<AREA_COEFFICIENT>& const temp_coefficient_vector, AREA_COEFFICIENT& const temp_coefficient) {//190610 Improve mergeOperation0, use batch to speed up
	typename GEOMETRY::POINT pair_density;
	int segment_number = 2;
	vector<AREA_COEFFICIENT> max_density_vector = { temp_coefficient };

	priority_queue<typename GEOMETRY::POINT, std::vector<typename GEOMETRY::POINT>, typename GEOMETRY::ValueIncrease> min_segment_density_queue;//190607
	std::set<typename GEOMETRY::POINT, typename GEOMETRY::ValueIncrease> mySet;
	//AREA_COEFFICIENT max_density_coefficient;

	while (area_vector.size() > input_argument.point_dimension) {
		int merge_count = 0;
		pair_density.id = 0;
		pair_density.value = 0;
		for (int vector_id = 1; vector_id < area_vector.size(); vector_id += 2) {
			getMergedInfor0ForParallelogram(original_time_series, area_vector, vector_id, segment_number, temp_coefficient);
			temp_coefficient_vector[vector_id] = temp_coefficient;
			//if (pair_density.value < temp_coefficient.segment_density) {
			pair_density.id = vector_id;
			pair_density.value = temp_coefficient.segment_density;
			//max_density_vector[0] = temp_coefficient;
		//}

			if (min_segment_density_queue.size() >= int(area_vector.size() / 4)) {
				if (min_segment_density_queue.top().value < pair_density.value) {
					min_segment_density_queue.pop();
					min_segment_density_queue.push(pair_density);
				}
			}
			else {
				min_segment_density_queue.push(pair_density);
			}
		}

		while (!min_segment_density_queue.empty()) {
			int left_id = min_segment_density_queue.top().id - 1;
			area_vector[min_segment_density_queue.top().id] = temp_coefficient_vector[min_segment_density_queue.top().id];
			area_vector[left_id].right_endpoint = INF;// .at(0);
			area_vector[left_id].rectangle_width = INF;// .at(0);
			min_segment_density_queue.pop();
			merge_count++;
			if (area_vector.size() - merge_count <= input_argument.point_dimension) {
				//area_vector.erase(area_vector.begin() + left_id);
#if _DEBUG
				//cout << "End loop!!!!!!!!!!!!!!" << endl;
#endif
				break;
			}
		}

		area_vector.erase(std::remove_if(area_vector.begin(), area_vector.end(), [](AREA_COEFFICIENT& i) { return i.right_endpoint == INF && i.rectangle_width == INF; }), area_vector.end());
		min_segment_density_queue = priority_queue <typename GEOMETRY::POINT, std::vector<typename GEOMETRY::POINT>, typename GEOMETRY::ValueIncrease>();
		//int left_id = pair_density.id - 1;
		//cout << "erase id: " << left_id << endl;
		//area_vector[pair_density.id] = temp_coefficient_vector[pair_density.id];
		//area_vector[pair_density.id] = max_density_vector[0];
		//area_vector.erase(area_vector.begin() + left_id);
		//area_vector[left_id].right_endpoint = INF;// .at(0);
		//area_vector[left_id].rectangle_width = INF;// .at(0);
		//min_segment_density_queue.clear();
	}
	//cout <<"vector size: " <<area_vector.size() << endl;

	/*for (auto&& i : area_vector) {
		cout << i.right_endpoint << " "<<i.rectangle_width << endl;
	}*/
}

//************************************
// Method:mergeOperationBatch2Set
// Qualifier:190610 Use set to instead priority_queue. Improve mergeOperation0, use batch to speed up
// date:190610
// author:
//************************************
TEMPLATE
void APLA::mergeOperationBatch2Set(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, vector<AREA_COEFFICIENT>& const temp_coefficient_vector, AREA_COEFFICIENT& const temp_coefficient) {//190610 Use set to instead priority_queue;
	typename GEOMETRY::POINT pair_density;
	int segment_number = 2;
	//int merged_id = 1;
	//vector<AREA_COEFFICIENT> max_density_vector = { temp_coefficient };

	//priority_queue<typename GEOMETRY::POINT, std::vector<typename GEOMETRY::POINT>, typename GEOMETRY::ValueIncrease> min_segment_density_queue;//190607
	std::set<typename GEOMETRY::POINT, typename GEOMETRY::ValueDecrease> max_segment_density_set;//190610
	//AREA_COEFFICIENT max_density_coefficient;

	//if (input_argument.point_dimension==2&& area_vector.size()==4) {
	//	for (int vector_id = 1; vector_id < area_vector.size(); vector_id += 2) {
	//		int left_id = vector_id - 1;
	//		getMergedInfor0ForParallelogramImprove(area_vector, vector_id, temp_coefficient);
	//		area_vector[vector_id] = temp_coefficient;
	//		area_vector[left_id].right_endpoint = INF;// .at(0);
	//		area_vector[left_id].rectangle_width = INF;// .at(0);
	//	}
	//	area_vector.erase(std::remove_if(area_vector.begin(), area_vector.end(), [](AREA_COEFFICIENT& i) { return i.right_endpoint == INF && i.rectangle_width == INF; }), area_vector.end());
	//	return;
	//}

	while (area_vector.size() > input_argument.point_dimension) {
		int merge_count = 0;
		//pair_density.id = 0;
		//pair_density.value = 0;

		/*================================Split Segment====================================================*/
		if (area_vector.size() > 4) {
			//int split_number = 1;
			int split_number = floor(sqrt(area_vector.size() / 2));
			split_number = split_number == 0 ? 1 : split_number;
			//input: width, right endpoint
			//output: a&b, min&max point, sum value, *right_subsegment != nullptr
			SplitSegmentByRealPLAArea(original_time_series, area_vector, split_number);
		}
		/*....................................................................................................*/
		for (int vector_id = 1; vector_id < area_vector.size(); vector_id += 2) {
			//getMergedInfor0ForParallelogram(original_time_series, area_vector, vector_id, segment_number, temp_coefficient);
			getMergedInfor0ForParallelogramImprove(area_vector, vector_id, temp_coefficient);//190611
			temp_coefficient_vector[vector_id] = temp_coefficient;
			pair_density.id = vector_id;
			pair_density.value = temp_coefficient.segment_density;
			max_segment_density_set.emplace(pair_density);
		}
		int merge_id = 0;
		int merge_number = int(area_vector.size() / 4);
		//int merge_number = int(area_vector.size()/4);
		//int merge_number = int(sqrt(area_vector.size()));
		//int merge_number = ceil(area_vector.size()/4);

		for (auto it = max_segment_density_set.begin(); it != max_segment_density_set.end() && merge_id <= merge_number; ++it, merge_id++) {
			int left_id = it->id - 1;
			area_vector[it->id] = temp_coefficient_vector[it->id];
			area_vector[left_id].right_endpoint = INF;// .at(0);
			area_vector[left_id].rectangle_width = INF;// .at(0);
			//merged_id = it->id+1;
			merge_count++;
			if (area_vector.size() - merge_count <= input_argument.point_dimension) {
				//area_vector.erase(area_vector.begin() + left_id);
#if _DEBUG
				//cout << "End loop!!!!!!!!!!!!!!" << endl;
#endif
				break;
			}
		}
		area_vector.erase(std::remove_if(area_vector.begin(), area_vector.end(), [](AREA_COEFFICIENT& i) { return i.right_endpoint == INF && i.rectangle_width == INF; }), area_vector.end());
		//min_segment_density_queue = priority_queue <typename GEOMETRY::POINT, std::vector<typename GEOMETRY::POINT>, typename GEOMETRY::ValueIncrease>();
		max_segment_density_set.clear();
		//int left_id = pair_density.id - 1;
		//cout << "erase id: " << left_id << endl;
		//area_vector[pair_density.id] = temp_coefficient_vector[pair_density.id];
		//area_vector[pair_density.id] = max_density_vector[0];
		//area_vector.erase(area_vector.begin() + left_id);
		//area_vector[left_id].right_endpoint = INF;// .at(0);
		//area_vector[left_id].rectangle_width = INF;// .at(0);
		//min_segment_density_queue.clear();
	}
	//cout <<"vector size: " <<area_vector.size() << endl;

	/*for (auto&& i : area_vector) {
		cout << i.right_endpoint << " "<<i.rectangle_width << endl;
	}*/
}

//************************************
// Method:mergeOperationBatch2Set
// Qualifier:190612 Add sub segemt to speed up,avoid repeat calculate, Use set to instead priority_queue;
// date:190612
// author:
//************************************
TEMPLATE
void APLA::mergeOperationBatch2SetPointer(typename TOOL::INPUT_ARGUMENT& input_argument, vector<AREA_COEFFICIENT>& const area_vector, vector<AREA_COEFFICIENT>& const temp_coefficient_vector, AREA_COEFFICIENT& const temp_coefficient, vector<int>& const count_break_point_vector) {//190612 Add sub segemt to speed up,avoid repeat calculate, Use set to instead priority_queue;
	typename GEOMETRY::POINT pair_density;
	int segment_number = 2;
	//int merged_id = 1;
	//vector<AREA_COEFFICIENT> max_density_vector = { temp_coefficient };
	//priority_queue<typename GEOMETRY::POINT, std::vector<typename GEOMETRY::POINT>, typename GEOMETRY::ValueIncrease> min_segment_density_queue;//190607
	std::set<typename GEOMETRY::POINT, typename GEOMETRY::ValueDecrease> max_segment_density_set;//190610
	//AREA_COEFFICIENT max_density_coefficient;
	//temp_coefficient.right_subsegment = new AREA_COEFFICIENT;

	//if (input_argument.point_dimension==2 && area_vector.size()==4) {
	//	for (int vector_id = 1; vector_id < area_vector.size(); vector_id += 2) {
	//		int left_id = vector_id - 1;
	//		getMergedInfor0ForParallelogramImprove(area_vector, vector_id, temp_coefficient);
	//		area_vector[vector_id] = temp_coefficient;
	//		area_vector[left_id].right_endpoint = INF;// .at(0);
	//		area_vector[left_id].rectangle_width = INF;// .at(0);
	//	}
	//	area_vector.erase(std::remove_if(area_vector.begin(), area_vector.end(), [](AREA_COEFFICIENT& i) { return i.right_endpoint == INF && i.rectangle_width == INF; }), area_vector.end());
	//	return;
	//}

	while (area_vector.size() > input_argument.point_dimension) {
		int merge_count = 0;
		//pair_density.id = 0;
		//pair_density.value = 0;
		for (int vector_id = 1; vector_id < area_vector.size(); vector_id += 2) {
			//getMergedInfor0ForParallelogram(original_time_series, area_vector, vector_id, segment_number, temp_coefficient);
			if (area_vector[vector_id].already_compute == true) {
				pair_density.id = vector_id;
				pair_density.value = area_vector[vector_id].right_subsegment->segment_density;
#if _DEBUG
				temp_coefficient_vector[vector_id] = *area_vector[vector_id].right_subsegment;
#endif
				max_segment_density_set.emplace(pair_density);
			}
			else {
				getMergedInfor0ForParallelogramImprove(area_vector, vector_id, temp_coefficient);//190611
				pair_density.id = vector_id;
				pair_density.value = temp_coefficient.segment_density;
				max_segment_density_set.emplace(pair_density);
				//temp_coefficient.right_subsegment = new AREA_COEFFICIENT;
#if _DEBUG
				//temp_coefficient_vector[vector_id] = temp_coefficient;
				temp_coefficient_vector[vector_id].apla = temp_coefficient.apla;
				temp_coefficient_vector[vector_id].sum_value = temp_coefficient.sum_value;
				temp_coefficient_vector[vector_id].right_endpoint = temp_coefficient.right_endpoint;
				temp_coefficient_vector[vector_id].rectangle_width = temp_coefficient.rectangle_width;
				temp_coefficient_vector[vector_id].segment_density = temp_coefficient.segment_density;
#endif
				//*area_vector[vector_id].right_subsegment = temp_coefficient;
				area_vector[vector_id].right_subsegment->apla = temp_coefficient.apla;
				area_vector[vector_id].right_subsegment->sum_value = temp_coefficient.sum_value;
				area_vector[vector_id].right_subsegment->right_endpoint = temp_coefficient.right_endpoint;
				area_vector[vector_id].right_subsegment->rectangle_width = temp_coefficient.rectangle_width;
				area_vector[vector_id].right_subsegment->segment_density = temp_coefficient.segment_density;

				area_vector[vector_id].already_compute = true;
			}

			//cout << &temp_coefficient.right_subsegment->right_endpoint <<" ";
			//cout << area_vector[vector_id].right_endpoint <<" "<<&area_vector[vector_id].right_subsegment->right_endpoint<<" " <<temp_coefficient.right_endpoint<<" " << temp_coefficient.right_subsegment->right_endpoint <<" "<< temp_coefficient_vector[vector_id].right_endpoint << " " << temp_coefficient_vector[vector_id].right_subsegment->right_endpoint << " " << &temp_coefficient_vector[vector_id].right_subsegment->right_endpoint << endl;
		}
		/*cout << "!!!Normal end: ";
		for (auto &&au : area_vector) {
			cout << au.right_endpoint << ", ";
		}
		cout << endl;
		cout << "!!!Sub Pointer: ";
		for (auto &&au : area_vector) {
			cout << au.right_subsegment->right_endpoint <<", ";
		}
		cout << endl;
		cout << "!Array Pointer: ";
		for (auto &&au : temp_coefficient_vector) {
			cout << au.right_endpoint << ", ";
		}
		cout << endl;
		cout << "!Array Sub: ";
		for (auto &&au : temp_coefficient_vector) {
			if (au.right_subsegment != nullptr)
				cout << au.right_subsegment->right_endpoint << ", ";
			else
				cout << "null ,";
		}
		cout << endl;*/
		/*cout << "Density: ";
		for (auto &&au : max_segment_density_set) {
			cout << au.value << ",";
		}
		cout << endl;*/

		int merge_id = 0;
		int merge_number = int(area_vector.size() / 3);
		//int merge_number = int(sqrt(area_vector.size()));
		//int merge_number = ceil(area_vector.size()/4);

		for (auto it = max_segment_density_set.begin(); it != max_segment_density_set.end() && merge_id <= merge_number; ++it, merge_id++) {
			/*=====================================================================================================*/
			countBreakPoint(area_vector, it->id, count_break_point_vector);//190613
			/*....................................................................................................*/
			int left_id = it->id - 1;
#if _DEBUG
			assert(area_vector[it->id].right_subsegment->right_endpoint == temp_coefficient_vector[it->id].right_endpoint);
#endif
			//area_vector[it->id] = *area_vector[it->id].right_subsegment;
			area_vector[it->id].apla = area_vector[it->id].right_subsegment->apla;
			area_vector[it->id].sum_value = area_vector[it->id].right_subsegment->sum_value;
			area_vector[it->id].right_endpoint = area_vector[it->id].right_subsegment->right_endpoint;
			area_vector[it->id].rectangle_width = area_vector[it->id].right_subsegment->rectangle_width;
			area_vector[it->id].segment_density = area_vector[it->id].right_subsegment->segment_density;
			area_vector[it->id].already_compute = false;
			if (it->id < area_vector.size() - 1)
				area_vector[it->id + 1].already_compute = false;
			//cout << area_vector[it->id].right_subsegment->right_endpoint << endl;
#if _DEBUG
			assert(area_vector[it->id].right_endpoint == temp_coefficient_vector[it->id].right_endpoint);
#endif
			area_vector[left_id].right_endpoint = INF;// .at(0);
			area_vector[left_id].rectangle_width = INF;// .at(0);
			//merged_id = it->id+1;
			merge_count++;
			if (area_vector.size() - merge_count <= input_argument.point_dimension) {
				//area_vector.erase(area_vector.begin() + left_id);
#if _DEBUG
				//cout << "End loop!!!!!!!!!!!!!!" << endl;
#endif
				break;
			}
		}
		area_vector.erase(std::remove_if(area_vector.begin(), area_vector.end(), [](AREA_COEFFICIENT& i) { return i.right_endpoint == INF && i.rectangle_width == INF; }), area_vector.end());
		//min_segment_density_queue = priority_queue <typename GEOMETRY::POINT, std::vector<typename GEOMETRY::POINT>, typename GEOMETRY::ValueIncrease>();
		max_segment_density_set.clear();
		//int left_id = pair_density.id - 1;
		//cout << "erase id: " << left_id << endl;
		//area_vector[pair_density.id] = temp_coefficient_vector[pair_density.id];
		//area_vector[pair_density.id] = max_density_vector[0];
		//area_vector.erase(area_vector.begin() + left_id);
		//area_vector[left_id].right_endpoint = INF;// .at(0);
		//area_vector[left_id].rectangle_width = INF;// .at(0);
		//min_segment_density_queue.clear();
	}
	//cout <<"vector size: " <<area_vector.size() << endl;

	/*for (auto&& i : area_vector) {
		cout << i.right_endpoint << " "<<i.rectangle_width << endl;
	}*/
}

//************************************
// Method:mergeOperationBatch2SetSpeed
// Qualifier:190611 Use set to instead priority_queue. Improve mergeOperation0, use batch to speed up, and other speed up algorithm
// date:190611
// author:
//************************************
TEMPLATE
void APLA::mergeOperationBatch2SetSpeed(typename TOOL::INPUT_ARGUMENT& input_argument, vector<AREA_COEFFICIENT>& const area_vector, vector<AREA_COEFFICIENT>& const temp_coefficient_vector, AREA_COEFFICIENT& const temp_coefficient) {//190611 Use set to instead priority_queue,speed;
	typename GEOMETRY::POINT pair_density;
	//int merged_id = 1;
	//vector<AREA_COEFFICIENT> max_density_vector = { temp_coefficient };

	//priority_queue<typename GEOMETRY::POINT, std::vector<typename GEOMETRY::POINT>, typename GEOMETRY::ValueIncrease> min_segment_density_queue;//190607
	std::set<typename GEOMETRY::POINT, typename GEOMETRY::ValueDecrease> max_segment_density_set;//190610
	std::map<double, bool> map_if_merge;//190611
	//AREA_COEFFICIENT max_density_coefficient;

	while (area_vector.size() > input_argument.point_dimension) {
		int merge_count = 0;
		//pair_density.id = 0;
		//pair_density.value = 0;
		for (int vector_id = 1; vector_id < area_vector.size(); vector_id += 1) {
			//getMergedInfor0ForParallelogram(original_time_series, area_vector, vector_id, segment_number, temp_coefficient);
			getMergedInfor0ForParallelogramImprove(area_vector, vector_id, temp_coefficient);//190611
			temp_coefficient_vector[vector_id] = temp_coefficient;
			//if (pair_density.value < temp_coefficient.segment_density) {
			pair_density.id = vector_id;
			pair_density.value = temp_coefficient.segment_density;
			//max_density_vector[0] = temp_coefficient;
		//}
			max_segment_density_set.emplace(pair_density);

			map_if_merge.emplace_hint(map_if_merge.end(), vector_id, true);
			/*if (min_segment_density_queue.size() >= int(area_vector.size() / 4)) {
				if (min_segment_density_queue.top().value < pair_density.value) {
					min_segment_density_queue.pop();
					min_segment_density_queue.push(pair_density);
				}
			}
			else {
				min_segment_density_queue.push(pair_density);
			}*/
		}
		int merge_id = 0;
		int merge_number = int(area_vector.size() / 2);
		//int merge_number = int(sqrt(area_vector.size()));

		for (auto it = max_segment_density_set.begin(); it != max_segment_density_set.end() && merge_id < merge_number; ++it) {
			int left_id = it->id - 1;
			if (map_if_merge.at(it->id)) {
				map_if_merge.at(it->id) = false;
				if (it->id < area_vector.size() - 1)
					map_if_merge.at(it->id + 1) = false;
				if (left_id > 1) {
					map_if_merge.at(left_id - 1) = false;
					map_if_merge.at(left_id) = false;
				}
				else if (left_id == 1) {
					map_if_merge.at(left_id) = false;
				}

				area_vector[it->id] = temp_coefficient_vector[it->id];
				area_vector[left_id].right_endpoint = INF;// .at(0);
				area_vector[left_id].rectangle_width = INF;// .at(0);
				//merged_id = it->id+1;
				merge_count++;
				merge_id++;
			}

			if (area_vector.size() - merge_count <= input_argument.point_dimension) {
				//area_vector.erase(area_vector.begin() + left_id);
#if _DEBUG
				//cout << "End loop!!!!!!!!!!!!!!" << endl;
#endif
				break;
			}
		}

		area_vector.erase(std::remove_if(area_vector.begin(), area_vector.end(), [](AREA_COEFFICIENT& i) { return i.right_endpoint == INF && i.rectangle_width == INF; }), area_vector.end());
		//min_segment_density_queue = priority_queue <typename GEOMETRY::POINT, std::vector<typename GEOMETRY::POINT>, typename GEOMETRY::ValueIncrease>();
		max_segment_density_set.clear();
		map_if_merge.clear();
		//int left_id = pair_density.id - 1;
		//cout << "erase id: " << left_id << endl;
		//area_vector[pair_density.id] = temp_coefficient_vector[pair_density.id];
		//area_vector[pair_density.id] = max_density_vector[0];
		//area_vector.erase(area_vector.begin() + left_id);
		//area_vector[left_id].right_endpoint = INF;// .at(0);
		//area_vector[left_id].rectangle_width = INF;// .at(0);
		//min_segment_density_queue.clear();
	}
	//cout <<"vector size: " <<area_vector.size() << endl;

	/*for (auto&& i : area_vector) {
		cout << i.right_endpoint << " "<<i.rectangle_width << endl;
	}*/
}

//************************************
// Method:mergeOperationBatch2SetSpeedPointer
// Qualifier:190612 Use set to instead priority_queue. Improve mergeOperation0, use batch to speed up, and other speed up algorithm
// Input: new *right_subsegment
// Output:
// date:190612
// author:
//************************************
TEMPLATE
void APLA::mergeOperationBatch2SetSpeedPointer(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, vector<AREA_COEFFICIENT>& const temp_coefficient_vector, AREA_COEFFICIENT& const temp_coefficient) {//190612 Add sub segemt to speed up,avoid repeat calculate, Use set to instead priority_queue;
	typename GEOMETRY::POINT pair_density;
	//int merged_id = 1;
	//vector<AREA_COEFFICIENT> max_density_vector = { temp_coefficient };

	//priority_queue<typename GEOMETRY::POINT, std::vector<typename GEOMETRY::POINT>, typename GEOMETRY::ValueIncrease> min_segment_density_queue;//190607
	std::set<typename GEOMETRY::POINT, typename GEOMETRY::ValueDecrease> max_segment_density_set;//190610 Get max value
	//std::set<typename GEOMETRY::POINT, typename GEOMETRY::ValueIncrease> max_segment_density_set;//190725 Get min value
	std::map<double, bool> map_if_merge;//190611
	//AREA_COEFFICIENT max_density_coefficient;

	while (area_vector.size() > input_argument.point_dimension) {
		int merge_count = 0;
		//pair_density.id = 0;
		//pair_density.value = 0;

		/*================================Split Segment====================================================*/
		if (area_vector.size() > 3) {
			//int split_number = 1;
			int split_number = floor(sqrt(area_vector.size() / 2));
			//split_number = split_number == 0 ? 1 : split_number;
//#if _DEBUG
//			cout<<"Before split: "<<endl;
//			for (auto&& au : area_vector) {
//				cout << au.right_endpoint << ",";
//			}
//			cout << endl;
//#endif
			//++++ Input: Long segment sum_value, a&b, min&max point, width , right endpoint
			//++++ Output: Sub segment sum_value, a&b, min&max point, width , right endpoint, *right_subsegment != nullptr
			SplitSegmentByRealPLAArea(original_time_series, area_vector, split_number);
			//for_each_n(area_vector.begin(), area_vector.size(), [](auto&& au) {assert(au.min_point.id != INF && au.max_point.id != INF && au.min_point.value != INF && au.max_point.value != INF); });
//#if _DEBUG
//			cout << "After split: " << endl;
//			for (auto&& au : area_vector) {
//				cout << au.right_endpoint << ",";
//			}
//			cout << endl;
//#endif
		}
		/*....................................................................................................*/

		/*================================get Merged Infor====================================================*/
		for (int vector_id = 1; vector_id < area_vector.size(); vector_id++) {
#if _DEBUG
			assert(area_vector[vector_id].right_subsegment != nullptr && area_vector[vector_id].sum_value != INF);
#endif
			pair_density.id = vector_id;
			if (area_vector[vector_id].already_compute == true) {
				pair_density.value = area_vector[vector_id].right_subsegment->segment_density;
				//pair_density.value = area_vector[vector_id].right_subsegment->area_difference;
#if _DEBUG
				assert(area_vector[vector_id].right_subsegment->rectangle_width == area_vector[vector_id - 1].rectangle_width + area_vector[vector_id].rectangle_width && area_vector[vector_id].right_subsegment->area_difference != INF);
				temp_coefficient_vector[vector_id] = *area_vector[vector_id].right_subsegment;
#endif
			}
			else {
				/*===============Get merged information======================*/
				//+++Input:
				//+++Output: sum value, a&b, segment Triangle Area Density, segment width, segment right end point, min&max point
				getMergedInfor0ForParallelogramImprove(area_vector, vector_id, temp_coefficient);//190611
#ifdef _DEBUG
				AREA_COEFFICIENT test_coefficient = temp_coefficient;
				getSegmentMinMaxPoint(original_time_series, test_coefficient);
				//assert(temp_coefficient.min_point.id == test_coefficient.min_point.id && temp_coefficient.max_point.id == test_coefficient.max_point.id);
				assert(temp_coefficient.min_point.value == test_coefficient.min_point.value && temp_coefficient.max_point.value == test_coefficient.max_point.value);
				assert(temp_coefficient.min_point.value == original_time_series[int(temp_coefficient.min_point.id)] && temp_coefficient.max_point.value == original_time_series[int(temp_coefficient.max_point.id)]);
#endif
				/*...........................................................*/
				/*==============Sort segment density=========================*/
				pair_density.value = temp_coefficient.segment_density;
				//pair_density.value = temp_coefficient.area_difference;
				//temp_coefficient.right_subsegment = new AREA_COEFFICIENT;
				/*........................................................*/

#if _DEBUG
				assert(temp_coefficient_vector.size() >= area_vector.size() && temp_coefficient.sum_value != INF && temp_coefficient.area_difference != INF);
				assert(temp_coefficient.rectangle_width == area_vector[vector_id - 1].rectangle_width + area_vector[vector_id].rectangle_width);
				//temp_coefficient_vector[vector_id] = temp_coefficient;
				temp_coefficient_vector[vector_id].apla = temp_coefficient.apla;
				temp_coefficient_vector[vector_id].sum_value = temp_coefficient.sum_value;
				temp_coefficient_vector[vector_id].right_endpoint = temp_coefficient.right_endpoint;
				temp_coefficient_vector[vector_id].rectangle_width = temp_coefficient.rectangle_width;
				temp_coefficient_vector[vector_id].segment_density = temp_coefficient.segment_density;

				temp_coefficient_vector[vector_id].min_point = temp_coefficient.min_point;//190725
				temp_coefficient_vector[vector_id].max_point = temp_coefficient.max_point;//190725
				temp_coefficient_vector[vector_id].area_difference = temp_coefficient.area_difference;
#endif

				/*=================Sub segment = long segment====================*/
				//*area_vector[vector_id].right_subsegment = temp_coefficient;
				area_vector[vector_id].right_subsegment->apla = temp_coefficient.apla;
				area_vector[vector_id].right_subsegment->sum_value = temp_coefficient.sum_value;
				area_vector[vector_id].right_subsegment->right_endpoint = temp_coefficient.right_endpoint;
				area_vector[vector_id].right_subsegment->rectangle_width = temp_coefficient.rectangle_width;
				area_vector[vector_id].right_subsegment->segment_density = temp_coefficient.segment_density;
				area_vector[vector_id].right_subsegment->increment_area = temp_coefficient.increment_area;
				area_vector[vector_id].already_compute = true;

				area_vector[vector_id].right_subsegment->min_point = temp_coefficient.min_point;//190725
				area_vector[vector_id].right_subsegment->max_point = temp_coefficient.max_point;//190725

				area_vector[vector_id].right_subsegment->area_difference = temp_coefficient.area_difference; //190724
				/*............................................................*/
			}

			max_segment_density_set.emplace(pair_density);
			map_if_merge.emplace_hint(map_if_merge.end(), vector_id, true);
		}
		/*..........................................................................................................*/
		int merge_id = 0;
		//int merge_number = ceil(area_vector.size() / 2);
		//int merge_number = ceil(sqrt(area_vector.size()));
		//int merge_number = floor(sqrt(area_vector.size()/2));
		int merge_number = floor(sqrt(area_vector.size()));
		merge_number = merge_number < 2 ? 2 : merge_number;
#if _DEBUG
		assert(merge_number > 0);
#endif
		/*===================================Merge Vector==========================================================================*/
		for (auto it = max_segment_density_set.begin(); it != max_segment_density_set.end() && merge_id < merge_number; ++it) {
			int left_id = it->id - 1;
#if _DEBUG
			//cout << "candidate merge id: " << left_id << " "<< it->id<<" "<< area_vector[left_id].right_endpoint<<" "<< area_vector[it->id].right_endpoint <<endl;
			assert(area_vector[it->id].right_subsegment->right_endpoint == temp_coefficient_vector[it->id].right_endpoint);
#endif
			if (map_if_merge.at(it->id)) {
				//cout << "true merge id: " << left_id << " " << it->id << " " << area_vector[left_id].right_endpoint << " " << area_vector[it->id].right_endpoint << endl;
				map_if_merge.at(it->id) = false;
				if (it->id < area_vector.size() - 1)
					map_if_merge.at(it->id + 1) = false;
				if (left_id > 1) {
					//map_if_merge.at(left_id - 1) = false;
					map_if_merge.at(left_id) = false;
				}
				else if (left_id == 1) {
					map_if_merge.at(left_id) = false;
				}

#if _DEBUG
				assert(area_vector[it->id].right_subsegment->rectangle_width == area_vector[left_id].rectangle_width + area_vector[it->id].rectangle_width && area_vector[it->id].right_subsegment->sum_value != INF);
#endif

				//area_vector[it->id] = *area_vector[it->id].right_subsegment;
				area_vector[it->id].apla = area_vector[it->id].right_subsegment->apla;
				area_vector[it->id].sum_value = area_vector[it->id].right_subsegment->sum_value;
				area_vector[it->id].right_endpoint = area_vector[it->id].right_subsegment->right_endpoint;
				area_vector[it->id].rectangle_width = area_vector[it->id].right_subsegment->rectangle_width;
				area_vector[it->id].segment_density = area_vector[it->id].right_subsegment->segment_density;
				area_vector[it->id].already_compute = false;

				area_vector[it->id].min_point = area_vector[it->id].right_subsegment->min_point;//190725
				area_vector[it->id].max_point = area_vector[it->id].right_subsegment->max_point;//190725

				area_vector[it->id].area_difference = area_vector[it->id].right_subsegment->area_difference;//190724
				/*---Test----*/
				area_vector[it->id].increment_area = area_vector[it->id].right_subsegment->increment_area;
				/*...........*/
				if (it->id < area_vector.size() - 1)
					area_vector[it->id + 1].already_compute = false;
#if _DEBUG
				assert(area_vector[it->id].right_endpoint == temp_coefficient_vector[it->id].right_endpoint);
#endif

				area_vector[left_id].right_endpoint = INF;// .at(0);
				area_vector[left_id].rectangle_width = INF;// .at(0);
				//merged_id = it->id+1;
				merge_count++;
				merge_id++;
			}

			if (area_vector.size() - merge_count <= input_argument.point_dimension) {
				//area_vector.erase(area_vector.begin() + left_id);
				break;
			}
		}
		area_vector.erase(std::remove_if(area_vector.begin(), area_vector.end(), [](AREA_COEFFICIENT& i) { return i.right_endpoint == INF && i.rectangle_width == INF; }), area_vector.end());
		//#if _DEBUG
		//		cout << "After merge" << endl;
		//		for (auto&& au : area_vector) {
		//			cout << au.right_endpoint << ",";
		//		}
		//		cout << endl;
		//#endif
				/*...........................................................................................................*/
				//min_segment_density_queue = priority_queue <typename GEOMETRY::POINT, std::vector<typename GEOMETRY::POINT>, typename GEOMETRY::ValueIncrease>();
		max_segment_density_set.clear();
		map_if_merge.clear();
		//int left_id = pair_density.id - 1;
		//cout << "erase id: " << left_id << endl;
		//area_vector[pair_density.id] = temp_coefficient_vector[pair_density.id];
		//area_vector[pair_density.id] = max_density_vector[0];
		//area_vector.erase(area_vector.begin() + left_id);
		//area_vector[left_id].right_endpoint = INF;// .at(0);
		//area_vector[left_id].rectangle_width = INF;// .at(0);
		//min_segment_density_queue.clear();
	}
	//cout <<"vector size: " <<area_vector.size() << endl;

	/*for (auto&& i : area_vector) {
		cout << i.right_endpoint << " "<<i.rectangle_width << endl;
	}*/
}

//************************************
// Method:mergeOperationBatch2SetSpeedPointer
// Qualifier:190823 Use set to instead priority_queue. Improve mergeOperation0, use batch to speed up, and other speed up algorithm
// Input: new *right_subsegment
// Output:
// date:190823
// author:
//************************************
TEMPLATE
void APLA::mergeOperationBatch2SetSpeedPointer(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const temp_coefficient_vector, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list) {//190823 Add sub segemt to speed up,avoid repeat calculate, Use set to instead priority_queue;
	typename GEOMETRY::POINT pair_density;
	AREA_COEFFICIENT temp_coefficient;
	//int merged_id = 1;
	//vector<AREA_COEFFICIENT> max_density_vector = { temp_coefficient };

	//priority_queue<typename GEOMETRY::POINT, std::vector<typename GEOMETRY::POINT>, typename GEOMETRY::ValueIncrease> min_segment_density_queue;//190607
	std::set<typename GEOMETRY::POINT, typename GEOMETRY::ValueDecrease> max_density_id_set;//190827 Get max value segment density : id
	//std::set<typename GEOMETRY::POINT, typename GEOMETRY::ValueIncrease> max_segment_density_set;//190725 Get min value
	std::map<double, bool> map_if_merge;//190611
	//AREA_COEFFICIENT max_density_coefficient;

	while (doubly_linked_list.size() > input_argument.point_dimension) {
		int merge_count = 0;
		//pair_density.id = 0;
		//pair_density.value = 0;
		/*================================1 Split Segment====================================================*/
		if (doubly_linked_list.size() > 3) {
			//int split_number = 1;
			int split_number = floor(sqrt(doubly_linked_list.size() / 2));
			//split_number = split_number == 0 ? 1 : split_number;

			//++++ Input: Long segment sum_value, a&b, min&max point, width , right endpoint
			//++++ Output: Sub segment sum_value, a&b, min&max point, width , right endpoint, *right_subsegment != nullptr
			SplitSegmentByRealPLAArea(original_time_series, doubly_linked_list, split_number);
		}
		/*....................................................................................................*/

		/*================================get Segment Merged Infor====================================================*/
		for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
#if _DEBUG
			assert(doubly_linked_list[segment_id].right_subsegment != nullptr && doubly_linked_list[segment_id].sum_value != INF);
#endif
			pair_density.id = segment_id;
			if (doubly_linked_list[segment_id].already_compute == true) {
				pair_density.value = doubly_linked_list[segment_id].right_subsegment->segment_density;
				//pair_density.value = doubly_linked_list[vector_id].right_subsegment->area_difference;
#if _DEBUG
				assert(doubly_linked_list[segment_id].right_subsegment->rectangle_width == doubly_linked_list[segment_id - 1].rectangle_width + doubly_linked_list[segment_id].rectangle_width && doubly_linked_list[segment_id].right_subsegment->area_difference != INF);
				temp_coefficient_vector[segment_id] = *doubly_linked_list[segment_id].right_subsegment;
#endif
			}
			else {
				/*===============Get merged information======================*/
				//+++Input:
				//+++Output: sum value, a&b, segment Triangle Area Density, segment width, segment right end point, min&max point
				getMergedInfor0ForParallelogramImprove(doubly_linked_list, segment_id, temp_coefficient);//190611

#ifdef _DEBUG
				AREA_COEFFICIENT test_coefficient = temp_coefficient;
				getSegmentMinMaxPoint(original_time_series, test_coefficient);
				//assert(temp_coefficient.min_point.id == test_coefficient.min_point.id && temp_coefficient.max_point.id == test_coefficient.max_point.id);
				assert(temp_coefficient.min_point.value == test_coefficient.min_point.value && temp_coefficient.max_point.value == test_coefficient.max_point.value);
				assert(temp_coefficient.min_point.value == original_time_series[int(temp_coefficient.min_point.id)] && temp_coefficient.max_point.value == original_time_series[int(temp_coefficient.max_point.id)]);
#endif
				/*...........................................................*/
				/*==============Sort segment density=========================*/
				pair_density.value = temp_coefficient.segment_density;
				//pair_density.value = temp_coefficient.area_difference;
				//temp_coefficient.right_subsegment = new AREA_COEFFICIENT;
				/*........................................................*/

#if _DEBUG
				assert(temp_coefficient_vector.size() >= doubly_linked_list.size() && temp_coefficient.sum_value != INF && temp_coefficient.area_difference != INF);
				assert(temp_coefficient.rectangle_width == doubly_linked_list[segment_id - 1].rectangle_width + doubly_linked_list[segment_id].rectangle_width);
				//temp_coefficient_vector[vector_id] = temp_coefficient;
				temp_coefficient_vector[segment_id].apla = temp_coefficient.apla;
				temp_coefficient_vector[segment_id].sum_value = temp_coefficient.sum_value;
				temp_coefficient_vector[segment_id].right_endpoint = temp_coefficient.right_endpoint;
				temp_coefficient_vector[segment_id].rectangle_width = temp_coefficient.rectangle_width;
				temp_coefficient_vector[segment_id].segment_density = temp_coefficient.segment_density;

				temp_coefficient_vector[segment_id].min_point = temp_coefficient.min_point;//190725
				temp_coefficient_vector[segment_id].max_point = temp_coefficient.max_point;//190725
				temp_coefficient_vector[segment_id].area_difference = temp_coefficient.area_difference;
#endif

				/*=================Sub segment = long segment====================*/
				//*doubly_linked_list[vector_id].right_subsegment = temp_coefficient;
				doubly_linked_list[segment_id].right_subsegment->apla = temp_coefficient.apla;
				doubly_linked_list[segment_id].right_subsegment->sum_value = temp_coefficient.sum_value;
				doubly_linked_list[segment_id].right_subsegment->right_endpoint = temp_coefficient.right_endpoint;
				doubly_linked_list[segment_id].right_subsegment->rectangle_width = temp_coefficient.rectangle_width;
				doubly_linked_list[segment_id].right_subsegment->segment_density = temp_coefficient.segment_density;
				doubly_linked_list[segment_id].right_subsegment->increment_area = temp_coefficient.increment_area;
				doubly_linked_list[segment_id].already_compute = true;

				doubly_linked_list[segment_id].right_subsegment->min_point = temp_coefficient.min_point;//190725
				doubly_linked_list[segment_id].right_subsegment->max_point = temp_coefficient.max_point;//190725
				doubly_linked_list[segment_id].right_subsegment->area_difference = temp_coefficient.area_difference; //190724
				/*............................................................*/
			}

			max_density_id_set.emplace(pair_density);
			//map_if_merge.emplace_hint(map_if_merge.end(), segment_id, true);
		}
		/*..........................................................................................................*/

		int merge_id = 0;
		//int merge_number = ceil(doubly_linked_list.size() / 2);
		//int merge_number = ceil(sqrt(doubly_linked_list.size()));
		//int merge_number = floor(sqrt(doubly_linked_list.size()/2));
		int merge_number = floor(sqrt(doubly_linked_list.size()));
		merge_number = merge_number < 2 ? 2 : merge_number;
#if _DEBUG
		assert(merge_number > 0);
#endif

		/*=======================================================               1 Merge Segment                     ===========================================================*/
		for (auto it = max_density_id_set.begin(); it != max_density_id_set.end() && merge_id < merge_number; ++it) {
			int left_id = it->id - 1;
#if _DEBUG
			//cout << "candidate merge id: " << left_id << " "<< it->id<<" "<< area_vector[left_id].right_endpoint<<" "<< area_vector[it->id].right_endpoint <<endl;
			assert(doubly_linked_list[it->id].right_subsegment->right_endpoint == temp_coefficient_vector[it->id].right_endpoint);
			assert(doubly_linked_list[it->id].right_subsegment->rectangle_width == doubly_linked_list[left_id].rectangle_width + doubly_linked_list[it->id].rectangle_width && doubly_linked_list[it->id].right_subsegment->sum_value != INF);
#endif

			//area_vector[it->id] = *area_vector[it->id].right_subsegment;
			doubly_linked_list[it->id].apla = doubly_linked_list[it->id].right_subsegment->apla;
			doubly_linked_list[it->id].sum_value = doubly_linked_list[it->id].right_subsegment->sum_value;
			doubly_linked_list[it->id].right_endpoint = doubly_linked_list[it->id].right_subsegment->right_endpoint;
			doubly_linked_list[it->id].rectangle_width = doubly_linked_list[it->id].right_subsegment->rectangle_width;
			doubly_linked_list[it->id].segment_density = doubly_linked_list[it->id].right_subsegment->segment_density;
			doubly_linked_list[it->id].already_compute = false;

			doubly_linked_list[it->id].min_point = doubly_linked_list[it->id].right_subsegment->min_point;//190725
			doubly_linked_list[it->id].max_point = doubly_linked_list[it->id].right_subsegment->max_point;//190725

			doubly_linked_list[it->id].area_difference = doubly_linked_list[it->id].right_subsegment->area_difference;//190724
			/*---Test----*/
			doubly_linked_list[it->id].increment_area = doubly_linked_list[it->id].right_subsegment->increment_area;
			/*...........*/
			if (it->id < doubly_linked_list.size() - 1)
				doubly_linked_list[it->id + 1].already_compute = false;
#if _DEBUG
			assert(doubly_linked_list[it->id].right_endpoint == temp_coefficient_vector[it->id].right_endpoint);
#endif

			//doubly_linked_list[left_id].right_endpoint = INF;// .at(0);
			//doubly_linked_list[left_id].rectangle_width = INF;// .at(0);
			//merged_id = it->id+1;
			doubly_linked_list.remove(left_id);
			merge_count++;
			merge_id++;

			if (doubly_linked_list.size() - merge_count <= input_argument.point_dimension) {
				break;
			}
		}
		/*.......................................................................................................................................................................................*/

		//min_segment_density_queue = priority_queue <typename GEOMETRY::POINT, std::vector<typename GEOMETRY::POINT>, typename GEOMETRY::ValueIncrease>();
		map_if_merge.clear();
		max_density_id_set.clear();
	}
	//cout <<"vector size: " <<area_vector.size() << endl;

	/*for (auto&& i : area_vector) {
		cout << i.right_endpoint << " "<<i.rectangle_width << endl;
	}*/
}

//190827
//************************************
// Method:mergeOperationBatch2SetSpeedPointer
// Qualifier:190827 Use set to instead priority_queue. Improve mergeOperation0, use batch to speed up, and other speed up algorithm
// Input: new *right_subsegment
// Output:
// date:190827
// author:
//************************************
TEMPLATE
void APLA::mergeSplitOperationLink(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list) {
	assert(0);
#ifdef _DEBUG
	//evaluate right point, min&max point, width. a&b, sum value
	assertLinkedList(doubly_linked_list);
#endif

	multimap<double, DoublyListNode<AREA_COEFFICIENT>& const, std::greater<double>> split_area_difference_map;// area difference, node*
	multimap<double, DoublyListNode<AREA_COEFFICIENT>&, std::greater<double>> merge_segment_density_map;// long segment merged information, node*
	int segment_id = INF;

	/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    Get Split & Merge Information   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
	for (segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		/*-------------------------------------------------------------Get Split information----------------------------------------------------------------------------*/
#ifdef _DEBUG
		assert(doubly_linked_list[segment_id].right_subsegment != nullptr && doubly_linked_list[segment_id].apla.a != INF && doubly_linked_list[segment_id].apla.b != INF && doubly_linked_list[segment_id].right_endpoint != INF && doubly_linked_list[segment_id].rectangle_width != INF && doubly_linked_list[segment_id].sum_value != INF && doubly_linked_list[segment_id].max_point.value != INF && doubly_linked_list[segment_id].min_point.value != INF && doubly_linked_list[segment_id].max_point.id != INF && doubly_linked_list[segment_id].min_point.id != INF);
#endif
		/*--------------------------------------           Get Area difference        ----------------------------------------------*/

		//const auto& const area_difference = getAreaDifference(original_time_series, doubly_linked_list[segment_id]);
		const auto& const area_difference = getAreaDifference(original_time_series, doubly_linked_list[segment_id]);
		if (area_difference > 0)
			split_area_difference_map.emplace(area_difference, doubly_linked_list.getNode(segment_id));

		/*---------------------------------------------------------------------------------------------------------------------------*/
#ifdef _DEBUG
		assert(doubly_linked_list[segment_id].area_difference != INF);
#endif
		/*...........................................................................................................................................*/

		/*===========================================================          get If Merged Information        ================================================================*/
		/*----------------------Get merged information--------------------------*/
		//+++Input:
		//+++Output: sum value, a&b, segment Triangle Area Density, segment width, segment right end point, min&max point
		if (segment_id > 0) {
			//getMergedInfor0ForParallelogramImprove(doubly_linked_list, segment_id, *doubly_linked_list[segment_id].right_subsegment);//190611
			getMergedSubSegmentInformation(original_time_series, doubly_linked_list.getNode(segment_id));//200109
			//getMergedSubSegmentInformation(doubly_linked_list.getNode(segment_id));

#ifdef _DEBUG
			assert(doubly_linked_list[segment_id].right_subsegment->segment_density != NULL);
			const auto& const test_merged_segment = doubly_linked_list[segment_id].right_subsegment;
			AREA_COEFFICIENT test_coefficient = *doubly_linked_list[segment_id].right_subsegment;
			getSegmentMinMaxPoint(original_time_series, test_coefficient);
			int test_segment_left_id = test_merged_segment->right_endpoint - test_merged_segment->rectangle_width + 1;
			assert(test_merged_segment->min_point.id <= test_merged_segment->right_endpoint && test_merged_segment->max_point.id <= test_merged_segment->right_endpoint && test_merged_segment->min_point.id >= test_segment_left_id && test_merged_segment->max_point.id >= test_segment_left_id);
			assert(test_merged_segment->min_point.value == test_coefficient.min_point.value && test_merged_segment->max_point.value == test_coefficient.max_point.value);
			assert(test_merged_segment->min_point.value == original_time_series[int(test_merged_segment->min_point.id)] && test_merged_segment->max_point.value == original_time_series[int(test_merged_segment->max_point.id)]);
#endif
			merge_segment_density_map.emplace(doubly_linked_list[segment_id].right_subsegment->segment_density, doubly_linked_list.getNode(segment_id));
		}
		/*...........................................................*/
		/*......................................................................................................................................................................*/
	}
	/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
#ifdef _DEBUG
	//assert(doubly_linked_list.size() >= input_argument.point_dimension);
	for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
		//cout << doubly_linked_list[segment_id].right_endpoint << "," << doubly_linked_list[segment_id].rectangle_width << "; ";
		//cout << doubly_linked_list[segment_id].area_difference << " ";
		assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint && doubly_linked_list[segment_id].area_difference != INF);
		assert(doubly_linked_list[segment_id].right_subsegment->rectangle_width == doubly_linked_list[segment_id].rectangle_width + doubly_linked_list[segment_id - 1].rectangle_width && doubly_linked_list[segment_id].right_subsegment->area_difference != INF);
	}
#endif

	/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Operation  Split & Merge  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
	while (doubly_linked_list.size() > input_argument.point_dimension) {
		splitSegmentBySlope(original_time_series, merge_segment_density_map, split_area_difference_map, doubly_linked_list);
		/*===========================200129 Approximaiton Process=================*/
		//write_reconstruct_time_series("./200129ApproximationProcess/ReconstructionTimeSeries", doubly_linked_list);
		/*=======================================================================*/
		mergeSegmentByDensity(original_time_series, merge_segment_density_map, split_area_difference_map, doubly_linked_list);
		/*===========================200129 Approximaiton Process=================*/
		//write_reconstruct_time_series("./200129ApproximationProcess/ReconstructionTimeSeries", doubly_linked_list);
		/*=======================================================================*/
		mergeSegmentByDensity(original_time_series, merge_segment_density_map, split_area_difference_map, doubly_linked_list);
		/*===========================200129 Approximaiton Process=================*/
		//write_reconstruct_time_series("./200129ApproximationProcess/ReconstructionTimeSeries", doubly_linked_list);
		/*=======================================================================*/

#ifdef _DEBUG
		//assert(doubly_linked_list.size() >= input_argument.point_dimension);
		for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
			//cout << doubly_linked_list[segment_id].area_difference << " ";
			if (doubly_linked_list[segment_id].area_difference > 0) {
				auto test_area_difference = split_area_difference_map.find(doubly_linked_list[segment_id].area_difference);
				if (test_area_difference == split_area_difference_map.end()) {
					std::cout << "Not found\n";
					assert(0);
				}
			}
			if (segment_id > 0) {
				auto test_segment_density = merge_segment_density_map.find(doubly_linked_list[segment_id].right_subsegment->segment_density);
				if (test_segment_density == merge_segment_density_map.end()) {
					std::cout << "Not found\n";
					assert(0);
				}
			}

			//assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint && doubly_linked_list[segment_id].area_difference != INF);
			//assert(doubly_linked_list[segment_id].right_subsegment->rectangle_width == doubly_linked_list[segment_id].rectangle_width + doubly_linked_list[segment_id - 1].rectangle_width && doubly_linked_list[segment_id].right_subsegment->area_difference != INF);
		}
#endif
	}
	while (doubly_linked_list.size() < input_argument.point_dimension) {

		/*--------------------------191124 for burst time series-------------*/
		if (split_area_difference_map.size() == 0) {
#ifdef _DEBUG
			assert(input_argument.point_dimension != INF);
#endif
			split_burst_segment(original_time_series, input_argument.point_dimension, doubly_linked_list);
			/*=========================*/
			/*=========================*/
			break;
		}
		/*-------------------------------------------------------------------*/
		splitSegmentBySlope(original_time_series, merge_segment_density_map, split_area_difference_map, doubly_linked_list);

		/*--------------------------191124 for burst time series-------------*/
		if (split_area_difference_map.size() == 0) {
#ifdef _DEBUG
			assert(input_argument.point_dimension != INF);
#endif
			split_burst_segment(original_time_series, input_argument.point_dimension, doubly_linked_list);
			break;
		}
		/*-------------------------------------------------------------------*/
		splitSegmentBySlope(original_time_series, merge_segment_density_map, split_area_difference_map, doubly_linked_list);
		mergeSegmentByDensity(original_time_series, merge_segment_density_map, split_area_difference_map, doubly_linked_list);

#ifdef _DEBUG
		//assert(doubly_linked_list.size() >= input_argument.point_dimension);
		for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
			//cout << doubly_linked_list[segment_id].area_difference << " ";
			if (doubly_linked_list[segment_id].area_difference > 0) {
				auto test_area_difference = split_area_difference_map.find(doubly_linked_list[segment_id].area_difference);
				if (test_area_difference == split_area_difference_map.end()) {
					std::cout << "Not found\n";
					assert(0);
				}
			}
			if (segment_id > 0) {
				auto test_segment_density = merge_segment_density_map.find(doubly_linked_list[segment_id].right_subsegment->segment_density);
				if (test_segment_density == merge_segment_density_map.end()) {
					std::cout << "Not found\n";
					assert(0);
				}
			}

			//assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint && doubly_linked_list[segment_id].area_difference != INF);
			//assert(doubly_linked_list[segment_id].right_subsegment->rectangle_width == doubly_linked_list[segment_id].rectangle_width + doubly_linked_list[segment_id - 1].rectangle_width && doubly_linked_list[segment_id].right_subsegment->area_difference != INF);
		}
#endif
	}
#ifdef _DEBUG
	for (auto&& au : doubly_linked_list) {
		assert(au.sum_value != INF);
	}
	//assertLinkedListAndSubLinkedList(doubly_linked_list);
#endif

	//	while (doubly_linked_list.size() != input_argument.point_dimension) {
//		while (doubly_linked_list.size() < input_argument.point_dimension) {
//			splitSegmentBySlope(original_time_series, merge_segment_density_map, split_area_difference_map, doubly_linked_list);
//		}
//
//#ifdef _DEBUG
//		//assert(doubly_linked_list.size() >= input_argument.point_dimension);
//		for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
//			//cout << doubly_linked_list[segment_id].area_difference << " ";
//			if (doubly_linked_list[segment_id].area_difference > 0) {
//				auto test_area_difference = split_area_difference_map.find(doubly_linked_list[segment_id].area_difference);
//				if (test_area_difference == split_area_difference_map.end()) {
//					std::cout << "Not found\n";
//					assert(0);
//				}
//			}
//			if (segment_id > 0) {
//				auto test_segment_density = merge_segment_density_map.find(doubly_linked_list[segment_id].right_subsegment->segment_density);
//				if (test_segment_density == merge_segment_density_map.end()) {
//					std::cout << "Not found\n";
//					assert(0);
//				}
//			}
//
//			//assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint && doubly_linked_list[segment_id].area_difference != INF);
//			//assert(doubly_linked_list[segment_id].right_subsegment->rectangle_width == doubly_linked_list[segment_id].rectangle_width + doubly_linked_list[segment_id - 1].rectangle_width && doubly_linked_list[segment_id].right_subsegment->area_difference != INF);
//		}
//#endif
//
//		while (doubly_linked_list.size() > input_argument.point_dimension) {
//			mergeSegmentByDensity(original_time_series, merge_segment_density_map, split_area_difference_map, doubly_linked_list);
//#ifdef _DEBUG
//			//assert(doubly_linked_list.size() >= input_argument.point_dimension);
//			for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
//				//cout << doubly_linked_list[segment_id].area_difference << " ";
//				if (doubly_linked_list[segment_id].area_difference > 0) {
//					auto test_area_difference = split_area_difference_map.find(doubly_linked_list[segment_id].area_difference);
//					if (test_area_difference == split_area_difference_map.end()) {
//						std::cout << "Not found\n";
//						assert(0);
//					}
//				}
//				if (segment_id > 0) {
//					auto test_segment_density = merge_segment_density_map.find(doubly_linked_list[segment_id].right_subsegment->segment_density);
//					if (test_segment_density == merge_segment_density_map.end()) {
//						std::cout << "Not found\n";
//						assert(0);
//					}
//				}
//				//assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint && doubly_linked_list[segment_id].area_difference != INF);
//				//assert(doubly_linked_list[segment_id].right_subsegment->rectangle_width == doubly_linked_list[segment_id].rectangle_width + doubly_linked_list[segment_id - 1].rectangle_width && doubly_linked_list[segment_id].right_subsegment->area_difference != INF);
//			}
//#endif
//		}
//	}
	/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
}

//200212 Add template. Change time series from pointer to vector
//************************************
// Method:mergeOperationBatch2SetSpeedPointer
// Qualifier:190827 Use set to instead priority_queue. Improve mergeOperation0, use batch to speed up, and other speed up algorithm
// Input: new *right_subsegment
// Output:
// Notice: 200213 Remove Min Max point and its function
// date:200212
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
void APLA::mergeSplitOperationLink(U& input_argument, const vector<T>& const original_time_series_vector, DoublyLinkedList<Y>& const doubly_linked_list) {
	assert(0);
#ifdef _DEBUG
	//evaluate right point, min&max point, width. a&b, sum value
	assertLinkedList(doubly_linked_list);
#endif

	multimap<double, DoublyListNode<Y>& const, std::greater<double>> split_area_difference_map;// area difference, node*
	multimap<double, DoublyListNode<Y>&, std::greater<double>> merge_segment_density_map;// long segment merged information, node*
	int segment_id = INF;

	/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    Get Split & Merge Information   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
	for (segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		/*-------------------------------------------------------------Get Split information----------------------------------------------------------------------------*/
#ifdef _DEBUG
		assert(doubly_linked_list[segment_id].right_subsegment != nullptr && doubly_linked_list[segment_id].apla.a != INF && doubly_linked_list[segment_id].apla.b != INF && doubly_linked_list[segment_id].right_endpoint != INF && doubly_linked_list[segment_id].rectangle_width != INF && doubly_linked_list[segment_id].sum_value != INF && doubly_linked_list[segment_id].max_point.value != INF && doubly_linked_list[segment_id].min_point.value != INF && doubly_linked_list[segment_id].max_point.id != INF && doubly_linked_list[segment_id].min_point.id != INF);
#endif
		/*--------------------------------------           Get Area difference        ----------------------------------------------*/

		//const auto& const area_difference = getAreaDifference(original_time_series, doubly_linked_list[segment_id]);
		const auto& const area_difference = getAreaDifference(original_time_series_vector, doubly_linked_list[segment_id]);
		if (area_difference > 0)
			split_area_difference_map.emplace(area_difference, doubly_linked_list.getNode(segment_id));

		/*---------------------------------------------------------------------------------------------------------------------------*/
#ifdef _DEBUG
		assert(doubly_linked_list[segment_id].area_difference != INF);
#endif
		/*...........................................................................................................................................*/

		/*===========================================================          get If Merged Information        ================================================================*/
		/*----------------------Get merged information--------------------------*/
		//+++Input:
		//+++Output: sum value, a&b, segment Triangle Area Density, segment width, segment right end point, min&max point
		if (segment_id > 0) {
			//getMergedInfor0ForParallelogramImprove(doubly_linked_list, segment_id, *doubly_linked_list[segment_id].right_subsegment);//190611
			getMergedSubSegmentInformation(original_time_series_vector, doubly_linked_list.getNode(segment_id));//200109
			//getMergedSubSegmentInformation(doubly_linked_list.getNode(segment_id));

#ifdef _DEBUG
			assert(doubly_linked_list[segment_id].right_subsegment->segment_density != NULL);
			const auto& const test_merged_segment = doubly_linked_list[segment_id].right_subsegment;
			AREA_COEFFICIENT test_coefficient = *doubly_linked_list[segment_id].right_subsegment;
			//getSegmentMinMaxPoint(original_time_series_vector, test_coefficient);
			int test_segment_left_id = test_merged_segment->right_endpoint - test_merged_segment->rectangle_width + 1;
#endif
			merge_segment_density_map.emplace(doubly_linked_list[segment_id].right_subsegment->segment_density, doubly_linked_list.getNode(segment_id));
		}
		/*...........................................................*/
		/*......................................................................................................................................................................*/
	}
	/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
#ifdef _DEBUG
	//assert(doubly_linked_list.size() >= input_argument.point_dimension);
	for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
		//cout << doubly_linked_list[segment_id].right_endpoint << "," << doubly_linked_list[segment_id].rectangle_width << "; ";
		//cout << doubly_linked_list[segment_id].area_difference << " ";
		assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint && doubly_linked_list[segment_id].area_difference != INF);
		assert(doubly_linked_list[segment_id].right_subsegment->rectangle_width == doubly_linked_list[segment_id].rectangle_width + doubly_linked_list[segment_id - 1].rectangle_width && doubly_linked_list[segment_id].right_subsegment->area_difference != INF);
	}
#endif

	/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Operation  Split & Merge  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
	while (doubly_linked_list.size() > input_argument.point_dimension) {
		splitSegmentBySlope(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list);
		/*===========================200129 Approximaiton Process=================*/
		//write_reconstruct_time_series("./200129ApproximationProcess/ReconstructionTimeSeries", doubly_linked_list);
		/*=======================================================================*/
		mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list);
		/*===========================200129 Approximaiton Process=================*/
		//write_reconstruct_time_series("./200129ApproximationProcess/ReconstructionTimeSeries", doubly_linked_list);
		/*=======================================================================*/
		mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list);
		/*===========================200129 Approximaiton Process=================*/
		//write_reconstruct_time_series("./200129ApproximationProcess/ReconstructionTimeSeries", doubly_linked_list);
		/*=======================================================================*/

#ifdef _DEBUG
		//assert(doubly_linked_list.size() >= input_argument.point_dimension);
		for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
			//cout << doubly_linked_list[segment_id].area_difference << " ";
			if (doubly_linked_list[segment_id].area_difference > 0) {
				auto test_area_difference = split_area_difference_map.find(doubly_linked_list[segment_id].area_difference);
				if (test_area_difference == split_area_difference_map.end()) {
					std::cout << "Not found\n";
					assert(0);
				}
			}
			if (segment_id > 0) {
				auto test_segment_density = merge_segment_density_map.find(doubly_linked_list[segment_id].right_subsegment->segment_density);
				if (test_segment_density == merge_segment_density_map.end()) {
					std::cout << "Not found\n";
					assert(0);
				}
			}

			//assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint && doubly_linked_list[segment_id].area_difference != INF);
			//assert(doubly_linked_list[segment_id].right_subsegment->rectangle_width == doubly_linked_list[segment_id].rectangle_width + doubly_linked_list[segment_id - 1].rectangle_width && doubly_linked_list[segment_id].right_subsegment->area_difference != INF);
		}
#endif
	}
	while (doubly_linked_list.size() < input_argument.point_dimension) {

		/*--------------------------191124 for burst time series-------------*/
		if (split_area_difference_map.size() == 0) {
#ifdef _DEBUG
			assert(input_argument.point_dimension != INF);
#endif
			split_burst_segment(original_time_series_vector, input_argument.point_dimension, doubly_linked_list);
			/*=========================*/
			/*=========================*/
			break;
		}
		/*-------------------------------------------------------------------*/
		splitSegmentBySlope(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list);

		/*--------------------------191124 for burst time series-------------*/
		if (split_area_difference_map.size() == 0) {
#ifdef _DEBUG
			assert(input_argument.point_dimension != INF);
#endif
			split_burst_segment(original_time_series_vector, input_argument.point_dimension, doubly_linked_list);
			break;
		}
		/*-------------------------------------------------------------------*/
		splitSegmentBySlope(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list);
		mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list);

#ifdef _DEBUG
		//assert(doubly_linked_list.size() >= input_argument.point_dimension);
		for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
			//cout << doubly_linked_list[segment_id].area_difference << " ";
			if (doubly_linked_list[segment_id].area_difference > 0) {
				auto test_area_difference = split_area_difference_map.find(doubly_linked_list[segment_id].area_difference);
				if (test_area_difference == split_area_difference_map.end()) {
					std::cout << "Not found\n";
					assert(0);
				}
			}
			if (segment_id > 0) {
				auto test_segment_density = merge_segment_density_map.find(doubly_linked_list[segment_id].right_subsegment->segment_density);
				if (test_segment_density == merge_segment_density_map.end()) {
					std::cout << "Not found\n";
					assert(0);
				}
			}

			//assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint && doubly_linked_list[segment_id].area_difference != INF);
			//assert(doubly_linked_list[segment_id].right_subsegment->rectangle_width == doubly_linked_list[segment_id].rectangle_width + doubly_linked_list[segment_id - 1].rectangle_width && doubly_linked_list[segment_id].right_subsegment->area_difference != INF);
		}
#endif
	}
#ifdef _DEBUG
	for (auto&& au : doubly_linked_list) {
		assert(au.sum_value != INF);
	}
	//assertLinkedListAndSubLinkedList(doubly_linked_list);
#endif

	//	while (doubly_linked_list.size() != input_argument.point_dimension) {
//		while (doubly_linked_list.size() < input_argument.point_dimension) {
//			splitSegmentBySlope(original_time_series, merge_segment_density_map, split_area_difference_map, doubly_linked_list);
//		}
//
//#ifdef _DEBUG
//		//assert(doubly_linked_list.size() >= input_argument.point_dimension);
//		for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
//			//cout << doubly_linked_list[segment_id].area_difference << " ";
//			if (doubly_linked_list[segment_id].area_difference > 0) {
//				auto test_area_difference = split_area_difference_map.find(doubly_linked_list[segment_id].area_difference);
//				if (test_area_difference == split_area_difference_map.end()) {
//					std::cout << "Not found\n";
//					assert(0);
//				}
//			}
//			if (segment_id > 0) {
//				auto test_segment_density = merge_segment_density_map.find(doubly_linked_list[segment_id].right_subsegment->segment_density);
//				if (test_segment_density == merge_segment_density_map.end()) {
//					std::cout << "Not found\n";
//					assert(0);
//				}
//			}
//
//			//assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint && doubly_linked_list[segment_id].area_difference != INF);
//			//assert(doubly_linked_list[segment_id].right_subsegment->rectangle_width == doubly_linked_list[segment_id].rectangle_width + doubly_linked_list[segment_id - 1].rectangle_width && doubly_linked_list[segment_id].right_subsegment->area_difference != INF);
//		}
//#endif
//
//		while (doubly_linked_list.size() > input_argument.point_dimension) {
//			mergeSegmentByDensity(original_time_series, merge_segment_density_map, split_area_difference_map, doubly_linked_list);
//#ifdef _DEBUG
//			//assert(doubly_linked_list.size() >= input_argument.point_dimension);
//			for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
//				//cout << doubly_linked_list[segment_id].area_difference << " ";
//				if (doubly_linked_list[segment_id].area_difference > 0) {
//					auto test_area_difference = split_area_difference_map.find(doubly_linked_list[segment_id].area_difference);
//					if (test_area_difference == split_area_difference_map.end()) {
//						std::cout << "Not found\n";
//						assert(0);
//					}
//				}
//				if (segment_id > 0) {
//					auto test_segment_density = merge_segment_density_map.find(doubly_linked_list[segment_id].right_subsegment->segment_density);
//					if (test_segment_density == merge_segment_density_map.end()) {
//						std::cout << "Not found\n";
//						assert(0);
//					}
//				}
//				//assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint && doubly_linked_list[segment_id].area_difference != INF);
//				//assert(doubly_linked_list[segment_id].right_subsegment->rectangle_width == doubly_linked_list[segment_id].rectangle_width + doubly_linked_list[segment_id - 1].rectangle_width && doubly_linked_list[segment_id].right_subsegment->area_difference != INF);
//			}
//#endif
//		}
//	}
	/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
}

//200212 Add template. Change time series from pointer to vector
//200212 Add template. Change time series from pointer to vector
//************************************
// Method:mergeOperationBatch2SetSpeedPointer
// Qualifier:190827 Use set to instead priority_queue. Improve mergeOperation0, use batch to speed up, and other speed up algorithm
// Input: new *right_subsegment
// Output:
// Notice: 200213 Remove Min Max point and its function
// date:200212
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U, typename U1>
void APLA::mergeSplitOperationLink(U& input_argument, const vector<T>& const original_time_series_vector, DoublyLinkedList<Y>& const doubly_linked_list, U1& const output_argument) {

	/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    MAP: split & merge  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
	multimap<double, DoublyListNode<Y>& const, std::greater<double>> split_area_difference_map;// area difference, node*
	multimap<double, DoublyListNode<Y>&, std::greater<double>> merge_segment_density_map;// long segment merged information, node*
	int segment_id = INF;
	/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

	/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    Get Split & Merge Information   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
	for (segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {

		/*########################    reference node and value in linkedlist    ################################################*/
		auto& const node_segment_current = doubly_linked_list.getNode(segment_id);
		auto& const value_segment_current = node_segment_current._value;
		/*######################################################################################################################*/

		//getSegmentMinMaxPoint(original_time_series_vector, value_segment_current);

		/*########################################                 scan get a&b of each segment             ###############################################################*/
		// a == INF means: this segment has no a&b, no min&max computation. has not been splitted
		if (value_segment_current.apla.a == INF) {

			/*............................................................................................................*/
#ifdef _DEBUG
			assert(value_segment_current.apla.b == INF && value_segment_current.right_subsegment->segment_density == INF);
#endif
			/*............................................................................................................*/

			/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!          get a&b or minmax of each segment         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

			/*++++++++++++++++++++++++++      Only get a&b     ++++++++++++++++++++++++++++++++++++++++*/
			//get_ab_segment(original_time_series_vector, value_segment_current);
			/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

			/*+++++++++++++++++++    200423 get a&b, min&max points   +++++++++++++++++++++++++++++++++*/
			get_ab_minmax_segment(original_time_series_vector, value_segment_current);
			/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

			/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		}

		/*.....................................................................................................................................................*/
#ifdef _DEBUG
		else {//evaluate a&b of segment
			Y test_splitted_segment = value_segment_current;
			/*..................get a&b of one segment...............*/
			get_ab_segment(original_time_series_vector, test_splitted_segment);
			/*......................................................*/
			assert_two_segments_a_b(test_splitted_segment, value_segment_current);
			//assert_segment_a_b(value_segment_current);
			assert_segment_a_b_minmax(original_time_series_vector, value_segment_current);
		}
		//assert(value_segment_current.right_subsegment != nullptr && value_segment_current.apla.a != INF && value_segment_current.apla.b != INF && value_segment_current.right_endpoint != INF && value_segment_current.rectangle_width != INF && value_segment_current.sum_value != INF && value_segment_current.max_point.value != INF && value_segment_current.min_point.value != INF && value_segment_current.max_point.id != INF && value_segment_current.min_point.id != INF);
		//200314 minmax point
		assert(value_segment_current.right_subsegment != nullptr && value_segment_current.apla.a != INF && value_segment_current.apla.b != INF && value_segment_current.right_endpoint != INF && value_segment_current.rectangle_width != INF);
#endif
		/*.....................................................................................................................................................*/

		/*##################################################################################################################################################################*/

		/*#######################################                      Get Split information                  ##############################################################*/

		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!           Get Area difference           !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		//const auto& const area_difference = getAreaDifference(original_time_series, doubly_linked_list[segment_id]);
		const auto& const area_difference = getAreaDifference(original_time_series_vector, value_segment_current);
		if (area_difference > 0 && value_segment_current.rectangle_width > 3)
			split_area_difference_map.emplace(area_difference, node_segment_current);
		/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

		/*.................................................................................................................................*/
#ifdef _DEBUG
		assert(value_segment_current.area_difference != INF);
		assert_segment_a_b(value_segment_current);
#endif
		/*.................................................................................................................................*/

		/*###################################################################################################################################################################*/

		/*#####################################################         Get merged information                         ######################################################*/
		//+++Output: sum value, a&b, segment Triangle Area Density, segment width, segment right end point, min&max point
		if (segment_id > 0) {

			/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!    get merged informaiton   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
			if (value_segment_current.right_subsegment->segment_density == INF) {
				//getMergedInfor0ForParallelogramImprove(doubly_linked_list, segment_id, *doubly_linked_list[segment_id].right_subsegment);//190611
				getMergedSubSegmentInformation(original_time_series_vector, node_segment_current, output_argument);//200109
				//getMergedSubSegmentInformation(doubly_linked_list.getNode(segment_id));
			}
			/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

			/*.................................................................................................................................*/
#ifdef _DEBUG
			const auto& const test_merged_segment = value_segment_current.right_subsegment;
			Y test_coefficient = *value_segment_current.right_subsegment;
			get_ab_segment(original_time_series_vector, test_coefficient);
			assert_two_segments_a_b(test_coefficient, *value_segment_current.right_subsegment);
			test_coefficient = *value_segment_current.right_subsegment;
			getLineSegmentTriangleAreaDensity(node_segment_current._prev->_value, value_segment_current, test_coefficient);//190611
			if (value_segment_current.right_subsegment->segment_density != INF) {
				assert(test_coefficient.segment_density != INF && fabs(value_segment_current.right_subsegment->segment_density - test_coefficient.segment_density) <= 1);
			}
#endif
			/*.................................................................................................................................*/

			/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!     MAP insertion: Density     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
			merge_segment_density_map.emplace(value_segment_current.right_subsegment->segment_density, node_segment_current);
			/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		}
		/*####################################################################################################################################################################*/
	}
	/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

	/*...............................................................................................................................*/
#ifdef _DEBUG
	//assert_minmax_value(original_time_series_vector, doubly_linked_list);
	//evaluate right point, min&max point, width. a&b, sum value
	assertLinkedList(doubly_linked_list);
	//assert(doubly_linked_list.size() >= input_argument.point_dimension);
	for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
		//cout << doubly_linked_list[segment_id].right_endpoint << "," << doubly_linked_list[segment_id].rectangle_width << "; ";
		//cout << doubly_linked_list[segment_id].area_difference << " ";
		assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint && doubly_linked_list[segment_id].area_difference != INF);
		assert(doubly_linked_list[segment_id].right_subsegment->rectangle_width == doubly_linked_list[segment_id].rectangle_width + doubly_linked_list[segment_id - 1].rectangle_width && doubly_linked_list[segment_id].right_subsegment->area_difference != INF);
	}
#endif
	/*...............................................................................................................................*/

	/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Operation  Split & Merge  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
	while (doubly_linked_list.size() > input_argument.point_dimension) {

		/*#########################################################################################################################*/
		/*===========================200129 Approximaiton Process=================*/
		splitSegmentBySlope(original_time_series_vector, input_argument.option_split_method, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
		/*========================================================================*/
		/*===========================200129 Approximaiton Process=================*/
		mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
		/*========================================================================*/
		/*===========================200129 Approximaiton Process=================*/
		mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
		/*=======================================================================*/
		/*#########################################################################################################################*/

		/*....................................................................................................................................*/
#ifdef _DEBUG
		assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
#endif
		/*....................................................................................................................................*/

	}
	/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

	/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
	while (doubly_linked_list.size() < input_argument.point_dimension) {

		/*#################     191124 for burst time series   #########################*/
		if (split_area_difference_map.size() == 0) {
			/*.........................................................*/
#ifdef _DEBUG
			assert(input_argument.point_dimension != INF);
#endif
			/*.........................................................*/

			/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
			split_burst_segment(original_time_series_vector, input_argument.point_dimension, doubly_linked_list);
			/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

			break;

		}
		/*#############################################################################*/

		/*#############################################################################*/
		splitSegmentBySlope(original_time_series_vector, input_argument.option_split_method, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
		/*#############################################################################*/

		/*#############################    191124 for burst time series     ########################*/
		if (split_area_difference_map.size() == 0) {

			/*.........................................................*/
#ifdef _DEBUG
			assert(input_argument.point_dimension != INF);
#endif
			/*.........................................................*/

			/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
			split_burst_segment(original_time_series_vector, input_argument.point_dimension, doubly_linked_list);
			/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
			break;
		}
		/*#########################################################################################*/

		/*#########################################################################################*/
		splitSegmentBySlope(original_time_series_vector, input_argument.option_split_method, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
		mergeSegmentByDensity(original_time_series_vector, merge_segment_density_map, split_area_difference_map, doubly_linked_list, output_argument);
		/*#########################################################################################*/

		/*..............................................................................................................................*/
#ifdef _DEBUG
		assert_loop_segment_density_area_difference(doubly_linked_list, split_area_difference_map, merge_segment_density_map);
#endif
		/*..............................................................................................................................*/

	}
	/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

}

//************************************
// Method:yProjectionAPLA
// Qualifier:get adaptive right end point throgh y projection. most static points
// Input:
// Output: For all height difference points, get all segemnts.
// date:190729
// author:
//************************************
TEMPLATE
void APLA::yProjectionAPLAInitial(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, const map<double, int>& const whole_difference_map, vector<AREA_COEFFICIENT>& const area_vector) {
#if _DEBUG
	assert(!whole_difference_map.empty());
#endif

	vector<AREA_COEFFICIENT> temp_area_vector;
	AREA_COEFFICIENT temp_coefficient;
	AREA_COEFFICIENT static_burst_coefficient;
	double flat_segment_min = INF, flat_segment_max = INF;// min max value in flat segment

	/*===========================Get Threshhold of burst time series=====================*/
	flat_segment_min = whole_difference_map.begin()->first;//min value
	auto height_difference_second_min_map = next(whole_difference_map.begin(), 1);
	double threshhold_divide = whole_difference_map.begin()->second / height_difference_second_min_map->second;
	double threshhold = INF;
	if (threshhold_divide > 2) {
		threshhold = whole_difference_map.begin()->first;
	}
	else {
		threshhold = height_difference_second_min_map->first;
	}

	flat_segment_max = threshhold;
	/*======================================================================================*/

	//Except flat segment. mountain segment max min value is same.
	/*======================================  Get Initial segment  =============================================================================*/
	for (int array_id = 0; array_id < input_argument.time_series_length; array_id++) {
		/*===================================   Not flat segment  ===================================================================*/
		if (original_time_series[array_id] > threshhold) {
			/*=========================    Meet Split point: Flat Segmnt + Mountain Segment  ==============================*/
			if (original_time_series[array_id] != original_time_series[array_id - 1]) {
				/*=========================    Get Flat Segment    ==========================================*/
				if (original_time_series[array_id - 1] <= threshhold) {
					static_burst_coefficient.y_projection_coefficient.is_flat = true;
					static_burst_coefficient.right_endpoint = array_id - 1;
					static_burst_coefficient.segment_right_point.id = static_burst_coefficient.right_endpoint;
					static_burst_coefficient.segment_right_point.value = original_time_series[int(static_burst_coefficient.right_endpoint)];
					static_burst_coefficient.min_point.value = flat_segment_min;
					static_burst_coefficient.max_point.value = flat_segment_max;
					static_burst_coefficient.rectangle_height = static_burst_coefficient.max_point.value - static_burst_coefficient.min_point.value;

					if (temp_area_vector.empty()) {
						/*--------------------------------   First Segment   -----------------------------*/
						static_burst_coefficient.rectangle_width = static_burst_coefficient.right_endpoint + 1;
						static_burst_coefficient.segment_left_point.id = 0;
						static_burst_coefficient.segment_left_point.value = original_time_series[0];
						static_burst_coefficient.y_projection_coefficient.segment_left_height_difference = 0;
						/*...............................................................................*/
					}
					else {
						/*--------------------------------   Not First Segment   -------------------------*/
						static_burst_coefficient.rectangle_width = static_burst_coefficient.right_endpoint - temp_area_vector.back().right_endpoint;
						static_burst_coefficient.segment_left_point.id = temp_area_vector.back().right_endpoint + 1;
						static_burst_coefficient.segment_left_point.value = original_time_series[int(temp_area_vector.back().right_endpoint) + 1];
						static_burst_coefficient.y_projection_coefficient.segment_left_height_difference = static_burst_coefficient.segment_left_point.value - temp_area_vector.back().segment_right_point.value;
						temp_area_vector.back().y_projection_coefficient.segment_right_height_difference = static_burst_coefficient.y_projection_coefficient.segment_left_height_difference * -1;
						/*...............................................................................*/
#if _DEBUG
						assert(temp_area_vector.back().right_endpoint + 1 == static_burst_coefficient.segment_left_point.id && temp_area_vector.back().segment_right_point.id == temp_area_vector.back().right_endpoint);
#endif
					}

					temp_area_vector.emplace_back(static_burst_coefficient);
#if _DEBUG
					assert(temp_area_vector.back().segment_right_point.id == temp_area_vector.back().right_endpoint);
#endif
				}
				/*.........................................................................................*/

				/*----------------------------------------------------   Mountain Segment   ----------------------------------------------*/
				temp_coefficient.right_endpoint = array_id;
				temp_coefficient.segment_right_point.id = temp_coefficient.right_endpoint;
				temp_coefficient.segment_right_point.value = original_time_series[int(temp_coefficient.right_endpoint)];
				temp_coefficient.min_point.value = temp_coefficient.segment_right_point.value;
				temp_coefficient.max_point.value = temp_coefficient.segment_right_point.value;
				temp_coefficient.rectangle_height = 0;
				if (temp_area_vector.empty()) {
					/*---------------------First Segment----------------------------*/
					temp_coefficient.rectangle_width = temp_coefficient.right_endpoint + 1;
					temp_coefficient.segment_left_point.id = 0;
					temp_coefficient.segment_left_point.value = original_time_series[0];
					temp_coefficient.y_projection_coefficient.segment_left_height_difference = 0;
					/*--------------------------------------------------------------*/
				}
				else {
					/*---------------------------Not First Segment------------------*/
					temp_coefficient.rectangle_width = temp_coefficient.right_endpoint - temp_area_vector.back().right_endpoint;
					temp_coefficient.segment_left_point.id = temp_area_vector.back().right_endpoint + 1;
					temp_coefficient.segment_left_point.value = original_time_series[int(temp_area_vector.back().right_endpoint) + 1];
					temp_coefficient.y_projection_coefficient.segment_left_height_difference = temp_coefficient.segment_left_point.value - temp_area_vector.back().segment_right_point.value;
					temp_area_vector.back().y_projection_coefficient.segment_right_height_difference = temp_coefficient.y_projection_coefficient.segment_left_height_difference * -1;
					/*--------------------------------------------------------------*/
				}
				/*--------------------------------------------------------------------------------------------------------------------------*/
#if _DEBUG
				assert(temp_area_vector.back().right_endpoint + 1 == temp_coefficient.segment_left_point.id && temp_area_vector.back().segment_right_point.id == temp_area_vector.back().right_endpoint && temp_coefficient.segment_left_point.value == temp_coefficient.segment_right_point.value);
#endif
				temp_area_vector.emplace_back(temp_coefficient);
				/*...................................................................................................................*/
			}
			else {
				/*===========================================    Extend Segment    ================================================*/
				if (temp_area_vector.empty()) {
					assert(0);
				}
				else {
					temp_area_vector.back().right_endpoint++;
#if _DEBUG
					assert(temp_area_vector.back().segment_right_point.value == original_time_series[int(temp_coefficient.right_endpoint)]);
#endif
					temp_area_vector.back().segment_right_point.id = temp_area_vector.back().right_endpoint;
					temp_area_vector.back().rectangle_width++;
				}
				/*...................................................................................................................*/
			}
		}
		/*........................................................................................*/
	}
	/*.........................................................................................................................................................................*/

	/*======If Last segment is flat, remember to push back it======*/
	if (temp_area_vector.back().right_endpoint < input_argument.time_series_length - 1) {
		temp_coefficient.y_projection_coefficient.is_flat = true;
		temp_coefficient.right_endpoint = input_argument.time_series_length - 1;
		temp_coefficient.segment_right_point.id = temp_coefficient.right_endpoint;
		temp_coefficient.segment_right_point.value = original_time_series[int(temp_coefficient.right_endpoint)];
		//temp_coefficient.min_point.value = temp_coefficient.segment_right_point.value;
		//temp_coefficient.max_point.value = temp_coefficient.segment_right_point.value;
		temp_coefficient.min_point.value = flat_segment_min;
		temp_coefficient.max_point.value = flat_segment_max;
		temp_coefficient.rectangle_height = static_burst_coefficient.max_point.value - static_burst_coefficient.min_point.value;
		temp_coefficient.rectangle_width = temp_coefficient.right_endpoint - temp_area_vector.back().right_endpoint;

		temp_coefficient.segment_left_point.id = temp_area_vector.back().right_endpoint + 1;
		temp_coefficient.segment_left_point.value = original_time_series[int(temp_area_vector.back().right_endpoint) + 1];

		temp_coefficient.y_projection_coefficient.segment_left_height_difference = temp_coefficient.segment_left_point.value - temp_area_vector.back().segment_right_point.value;
		temp_area_vector.back().y_projection_coefficient.segment_right_height_difference = temp_coefficient.y_projection_coefficient.segment_left_height_difference * -1;

		temp_area_vector.emplace_back(temp_coefficient);
#if _DEBUG
		assert(original_time_series[int(temp_coefficient.right_endpoint)] <= threshhold);
#endif
	}
	temp_area_vector.back().y_projection_coefficient.segment_right_height_difference = 0;
	/*................................................................*/

#if _DEBUG

	for_each_n(temp_area_vector.begin(), temp_area_vector.size(), [](auto&& au) { assert(au.right_endpoint != INF && au.rectangle_width != INF && au.y_projection_coefficient.segment_left_height_difference != INF && au.y_projection_coefficient.segment_right_height_difference != INF && au.rectangle_height != INF && au.segment_left_point.value == au.segment_right_point.value); });

	for_each_n(temp_area_vector.begin(), temp_area_vector.size(), [](auto&& au) {if (!au.y_projection_coefficient.is_flat) assert(au.min_point.value == au.max_point.value && au.min_point.value == au.segment_left_point.value && au.segment_left_point.value == au.segment_right_point.value); });
	cout << "After initial, All segment size: " << temp_area_vector.size() << endl;
	cout << "Y projeciton inital: " << endl;
	for_each(temp_area_vector.begin(), temp_area_vector.end(), [](const AREA_COEFFICIENT& const segment) {cout << segment.right_endpoint + 1 << ","; });
	cout << endl;
	assert(!temp_area_vector.empty());
#endif

	area_vector.swap(temp_area_vector);
}

//191028 Check if burst time series
//************************************
// Method:checkIfBurstDataSet
// Qualifier: Check if burst time series
// 190918 Use Linded list
// Input: T:origitnal time series, 
// Output: dataset map
// date:191028 14:03
// author:
//************************************
TEMPLATE
bool APLA::checkIfBurstDataSet(typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument) {
#ifdef _DEBUG
	assert(y_projection_argument.is_y_projection == false && y_projection_argument.whole_difference_map.empty());
#endif
	//return y_projection_argument.is_y_projection = false;
	int array_id = INF;
	/*Count y projeciton point number is much smaller than n*/
	for (array_id = 0; array_id < input_argument.time_series_length && y_projection_argument.whole_difference_map.size() < input_argument.time_series_length / 20; array_id++) {
		auto whole_find_difference = y_projection_argument.whole_difference_map.find(original_time_series[array_id]);
		if (whole_find_difference != y_projection_argument.whole_difference_map.end())
			whole_find_difference->second++;
		else
			y_projection_argument.whole_difference_map.emplace_hint(y_projection_argument.whole_difference_map.end(), original_time_series[array_id], 1);
	}
	/*if above scan can finish normally, it is burst time series*/
	if (array_id == input_argument.time_series_length) {
		/*=================================Get Threshhold of burst time series=========================*/
		y_projection_argument.flat_segment_min = y_projection_argument.whole_difference_map.begin()->first;//first threshold. min value in flat segment
		/*if y value is same for all time series*/
		if (y_projection_argument.whole_difference_map.size() < 3) {
#ifdef _DEBUG
			assert(y_projection_argument.whole_difference_map.size() > 0);
#endif
			y_projection_argument.flat_segment_max = y_projection_argument.flat_segment_min;
			return y_projection_argument.is_y_projection = true;
		}

		const auto& const height_difference_second_min_map = next(y_projection_argument.whole_difference_map.begin(), 1);//second threshold

		if (y_projection_argument.whole_difference_map.begin()->second / height_difference_second_min_map->second > 2) {
			y_projection_argument.flat_segment_max = y_projection_argument.flat_segment_min;//threshold
		}
		else {
			y_projection_argument.flat_segment_max = height_difference_second_min_map->first;//threshold
		}
		/*=============================================================================================*/
		return y_projection_argument.is_y_projection = true;
	}
	return y_projection_argument.is_y_projection = false;
}

//************************************
// Method:check_if_burst_dataset
// Qualifier: Check if burst time series. for threshold , max value may also be threshold
// 190918 Use Linded list
// Input: T:origitnal time series, 
// Output: dataset map
// date:1911206 14:03
// author:
//************************************
TEMPLATE
bool APLA::check_if_burst_dataset(typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument) {
#ifdef _DEBUG
	assert(y_projection_argument.is_y_projection == false && y_projection_argument.whole_difference_map.empty());
#endif
	//return y_projection_argument.is_y_projection = false;
	int array_id = INF;
	/*Count y projeciton point number is much smaller than n*/
	for (array_id = 0; array_id < input_argument.time_series_length && y_projection_argument.whole_difference_map.size() < input_argument.time_series_length / 20; array_id++) {
		auto whole_find_difference = y_projection_argument.whole_difference_map.find(original_time_series[array_id]);
		if (whole_find_difference != y_projection_argument.whole_difference_map.end())
			whole_find_difference->second++;
		else
			y_projection_argument.whole_difference_map.emplace_hint(y_projection_argument.whole_difference_map.end(), original_time_series[array_id], 1);
	}

	/*if above scan can finish normally, it is burst time series*/
	if (array_id == input_argument.time_series_length) {
		/*=================================Get Threshhold of burst time series=========================*/
		std::map<int, double, std::greater<int>> most_frequent_value_map;
		for (auto&& au : y_projection_argument.whole_difference_map) {
			most_frequent_value_map.emplace(au.second, au.first);
		}
		y_projection_argument.flat_segment_min = most_frequent_value_map.begin()->second;//first threshold. min value in flat segment
		/*if y value is same for all time series*/

		const auto& const second_y_number = next(most_frequent_value_map.begin(), 1);//second threshold

		if (most_frequent_value_map.begin()->first / second_y_number->first > 2) {
			y_projection_argument.flat_segment_max = y_projection_argument.flat_segment_min;//threshold
		}
		else {
			y_projection_argument.flat_segment_max = max(most_frequent_value_map->second, y_projection_argument.flat_segment_min);//threshold
			y_projection_argument.flat_segment_min = min(most_frequent_value_map->second, y_projection_argument.flat_segment_min);
		}
		/*=============================================================================================*/
		return y_projection_argument.is_y_projection = true;
	}

	return y_projection_argument.is_y_projection = false;
}

//************************************
// Method:initialYProjectionAll
// Qualifier: initial split burst time series by Y-Projection.
// Input: initialized YProjection Linked List
// Output: For all height difference points, get all segemnts.
// date:191028
// author:
//************************************
TEMPLATE
void APLA::initialYProjectionAll(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, const typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<AREA_COEFFICIENT>& const all_linked_list) {
	AREA_COEFFICIENT temp_coefficient;
#if _DEBUG
	assert(y_projection_argument.flat_segment_min != INF && y_projection_argument.flat_segment_max != INF && y_projection_argument.is_y_projection == true);
#endif
	//Except flat segment. mountain segment max min value is same.
	/*======================================  Get Initial segment  =============================================================================*/
	for (int array_id = 0; array_id < input_argument.time_series_length; array_id++) {
		/*===================================   Not flat segment  ===================================================================*/
		if (original_time_series[array_id] > y_projection_argument.flat_segment_max) {
			/*=========================    Meet Split point: Flat Segmnt + Mountain Segment  ==============================*/
			if (original_time_series[array_id] != original_time_series[array_id - 1]) {
				/*=======================================================================    Get Flat Segment    =====================================================================================*/
				if (original_time_series[array_id - 1] <= y_projection_argument.flat_segment_max && array_id > 0) {
					temp_coefficient.y_projection_coefficient.is_flat = true;
					temp_coefficient.right_endpoint = array_id - 1;
					temp_coefficient.segment_right_point.id = temp_coefficient.right_endpoint;
					temp_coefficient.segment_right_point.value = original_time_series[int(temp_coefficient.right_endpoint)];
					temp_coefficient.min_point.value = y_projection_argument.flat_segment_min;
					temp_coefficient.max_point.value = y_projection_argument.flat_segment_max;
					temp_coefficient.rectangle_height = temp_coefficient.max_point.value - temp_coefficient.min_point.value;

					if (all_linked_list.empty()) {
						/*--------------------------------   First Segment coefficient   -----------------------------*/
						temp_coefficient.rectangle_width = temp_coefficient.right_endpoint + 1;
						temp_coefficient.segment_left_point.id = 0;
						temp_coefficient.segment_left_point.value = original_time_series[0];
						temp_coefficient.y_projection_coefficient.segment_left_height_difference = 0;
						/*--------------------------------------------------------------------------------------------*/
					}
					else {
						/*---------------------------------------------------------   Not First Segment Coefficient  ---------------------------------------------------*/
						temp_coefficient.rectangle_width = temp_coefficient.right_endpoint - all_linked_list.back().right_endpoint;
						temp_coefficient.segment_left_point.id = all_linked_list.back().right_endpoint + 1;
						temp_coefficient.segment_left_point.value = original_time_series[int(all_linked_list.back().right_endpoint) + 1];
						temp_coefficient.y_projection_coefficient.segment_left_height_difference = temp_coefficient.segment_left_point.value - all_linked_list.back().segment_right_point.value;
						all_linked_list.back().y_projection_coefficient.segment_right_height_difference = temp_coefficient.y_projection_coefficient.segment_left_height_difference * -1;
						/*------------------------------------------------------------------------------------------------------------------------------------------------*/
#if _DEBUG
						assert(all_linked_list.back().right_endpoint + 1 == temp_coefficient.segment_left_point.id && all_linked_list.back().segment_right_point.id == all_linked_list.back().right_endpoint);
#endif
					}

					all_linked_list.add(temp_coefficient);
#if _DEBUG
					assert(all_linked_list.back().segment_right_point.id == all_linked_list.back().right_endpoint);
#endif
				}
				/*===================================================================================================================================================================*/

				/*--------------------------------   Mountain Segment   -----------------------------*/
				temp_coefficient.right_endpoint = array_id;
				temp_coefficient.segment_right_point.id = temp_coefficient.right_endpoint;
				temp_coefficient.segment_right_point.value = original_time_series[int(temp_coefficient.right_endpoint)];
				temp_coefficient.min_point.value = temp_coefficient.segment_right_point.value;
				temp_coefficient.max_point.value = temp_coefficient.segment_right_point.value;
				temp_coefficient.rectangle_height = 0;
				if (all_linked_list.empty()) {
					/*---------------------First Segment----------------------------*/
					temp_coefficient.rectangle_width = temp_coefficient.right_endpoint + 1;
					temp_coefficient.segment_left_point.id = 0;
					temp_coefficient.segment_left_point.value = original_time_series[0];
					temp_coefficient.y_projection_coefficient.segment_left_height_difference = 0;
					/*--------------------------------------------------------------*/
				}
				else {
					/*---------------------------Not First Segment------------------*/
					temp_coefficient.rectangle_width = temp_coefficient.right_endpoint - all_linked_list.back().right_endpoint;
					temp_coefficient.segment_left_point.id = all_linked_list.back().right_endpoint + 1;
					temp_coefficient.segment_left_point.value = original_time_series[int(all_linked_list.back().right_endpoint) + 1];
					temp_coefficient.y_projection_coefficient.segment_left_height_difference = temp_coefficient.segment_left_point.value - all_linked_list.back().segment_right_point.value;
					all_linked_list.back().y_projection_coefficient.segment_right_height_difference = temp_coefficient.y_projection_coefficient.segment_left_height_difference * -1;
					/*-------------------------------------------------------------*/
				}
				/*-------------------------------------------------------------------------------*/
				all_linked_list.add(temp_coefficient);
#if _DEBUG
				if (!all_linked_list.size() > 1)
					assert(all_linked_list.back().right_endpoint + 1 == temp_coefficient.segment_left_point.id && all_linked_list.back().segment_right_point.id == all_linked_list.back().right_endpoint && temp_coefficient.segment_left_point.value == temp_coefficient.segment_right_point.value);
#endif
				/*...................................................................................................................*/
			}
			else {
				/*===========================================    Extend Segment    ================================================*/
				if (all_linked_list.empty()) {
					assert(0);
				}
				else {
					all_linked_list.back().right_endpoint++;
#if _DEBUG
					assert(all_linked_list.back().segment_right_point.value == original_time_series[int(temp_coefficient.right_endpoint)]);
#endif
					all_linked_list.back().segment_right_point.id = all_linked_list.back().right_endpoint;
					all_linked_list.back().rectangle_width++;
				}
				/*=======================================================================================================================*/
			}
		}
		/*........................................................................................*/
	}
	/*.........................................................................................................................................................................*/

	/*====================================If Last segment is flat, remember to push back it==============================*/
	if (all_linked_list.back().right_endpoint < input_argument.time_series_length - 1) {
		temp_coefficient.y_projection_coefficient.is_flat = true;
		temp_coefficient.right_endpoint = input_argument.time_series_length - 1;
		temp_coefficient.segment_right_point.id = temp_coefficient.right_endpoint;
		temp_coefficient.segment_right_point.value = original_time_series[int(temp_coefficient.right_endpoint)];
		//temp_coefficient.min_point.value = temp_coefficient.segment_right_point.value;
		//temp_coefficient.max_point.value = temp_coefficient.segment_right_point.value;
		temp_coefficient.min_point.value = y_projection_argument.flat_segment_min;
		temp_coefficient.max_point.value = y_projection_argument.flat_segment_max;
		temp_coefficient.rectangle_height = temp_coefficient.max_point.value - temp_coefficient.min_point.value;
		temp_coefficient.rectangle_width = temp_coefficient.right_endpoint - all_linked_list.back().right_endpoint;

		temp_coefficient.segment_left_point.id = all_linked_list.back().right_endpoint + 1;
		temp_coefficient.segment_left_point.value = original_time_series[int(all_linked_list.back().right_endpoint) + 1];

		temp_coefficient.y_projection_coefficient.segment_left_height_difference = temp_coefficient.segment_left_point.value - all_linked_list.back().segment_right_point.value;
		all_linked_list.back().y_projection_coefficient.segment_right_height_difference = temp_coefficient.y_projection_coefficient.segment_left_height_difference * -1;

		all_linked_list.add(temp_coefficient);
#if _DEBUG
		assert(original_time_series[int(temp_coefficient.right_endpoint)] <= y_projection_argument.flat_segment_max);
#endif
	}
	all_linked_list.back().y_projection_coefficient.segment_right_height_difference = 0;
	/*================================================================================================================================*/

#if _DEBUG

	for (int segment_id = 0; segment_id < all_linked_list.size(); segment_id++) {
		const auto& const all_list_segment = all_linked_list[segment_id];
		assert(all_list_segment.right_endpoint != INF && all_list_segment.rectangle_width != INF && all_list_segment.y_projection_coefficient.segment_left_height_difference != INF && all_list_segment.y_projection_coefficient.segment_right_height_difference != INF && all_list_segment.rectangle_height != INF);
		if (!all_list_segment.y_projection_coefficient.is_flat)
			assert(all_list_segment.min_point.value == all_list_segment.max_point.value && all_list_segment.min_point.value == all_list_segment.segment_left_point.value && all_list_segment.segment_left_point.value == all_list_segment.segment_right_point.value);
	}

	cout << "After initial, All segment size: " << all_linked_list.size() << endl;
	cout << "Y projeciton inital right endpoint: " << endl;
	/*for (int segment_id = 0; segment_id < all_linked_list.size(); segment_id++) {
		cout << all_linked_list[segment_id].right_endpoint + 1 << ",";
	}
	cout << endl;*/
	assert(!all_linked_list.empty());
#endif
	//area_vector.swap(temp_area_vector);
}

//************************************
// Method:initialYProjectionCluster
// Qualifier: cluster segments into two category, flat segments and mountain segments. split original time series by flat segment & mountain segment(unflat segment)
// Input: initialized YProjection Linked List all_linked_list
// Output: clustered linked list
// date:191030
// author:
//************************************
TEMPLATE
void APLA::initialYProjectionCluster(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, const DoublyLinkedList<AREA_COEFFICIENT>& const all_linked_list, DoublyLinkedList<AREA_COEFFICIENT>& const cluster_linked_list) {
#if _DEBUG
	assert(cluster_linked_list.empty() && !all_linked_list.empty());
#endif
	AREA_COEFFICIENT temp_coefficient;
	int flat_segment_number = 0;

	temp_coefficient.min_point.value = INF;
	temp_coefficient.max_point.value = -INF;
	temp_coefficient.rectangle_width = 0;

	auto& const sub_vector = temp_coefficient.y_projection_coefficient.sub_segment_vector;

	/*======================================================================== linked list size > N, Cluster unstable points(unflat segments)=================================================================================*/
	for (int segment_id = 0; segment_id < all_linked_list.size(); segment_id++) {
		const auto& const all_segment = all_linked_list[segment_id];
		const auto& const all_segment_y = all_segment.y_projection_coefficient;
		/*------------------------------------------------push back mountain & flat segment--------------------------------------------------------*/
#if _DEBUG
		assert(all_segment.rectangle_height != INF && all_segment.rectangle_width != INF && all_segment.segment_right_point.id == all_segment.right_endpoint && all_segment.segment_right_point.value == original_time_series[int(all_segment.right_endpoint)] && all_segment.y_projection_coefficient.segment_right_height_difference != INF && all_segment.y_projection_coefficient.segment_left_height_difference != INF);
#endif
		// segment is flat segment or
		if (all_segment_y.is_flat || fabs(all_segment_y.segment_right_height_difference) > (cluster_linked_list.empty() ? INF : fabs(cluster_linked_list.front().y_projection_coefficient.segment_left_height_difference))) {
			flat_segment_number++;
			/*---------------------------------     push back mountain segment     ---------------------------------------*/
			if (!sub_vector.empty()) {
#if _DEBUG
				auto right_id = sub_vector.back().segment_right_point.id;
				auto left_id = sub_vector.front().segment_left_point.id;
				assert(temp_coefficient.rectangle_width > 0 && temp_coefficient.rectangle_width == sub_vector.back().segment_right_point.id - sub_vector.front().segment_left_point.id + 1);
				if (!cluster_linked_list.empty()) {
					sub_vector.front().segment_left_point.id - 1 == cluster_linked_list.back().right_endpoint;
				}
#endif
				temp_coefficient.rectangle_height = temp_coefficient.max_point.value - temp_coefficient.min_point.value;
				temp_coefficient.y_projection_coefficient.is_flat = false;

				temp_coefficient.right_endpoint = temp_coefficient.y_projection_coefficient.sub_segment_vector.back().right_endpoint;
				temp_coefficient.segment_right_point = temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point;
				temp_coefficient.segment_left_point = temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point;

				temp_coefficient.y_projection_coefficient.segment_right_height_difference = temp_coefficient.y_projection_coefficient.sub_segment_vector.back().y_projection_coefficient.segment_right_height_difference;
				temp_coefficient.y_projection_coefficient.segment_left_height_difference = temp_coefficient.y_projection_coefficient.sub_segment_vector.front().y_projection_coefficient.segment_left_height_difference;
#if _DEBUG
				assert(temp_coefficient.rectangle_height != INF && temp_coefficient.segment_right_point.id == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id && temp_coefficient.segment_right_point.value == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.value && temp_coefficient.segment_left_point.id == temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id && temp_coefficient.segment_left_point.value == temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.value);
				assert(temp_coefficient.y_projection_coefficient.segment_right_height_difference != INF && temp_coefficient.y_projection_coefficient.segment_left_height_difference != INF);
#endif
				cluster_linked_list.add(temp_coefficient);

				temp_coefficient.y_projection_coefficient.sub_segment_vector.clear();
				temp_coefficient.y_projection_coefficient.sub_segment_vector.shrink_to_fit();
				//temp_coefficient.~AREA_COEFFICIENT();
				temp_coefficient.min_point.value = INF;
				temp_coefficient.max_point.value = -INF;
				temp_coefficient.rectangle_height = INF;
				temp_coefficient.rectangle_width = 0;
			}
			/*-----------------------------------------------------------------------------------------------------------*/
			/*----------------------------------------        push back flat segment    ---------------------------------*/
#if _DEBUG
			assert(all_segment_y.segment_right_height_difference != INF && all_segment_y.segment_left_height_difference != INF);
#endif
			//au.rectangle_height = 0;
			if (all_linked_list[segment_id].y_projection_coefficient.is_flat)
				cluster_linked_list.add(all_linked_list[segment_id]);
			else {
#if _DEBUG
				assert(all_linked_list[segment_id].segment_right_point.value != INF && all_linked_list[segment_id].rectangle_width != INF && all_linked_list[segment_id].y_projection_coefficient.segment_right_height_difference != INF && all_linked_list[segment_id].y_projection_coefficient.segment_left_height_difference != INF);
#endif
				temp_coefficient.min_point.value = min(temp_coefficient.min_point.value, all_linked_list[segment_id].segment_right_point.value);
				temp_coefficient.max_point.value = max(temp_coefficient.max_point.value, all_linked_list[segment_id].segment_right_point.value);
				temp_coefficient.rectangle_width += all_linked_list[segment_id].rectangle_width;
				temp_coefficient.y_projection_coefficient.sub_segment_vector.emplace_back(all_linked_list[segment_id]);
#if _DEBUG
				assert(temp_coefficient.rectangle_width == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id - temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id + 1);
#endif
			}
			/*------------------------------------------------------------------------------------------------------------*/
		}/*.......................................................................................................*/
		else {
			/*---------------------------------push back mountain sub segemnt-----------------------------------------------*/
#if _DEBUG
			assert(all_linked_list[segment_id].segment_right_point.value != INF && all_linked_list[segment_id].rectangle_width != INF && all_linked_list[segment_id].y_projection_coefficient.segment_right_height_difference != INF && all_linked_list[segment_id].y_projection_coefficient.segment_left_height_difference != INF);
#endif
			temp_coefficient.min_point.value = min(temp_coefficient.min_point.value, all_linked_list[segment_id].segment_right_point.value);
			temp_coefficient.max_point.value = max(temp_coefficient.max_point.value, all_linked_list[segment_id].segment_right_point.value);
			temp_coefficient.rectangle_width += all_linked_list[segment_id].rectangle_width;
			temp_coefficient.y_projection_coefficient.sub_segment_vector.emplace_back(all_linked_list[segment_id]);
#if _DEBUG
			assert(temp_coefficient.rectangle_width == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id - temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id + 1);
#endif
			/*----------------------------------------------------------------------------------------------------------------*/
		}
	}
	/*===================================================================================================================================================================================*/

	/*------------------------------------------------------Last segment-----------------------------------------------------------*/
	if (!temp_coefficient.y_projection_coefficient.sub_segment_vector.empty()) {
#if _DEBUG
		assert(temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id != INF);
		assert(temp_coefficient.rectangle_width > 0 && temp_coefficient.rectangle_width == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id - temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id + 1 && temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id - temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id + 1 == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id - cluster_linked_list.back().right_endpoint);
#endif
		temp_coefficient.rectangle_height = temp_coefficient.max_point.value - temp_coefficient.min_point.value;
		temp_coefficient.y_projection_coefficient.is_flat = false;

		temp_coefficient.right_endpoint = temp_coefficient.y_projection_coefficient.sub_segment_vector.back().right_endpoint;
		temp_coefficient.segment_right_point = temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point;
		temp_coefficient.segment_left_point = temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point;

		temp_coefficient.y_projection_coefficient.segment_right_height_difference = temp_coefficient.y_projection_coefficient.sub_segment_vector.back().y_projection_coefficient.segment_right_height_difference;
		temp_coefficient.y_projection_coefficient.segment_left_height_difference = temp_coefficient.y_projection_coefficient.sub_segment_vector.front().y_projection_coefficient.segment_left_height_difference;
#if _DEBUG
		assert(temp_coefficient.rectangle_height != INF && temp_coefficient.segment_right_point.id == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id && temp_coefficient.segment_right_point.value == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.value && temp_coefficient.segment_left_point.id == temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id && temp_coefficient.segment_left_point.value == temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.value);
#endif
		cluster_linked_list.add(temp_coefficient);
	}
	/*-------------------------------------------------------------------------------------------------------------------------------*/

#if _DEBUG
	assert(cluster_linked_list.back().right_endpoint == input_argument.time_series_length - 1);
	for (int segment_id = 0; segment_id < cluster_linked_list.size(); segment_id++) {
		assert(cluster_linked_list[segment_id].rectangle_height != INF && cluster_linked_list[segment_id].right_endpoint != INF && cluster_linked_list[segment_id].rectangle_width != INF && cluster_linked_list[segment_id].y_projection_coefficient.segment_right_height_difference != INF);
		if (!cluster_linked_list[segment_id].y_projection_coefficient.is_flat) assert(cluster_linked_list[segment_id].y_projection_coefficient.segment_left_height_difference == cluster_linked_list[segment_id].y_projection_coefficient.sub_segment_vector.front().y_projection_coefficient.segment_left_height_difference && cluster_linked_list[segment_id].y_projection_coefficient.segment_right_height_difference == cluster_linked_list[segment_id].y_projection_coefficient.sub_segment_vector.back().y_projection_coefficient.segment_right_height_difference);
	}
	/*cout << "Cluster right endpoint: " << endl;
	for (int segment_id = 0; segment_id < cluster_linked_list.size(); segment_id++) {
		cout << cluster_linked_list[segment_id].right_endpoint + 1<< ",";
	}
	cout << endl;
	cout << "Rectangle width: " << endl;
	for (int segment_id = 0; segment_id < cluster_linked_list.size(); segment_id++) {
		cout << cluster_linked_list[segment_id].rectangle_width << ",";
	}
	cout << endl;
	cout << "Segment right difference: " << endl;
	for (int segment_id = 0; segment_id < cluster_linked_list.size(); segment_id++) {
		cout << cluster_linked_list[segment_id].y_projection_coefficient.segment_right_height_difference << ",";
	}
	cout << endl;
	cout << "Merged vector Rright endpoint: " << endl;
	for (int segment_id = 0; segment_id < cluster_linked_list.size(); segment_id++) {
		cout << ";{" << cluster_linked_list[segment_id].right_endpoint + 1 << "}; ";
		if (!cluster_linked_list[segment_id].y_projection_coefficient.sub_segment_vector.empty()) {
			cout << "(";
			for_each(cluster_linked_list[segment_id].y_projection_coefficient.sub_segment_vector.begin(), cluster_linked_list[segment_id].y_projection_coefficient.sub_segment_vector.end(), [](const AREA_COEFFICIENT& const segment) {cout << segment.right_endpoint + 1 << ","; });
			cout << ")";
		}
	}
	cout << endl;*/
	cout << "Whole segment size: " << all_linked_list.size() << ", Merged segment size: " << cluster_linked_list.size() << " Flat number: " << flat_segment_number << endl;
#endif
}

//************************************
// Method:get_y_all_cluster_segment
// Qualifier: cluster segments into two category, flat segments and mountain segments. split original time series by flat segment & mountain segment(unflat segment)
// Input: initialized YProjection Linked List all_linked_list
// Output: all linked list 
//         clustered linked list, 
//         flat_segment_number, 
//         total_flat_segment_length.
// date:191210
// author:
//************************************
TEMPLATE
template<typename T>
void APLA::get_y_all_cluster_segment(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<T>& const all_segment_linked_list, DoublyLinkedList<T>& const cluster_linked_list) {
	AREA_COEFFICIENT temp_coefficient;
	AREA_COEFFICIENT burst_temp_segment;
	y_projection_argument.flat_segment_number = 0; //191209 the number of falt segments
	y_projection_argument.total_flat_segment_length = 0;//191209 the length of all flat semgent
#if _DEBUG
	assert(y_projection_argument.flat_segment_max != INF && y_projection_argument.flat_segment_min != INF && y_projection_argument.flat_segment_min <= y_projection_argument.flat_segment_max);
	int test_flat_segment_number = 0;
	int test_total_flat_segment_length = 0;
	DoublyLinkedList<AREA_COEFFICIENT> test_cluster_linked_list = DoublyLinkedList<AREA_COEFFICIENT>();
#endif

	/*-------------------------------------------get all & cluster linked  list------------------------------------------------------------------*/
			//all_segment_linked_list.clear();
	burst_temp_segment.right_endpoint = 0;
	burst_temp_segment.rectangle_width = 0;
	temp_coefficient.right_endpoint = 0;
	temp_coefficient.rectangle_width = 1;

	for (int array_id = 0; array_id < input_argument.time_series_length; array_id++) {
		/*-----------------------------------------------------------------Not Flat Segment------------------------------------------------------------------------*/
		if (original_time_series[array_id] != y_projection_argument.flat_segment_max && original_time_series[array_id] != y_projection_argument.flat_segment_min) {
			/*----------------    Meet Split point: Flat Segmnt + Mountain Segment  -------------------*/
			if (original_time_series[array_id] != original_time_series[array_id - 1]) {
				/*--------------------------------------------------------------get flat segment-------------------------------------*/
				if (original_time_series[array_id - 1] == y_projection_argument.flat_segment_max || original_time_series[array_id - 1] == y_projection_argument.flat_segment_min && array_id > 0) {
					temp_coefficient.is_flat = true;
					temp_coefficient.right_endpoint = array_id - 1;
					temp_coefficient.segment_right_height_difference = original_time_series[array_id] - original_time_series[array_id - 1];

					if (all_segment_linked_list.empty()) {
						/*--------------------------------   First Segment coefficient   -----------------------------*/
						temp_coefficient.rectangle_width = temp_coefficient.right_endpoint + 1;
						/*--------------------------------   -------------------------   -----------------------------*/
					}
					else {
						/*---------------------------------------------------------   Not First Segment Coefficient  ---------------------------------------------------*/
						temp_coefficient.rectangle_width = temp_coefficient.right_endpoint - all_segment_linked_list.back().right_endpoint;
						/*----------------------------------------------------------------------------------------------------------------------------------------*/
					}

					if (cluster_linked_list.empty()) {
						if (!all_segment_linked_list.empty()) {
							burst_temp_segment.right_endpoint = all_segment_linked_list.back().right_endpoint;
							burst_temp_segment.rectangle_width = burst_temp_segment.right_endpoint + 1;
							burst_temp_segment.segment_right_height_difference = original_time_series[int(burst_temp_segment.right_endpoint) + 1] - original_time_series[int(burst_temp_segment.right_endpoint)];
							burst_temp_segment.is_flat = false;
							cluster_linked_list.add(burst_temp_segment);
						}
						cluster_linked_list.add(temp_coefficient);
					}
					else {
						burst_temp_segment.right_endpoint = all_segment_linked_list.back().right_endpoint;
						burst_temp_segment.rectangle_width = burst_temp_segment.right_endpoint - cluster_linked_list.back().right_endpoint;
						burst_temp_segment.segment_right_height_difference = original_time_series[int(burst_temp_segment.right_endpoint) + 1] - original_time_series[int(burst_temp_segment.right_endpoint)];
						burst_temp_segment.is_flat = false;
						cluster_linked_list.add(burst_temp_segment);
						cluster_linked_list.add(temp_coefficient);
					}
					y_projection_argument.flat_segment_number++;
					y_projection_argument.total_flat_segment_length += temp_coefficient.rectangle_width;
					all_segment_linked_list.add(temp_coefficient);

				}
				/*----------------------------------------------------------------------------------------------------------------------------------------*/
				/*--------------------------------   Burst Segment   -----------------------------*/
				temp_coefficient.right_endpoint = array_id;
				temp_coefficient.is_flat = false;
				temp_coefficient.segment_right_height_difference = original_time_series[array_id + 1] - original_time_series[array_id];
				if (all_segment_linked_list.empty()) {
					/*---------------------First Segment----------------------------*/
					temp_coefficient.rectangle_width = temp_coefficient.right_endpoint + 1;
					/*--------------------------------------------------------------*/
				}
				else {
					/*---------------------------Not First Segment------------------*/
					temp_coefficient.rectangle_width = temp_coefficient.right_endpoint - all_segment_linked_list.back().right_endpoint;
					/*-------------------------------------------------------------*/
				}
				all_segment_linked_list.add(temp_coefficient);
				/*-------------------------------------------------------------------------------*/
			}
			else {
				/*=========================================== Same value   Extend Segment    ================================================*/
				if (all_segment_linked_list.empty()) {
					assert(0);
				}
				else {
					all_segment_linked_list.back().right_endpoint++;
					all_segment_linked_list.back().rectangle_width++;
					all_segment_linked_list.back().segment_right_height_difference = original_time_series[int(all_segment_linked_list.back().right_endpoint) + 1] - original_time_series[int(all_segment_linked_list.back().right_endpoint)];
				}
				/*=======================================================================================================================*/
			}
			/*-------------------------------------------------------------------------------------------------------------------------*/
		}

		/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/
	}
	/*========================time series only one line ======================*/
	if (all_segment_linked_list.empty()) {
		temp_coefficient.right_endpoint = input_argument.time_series_length - 1;
		temp_coefficient.rectangle_width = input_argument.time_series_length;
		temp_coefficient.is_flat = true;
		temp_coefficient.segment_right_height_difference = 0;
		//cluster_linked_list.add(temp_coefficient);

		y_projection_argument.flat_segment_number++;
		y_projection_argument.total_flat_segment_length += temp_coefficient.rectangle_width;
		all_segment_linked_list.add(temp_coefficient);
		cluster_linked_list.add(temp_coefficient);
	}
	/*=======================================================================*/

	/*====================================If Last segment is flat, remember to push back it==============================*/
	if (all_segment_linked_list.back().right_endpoint < input_argument.time_series_length - 1) {
		temp_coefficient.is_flat = true;
		temp_coefficient.right_endpoint = input_argument.time_series_length - 1;
		temp_coefficient.rectangle_width = temp_coefficient.right_endpoint - all_segment_linked_list.back().right_endpoint;
		temp_coefficient.segment_right_height_difference = 0;

		if (cluster_linked_list.empty()) {
			cluster_linked_list.add(temp_coefficient);
		}
		else {

			burst_temp_segment.right_endpoint = all_segment_linked_list.back().right_endpoint;
			burst_temp_segment.rectangle_width = burst_temp_segment.right_endpoint - cluster_linked_list.back().right_endpoint;
			burst_temp_segment.segment_right_height_difference = original_time_series[int(burst_temp_segment.right_endpoint) + 1] - original_time_series[int(burst_temp_segment.right_endpoint)];
			burst_temp_segment.is_flat = false;
			cluster_linked_list.add(burst_temp_segment);
			cluster_linked_list.add(temp_coefficient);
		}
		y_projection_argument.flat_segment_number++;
		y_projection_argument.total_flat_segment_length += temp_coefficient.rectangle_width;
		all_segment_linked_list.add(temp_coefficient);
#if _DEBUG
		assert(original_time_series[int(temp_coefficient.right_endpoint)] <= y_projection_argument.flat_segment_max && original_time_series[int(temp_coefficient.right_endpoint)] >= y_projection_argument.flat_segment_min);
#endif
	}
	/*--------------------------------the last segment is burst segment--------------*/
	if (cluster_linked_list.back().right_endpoint < input_argument.time_series_length - 1) {

		burst_temp_segment.right_endpoint = input_argument.time_series_length - 1;
		burst_temp_segment.rectangle_width = burst_temp_segment.right_endpoint - cluster_linked_list.back().right_endpoint;
		burst_temp_segment.segment_right_height_difference = 0;
		burst_temp_segment.is_flat = false;
		cluster_linked_list.add(burst_temp_segment);
	}
	/*---------------------------------------------------------------------------------*/
	all_segment_linked_list.back().segment_right_height_difference = 0;
	/*=================================================================================================================================================================================*/

	/*==================================================== Evaluation ============================================================================*/
#ifdef _DEBUG
	for (int segment_id = 0; segment_id < all_segment_linked_list.size(); segment_id++) {
		const auto& const all_list_segment = all_segment_linked_list[segment_id];
		assert(all_list_segment.right_endpoint != INF && all_list_segment.rectangle_width != INF && all_list_segment.segment_right_height_difference != INF);
	}
	for (int segment_id = 0; segment_id < all_segment_linked_list.size() - 1; segment_id++) {
		const auto& const all_list_segment = all_segment_linked_list[segment_id];
		assert(all_list_segment.segment_right_height_difference == original_time_series[int(all_list_segment.right_endpoint) + 1] - original_time_series[int(all_list_segment.right_endpoint)]);
	}
#endif
	/*========================================================================================================================================*/

	/*=============================================================EvaluateIndependent cluster linked list========================================================*/
#ifdef _DEBUG
	burst_temp_segment.right_endpoint = 0;
	burst_temp_segment.rectangle_width = 0;
	for (int segment_id = 0; segment_id < all_segment_linked_list.size(); segment_id++) {
		auto& const all_segment = all_segment_linked_list[segment_id];

		assert(all_segment.segment_right_height_difference != INF);

		/*---------              burst segment          ----------------*/
		if (original_time_series[int(all_segment.right_endpoint)] != y_projection_argument.flat_segment_max && original_time_series[int(all_segment.right_endpoint)] != y_projection_argument.flat_segment_min) {
			burst_temp_segment.rectangle_width += all_segment.rectangle_width;
			burst_temp_segment.right_endpoint = all_segment.right_endpoint;
			burst_temp_segment.segment_right_height_difference = all_segment.segment_right_height_difference;
		}/*---------             flat segment          ----------------*/
		else {
			/*.........   count flat segment  .............*/
			test_flat_segment_number++;
			test_total_flat_segment_length += all_segment.rectangle_width;
			/*............................................*/
			if (burst_temp_segment.rectangle_width > 0) {
#ifdef _DEBUG
				assert(burst_temp_segment.segment_right_height_difference != INF && burst_temp_segment.right_endpoint == all_segment.right_endpoint - all_segment.rectangle_width || burst_temp_segment.right_endpoint - 1 == all_segment.right_endpoint - all_segment.rectangle_width);
#endif
				test_cluster_linked_list.add(burst_temp_segment);
			}

			all_segment.is_flat = true;
#ifdef _DEBUG
			assert(all_segment.segment_right_height_difference != INF);
#endif
			test_cluster_linked_list.add(all_segment);
			burst_temp_segment.right_endpoint = 0;
			burst_temp_segment.rectangle_width = 0;
		}
	}
	//for end segment
	if (burst_temp_segment.rectangle_width > 0) {
#ifdef _DEBUG
		assert(burst_temp_segment.segment_right_height_difference != INF && burst_temp_segment.right_endpoint == input_argument.time_series_length - 1);
#endif
		test_cluster_linked_list.add(burst_temp_segment);
	}
#ifdef _DEBUG
	assert(test_cluster_linked_list.back().right_endpoint == input_argument.time_series_length - 1 && test_cluster_linked_list[0].rectangle_width == test_cluster_linked_list[0].right_endpoint + 1);
#endif
#endif
	/*==========================================================================================================================================================================================================*/
	/*==================================================== Evaluation ============================================================================*/
#ifdef _DEBUG

	assert(test_flat_segment_number == y_projection_argument.flat_segment_number && test_total_flat_segment_length == y_projection_argument.total_flat_segment_length);
	/*...................assert right endpoint, width, right height difference........................*/
	assert_linkedlist_rightEndpoint_Width_rightHeightDifference(input_argument, all_segment_linked_list);
	assert_linkedlist_rightEndpoint_Width_rightHeightDifference(input_argument, cluster_linked_list);
	assert_linkedlist_rightEndpoint_Width_rightHeightDifference(input_argument, test_cluster_linked_list);
	/*................................................................................................*/
	assert(cluster_linked_list.size() == test_cluster_linked_list.size());
	assert(cluster_linked_list.front().rectangle_width == test_cluster_linked_list.front().rectangle_width && cluster_linked_list.front().rectangle_width == cluster_linked_list.front().right_endpoint + 1 && test_cluster_linked_list.front().rectangle_width == test_cluster_linked_list.front().right_endpoint + 1);
	for (int segment_id = 1; segment_id < cluster_linked_list.size(); segment_id++) {
		const auto& const left_segment = cluster_linked_list[segment_id - 1];
		const auto& const right_segment = cluster_linked_list[segment_id];
		const auto& const test_cluster_segment = test_cluster_linked_list[segment_id];
		assert(right_segment.right_endpoint == test_cluster_segment.right_endpoint && right_segment.rectangle_width == test_cluster_segment.rectangle_width && right_segment.is_flat == test_cluster_segment.is_flat && right_segment.segment_right_height_difference == test_cluster_segment.segment_right_height_difference && right_segment.segment_right_height_difference != INF);
		assert(left_segment.right_endpoint == right_segment.right_endpoint - right_segment.rectangle_width);
	}
#endif	
	/*========================================================================================================================================*/
}


//200212 Use vector to instead pointer for time series .Add template
//************************************
// Method:get_y_all_cluster_segment
// Qualifier: cluster segments into two category, flat segments and mountain segments. split original time series by flat segment & mountain segment(unflat segment)
// Input: initialized YProjection Linked List all_linked_list
// Output: all linked list 
//         clustered linked list, 
//         flat_segment_number, 
//         total_flat_segment_length.
// date:200212 
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
void APLA::get_y_all_cluster_segment(U& input_argument, const vector<T>& const original_time_series_vector, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<Y>& const all_segment_linked_list, DoublyLinkedList<Y>& const cluster_linked_list) {
	Y temp_coefficient;
	Y burst_temp_segment;
	y_projection_argument.flat_segment_number = 0; //191209 the number of falt segments
	y_projection_argument.total_flat_segment_length = 0;//191209 the length of all flat semgent
#if _DEBUG
	assert(y_projection_argument.flat_segment_max != INF && y_projection_argument.flat_segment_min != INF && y_projection_argument.flat_segment_min <= y_projection_argument.flat_segment_max);
	int test_flat_segment_number = 0;
	int test_total_flat_segment_length = 0;
	DoublyLinkedList<Y> test_cluster_linked_list = DoublyLinkedList<Y>();
#endif

	/*-------------------------------------------get all & cluster linked  list------------------------------------------------------------------*/
			//all_segment_linked_list.clear();
	burst_temp_segment.right_endpoint = 0;
	burst_temp_segment.rectangle_width = 0;
	temp_coefficient.right_endpoint = 0;
	temp_coefficient.rectangle_width = 0;

	// Compute four coefficient: 
	//1 is flat? 
	//2 right endoint, 
	//3 rectangle with, 
	//4 segment_right_height_difference
	// initial segment right endpoint is 0
	for (int array_id = 0; array_id < input_argument.time_series_length; array_id++) {
		/*-----------------------------------------------------------------Not Flat Segment------------------------------------------------------------------------*/
		if (original_time_series_vector[array_id] != y_projection_argument.flat_segment_max && original_time_series_vector[array_id] != y_projection_argument.flat_segment_min) {
			/*----------------    Meet Split point: Flat Segmnt + Mountain Segment  -------------------*/
			//if (array_id == 0) {//first point is burst point
			//	temp_coefficient.is_flat = false;
			//	while (original_time_series_vector[array_id] == original_time_series_vector[array_id + 1]) {
			//		array_id++;
			//		temp_coefficient.right_endpoint++;
			//	}
			//	temp_coefficient.rectangle_width = temp_coefficient.right_endpoint + 1;
			//	temp_coefficient.segment_right_height_difference = original_time_series_vector[array_id + 1] - original_time_series_vector[array_id];
			//	assert(temp_coefficient.rectangle_width > 0);
			//	all_segment_linked_list.add(temp_coefficient);
			//	array_id++;
			//}

			if (array_id > 0 && original_time_series_vector[array_id] != original_time_series_vector[array_id - 1]) { // Before array_id are flat points
				/*--------------------------------------------------------------get flat segment-------------------------------------*/
				if (original_time_series_vector[array_id - 1] == y_projection_argument.flat_segment_max || original_time_series_vector[array_id - 1] == y_projection_argument.flat_segment_min && array_id > 0) {
					temp_coefficient.is_flat = true;
					temp_coefficient.right_endpoint = array_id - 1;
					temp_coefficient.segment_right_height_difference = original_time_series_vector[array_id] - original_time_series_vector[array_id - 1];

					if (all_segment_linked_list.empty()) {
						/*--------------------------------   First Segment coefficient   -----------------------------*/
						temp_coefficient.rectangle_width = temp_coefficient.right_endpoint + 1;
						/*--------------------------------   -------------------------   -----------------------------*/
					}
					else {
						/*---------------------------------------------------------   Not First Segment Coefficient  ---------------------------------------------------*/
						temp_coefficient.rectangle_width = temp_coefficient.right_endpoint - all_segment_linked_list.back().right_endpoint;
						/*----------------------------------------------------------------------------------------------------------------------------------------*/
					}

					if (cluster_linked_list.empty()) {
						if (!all_segment_linked_list.empty()) {
							burst_temp_segment.right_endpoint = all_segment_linked_list.back().right_endpoint;
							burst_temp_segment.rectangle_width = burst_temp_segment.right_endpoint + 1;
							burst_temp_segment.segment_right_height_difference = original_time_series_vector[int(burst_temp_segment.right_endpoint) + 1] - original_time_series_vector[int(burst_temp_segment.right_endpoint)];
							burst_temp_segment.is_flat = false;
							cluster_linked_list.add(burst_temp_segment);
						}
						cluster_linked_list.add(temp_coefficient);
					}
					else {
						burst_temp_segment.right_endpoint = all_segment_linked_list.back().right_endpoint;
						burst_temp_segment.rectangle_width = burst_temp_segment.right_endpoint - cluster_linked_list.back().right_endpoint;
						burst_temp_segment.segment_right_height_difference = original_time_series_vector[int(burst_temp_segment.right_endpoint) + 1] - original_time_series_vector[int(burst_temp_segment.right_endpoint)];
						burst_temp_segment.is_flat = false;
						cluster_linked_list.add(burst_temp_segment);
						cluster_linked_list.add(temp_coefficient);
					}
					y_projection_argument.flat_segment_number++;
					y_projection_argument.total_flat_segment_length += temp_coefficient.rectangle_width;
					assert(temp_coefficient.rectangle_width > 0);
					all_segment_linked_list.add(temp_coefficient);

				}
				/*----------------------------------------------------------------------------------------------------------------------------------------*/
				/*--------------------------------   Burst Segment   -----------------------------*/
				temp_coefficient.right_endpoint = array_id;
				temp_coefficient.is_flat = false;
				if (array_id + 1 < original_time_series_vector.size()) {
					temp_coefficient.segment_right_height_difference = original_time_series_vector[array_id + 1] - original_time_series_vector[array_id];
				}
				else {
					temp_coefficient.segment_right_height_difference = 0;
				}

				if (all_segment_linked_list.empty()) {
					/*---------------------First Segment----------------------------*/
					temp_coefficient.rectangle_width = temp_coefficient.right_endpoint + 1;
					/*--------------------------------------------------------------*/
				}
				else {
					/*---------------------------Not First Segment------------------*/
					temp_coefficient.rectangle_width = temp_coefficient.right_endpoint - all_segment_linked_list.back().right_endpoint;
					/*-------------------------------------------------------------*/
				}
				all_segment_linked_list.add(temp_coefficient);
				/*-------------------------------------------------------------------------------*/
			}
			else {
				/*=========================================== Same value   Extend Segment    ================================================*/
				if (all_segment_linked_list.empty()) {// this segment in head of time series, is burst segment.
					temp_coefficient.right_endpoint = array_id;
					temp_coefficient.rectangle_width = temp_coefficient.right_endpoint + 1;
					temp_coefficient.is_flat = false;
					temp_coefficient.segment_right_height_difference = original_time_series_vector[int(temp_coefficient.right_endpoint) + 1] - original_time_series_vector[int(temp_coefficient.right_endpoint)];
					assert(temp_coefficient.rectangle_width == temp_coefficient.right_endpoint + 1 && original_time_series_vector[int(temp_coefficient.right_endpoint)] != y_projection_argument.flat_segment_max && original_time_series_vector[int(temp_coefficient.right_endpoint)] != y_projection_argument.flat_segment_min);
				}
				else {
					all_segment_linked_list.back().right_endpoint++;
					all_segment_linked_list.back().rectangle_width++;
					if (all_segment_linked_list.back().right_endpoint + 1 < original_time_series_vector.size())
						all_segment_linked_list.back().segment_right_height_difference = original_time_series_vector[int(all_segment_linked_list.back().right_endpoint) + 1] - original_time_series_vector[int(all_segment_linked_list.back().right_endpoint)];
				}
				/*=======================================================================================================================*/
			}
			/*-------------------------------------------------------------------------------------------------------------------------*/
		}
		else if (all_segment_linked_list.empty() && temp_coefficient.rectangle_width > 0) {
#if _DEBUG
			assert(!temp_coefficient.is_flat);
			int begin_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
			for (int array_id = 0; array_id < temp_coefficient.right_endpoint; array_id++) {
				assert(original_time_series_vector[array_id] != y_projection_argument.flat_segment_max && original_time_series_vector[array_id] != y_projection_argument.flat_segment_min);
			}
#endif

			all_segment_linked_list.add(temp_coefficient);
		}

		/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/
	}

	/*========================time series only one line ======================*/
	if (all_segment_linked_list.empty()) {
		temp_coefficient.right_endpoint = input_argument.time_series_length - 1;
		temp_coefficient.rectangle_width = input_argument.time_series_length;
		temp_coefficient.is_flat = true;
		temp_coefficient.segment_right_height_difference = 0;
		//cluster_linked_list.add(temp_coefficient);

		y_projection_argument.flat_segment_number++;
		y_projection_argument.total_flat_segment_length += temp_coefficient.rectangle_width;
		assert(temp_coefficient.rectangle_width > 0);
		all_segment_linked_list.add(temp_coefficient);
		cluster_linked_list.add(temp_coefficient);
	}
	/*=======================================================================*/

	/*====================================If Last segment is flat, remember to push back it==============================*/
	if (all_segment_linked_list.back().right_endpoint < input_argument.time_series_length - 1) {
		temp_coefficient.is_flat = true;
		temp_coefficient.right_endpoint = input_argument.time_series_length - 1;
		temp_coefficient.rectangle_width = temp_coefficient.right_endpoint - all_segment_linked_list.back().right_endpoint;
		temp_coefficient.segment_right_height_difference = 0;

		if (cluster_linked_list.empty()) {
			cluster_linked_list.add(temp_coefficient);
		}
		else {

			burst_temp_segment.right_endpoint = all_segment_linked_list.back().right_endpoint;
			burst_temp_segment.rectangle_width = burst_temp_segment.right_endpoint - cluster_linked_list.back().right_endpoint;
			burst_temp_segment.segment_right_height_difference = original_time_series_vector[int(burst_temp_segment.right_endpoint) + 1] - original_time_series_vector[int(burst_temp_segment.right_endpoint)];
			burst_temp_segment.is_flat = false;
			cluster_linked_list.add(burst_temp_segment);
			cluster_linked_list.add(temp_coefficient);
		}
		y_projection_argument.flat_segment_number++;
		y_projection_argument.total_flat_segment_length += temp_coefficient.rectangle_width;
		assert(temp_coefficient.rectangle_width > 0);
		all_segment_linked_list.add(temp_coefficient);
#if _DEBUG
		assert(original_time_series_vector[int(temp_coefficient.right_endpoint)] <= y_projection_argument.flat_segment_max && original_time_series_vector[int(temp_coefficient.right_endpoint)] >= y_projection_argument.flat_segment_min);
#endif
	}
	/*--------------------------------the last segment is burst segment--------------*/
	if (cluster_linked_list.back().right_endpoint < input_argument.time_series_length - 1) {

		burst_temp_segment.right_endpoint = input_argument.time_series_length - 1;
		burst_temp_segment.rectangle_width = burst_temp_segment.right_endpoint - cluster_linked_list.back().right_endpoint;
		burst_temp_segment.segment_right_height_difference = 0;
		burst_temp_segment.is_flat = false;
		cluster_linked_list.add(burst_temp_segment);
	}
	/*---------------------------------------------------------------------------------*/
	all_segment_linked_list.back().segment_right_height_difference = 0;
	/*=================================================================================================================================================================================*/


//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	/*==================================================== Evaluation ============================================================================*/
#ifdef _DEBUG
	for (int segment_id = 0; segment_id < all_segment_linked_list.size(); segment_id++) {
		const auto& const all_list_segment = all_segment_linked_list[segment_id];
		assert(all_list_segment.right_endpoint != INF && all_list_segment.rectangle_width != INF && all_list_segment.segment_right_height_difference != INF && all_list_segment.rectangle_width > 0);
		int begin_id = all_list_segment.right_endpoint - all_list_segment.rectangle_width + 1;

		for (int array_id = begin_id; array_id <= all_list_segment.right_endpoint; array_id++) {
			if (all_list_segment.is_flat) {
				assert(original_time_series_vector[array_id] == y_projection_argument.flat_segment_max || original_time_series_vector[array_id] == y_projection_argument.flat_segment_min);
			}
			else {
				assert(original_time_series_vector[array_id] != y_projection_argument.flat_segment_max || original_time_series_vector[array_id] != y_projection_argument.flat_segment_min);
				if (array_id + 1 <= all_list_segment.right_endpoint) {
					assert(original_time_series_vector[array_id] == original_time_series_vector[array_id + 1]);
				}
			}


		}
	}
	for (int segment_id = 0; segment_id < all_segment_linked_list.size() - 1; segment_id++) {
		const auto& const all_list_segment = all_segment_linked_list[segment_id];
		assert(all_list_segment.right_endpoint < all_segment_linked_list[segment_id + 1].right_endpoint);
		assert(all_list_segment.segment_right_height_difference == original_time_series_vector[int(all_list_segment.right_endpoint) + 1] - original_time_series_vector[int(all_list_segment.right_endpoint)]);
		if (!all_list_segment.is_flat) {
			assert(original_time_series_vector[int(all_list_segment.right_endpoint) + 1] != original_time_series_vector[int(all_list_segment.right_endpoint)]);
		}
	}


	for (int segment_id = 0; segment_id < cluster_linked_list.size(); segment_id++) {
		const auto& const cluster_list_segment = cluster_linked_list[segment_id];
		assert(cluster_list_segment.right_endpoint != INF && cluster_list_segment.rectangle_width != INF && cluster_list_segment.segment_right_height_difference != INF && cluster_list_segment.rectangle_width > 0);
		int begin_id = cluster_list_segment.right_endpoint - cluster_list_segment.rectangle_width + 1;

		for (int array_id = begin_id; array_id <= cluster_list_segment.right_endpoint; array_id++) {
			if (cluster_list_segment.is_flat) {
				assert(original_time_series_vector[array_id] == y_projection_argument.flat_segment_max || original_time_series_vector[array_id] == y_projection_argument.flat_segment_min);
			}
			else {
				assert(original_time_series_vector[array_id] != y_projection_argument.flat_segment_max || original_time_series_vector[array_id] != y_projection_argument.flat_segment_min);
			}

		}
	}
#endif
	/*========================================================================================================================================*/

	/*=============================================================EvaluateIndependent cluster linked list========================================================*/
#ifdef _DEBUG
	burst_temp_segment.right_endpoint = 0;
	burst_temp_segment.rectangle_width = 0;
	for (int segment_id = 0; segment_id < all_segment_linked_list.size(); segment_id++) {
		auto& const all_segment = all_segment_linked_list[segment_id];

		assert(all_segment.segment_right_height_difference != INF);

		/*---------              burst segment          ----------------*/
		if (original_time_series_vector[int(all_segment.right_endpoint)] != y_projection_argument.flat_segment_max && original_time_series_vector[int(all_segment.right_endpoint)] != y_projection_argument.flat_segment_min) {
			assert(!all_segment.is_flat);
			burst_temp_segment.rectangle_width += all_segment.rectangle_width;
			burst_temp_segment.right_endpoint = all_segment.right_endpoint;
			burst_temp_segment.segment_right_height_difference = all_segment.segment_right_height_difference;
		}/*---------             flat segment          ----------------*/
		else {
			assert(all_segment.is_flat);
			/*.........   count flat segment  .............*/
			test_flat_segment_number++;
			test_total_flat_segment_length += all_segment.rectangle_width;
			/*............................................*/
			if (burst_temp_segment.rectangle_width > 0) {
#ifdef _DEBUG
				assert(burst_temp_segment.segment_right_height_difference != INF && burst_temp_segment.right_endpoint == all_segment.right_endpoint - all_segment.rectangle_width || burst_temp_segment.right_endpoint - 1 == all_segment.right_endpoint - all_segment.rectangle_width);
#endif
				test_cluster_linked_list.add(burst_temp_segment);
			}

			all_segment.is_flat = true;
#ifdef _DEBUG
			assert(all_segment.segment_right_height_difference != INF);
#endif
			test_cluster_linked_list.add(all_segment);
			burst_temp_segment.right_endpoint = 0;
			burst_temp_segment.rectangle_width = 0;
		}
	}
	//for end segment
	if (burst_temp_segment.rectangle_width > 0) {
#ifdef _DEBUG
		assert(burst_temp_segment.segment_right_height_difference != INF && burst_temp_segment.right_endpoint == input_argument.time_series_length - 1);
#endif
		test_cluster_linked_list.add(burst_temp_segment);
	}
#ifdef _DEBUG
	assert(test_cluster_linked_list.back().right_endpoint == input_argument.time_series_length - 1 && test_cluster_linked_list[0].rectangle_width == test_cluster_linked_list[0].right_endpoint + 1);
#endif
#endif
	/*==========================================================================================================================================================================================================*/
	/*==================================================== Evaluation ============================================================================*/
#ifdef _DEBUG

	assert(test_flat_segment_number == y_projection_argument.flat_segment_number && test_total_flat_segment_length == y_projection_argument.total_flat_segment_length);
	/*...................assert right endpoint, width, right height difference........................*/
	assert_linkedlist_rightEndpoint_Width_rightHeightDifference(input_argument, all_segment_linked_list);
	assert_linkedlist_rightEndpoint_Width_rightHeightDifference(input_argument, cluster_linked_list);
	assert_linkedlist_rightEndpoint_Width_rightHeightDifference(input_argument, test_cluster_linked_list);
	/*................................................................................................*/
	assert(cluster_linked_list.size() == test_cluster_linked_list.size());
	assert(cluster_linked_list.front().rectangle_width == test_cluster_linked_list.front().rectangle_width && cluster_linked_list.front().rectangle_width == cluster_linked_list.front().right_endpoint + 1 && test_cluster_linked_list.front().rectangle_width == test_cluster_linked_list.front().right_endpoint + 1);
	for (int segment_id = 1; segment_id < cluster_linked_list.size(); segment_id++) {
		const auto& const left_segment = cluster_linked_list[segment_id - 1];
		const auto& const right_segment = cluster_linked_list[segment_id];
		const auto& const test_cluster_segment = test_cluster_linked_list[segment_id];
		assert(right_segment.right_endpoint == test_cluster_segment.right_endpoint && right_segment.rectangle_width == test_cluster_segment.rectangle_width && right_segment.is_flat == test_cluster_segment.is_flat && right_segment.segment_right_height_difference == test_cluster_segment.segment_right_height_difference && right_segment.segment_right_height_difference != INF);
		assert(left_segment.right_endpoint == right_segment.right_endpoint - right_segment.rectangle_width);
	}
#endif	
	/*========================================================================================================================================*/
}


//200213 whether is flat point
//************************************
// Method:is_flat_point
// Qualifier: 
// Input: whether flat points
// Output:
// date:200213 
// author:
//************************************
TEMPLATE
template<typename T, typename U>
inline bool APLA::is_flat_point(const U& const y_projection_argument, const T& const data) {
#if _DEBUG
	assert(data != INF && y_projection_argument.flat_segment_max != INF && y_projection_argument.flat_segment_min != INF && y_projection_argument.flat_segment_min <= y_projection_argument.flat_segment_max);
#endif

	if (data == y_projection_argument.flat_segment_min || data == y_projection_argument.flat_segment_max)
		return true;
	else
		return false;
}

//200213 get rectangle width of current segment
TEMPLATE
template<typename T, typename U>
inline double& APLA::y_projection_get_segment_width(const DoublyLinkedList<U>& const all_segment_linked_list, T& const temp_coefficient) {
	assert(temp_coefficient.right_endpoint != INF);
	if (all_segment_linked_list.empty()) {
		/*--------------------------------   First Segment coefficient   -----------------------------*/
		return temp_coefficient.rectangle_width = temp_coefficient.right_endpoint + 1;
		/*--------------------------------   -------------------------   -----------------------------*/
	}
	else {
		/*---------------------------------------------------------   Not First Segment Coefficient  ---------------------------------------------------*/
		return temp_coefficient.rectangle_width = temp_coefficient.right_endpoint - all_segment_linked_list.back().right_endpoint;
		/*----------------------------------------------------------------------------------------------------------------------------------------*/
	}
}

//200213 new Y projection method. for complicated situation, frist point is or not flat point.
//200212 Use vector to instead pointer for time series .Add template
//************************************
// Method:get_y_all_cluster_segment_200213
// Qualifier: cluster segments into two category, flat segments and mountain segments. split original time series by flat segment & mountain segment(unflat segment)
// Input: initialized YProjection Linked List all_linked_list
// Output: all linked list 
//         clustered linked list, 
//         flat_segment_number, 
//         total_flat_segment_length.
// date:200212 
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
void APLA::get_y_all_cluster_segment_200213(U& input_argument, const vector<T>& const original_time_series_vector, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<Y>& const all_segment_linked_list, DoublyLinkedList<Y>& const cluster_linked_list) {
	Y temp_coefficient;
	Y burst_temp_segment;
	y_projection_argument.flat_segment_number = 0; //191209 the number of flat segments
	y_projection_argument.total_flat_segment_length = 0;//191209 the length of all flat semgent
#if _DEBUG
	assert(y_projection_argument.flat_segment_max != INF && y_projection_argument.flat_segment_min != INF && y_projection_argument.flat_segment_min <= y_projection_argument.flat_segment_max && !original_time_series_vector.empty() && original_time_series_vector.size() == input_argument.time_series_length && all_segment_linked_list.empty() && cluster_linked_list.empty());
	int test_flat_segment_number = 0;
	int test_total_flat_segment_length = 0;
	DoublyLinkedList<Y> test_cluster_linked_list = DoublyLinkedList<Y>();
#endif

	/*-------------------------------------------get all & cluster linked  list------------------------------------------------------------------*/
			//all_segment_linked_list.clear();
	burst_temp_segment.right_endpoint = 0;
	burst_temp_segment.rectangle_width = 0;
	temp_coefficient.right_endpoint = INF;
	temp_coefficient.rectangle_width = INF;

	double last_flat_segment_right_endpoint = INF;

	// Compute four coefficient: 
	//1 is flat? 
	//2 right endoint, 
	//3 rectangle with, 
	//4 segment_right_height_difference
	// initial segment right endpoint is 0
	for (int array_id = 0; array_id < input_argument.time_series_length - 1; array_id++) {
		// current point is flat point
		if (is_flat_point(y_projection_argument, original_time_series_vector[array_id])) {
			//next point is differnt burst point, current point and segment is flat segment, insert into all linkedlist & cluster linkedlist
			if (!is_flat_point(y_projection_argument, original_time_series_vector[array_id + 1]) && original_time_series_vector[array_id] != original_time_series_vector[array_id + 1]) {
				temp_coefficient.is_flat = true;
				temp_coefficient.right_endpoint = array_id;
				temp_coefficient.segment_right_height_difference = original_time_series_vector[array_id + 1] - original_time_series_vector[array_id];

				y_projection_get_segment_width(all_segment_linked_list, temp_coefficient);

				all_segment_linked_list.add(temp_coefficient);
				cluster_linked_list.add(temp_coefficient);

				// record current flat segment position
				last_flat_segment_right_endpoint = temp_coefficient.right_endpoint;

				y_projection_argument.flat_segment_number++;
				y_projection_argument.total_flat_segment_length += temp_coefficient.rectangle_width;
			}
			else {
				assert(is_flat_point(y_projection_argument, original_time_series_vector[array_id + 1]));
			}
		}
		else {//Current point is burst point
			// next point is flat point. current segment is burst segment. insert it into all linkedlist
			if (is_flat_point(y_projection_argument, original_time_series_vector[array_id + 1])) {
				temp_coefficient.is_flat = false;
				temp_coefficient.right_endpoint = array_id;
				temp_coefficient.segment_right_height_difference = original_time_series_vector[array_id + 1] - original_time_series_vector[array_id];
				y_projection_get_segment_width(all_segment_linked_list, temp_coefficient);

				all_segment_linked_list.add(temp_coefficient);

				burst_temp_segment.is_flat = temp_coefficient.is_flat;
				burst_temp_segment.right_endpoint = temp_coefficient.right_endpoint;
				burst_temp_segment.segment_right_height_difference = temp_coefficient.segment_right_height_difference;

				if (cluster_linked_list.empty()) {
					burst_temp_segment.rectangle_width = burst_temp_segment.right_endpoint + 1;
				}
				else {
					assert(cluster_linked_list.back().right_endpoint == last_flat_segment_right_endpoint);
					burst_temp_segment.rectangle_width = burst_temp_segment.right_endpoint - cluster_linked_list.back().right_endpoint;
				}

				cluster_linked_list.add(burst_temp_segment);

			}// next point is different burst points. current segment is burst segment. insert it into all linkedlist
			else if (original_time_series_vector[array_id] != original_time_series_vector[array_id + 1]) {// different burst points
				temp_coefficient.is_flat = false;
				temp_coefficient.right_endpoint = array_id;
				temp_coefficient.segment_right_height_difference = original_time_series_vector[array_id + 1] - original_time_series_vector[array_id];
				y_projection_get_segment_width(all_segment_linked_list, temp_coefficient);

				all_segment_linked_list.add(temp_coefficient);
			}//next point is equal to current point.Continue loop
			else {
				assert(original_time_series_vector[array_id] == original_time_series_vector[array_id + 1]);
			}
		}

	}
	/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/*========================                                     time series only one line                                           ======================*/
	if (all_segment_linked_list.empty()) {
		temp_coefficient.right_endpoint = input_argument.time_series_length - 1;
		temp_coefficient.rectangle_width = input_argument.time_series_length;
		temp_coefficient.is_flat = true;
		temp_coefficient.segment_right_height_difference = 0;
		//cluster_linked_list.add(temp_coefficient);

		y_projection_argument.flat_segment_number++;
		y_projection_argument.total_flat_segment_length += temp_coefficient.rectangle_width;
		assert(temp_coefficient.rectangle_width > 0);
		all_segment_linked_list.add(temp_coefficient);
		cluster_linked_list.add(temp_coefficient);
	}
	/*=========================================================================================================================================================*/

	/*===================================================If Last segment is not push, remember to push back it=================================================*/
	if (all_segment_linked_list.back().right_endpoint < input_argument.time_series_length - 1) {
		temp_coefficient.right_endpoint = input_argument.time_series_length - 1;
		temp_coefficient.rectangle_width = temp_coefficient.right_endpoint - all_segment_linked_list.back().right_endpoint;
		temp_coefficient.segment_right_height_difference = 0;
		//the last segment is flat segment, insert it into all & cluster linkedlist
		if (is_flat_point(y_projection_argument, original_time_series_vector[temp_coefficient.right_endpoint])) {
			assert(all_segment_linked_list.back().right_endpoint == cluster_linked_list.back().right_endpoint && all_segment_linked_list.back().is_flat == cluster_linked_list.back().is_flat);
			temp_coefficient.is_flat = true;
			cluster_linked_list.add(temp_coefficient);

			y_projection_argument.flat_segment_number++;
			y_projection_argument.total_flat_segment_length += temp_coefficient.rectangle_width;
		}// the last segment is burst segment, insert it into all linked list, and burst segment into cluster linked list
		else {
			temp_coefficient.is_flat = false;
			burst_temp_segment.right_endpoint = temp_coefficient.right_endpoint;
			burst_temp_segment.segment_right_height_difference = 0;
			if (cluster_linked_list.empty()) burst_temp_segment.rectangle_width = burst_temp_segment.right_endpoint + 1;
			else {
				assert(cluster_linked_list.back().right_endpoint == last_flat_segment_right_endpoint);
				burst_temp_segment.rectangle_width = burst_temp_segment.right_endpoint - cluster_linked_list.back().right_endpoint;
			}

			cluster_linked_list.add(burst_temp_segment);
		}
		all_segment_linked_list.add(temp_coefficient);
#if _DEBUG
		assert(temp_coefficient.rectangle_width > 0);
		///assert(original_time_series_vector[int(temp_coefficient.right_endpoint)] <= y_projection_argument.flat_segment_max && original_time_series_vector[int(temp_coefficient.right_endpoint)] >= y_projection_argument.flat_segment_min);
#endif
	}
	/*===============================================================================================================================================================*/


//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	/*==================================================== Evaluation ============================================================================*/
#ifdef _DEBUG
	assert(all_segment_linked_list.back().segment_right_height_difference == 0);
	// assert all linked list  point in semgnet
	for (int segment_id = 0; segment_id < all_segment_linked_list.size(); segment_id++) {
		const auto& const all_list_segment = all_segment_linked_list[segment_id];
		assert(all_list_segment.right_endpoint != INF && all_list_segment.rectangle_width != INF && all_list_segment.segment_right_height_difference != INF && all_list_segment.rectangle_width > 0);

		int begin_id = all_list_segment.right_endpoint - all_list_segment.rectangle_width + 1;
		for (int array_id = begin_id; array_id <= all_list_segment.right_endpoint; array_id++) {
			if (all_list_segment.is_flat) {// assert flat point in flat segment
				assert(is_flat_point(y_projection_argument, original_time_series_vector[array_id]));
			}
			else {// assert burst point in burst segment is not flat points and all same
				assert(!is_flat_point(y_projection_argument, original_time_series_vector[array_id]));
				if (array_id + 1 <= all_list_segment.right_endpoint) {
					assert(original_time_series_vector[array_id] == original_time_series_vector[array_id + 1]);
				}
			}
		}
	}
	// assert all linked list, the adajcent segment. height difference.
	for (int segment_id = 0; segment_id < all_segment_linked_list.size() - 1; segment_id++) {
		const auto& const all_list_segment = all_segment_linked_list[segment_id];
		assert(all_list_segment.right_endpoint < all_segment_linked_list[segment_id + 1].right_endpoint);
		assert(all_list_segment.segment_right_height_difference == original_time_series_vector[int(all_list_segment.right_endpoint) + 1] - original_time_series_vector[int(all_list_segment.right_endpoint)]);
		// adjacent burst segmetn. the endpoint is different
		if (!all_list_segment.is_flat) {
			assert(original_time_series_vector[int(all_list_segment.right_endpoint) + 1] != original_time_series_vector[int(all_list_segment.right_endpoint)]);
		}
	}

	for (int segment_id = 0; segment_id < cluster_linked_list.size(); segment_id++) {
		const auto& const cluster_list_segment = cluster_linked_list[segment_id];
		assert(cluster_list_segment.right_endpoint != INF && cluster_list_segment.rectangle_width != INF && cluster_list_segment.segment_right_height_difference != INF && cluster_list_segment.rectangle_width > 0);
		int begin_id = cluster_list_segment.right_endpoint - cluster_list_segment.rectangle_width + 1;

		for (int array_id = begin_id; array_id <= cluster_list_segment.right_endpoint; array_id++) {
			if (cluster_list_segment.is_flat) {
				assert(is_flat_point(y_projection_argument, original_time_series_vector[array_id]));
			}
			else {
				assert(!is_flat_point(y_projection_argument, original_time_series_vector[array_id]));
			}

		}
	}
#endif
	/*========================================================================================================================================*/

	/*=============================================================EvaluateIndependent cluster linked list========================================================*/
#ifdef _DEBUG
	burst_temp_segment.right_endpoint = 0;
	burst_temp_segment.rectangle_width = 0;
	for (int segment_id = 0; segment_id < all_segment_linked_list.size(); segment_id++) {
		auto& const all_segment = all_segment_linked_list[segment_id];

		assert(all_segment.segment_right_height_difference != INF);

		/*---------              burst segment          ----------------*/
		if (original_time_series_vector[int(all_segment.right_endpoint)] != y_projection_argument.flat_segment_max && original_time_series_vector[int(all_segment.right_endpoint)] != y_projection_argument.flat_segment_min) {
			assert(!all_segment.is_flat);
			burst_temp_segment.rectangle_width += all_segment.rectangle_width;
			burst_temp_segment.right_endpoint = all_segment.right_endpoint;
			burst_temp_segment.segment_right_height_difference = all_segment.segment_right_height_difference;
		}/*---------             flat segment          ----------------*/
		else {
			assert(all_segment.is_flat);
			/*.........   count flat segment  .............*/
			test_flat_segment_number++;
			test_total_flat_segment_length += all_segment.rectangle_width;
			/*............................................*/
			if (burst_temp_segment.rectangle_width > 0) {
#ifdef _DEBUG
				assert(burst_temp_segment.segment_right_height_difference != INF && burst_temp_segment.right_endpoint == all_segment.right_endpoint - all_segment.rectangle_width || burst_temp_segment.right_endpoint - 1 == all_segment.right_endpoint - all_segment.rectangle_width);
#endif
				test_cluster_linked_list.add(burst_temp_segment);
			}

			all_segment.is_flat = true;
#ifdef _DEBUG
			assert(all_segment.segment_right_height_difference != INF);
#endif
			test_cluster_linked_list.add(all_segment);
			burst_temp_segment.right_endpoint = 0;
			burst_temp_segment.rectangle_width = 0;
		}
	}
	//for end segment
	if (burst_temp_segment.rectangle_width > 0) {
#ifdef _DEBUG
		assert(burst_temp_segment.segment_right_height_difference != INF && burst_temp_segment.right_endpoint == input_argument.time_series_length - 1);
#endif
		test_cluster_linked_list.add(burst_temp_segment);
	}
#ifdef _DEBUG
	assert(test_cluster_linked_list.back().right_endpoint == input_argument.time_series_length - 1 && test_cluster_linked_list[0].rectangle_width == test_cluster_linked_list[0].right_endpoint + 1);
#endif
#endif
	/*==========================================================================================================================================================================================================*/
	/*==================================================== Evaluation ============================================================================*/
#ifdef _DEBUG

	assert(test_flat_segment_number == y_projection_argument.flat_segment_number && test_total_flat_segment_length == y_projection_argument.total_flat_segment_length);
	/*...................assert right endpoint, width, right height difference........................*/
	assert_linkedlist_rightEndpoint_Width_rightHeightDifference(input_argument, all_segment_linked_list);
	assert_linkedlist_rightEndpoint_Width_rightHeightDifference(input_argument, cluster_linked_list);
	assert_linkedlist_rightEndpoint_Width_rightHeightDifference(input_argument, test_cluster_linked_list);
	/*................................................................................................*/
	assert(cluster_linked_list.size() == test_cluster_linked_list.size());
	assert(cluster_linked_list.front().rectangle_width == test_cluster_linked_list.front().rectangle_width && cluster_linked_list.front().rectangle_width == cluster_linked_list.front().right_endpoint + 1 && test_cluster_linked_list.front().rectangle_width == test_cluster_linked_list.front().right_endpoint + 1);
	for (int segment_id = 1; segment_id < cluster_linked_list.size(); segment_id++) {
		const auto& const left_segment = cluster_linked_list[segment_id - 1];
		const auto& const right_segment = cluster_linked_list[segment_id];
		const auto& const test_cluster_segment = test_cluster_linked_list[segment_id];
		assert(right_segment.right_endpoint == test_cluster_segment.right_endpoint && right_segment.rectangle_width == test_cluster_segment.rectangle_width && right_segment.is_flat == test_cluster_segment.is_flat && right_segment.segment_right_height_difference == test_cluster_segment.segment_right_height_difference && right_segment.segment_right_height_difference != INF);
		assert(left_segment.right_endpoint == right_segment.right_endpoint - right_segment.rectangle_width);
	}
#endif	
	/*========================================================================================================================================*/
}

//************************************
// Method:yProjectionAPLAMerge
// Qualifier:190730  y projection, merge initialed y projection method.
// date:190730
// author:
//************************************
TEMPLATE
void APLA::yProjectionAPLAMerge(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, const map<double, int>& const whole_difference_map, vector<AREA_COEFFICIENT>& const area_vector) {
#if _DEBUG
	assert(area_vector.size() > 0);
#endif

	AREA_COEFFICIENT temp_coefficient;
	int segment_id = INF;

	/*===  Whole segment number <= N, try to split flat segment  ===*/
	if (area_vector.size() <= input_argument.point_dimension) {
#if _DEBUG

		/*cout << "flat segment height \n";
		for_each_n(area_vector.begin(), area_vector.size(), [](auto&& au) { if(au.y_projection_coefficient.is_flat) cout<<au.rectangle_height<<","; });
		cout << endl;*/
#endif
		int segment_middle_id = INF;
		while (area_vector.size() < input_argument.point_dimension) {
			for (segment_id = 0; segment_id < area_vector.size() && area_vector.size() < input_argument.point_dimension; segment_id++) {
				if (area_vector[segment_id].y_projection_coefficient.is_flat && area_vector[segment_id].rectangle_width > 3) {
#if _DEBUG
					assert(area_vector[segment_id].rectangle_width > 1);
#endif
					segment_middle_id = findSegmentMiddleID(area_vector[segment_id]);
					temp_coefficient.y_projection_coefficient.is_flat = true;
					/*=================================Splited left sub segment====================================*/
					temp_coefficient.right_endpoint = segment_middle_id;
					temp_coefficient.rectangle_width = segment_middle_id - area_vector[segment_id].segment_left_point.id + 1;
					temp_coefficient.segment_right_point.id = segment_middle_id;
					temp_coefficient.segment_right_point.value = original_time_series[segment_middle_id];
					temp_coefficient.segment_left_point = area_vector[segment_id].segment_left_point;
					temp_coefficient.y_projection_coefficient.segment_left_height_difference = area_vector[segment_id].y_projection_coefficient.segment_left_height_difference;
					temp_coefficient.y_projection_coefficient.segment_right_height_difference = temp_coefficient.segment_right_point.value - original_time_series[segment_middle_id + 1];
#if _DEBUG
					assert(temp_coefficient.right_endpoint == temp_coefficient.segment_right_point.id);
#endif
					/*...............................................................................................*/
					/*=================================Splited right sub segment====================================*/
					area_vector[segment_id].rectangle_width -= temp_coefficient.rectangle_width;
					area_vector[segment_id].segment_left_point.id = segment_middle_id + 1;
					area_vector[segment_id].segment_left_point.value = original_time_series[segment_middle_id + 1];
					area_vector[segment_id].y_projection_coefficient.segment_left_height_difference = area_vector[segment_id].segment_left_point.value - original_time_series[segment_middle_id];
#if _DEBUG
					assert(area_vector[segment_id].rectangle_width == area_vector[segment_id].right_endpoint - temp_coefficient.right_endpoint);

#endif
					/*...............................................................................................*/

					/*------   Min Max point, rectangle height. get left sub segment & right sub segment    -------*/
					temp_coefficient.min_point.value = area_vector[segment_id].min_point.value;
					temp_coefficient.max_point.value = area_vector[segment_id].max_point.value;
					temp_coefficient.rectangle_height = area_vector[segment_id].rectangle_height;
#if _DEBUG
					assert(temp_coefficient.rectangle_height == temp_coefficient.max_point.value - temp_coefficient.min_point.value);
#endif
					/*.............................................................................................*/
					area_vector.insert(area_vector.begin() + segment_id, temp_coefficient);
				}
			}
		}
#if _DEBUG
		assert(area_vector.size() == input_argument.point_dimension);
#endif
		return;
	}
	/*.............................................................*/
	int flat_segment_number = 0;
	vector<AREA_COEFFICIENT> merged_area_vector;

	temp_coefficient.min_point.value = INF;
	temp_coefficient.max_point.value = -INF;
	temp_coefficient.rectangle_width = 0;

	/*========================================================================Cluster unstable points=================================================================================*/
	for (auto&& au : area_vector) {
		/*------------------------------------------------push back mountain & flat segment--------------------------------------------------------*/
#if _DEBUG
		assert(au.rectangle_height != INF && au.rectangle_width != INF && au.segment_right_point.id == au.right_endpoint && au.segment_right_point.value == original_time_series[int(au.right_endpoint)] && au.y_projection_coefficient.segment_right_height_difference != INF && au.y_projection_coefficient.segment_left_height_difference != INF);
#endif
		if (au.y_projection_coefficient.is_flat || fabs(au.y_projection_coefficient.segment_right_height_difference) > (merged_area_vector.empty() ? INF : fabs(merged_area_vector.front().y_projection_coefficient.segment_left_height_difference))) {
			flat_segment_number++;
			/*----------- ------     push back mountain segment     ----------------------*/
			if (!temp_coefficient.y_projection_coefficient.sub_segment_vector.empty()) {
#if _DEBUG
				assert(temp_coefficient.rectangle_width > 0 && temp_coefficient.rectangle_width == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id - temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id + 1 && temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id - temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id + 1 == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id - merged_area_vector.back().right_endpoint);
#endif
				temp_coefficient.rectangle_height = temp_coefficient.max_point.value - temp_coefficient.min_point.value;
				temp_coefficient.y_projection_coefficient.is_flat = false;

				temp_coefficient.right_endpoint = temp_coefficient.y_projection_coefficient.sub_segment_vector.back().right_endpoint;
				temp_coefficient.segment_right_point = temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point;
				temp_coefficient.segment_left_point = temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point;

				temp_coefficient.y_projection_coefficient.segment_right_height_difference = temp_coefficient.y_projection_coefficient.sub_segment_vector.back().y_projection_coefficient.segment_right_height_difference;
				temp_coefficient.y_projection_coefficient.segment_left_height_difference = temp_coefficient.y_projection_coefficient.sub_segment_vector.front().y_projection_coefficient.segment_left_height_difference;
#if _DEBUG
				assert(temp_coefficient.rectangle_height != INF && temp_coefficient.segment_right_point.id == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id && temp_coefficient.segment_right_point.value == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.value && temp_coefficient.segment_left_point.id == temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id && temp_coefficient.segment_left_point.value == temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.value);
				assert(temp_coefficient.y_projection_coefficient.segment_right_height_difference != INF && temp_coefficient.y_projection_coefficient.segment_left_height_difference != INF);
#endif
				merged_area_vector.emplace_back(temp_coefficient);

				temp_coefficient.y_projection_coefficient.sub_segment_vector.clear();
				temp_coefficient.y_projection_coefficient.sub_segment_vector.shrink_to_fit();
				//temp_coefficient.~AREA_COEFFICIENT();
				temp_coefficient.min_point.value = INF;
				temp_coefficient.max_point.value = -INF;
				temp_coefficient.rectangle_height = INF;
				temp_coefficient.rectangle_width = 0;
			}
			/*...............................................................................*/
			/*---------push back flat segment-----------*/
#if _DEBUG
			assert(au.y_projection_coefficient.segment_right_height_difference != INF && au.y_projection_coefficient.segment_left_height_difference != INF);
#endif

			//au.rectangle_height = 0;
			if (au.y_projection_coefficient.is_flat)
				merged_area_vector.emplace_back(au);
			else {
#if _DEBUG
				assert(au.segment_right_point.value != INF && au.rectangle_width != INF && au.y_projection_coefficient.segment_right_height_difference != INF && au.y_projection_coefficient.segment_left_height_difference != INF);
#endif
				temp_coefficient.min_point.value = min(temp_coefficient.min_point.value, au.segment_right_point.value);
				temp_coefficient.max_point.value = max(temp_coefficient.max_point.value, au.segment_right_point.value);
				temp_coefficient.rectangle_width += au.rectangle_width;
				temp_coefficient.y_projection_coefficient.sub_segment_vector.emplace_back(au);
#if _DEBUG
				assert(temp_coefficient.rectangle_width == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id - temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id + 1);
#endif
			}

			/*..........................................*/
		}/*.......................................................................................................*/
		else {
			/*------------------------ ---push back mountain sub segemnt-----------------------------------------------*/
#if _DEBUG
			assert(au.segment_right_point.value != INF && au.rectangle_width != INF && au.y_projection_coefficient.segment_right_height_difference != INF && au.y_projection_coefficient.segment_left_height_difference != INF);
#endif
			temp_coefficient.min_point.value = min(temp_coefficient.min_point.value, au.segment_right_point.value);
			temp_coefficient.max_point.value = max(temp_coefficient.max_point.value, au.segment_right_point.value);
			temp_coefficient.rectangle_width += au.rectangle_width;
			temp_coefficient.y_projection_coefficient.sub_segment_vector.emplace_back(au);
#if _DEBUG
			assert(temp_coefficient.rectangle_width == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id - temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id + 1);
#endif
			/*..................................................................................................*/
		}
	}
	/*................................................................................................................................................................................*/

	/*------------------------------------------------------Last segment-----------------------------------------------------------*/
	if (!temp_coefficient.y_projection_coefficient.sub_segment_vector.empty()) {
#if _DEBUG
		assert(temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id != INF);
		assert(temp_coefficient.rectangle_width > 0 && temp_coefficient.rectangle_width == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id - temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id + 1 && temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id - temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id + 1 == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id - merged_area_vector.back().right_endpoint);
#endif
		temp_coefficient.rectangle_height = temp_coefficient.max_point.value - temp_coefficient.min_point.value;
		temp_coefficient.y_projection_coefficient.is_flat = false;

		temp_coefficient.right_endpoint = temp_coefficient.y_projection_coefficient.sub_segment_vector.back().right_endpoint;
		temp_coefficient.segment_right_point = temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point;
		temp_coefficient.segment_left_point = temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point;

		temp_coefficient.y_projection_coefficient.segment_right_height_difference = temp_coefficient.y_projection_coefficient.sub_segment_vector.back().y_projection_coefficient.segment_right_height_difference;
		temp_coefficient.y_projection_coefficient.segment_left_height_difference = temp_coefficient.y_projection_coefficient.sub_segment_vector.front().y_projection_coefficient.segment_left_height_difference;
#if _DEBUG
		assert(temp_coefficient.rectangle_height != INF && temp_coefficient.segment_right_point.id == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id && temp_coefficient.segment_right_point.value == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.value && temp_coefficient.segment_left_point.id == temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id && temp_coefficient.segment_left_point.value == temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.value);
#endif
		merged_area_vector.emplace_back(temp_coefficient);
	}
	/*................................................................................................................................*/

#if _DEBUG
	assert(merged_area_vector.back().right_endpoint == input_argument.time_series_length - 1);
	for_each_n(merged_area_vector.begin(), merged_area_vector.size(), [](auto&& au) {assert(au.rectangle_height != INF && au.right_endpoint != INF && au.rectangle_width != INF && au.y_projection_coefficient.segment_right_height_difference != INF); });
	for_each_n(merged_area_vector.begin(), merged_area_vector.size(), [](auto&& au) {if (!au.y_projection_coefficient.is_flat) assert(au.y_projection_coefficient.segment_left_height_difference == au.y_projection_coefficient.sub_segment_vector.front().y_projection_coefficient.segment_left_height_difference && au.y_projection_coefficient.segment_right_height_difference == au.y_projection_coefficient.sub_segment_vector.back().y_projection_coefficient.segment_right_height_difference); });
	cout << "Rectangle height: " << endl;
	for_each_n(merged_area_vector.begin(), merged_area_vector.size(), [](auto&& au) {cout << au.rectangle_height << ","; });
	cout << endl;
	cout << "Segment right difference: " << endl;
	for_each_n(merged_area_vector.begin(), merged_area_vector.size(), [](auto&& au) {cout << au.y_projection_coefficient.segment_right_height_difference << ","; });
	cout << endl;
	cout << "Merged vector : " << endl;
	for (auto&& au : merged_area_vector) {
		cout << ";{" << au.right_endpoint + 1 << "}; ";
		if (!au.y_projection_coefficient.sub_segment_vector.empty()) {
			cout << "(";
			for_each(au.y_projection_coefficient.sub_segment_vector.begin(), au.y_projection_coefficient.sub_segment_vector.end(), [](const AREA_COEFFICIENT& const segment) {cout << segment.right_endpoint + 1 << ","; });
			cout << ")";
		}
	}
	cout << endl;
	cout << "Whole segment size: " << area_vector.size() << ", Merged segment size: " << merged_area_vector.size() << " Flat number: " << flat_segment_number << endl;
#endif

	/*------------------------------If N == 2 -----------------------------*/
	if (input_argument.point_dimension == 2) {
		vector<AREA_COEFFICIENT> result_area_vector;
		for (auto&& au : merged_area_vector) {
			if (au.y_projection_coefficient.is_flat && au.rectangle_width >= input_argument.time_series_length / 2) {
				temp_coefficient.right_endpoint = au.segment_right_point.id;
				temp_coefficient.rectangle_width = temp_coefficient.right_endpoint + 1;
				result_area_vector.emplace_back(temp_coefficient);
				temp_coefficient.right_endpoint = input_argument.time_series_length - 1;
				temp_coefficient.rectangle_width = temp_coefficient.right_endpoint - result_area_vector.back().right_endpoint;
				result_area_vector.emplace_back(temp_coefficient);
				area_vector.swap(result_area_vector);
				return;
			}
		}
	}
	/*.....................................................................*/

	/*................................................................................................................................................................................*/

	//????????????????????????????Needs improvement
	//temp_coefficient.~AREA_COEFFICIENT();

	map<double, int> height_difference_id_map;// get shortest segment

	/*=================================================================================Merge Segemnt===================================================================================*/
	if (merged_area_vector.size() > input_argument.point_dimension) {
		while (merged_area_vector.size() > input_argument.point_dimension) {
			height_difference_id_map.clear();
			/*------------------------------Find Merge Candidate ID--------------------------------------------*/
#if _DEBUG
			assert(height_difference_id_map.empty());
			/*cout << "Segment left difference: " << endl;
			for_each_n(merged_area_vector.begin(), merged_area_vector.size(), [](auto&& au) {cout << au.y_projection_coefficient.segment_left_height_difference << ","; });
			cout << endl;*/
#endif
			for (segment_id = 1; segment_id < merged_area_vector.size(); segment_id++) {
#if _DEBUG
				assert(merged_area_vector[segment_id].rectangle_height != INF && merged_area_vector[segment_id].right_endpoint != INF);
				if (merged_area_vector[segment_id].y_projection_coefficient.is_flat)
					assert(merged_area_vector[segment_id].y_projection_coefficient.sub_segment_vector.empty());
				if (!merged_area_vector[segment_id].y_projection_coefficient.sub_segment_vector.empty()) {
					//assert(merged_area_vector[segment_id].y_projection_coefficient.segment_left_height_difference == merged_area_vector[segment_id].y_projection_coefficient.sub_segment_vector.front().y_projection_coefficient.segment_left_height_difference);
					assert(merged_area_vector[segment_id].y_projection_coefficient.segment_right_height_difference == merged_area_vector[segment_id].y_projection_coefficient.sub_segment_vector.back().y_projection_coefficient.segment_right_height_difference);
				}
#endif
				//height_difference_id_map.emplace(merged_area_vector[segment_id].rectangle_height, segment_id); segment height
				height_difference_id_map.emplace(fabs(merged_area_vector[segment_id].y_projection_coefficient.segment_left_height_difference), segment_id); //segment right difference
			}
			/*.................................................................................................*/
			/*-----------------------------------Merge Operation-----------------------------------------------*/
#if _DEBUG
			/*for_each_n(height_difference_id_map.begin(), height_difference_id_map.size(), [](auto&& au) {cout << au.first<<":"<< au.second <<", "; });
			cout << endl;*/
			assert(!height_difference_id_map.empty());
#endif
			auto shortest_segment_id = height_difference_id_map.begin()->second;
			if (shortest_segment_id == 0) {
				assert(0);
			}
			else {//?? Needs improvement; merge 3 segments, top in the center.
				auto left_segment_id = shortest_segment_id - 1;
				merged_area_vector[shortest_segment_id].rectangle_width += merged_area_vector[left_segment_id].rectangle_width;
				merged_area_vector[shortest_segment_id].segment_left_point = merged_area_vector[left_segment_id].segment_left_point;
				merged_area_vector[shortest_segment_id].y_projection_coefficient.segment_left_height_difference = merged_area_vector[left_segment_id].y_projection_coefficient.segment_left_height_difference;
				merged_area_vector[shortest_segment_id].min_point.value = min(merged_area_vector[shortest_segment_id].min_point.value, merged_area_vector[left_segment_id].min_point.value);
				merged_area_vector[shortest_segment_id].max_point.value = max(merged_area_vector[shortest_segment_id].max_point.value, merged_area_vector[left_segment_id].max_point.value);
				merged_area_vector[shortest_segment_id].rectangle_height = merged_area_vector[shortest_segment_id].max_point.value - merged_area_vector[shortest_segment_id].min_point.value;
				/*-------               Left segment           --------*/
				merged_area_vector[left_segment_id].right_endpoint = INF;
				merged_area_vector[left_segment_id].rectangle_width = INF;
				/*.....................................................*/
				merged_area_vector.erase(merged_area_vector.begin() + left_segment_id);
#if _DEBUG
				assert(merged_area_vector[left_segment_id].right_endpoint != INF && merged_area_vector[left_segment_id].rectangle_width != INF && merged_area_vector[left_segment_id].rectangle_height != INF && merged_area_vector[left_segment_id].min_point.value != INF && merged_area_vector[left_segment_id].max_point.value != INF);
#endif
			}
			//??????????????????????????
			/*.................................................................................................*/
		}
		/*..............................................................................................................................................................................................*/
	}/*================================================================================Split Segment====================================================================================================*/
	else if (merged_area_vector.size() < input_argument.point_dimension) {
		while (merged_area_vector.size() < input_argument.point_dimension) {
			height_difference_id_map.clear();
			/*-----------------------------------Find highest segment to split--------------------------------*/
#if _DEBUG
			assert(height_difference_id_map.empty());
#endif
			for (segment_id = 0; segment_id < merged_area_vector.size(); segment_id++) {
#if _DEBUG
				assert(merged_area_vector[segment_id].rectangle_height != INF);
#endif
				if (merged_area_vector[segment_id].rectangle_height > 0 && merged_area_vector[segment_id].y_projection_coefficient.sub_segment_vector.size() > 1) {
#if _DEBUG
					assert(!merged_area_vector[segment_id].y_projection_coefficient.is_flat && !merged_area_vector[segment_id].y_projection_coefficient.sub_segment_vector.empty() && merged_area_vector[segment_id].rectangle_height != INF);
					if (segment_id > 0)
						assert(merged_area_vector[segment_id].rectangle_width == merged_area_vector[segment_id].right_endpoint - merged_area_vector[segment_id - 1].right_endpoint);
#endif
					height_difference_id_map.emplace(merged_area_vector[segment_id].rectangle_height, segment_id);
				}
			}
			/*.................................................................................................*/
#if _DEBUG
			assert(!height_difference_id_map.empty());
#endif
			/*-----------------------------------Split Operation-----------------------------------------------*/
			auto highest_segment_id = height_difference_id_map.rbegin()->second;

			if (highest_segment_id == 0) {
				assert(0);
			}
			else {//?? Needs improvement; merge 3 segments, top in the center.
#if _DEBUG
				assert(!merged_area_vector[highest_segment_id].y_projection_coefficient.is_flat && !merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector.empty());
				assert(merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector.front().segment_left_point.id == merged_area_vector[highest_segment_id].segment_left_point.id && merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector.front().segment_left_point.value == merged_area_vector[highest_segment_id].segment_left_point.value);
				assert(merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector.back().segment_right_point.id == merged_area_vector[highest_segment_id].segment_right_point.id && merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector.back().segment_right_point.value == merged_area_vector[highest_segment_id].segment_right_point.value);
				assert(merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector.back().y_projection_coefficient.segment_right_height_difference == merged_area_vector[highest_segment_id].y_projection_coefficient.segment_right_height_difference && merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector.front().y_projection_coefficient.segment_left_height_difference == merged_area_vector[highest_segment_id].y_projection_coefficient.segment_left_height_difference);
				assert(merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector.front().segment_left_point.id == merged_area_vector[highest_segment_id - 1].right_endpoint + 1);
#endif
				//AREA_COEFFICIENT left_coefficient, middle_coefficient;
				if (merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector.size() == 1) {
					continue;
				}

				map<double, int> sub_height_difference_id_map;
				int sub_segment_id = INF;
				int highest_difference_sub_segment_id = INF;

				/*----------------------------------------------Find highest segment difference in sub segment----------------------------------------------*/
				for (sub_segment_id = 0; sub_segment_id < merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector.size() - 1; sub_segment_id++) {
#if _DEBUG
					assert(merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector[sub_segment_id].y_projection_coefficient.segment_right_height_difference != INF);
#endif
					sub_height_difference_id_map.emplace(fabs(merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector[sub_segment_id].y_projection_coefficient.segment_right_height_difference), sub_segment_id);
				}
				/*..........................................................................................................................................*/

				//temp_coefficient.~AREA_COEFFICIENT();
				//get highest sub segment id
				temp_coefficient.y_projection_coefficient.sub_segment_vector.clear();
				temp_coefficient.y_projection_coefficient.sub_segment_vector.shrink_to_fit();
				highest_difference_sub_segment_id = sub_height_difference_id_map.rbegin()->second;

				/*=================================Splited left sub segment====================================*/
				temp_coefficient.right_endpoint = merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector[highest_difference_sub_segment_id].right_endpoint;
				temp_coefficient.rectangle_width = temp_coefficient.right_endpoint - merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector.front().segment_left_point.id + 1;
				temp_coefficient.segment_right_point = merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector[highest_difference_sub_segment_id].segment_right_point;
				temp_coefficient.segment_left_point = merged_area_vector[highest_segment_id].segment_left_point;
				temp_coefficient.y_projection_coefficient.segment_left_height_difference = merged_area_vector[highest_segment_id].y_projection_coefficient.segment_left_height_difference;
				temp_coefficient.y_projection_coefficient.segment_right_height_difference = merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector[highest_difference_sub_segment_id].y_projection_coefficient.segment_right_height_difference;
#if _DEBUG
				assert(temp_coefficient.right_endpoint == merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector[highest_difference_sub_segment_id].segment_right_point.id);
				assert(temp_coefficient.rectangle_width == temp_coefficient.right_endpoint - merged_area_vector[highest_segment_id - 1].right_endpoint);
#endif
				/*==============================================================================================*/
				/*=================================Splited right sub segment====================================*/
				merged_area_vector[highest_segment_id].rectangle_width -= temp_coefficient.rectangle_width;
				merged_area_vector[highest_segment_id].segment_left_point = merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector[highest_difference_sub_segment_id + 1].segment_left_point;
				merged_area_vector[highest_segment_id].y_projection_coefficient.segment_left_height_difference = merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector[highest_difference_sub_segment_id + 1].y_projection_coefficient.segment_left_height_difference;
#if _DEBUG
				assert(merged_area_vector[highest_segment_id].rectangle_width == merged_area_vector[highest_segment_id].right_endpoint - temp_coefficient.right_endpoint);
#endif
				/*==============================================================================================*/

				/*-----------------------------Split highest segment Sub Segments---------------------------------*/
				// copy first several sub segments
				temp_coefficient.y_projection_coefficient.sub_segment_vector.assign(merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector.begin(), merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector.begin() + highest_difference_sub_segment_id + 1);
				// erase first several sub elements:
				merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector.erase(merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector.begin(), merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector.begin() + highest_difference_sub_segment_id + 1);
				/*-----------------------------------------------------------------------------------------------*/

				/*------   Min Max point, rectangle height. get left sub segment & right sub segment    -------*/
				temp_coefficient.min_point.value = merged_area_vector[highest_segment_id].min_point.value = INF;
				temp_coefficient.max_point.value = merged_area_vector[highest_segment_id].max_point.value = -INF;

				for (auto&& au : temp_coefficient.y_projection_coefficient.sub_segment_vector) {
#if _DEBUG
					assert(au.segment_left_point.value == au.segment_right_point.value && au.min_point.value == au.max_point.value);
#endif
					temp_coefficient.min_point.value = min(temp_coefficient.min_point.value, au.min_point.value);
					temp_coefficient.max_point.value = max(temp_coefficient.max_point.value, au.max_point.value);
				}

				for (auto&& au : merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector) {
#if _DEBUG
					assert(au.segment_left_point.value == au.segment_right_point.value && au.min_point.value == au.max_point.value);
#endif
					merged_area_vector[highest_segment_id].min_point.value = min(merged_area_vector[highest_segment_id].min_point.value, au.min_point.value);
					merged_area_vector[highest_segment_id].max_point.value = max(merged_area_vector[highest_segment_id].max_point.value, au.max_point.value);
				}

				temp_coefficient.rectangle_height = temp_coefficient.max_point.value - temp_coefficient.min_point.value;
				merged_area_vector[highest_segment_id].rectangle_height = merged_area_vector[highest_segment_id].max_point.value - merged_area_vector[highest_segment_id].min_point.value;
				/*.............................................................................................*/
#if _DEBUG
				assert(temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id + 1 == merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector.front().segment_left_point.id);
				assert(temp_coefficient.y_projection_coefficient.sub_segment_vector.back().right_endpoint == temp_coefficient.right_endpoint);
				assert(temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id == temp_coefficient.segment_right_point.id);
				assert(temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id == temp_coefficient.segment_left_point.id);
				assert(temp_coefficient.segment_right_point.id + 1 == merged_area_vector[highest_segment_id].segment_left_point.id);
				assert(temp_coefficient.y_projection_coefficient.sub_segment_vector.back().y_projection_coefficient.segment_right_height_difference == temp_coefficient.y_projection_coefficient.segment_right_height_difference);
				assert(temp_coefficient.y_projection_coefficient.sub_segment_vector.front().y_projection_coefficient.segment_left_height_difference == temp_coefficient.y_projection_coefficient.segment_left_height_difference);

				assert(temp_coefficient.rectangle_height >= 0 && merged_area_vector[highest_segment_id].rectangle_height >= 0);
				assert(merged_area_vector[highest_segment_id].segment_left_point.id == merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector.front().segment_left_point.id);
				assert(merged_area_vector[highest_segment_id].segment_right_point.id == merged_area_vector[highest_segment_id].y_projection_coefficient.sub_segment_vector.back().segment_right_point.id);

				//assert(temp_coefficient.y_projection_coefficient.sub_segment_vector.back().right_endpoint + 1 == assert(merged_area_vector[highest_segment_id].segment_left_point.id);
				assert(temp_coefficient.y_projection_coefficient.segment_right_height_difference == merged_area_vector[highest_segment_id].y_projection_coefficient.segment_left_height_difference * -1);
#endif
				merged_area_vector.insert(merged_area_vector.begin() + highest_segment_id, temp_coefficient);
			}
			/*....................................................................................................*/
		}
	}
	else {
		area_vector.swap(merged_area_vector);
#if _DEBUG
		assert(area_vector.size() == input_argument.point_dimension);
#endif
		return;
		assert(0);
	}
	/*..................................................................................................................................................................................................*/
	//??????

	area_vector.swap(merged_area_vector);

#if _DEBUG
	assert(area_vector.size() == input_argument.point_dimension);
#endif
}

//************************************
// Method:YProjectionAPLALink
// Qualifier:190730 y projection, merge & split. initialed y projection method.
// Input: 1 min value & max value(threshold) of flat segment, 2 Original time series, 3 initialized Linked List
// Output: APLA Linked list
// date:191029
// author:
//************************************
TEMPLATE
void APLA::YProjectionAPLALink(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, const typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list) {
#if _DEBUG
	assert(!doubly_linked_list.empty() && y_projection_argument.initial_N != INF && y_projection_argument.flat_segment_min != INF && y_projection_argument.flat_segment_max != INF); //threshhold);
#endif
	AREA_COEFFICIENT temp_coefficient;
	int segment_id = INF;

	/*==========================================================  segment number <= N, split flat segment  ============================================================================*/
	if (doubly_linked_list.size() <= input_argument.point_dimension) {
#if _DEBUG
		/*cout << "flat segment height \n";
		for_each_n(area_vector.begin(), area_vector.size(), [](auto&& au) { if(au.y_projection_coefficient.is_flat) cout<<au.rectangle_height<<","; });
		cout << endl;*/
#endif
		int segment_middle_id = INF;
		while (doubly_linked_list.size() < input_argument.point_dimension) {
			for (segment_id = 0; segment_id < doubly_linked_list.size() && doubly_linked_list.size() < input_argument.point_dimension; segment_id++) {
				/*----------------------------------------------------Flat segment ---------------------------------------------------------------------*/
				if (doubly_linked_list[segment_id].y_projection_coefficient.is_flat && doubly_linked_list[segment_id].rectangle_width > 3) {
#if _DEBUG
					assert(doubly_linked_list[segment_id].rectangle_width > 1);
#endif
					segment_middle_id = findSegmentMiddleID(doubly_linked_list[segment_id]);
					temp_coefficient.y_projection_coefficient.is_flat = true;
					/*=================================Splited left sub segment====================================*/
					temp_coefficient.right_endpoint = segment_middle_id;
					temp_coefficient.rectangle_width = segment_middle_id - doubly_linked_list[segment_id].segment_left_point.id + 1;
					temp_coefficient.segment_right_point.id = segment_middle_id;
					temp_coefficient.segment_right_point.value = original_time_series[segment_middle_id];
					temp_coefficient.segment_left_point = doubly_linked_list[segment_id].segment_left_point;
					temp_coefficient.y_projection_coefficient.segment_left_height_difference = doubly_linked_list[segment_id].y_projection_coefficient.segment_left_height_difference;
					temp_coefficient.y_projection_coefficient.segment_right_height_difference = temp_coefficient.segment_right_point.value - original_time_series[segment_middle_id + 1];
#if _DEBUG
					assert(temp_coefficient.right_endpoint == temp_coefficient.segment_right_point.id);
#endif
					/*===============================================================================================*/
					/*==================================Splited right sub segment====================================*/
					doubly_linked_list[segment_id].rectangle_width -= temp_coefficient.rectangle_width;
					doubly_linked_list[segment_id].segment_left_point.id = segment_middle_id + 1;
					doubly_linked_list[segment_id].segment_left_point.value = original_time_series[segment_middle_id + 1];
					doubly_linked_list[segment_id].y_projection_coefficient.segment_left_height_difference = doubly_linked_list[segment_id].segment_left_point.value - original_time_series[segment_middle_id];
#if _DEBUG
					assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - temp_coefficient.right_endpoint);
#endif
					/*================================================================================================*/

					/*---------   Min Max point, rectangle height. get left sub segment & right sub segment ----------*/
					temp_coefficient.min_point.value = doubly_linked_list[segment_id].min_point.value;
					temp_coefficient.max_point.value = doubly_linked_list[segment_id].max_point.value;
					temp_coefficient.rectangle_height = doubly_linked_list[segment_id].rectangle_height;
#if _DEBUG
					assert(temp_coefficient.rectangle_height == temp_coefficient.max_point.value - temp_coefficient.min_point.value);
#endif
					/*-------------------------------------------------------------------------------------------------*/
					doubly_linked_list.insertValueBeforeNode(temp_coefficient, doubly_linked_list.getNode(segment_id));
				}
				/*---------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
			}
		}
#if _DEBUG
		assert(doubly_linked_list.size() == input_argument.point_dimension);
#endif
		return;
	}
	/*========================================================================================================================================================================================================*/

	int flat_segment_number = 0;
	//vector<AREA_COEFFICIENT> merged_area_vector;
	DoublyLinkedList<AREA_COEFFICIENT> merged_linked_list;

	temp_coefficient.min_point.value = INF;
	temp_coefficient.max_point.value = -INF;
	temp_coefficient.rectangle_width = 0;

	/*======================================================================== linked list size > N, Cluster unstable points(unflat segments)=================================================================================*/
	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		/*------------------------------------------------push back mountain & flat segment--------------------------------------------------------*/
#if _DEBUG
		assert(doubly_linked_list[segment_id].rectangle_height != INF && doubly_linked_list[segment_id].rectangle_width != INF && doubly_linked_list[segment_id].segment_right_point.id == doubly_linked_list[segment_id].right_endpoint && doubly_linked_list[segment_id].segment_right_point.value == original_time_series[int(doubly_linked_list[segment_id].right_endpoint)] && doubly_linked_list[segment_id].y_projection_coefficient.segment_right_height_difference != INF && doubly_linked_list[segment_id].y_projection_coefficient.segment_left_height_difference != INF);
#endif
		if (doubly_linked_list[segment_id].y_projection_coefficient.is_flat || fabs(doubly_linked_list[segment_id].y_projection_coefficient.segment_right_height_difference) > (merged_linked_list.empty() ? INF : fabs(merged_linked_list.front().y_projection_coefficient.segment_left_height_difference))) {
			flat_segment_number++;
			/*---------------------------------     push back mountain segment     ---------------------------------------*/
			if (!temp_coefficient.y_projection_coefficient.sub_segment_vector.empty()) {
#if _DEBUG
				assert(temp_coefficient.rectangle_width > 0 && temp_coefficient.rectangle_width == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id - temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id + 1 && temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id - temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id + 1 == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id - merged_linked_list.back().right_endpoint);
#endif
				temp_coefficient.rectangle_height = temp_coefficient.max_point.value - temp_coefficient.min_point.value;
				temp_coefficient.y_projection_coefficient.is_flat = false;

				temp_coefficient.right_endpoint = temp_coefficient.y_projection_coefficient.sub_segment_vector.back().right_endpoint;
				temp_coefficient.segment_right_point = temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point;
				temp_coefficient.segment_left_point = temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point;

				temp_coefficient.y_projection_coefficient.segment_right_height_difference = temp_coefficient.y_projection_coefficient.sub_segment_vector.back().y_projection_coefficient.segment_right_height_difference;
				temp_coefficient.y_projection_coefficient.segment_left_height_difference = temp_coefficient.y_projection_coefficient.sub_segment_vector.front().y_projection_coefficient.segment_left_height_difference;
#if _DEBUG
				assert(temp_coefficient.rectangle_height != INF && temp_coefficient.segment_right_point.id == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id && temp_coefficient.segment_right_point.value == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.value && temp_coefficient.segment_left_point.id == temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id && temp_coefficient.segment_left_point.value == temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.value);
				assert(temp_coefficient.y_projection_coefficient.segment_right_height_difference != INF && temp_coefficient.y_projection_coefficient.segment_left_height_difference != INF);
#endif
				merged_linked_list.add(temp_coefficient);

				temp_coefficient.y_projection_coefficient.sub_segment_vector.clear();
				temp_coefficient.y_projection_coefficient.sub_segment_vector.shrink_to_fit();
				//temp_coefficient.~AREA_COEFFICIENT();
				temp_coefficient.min_point.value = INF;
				temp_coefficient.max_point.value = -INF;
				temp_coefficient.rectangle_height = INF;
				temp_coefficient.rectangle_width = 0;
			}
			/*-----------------------------------------------------------------------------------------------------------*/
			/*----------------------------------------        push back flat segment    ---------------------------------*/
#if _DEBUG
			assert(doubly_linked_list[segment_id].y_projection_coefficient.segment_right_height_difference != INF && doubly_linked_list[segment_id].y_projection_coefficient.segment_left_height_difference != INF);
#endif
			//au.rectangle_height = 0;
			if (doubly_linked_list[segment_id].y_projection_coefficient.is_flat)
				merged_linked_list.add(doubly_linked_list[segment_id]);
			else {
#if _DEBUG
				assert(doubly_linked_list[segment_id].segment_right_point.value != INF && doubly_linked_list[segment_id].rectangle_width != INF && doubly_linked_list[segment_id].y_projection_coefficient.segment_right_height_difference != INF && doubly_linked_list[segment_id].y_projection_coefficient.segment_left_height_difference != INF);
#endif
				temp_coefficient.min_point.value = min(temp_coefficient.min_point.value, doubly_linked_list[segment_id].segment_right_point.value);
				temp_coefficient.max_point.value = max(temp_coefficient.max_point.value, doubly_linked_list[segment_id].segment_right_point.value);
				temp_coefficient.rectangle_width += doubly_linked_list[segment_id].rectangle_width;
				temp_coefficient.y_projection_coefficient.sub_segment_vector.emplace_back(doubly_linked_list[segment_id]);
#if _DEBUG
				assert(temp_coefficient.rectangle_width == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id - temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id + 1);
#endif
			}
			/*------------------------------------------------------------------------------------------------------------*/
		}/*.......................................................................................................*/
		else {
			/*---------------------------------push back mountain sub segemnt-----------------------------------------------*/
#if _DEBUG
			assert(doubly_linked_list[segment_id].segment_right_point.value != INF && doubly_linked_list[segment_id].rectangle_width != INF && doubly_linked_list[segment_id].y_projection_coefficient.segment_right_height_difference != INF && doubly_linked_list[segment_id].y_projection_coefficient.segment_left_height_difference != INF);
#endif
			temp_coefficient.min_point.value = min(temp_coefficient.min_point.value, doubly_linked_list[segment_id].segment_right_point.value);
			temp_coefficient.max_point.value = max(temp_coefficient.max_point.value, doubly_linked_list[segment_id].segment_right_point.value);
			temp_coefficient.rectangle_width += doubly_linked_list[segment_id].rectangle_width;
			temp_coefficient.y_projection_coefficient.sub_segment_vector.emplace_back(doubly_linked_list[segment_id]);
#if _DEBUG
			assert(temp_coefficient.rectangle_width == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id - temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id + 1);
#endif
			/*----------------------------------------------------------------------------------------------------------------*/
		}
	}
	/*===================================================================================================================================================================================*/

	/*------------------------------------------------------Last segment-----------------------------------------------------------*/
	if (!temp_coefficient.y_projection_coefficient.sub_segment_vector.empty()) {
#if _DEBUG
		assert(temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id != INF);
		assert(temp_coefficient.rectangle_width > 0 && temp_coefficient.rectangle_width == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id - temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id + 1 && temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id - temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id + 1 == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id - merged_linked_list.back().right_endpoint);
#endif
		temp_coefficient.rectangle_height = temp_coefficient.max_point.value - temp_coefficient.min_point.value;
		temp_coefficient.y_projection_coefficient.is_flat = false;

		temp_coefficient.right_endpoint = temp_coefficient.y_projection_coefficient.sub_segment_vector.back().right_endpoint;
		temp_coefficient.segment_right_point = temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point;
		temp_coefficient.segment_left_point = temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point;

		temp_coefficient.y_projection_coefficient.segment_right_height_difference = temp_coefficient.y_projection_coefficient.sub_segment_vector.back().y_projection_coefficient.segment_right_height_difference;
		temp_coefficient.y_projection_coefficient.segment_left_height_difference = temp_coefficient.y_projection_coefficient.sub_segment_vector.front().y_projection_coefficient.segment_left_height_difference;
#if _DEBUG
		assert(temp_coefficient.rectangle_height != INF && temp_coefficient.segment_right_point.id == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id && temp_coefficient.segment_right_point.value == temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.value && temp_coefficient.segment_left_point.id == temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id && temp_coefficient.segment_left_point.value == temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.value);
#endif
		merged_linked_list.add(temp_coefficient);
	}
	/*-------------------------------------------------------------------------------------------------------------------------------*/

#if _DEBUG
	assert(merged_linked_list.back().right_endpoint == input_argument.time_series_length - 1);
	for (int segment_id = 0; segment_id < merged_linked_list.size(); segment_id++) {
		assert(merged_linked_list[segment_id].rectangle_height != INF && merged_linked_list[segment_id].right_endpoint != INF && merged_linked_list[segment_id].rectangle_width != INF && merged_linked_list[segment_id].y_projection_coefficient.segment_right_height_difference != INF);
		if (!merged_linked_list[segment_id].y_projection_coefficient.is_flat) assert(merged_linked_list[segment_id].y_projection_coefficient.segment_left_height_difference == merged_linked_list[segment_id].y_projection_coefficient.sub_segment_vector.front().y_projection_coefficient.segment_left_height_difference && merged_linked_list[segment_id].y_projection_coefficient.segment_right_height_difference == merged_linked_list[segment_id].y_projection_coefficient.sub_segment_vector.back().y_projection_coefficient.segment_right_height_difference);
	}
	cout << "Rectangle height: " << endl;
	for (int segment_id = 0; segment_id < merged_linked_list.size(); segment_id++) {
		cout << merged_linked_list[segment_id].rectangle_height << ",";
	}
	cout << endl;
	cout << "Segment right difference: " << endl;
	for (int segment_id = 0; segment_id < merged_linked_list.size(); segment_id++) {
		cout << merged_linked_list[segment_id].y_projection_coefficient.segment_right_height_difference << ",";
	}
	cout << endl;
	cout << "Merged vector : " << endl;
	for (int segment_id = 0; segment_id < merged_linked_list.size(); segment_id++) {
		cout << ";{" << merged_linked_list[segment_id].right_endpoint + 1 << "}; ";
		if (!merged_linked_list[segment_id].y_projection_coefficient.sub_segment_vector.empty()) {
			cout << "(";
			for_each(merged_linked_list[segment_id].y_projection_coefficient.sub_segment_vector.begin(), merged_linked_list[segment_id].y_projection_coefficient.sub_segment_vector.end(), [](const AREA_COEFFICIENT& const segment) {cout << segment.right_endpoint + 1 << ","; });
			cout << ")";
		}
	}
	cout << endl;
	cout << "Whole segment size: " << doubly_linked_list.size() << ", Merged segment size: " << merged_linked_list.size() << " Flat number: " << flat_segment_number << endl;
#endif


	/*-----------------------------------------------------If N == 2 --------------------------------------*/
	if (input_argument.point_dimension == 2) {
		DoublyLinkedList<AREA_COEFFICIENT> result_linked_list;
		for (int segment_id = 0; segment_id < merged_linked_list.size(); segment_id++) {
			if (merged_linked_list[segment_id].y_projection_coefficient.is_flat && merged_linked_list[segment_id].rectangle_width >= input_argument.time_series_length / 2) {
				temp_coefficient.right_endpoint = merged_linked_list[segment_id].segment_right_point.id;
				temp_coefficient.rectangle_width = temp_coefficient.right_endpoint + 1;
				result_linked_list.add(temp_coefficient);
				temp_coefficient.right_endpoint = input_argument.time_series_length - 1;
				temp_coefficient.rectangle_width = temp_coefficient.right_endpoint - result_linked_list.back().right_endpoint;
				result_linked_list.add(temp_coefficient);
				//doubly_linked_list.swap(result_linked_list);
				return;
			}
		}
	}
	/*-------------------------------------------------------------------------------------------------------*/

	/*................................................................................................................................................................................*/

	//????????????????????????????Needs improvement
	//temp_coefficient.~AREA_COEFFICIENT();

	map<double, int> height_difference_id_map;// get shortest segment

	/*=================================================================================Merge Segemnt===================================================================================*/
	if (merged_linked_list.size() > input_argument.point_dimension) {
		while (merged_linked_list.size() > input_argument.point_dimension) {
			height_difference_id_map.clear();
			/*------------------------------Find Merge Candidate ID--------------------------------------------*/
#if _DEBUG
			assert(height_difference_id_map.empty());
			/*cout << "Segment left difference: " << endl;
			for_each_n(merged_area_vector.begin(), merged_area_vector.size(), [](auto&& au) {cout << au.y_projection_coefficient.segment_left_height_difference << ","; });
			cout << endl;*/
#endif
			for (segment_id = 1; segment_id < merged_linked_list.size(); segment_id++) {
#if _DEBUG
				assert(merged_linked_list[segment_id].rectangle_height != INF && merged_linked_list[segment_id].right_endpoint != INF);
				if (merged_linked_list[segment_id].y_projection_coefficient.is_flat)
					assert(merged_linked_list[segment_id].y_projection_coefficient.sub_segment_vector.empty());
				if (!merged_linked_list[segment_id].y_projection_coefficient.sub_segment_vector.empty()) {
					//assert(merged_area_vector[segment_id].y_projection_coefficient.segment_left_height_difference == merged_area_vector[segment_id].y_projection_coefficient.sub_segment_vector.front().y_projection_coefficient.segment_left_height_difference);
					assert(merged_linked_list[segment_id].y_projection_coefficient.segment_right_height_difference == merged_linked_list[segment_id].y_projection_coefficient.sub_segment_vector.back().y_projection_coefficient.segment_right_height_difference);
				}
#endif
				//height_difference_id_map.emplace(merged_area_vector[segment_id].rectangle_height, segment_id); segment height
				height_difference_id_map.emplace(fabs(merged_linked_list[segment_id].y_projection_coefficient.segment_left_height_difference), segment_id); //segment right difference
			}
			/*.................................................................................................*/
			/*-----------------------------------Merge Operation-----------------------------------------------*/
#if _DEBUG
			/*for_each_n(height_difference_id_map.begin(), height_difference_id_map.size(), [](auto&& au) {cout << au.first<<":"<< au.second <<", "; });
			cout << endl;*/
			assert(!height_difference_id_map.empty());
#endif
			auto shortest_segment_id = height_difference_id_map.begin()->second;
			if (shortest_segment_id == 0) {
				assert(0);
			}
			else {//?? Needs improvement; merge 3 segments, top in the center.
				auto left_segment_id = shortest_segment_id - 1;
				merged_linked_list[shortest_segment_id].rectangle_width += merged_linked_list[left_segment_id].rectangle_width;
				merged_linked_list[shortest_segment_id].segment_left_point = merged_linked_list[left_segment_id].segment_left_point;
				merged_linked_list[shortest_segment_id].y_projection_coefficient.segment_left_height_difference = merged_linked_list[left_segment_id].y_projection_coefficient.segment_left_height_difference;
				merged_linked_list[shortest_segment_id].min_point.value = min(merged_linked_list[shortest_segment_id].min_point.value, merged_linked_list[left_segment_id].min_point.value);
				merged_linked_list[shortest_segment_id].max_point.value = max(merged_linked_list[shortest_segment_id].max_point.value, merged_linked_list[left_segment_id].max_point.value);
				merged_linked_list[shortest_segment_id].rectangle_height = merged_linked_list[shortest_segment_id].max_point.value - merged_linked_list[shortest_segment_id].min_point.value;
				/*-------               Left segment           --------*/
				merged_linked_list[left_segment_id].right_endpoint = INF;
				merged_linked_list[left_segment_id].rectangle_width = INF;
				/*.....................................................*/
				merged_linked_list.remove(left_segment_id);
#if _DEBUG
				assert(merged_linked_list[left_segment_id].right_endpoint != INF && merged_linked_list[left_segment_id].rectangle_width != INF && merged_linked_list[left_segment_id].rectangle_height != INF && merged_linked_list[left_segment_id].min_point.value != INF && merged_linked_list[left_segment_id].max_point.value != INF);
#endif
			}
			//??????????????????????????
			/*.................................................................................................*/
		}
		/*..............................................................................................................................................................................................*/
	}/*================================================================================Split Segment====================================================================================================*/
	else if (merged_linked_list.size() < input_argument.point_dimension) {
		while (merged_linked_list.size() < input_argument.point_dimension) {
			height_difference_id_map.clear();
			/*-----------------------------------Find highest segment to split--------------------------------*/
#if _DEBUG
			assert(height_difference_id_map.empty());
#endif
			for (segment_id = 0; segment_id < merged_linked_list.size(); segment_id++) {
#if _DEBUG
				assert(merged_linked_list[segment_id].rectangle_height != INF);
#endif
				if (merged_linked_list[segment_id].rectangle_height > 0 && merged_linked_list[segment_id].y_projection_coefficient.sub_segment_vector.size() > 1) {
#if _DEBUG
					assert(!merged_linked_list[segment_id].y_projection_coefficient.is_flat && !merged_linked_list[segment_id].y_projection_coefficient.sub_segment_vector.empty() && merged_linked_list[segment_id].rectangle_height != INF);
					if (segment_id > 0)
						assert(merged_linked_list[segment_id].rectangle_width == merged_linked_list[segment_id].right_endpoint - merged_linked_list[segment_id - 1].right_endpoint);
#endif
					height_difference_id_map.emplace(merged_linked_list[segment_id].rectangle_height, segment_id);
				}
			}
			/*.................................................................................................*/
#if _DEBUG
			assert(!height_difference_id_map.empty());
#endif
			/*-----------------------------------Split Operation-----------------------------------------------*/
			auto highest_segment_id = height_difference_id_map.rbegin()->second;

			if (highest_segment_id == 0) {
				assert(0);
			}
			else {//?? Needs improvement; merge 3 segments, top in the center.
#if _DEBUG
				assert(!merged_linked_list[highest_segment_id].y_projection_coefficient.is_flat && !merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.empty());
				assert(merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.front().segment_left_point.id == merged_linked_list[highest_segment_id].segment_left_point.id && merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.front().segment_left_point.value == merged_linked_list[highest_segment_id].segment_left_point.value);
				assert(merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.back().segment_right_point.id == merged_linked_list[highest_segment_id].segment_right_point.id && merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.back().segment_right_point.value == merged_linked_list[highest_segment_id].segment_right_point.value);
				assert(merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.back().y_projection_coefficient.segment_right_height_difference == merged_linked_list[highest_segment_id].y_projection_coefficient.segment_right_height_difference && merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.front().y_projection_coefficient.segment_left_height_difference == merged_linked_list[highest_segment_id].y_projection_coefficient.segment_left_height_difference);
				assert(merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.front().segment_left_point.id == merged_linked_list[highest_segment_id - 1].right_endpoint + 1);
#endif
				//AREA_COEFFICIENT left_coefficient, middle_coefficient;
				if (merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.size() == 1) {
					continue;
				}

				map<double, int> sub_height_difference_id_map;
				int sub_segment_id = INF;
				int highest_difference_sub_segment_id = INF;

				/*----------------------------------------------Find highest segment difference in sub segment----------------------------------------------*/
				for (sub_segment_id = 0; sub_segment_id < merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.size() - 1; sub_segment_id++) {
#if _DEBUG
					assert(merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector[sub_segment_id].y_projection_coefficient.segment_right_height_difference != INF);
#endif
					sub_height_difference_id_map.emplace(fabs(merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector[sub_segment_id].y_projection_coefficient.segment_right_height_difference), sub_segment_id);
				}
				/*..........................................................................................................................................*/

				//temp_coefficient.~AREA_COEFFICIENT();
				//get highest sub segment id
				temp_coefficient.y_projection_coefficient.sub_segment_vector.clear();
				temp_coefficient.y_projection_coefficient.sub_segment_vector.shrink_to_fit();
				highest_difference_sub_segment_id = sub_height_difference_id_map.rbegin()->second;

				/*=================================Splited left sub segment====================================*/
				temp_coefficient.right_endpoint = merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector[highest_difference_sub_segment_id].right_endpoint;
				temp_coefficient.rectangle_width = temp_coefficient.right_endpoint - merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.front().segment_left_point.id + 1;
				temp_coefficient.segment_right_point = merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector[highest_difference_sub_segment_id].segment_right_point;
				temp_coefficient.segment_left_point = merged_linked_list[highest_segment_id].segment_left_point;
				temp_coefficient.y_projection_coefficient.segment_left_height_difference = merged_linked_list[highest_segment_id].y_projection_coefficient.segment_left_height_difference;
				temp_coefficient.y_projection_coefficient.segment_right_height_difference = merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector[highest_difference_sub_segment_id].y_projection_coefficient.segment_right_height_difference;
#if _DEBUG
				assert(temp_coefficient.right_endpoint == merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector[highest_difference_sub_segment_id].segment_right_point.id);
				assert(temp_coefficient.rectangle_width == temp_coefficient.right_endpoint - merged_linked_list[highest_segment_id - 1].right_endpoint);
#endif
				/*...............................................................................................*/
				/*=================================Splited right sub segment====================================*/
				merged_linked_list[highest_segment_id].rectangle_width -= temp_coefficient.rectangle_width;
				merged_linked_list[highest_segment_id].segment_left_point = merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector[highest_difference_sub_segment_id + 1].segment_left_point;
				merged_linked_list[highest_segment_id].y_projection_coefficient.segment_left_height_difference = merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector[highest_difference_sub_segment_id + 1].y_projection_coefficient.segment_left_height_difference;
#if _DEBUG
				assert(merged_linked_list[highest_segment_id].rectangle_width == merged_linked_list[highest_segment_id].right_endpoint - temp_coefficient.right_endpoint);
#endif
				/*...............................................................................................*/

				/*-------------------Split highest segment Sub Segments------------*/
				// copy first several sub segments
				temp_coefficient.y_projection_coefficient.sub_segment_vector.assign(merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.begin(), merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.begin() + highest_difference_sub_segment_id + 1);
				// erase first several sub elements:
				merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.erase(merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.begin(), merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.begin() + highest_difference_sub_segment_id + 1);
				/*................................................................*/

				/*------   Min Max point, rectangle height. get left sub segment & right sub segment    -------*/
				temp_coefficient.min_point.value = merged_linked_list[highest_segment_id].min_point.value = INF;
				temp_coefficient.max_point.value = merged_linked_list[highest_segment_id].max_point.value = -INF;

				for (auto&& au : temp_coefficient.y_projection_coefficient.sub_segment_vector) {
#if _DEBUG
					assert(au.segment_left_point.value == au.segment_right_point.value && au.min_point.value == au.max_point.value);
#endif
					temp_coefficient.min_point.value = min(temp_coefficient.min_point.value, au.min_point.value);
					temp_coefficient.max_point.value = max(temp_coefficient.max_point.value, au.max_point.value);
				}

				for (auto&& au : merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector) {
#if _DEBUG
					assert(au.segment_left_point.value == au.segment_right_point.value && au.min_point.value == au.max_point.value);
#endif
					merged_linked_list[highest_segment_id].min_point.value = min(merged_linked_list[highest_segment_id].min_point.value, au.min_point.value);
					merged_linked_list[highest_segment_id].max_point.value = max(merged_linked_list[highest_segment_id].max_point.value, au.max_point.value);
				}

				temp_coefficient.rectangle_height = temp_coefficient.max_point.value - temp_coefficient.min_point.value;
				merged_linked_list[highest_segment_id].rectangle_height = merged_linked_list[highest_segment_id].max_point.value - merged_linked_list[highest_segment_id].min_point.value;
				/*.............................................................................................*/
#if _DEBUG
				assert(temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id + 1 == merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.front().segment_left_point.id);
				assert(temp_coefficient.y_projection_coefficient.sub_segment_vector.back().right_endpoint == temp_coefficient.right_endpoint);
				assert(temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id == temp_coefficient.segment_right_point.id);
				assert(temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id == temp_coefficient.segment_left_point.id);
				assert(temp_coefficient.segment_right_point.id + 1 == merged_linked_list[highest_segment_id].segment_left_point.id);
				assert(temp_coefficient.y_projection_coefficient.sub_segment_vector.back().y_projection_coefficient.segment_right_height_difference == temp_coefficient.y_projection_coefficient.segment_right_height_difference);
				assert(temp_coefficient.y_projection_coefficient.sub_segment_vector.front().y_projection_coefficient.segment_left_height_difference == temp_coefficient.y_projection_coefficient.segment_left_height_difference);

				assert(temp_coefficient.rectangle_height >= 0 && merged_linked_list[highest_segment_id].rectangle_height >= 0);
				assert(merged_linked_list[highest_segment_id].segment_left_point.id == merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.front().segment_left_point.id);
				assert(merged_linked_list[highest_segment_id].segment_right_point.id == merged_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.back().segment_right_point.id);

				//assert(temp_coefficient.y_projection_coefficient.sub_segment_vector.back().right_endpoint + 1 == assert(merged_area_vector[highest_segment_id].segment_left_point.id);
				assert(temp_coefficient.y_projection_coefficient.segment_right_height_difference == merged_linked_list[highest_segment_id].y_projection_coefficient.segment_left_height_difference * -1);
#endif
				merged_linked_list.add(highest_segment_id, temp_coefficient);
				//merged_area_vector.insert(merged_linked_list.begin() + highest_segment_id, temp_coefficient);
			}
			/*....................................................................................................*/
		}
	}
	else {
		//doubly_linked_list.swap(merged_linked_list);
#if _DEBUG
		assert(doubly_linked_list.size() == input_argument.point_dimension);
#endif
		return;
		assert(0);
	}
	/*..................................................................................................................................................................................................*/
	//??????
	//doubly_linked_list.swap(merged_linked_list);
#if _DEBUG
	assert(doubly_linked_list.size() == input_argument.point_dimension);
#endif
}

//************************************
// Method:YProjectionMerge
// Qualifier:merge & split segment through all_linked_list & cluster_linked_list
// Input: y_projection_argument, all_linked_list, cluster_linked_list
// Output: APLA Linked list
// date:191030
// author:
//************************************
TEMPLATE
//void APLA::YProjectionMerge(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, const TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, const DoublyLinkedList<AREA_COEFFICIENT>& const all_linked_list, const DoublyLinkedList<AREA_COEFFICIENT>& const cluster_linked_list, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list) {
void APLA::YProjectionMerge(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, const DoublyLinkedList<AREA_COEFFICIENT>& const all_linked_list, const DoublyLinkedList<AREA_COEFFICIENT>& const cluster_linked_list, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list) {
#if _DEBUG
	//assert(!all_linked_list.empty() && !cluster_linked_list.empty()  && doubly_linked_list.empty() && y_projection_argument.initial_N != INF && y_projection_argument.flat_segment_min != INF && y_projection_argument.flat_segment_max != INF); //threshhold);
	assert(!all_linked_list.empty() && !cluster_linked_list.empty() && doubly_linked_list.empty());//&& y_projection_argument.initial_N != INF && y_projection_argument.flat_segment_min != INF && y_projection_argument.flat_segment_max != INF); //threshhold);
#endif

	AREA_COEFFICIENT temp_coefficient;
	int segment_id = INF;

	/*==========================================================  segment number <= N, split flat segment  ============================================================================*/
	if (all_linked_list.size() <= input_argument.point_dimension) {
		doubly_linked_list.copy(all_linked_list);// keep all list & cluster list are unchanged 
#if _DEBUG
		/*cout << "flat segment height \n";
		for_each_n(area_vector.begin(), area_vector.size(), [](auto&& au) { if(au.y_projection_coefficient.is_flat) cout<<au.rectangle_height<<","; });
		cout << endl;*/
#endif
		int segment_middle_id = INF;
		while (doubly_linked_list.size() < input_argument.point_dimension) {
			for (segment_id = 0; segment_id < doubly_linked_list.size() && doubly_linked_list.size() < input_argument.point_dimension; segment_id++) {
				/*----------------------------------------------------Flat segment ---------------------------------------------------------------------*/
				if (doubly_linked_list[segment_id].y_projection_coefficient.is_flat && doubly_linked_list[segment_id].rectangle_width > 3) {
#if _DEBUG
					assert(doubly_linked_list[segment_id].rectangle_width > 1);
#endif
					segment_middle_id = findSegmentMiddleID(doubly_linked_list[segment_id]);
					temp_coefficient.y_projection_coefficient.is_flat = true;
					/*=================================Splited left sub segment====================================*/
					temp_coefficient.right_endpoint = segment_middle_id;
					temp_coefficient.rectangle_width = segment_middle_id - doubly_linked_list[segment_id].segment_left_point.id + 1;
					temp_coefficient.segment_right_point.id = segment_middle_id;
					temp_coefficient.segment_right_point.value = original_time_series[segment_middle_id];
					temp_coefficient.segment_left_point = doubly_linked_list[segment_id].segment_left_point;
					temp_coefficient.y_projection_coefficient.segment_left_height_difference = doubly_linked_list[segment_id].y_projection_coefficient.segment_left_height_difference;
					temp_coefficient.y_projection_coefficient.segment_right_height_difference = temp_coefficient.segment_right_point.value - original_time_series[segment_middle_id + 1];
#if _DEBUG
					assert(temp_coefficient.right_endpoint == temp_coefficient.segment_right_point.id);
#endif
					/*===============================================================================================*/
					/*==================================Splited right sub segment====================================*/
					doubly_linked_list[segment_id].rectangle_width -= temp_coefficient.rectangle_width;
					doubly_linked_list[segment_id].segment_left_point.id = segment_middle_id + 1;
					doubly_linked_list[segment_id].segment_left_point.value = original_time_series[segment_middle_id + 1];
					doubly_linked_list[segment_id].y_projection_coefficient.segment_left_height_difference = doubly_linked_list[segment_id].segment_left_point.value - original_time_series[segment_middle_id];
#if _DEBUG
					assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - temp_coefficient.right_endpoint);
#endif
					/*================================================================================================*/

					/*---------   Min Max point, rectangle height. get left sub segment & right sub segment ----------*/
					temp_coefficient.min_point.value = doubly_linked_list[segment_id].min_point.value;
					temp_coefficient.max_point.value = doubly_linked_list[segment_id].max_point.value;
					temp_coefficient.rectangle_height = doubly_linked_list[segment_id].rectangle_height;
#if _DEBUG
					assert(temp_coefficient.rectangle_height == temp_coefficient.max_point.value - temp_coefficient.min_point.value);
#endif
					/*-------------------------------------------------------------------------------------------------*/
					doubly_linked_list.insertValueBeforeNode(temp_coefficient, doubly_linked_list.getNode(segment_id));
				}
				/*---------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
			}
		}
#if _DEBUG
		assert(doubly_linked_list.size() == input_argument.point_dimension);
#endif
		return;
	}
	/*========================================================================================================================================================================================================*/

	int flat_segment_number = 0;
	//vector<AREA_COEFFICIENT> merged_area_vector;

	temp_coefficient.min_point.value = INF;
	temp_coefficient.max_point.value = -INF;
	temp_coefficient.rectangle_width = 0;
	/*==========================================================  segment number > N, merge flat segment  ============================================================================*/
	/*-----------------------------------------------------If N == 2 --------------------------------------*/
	if (input_argument.point_dimension == 2) {
#if _DEBUG
		assert(doubly_linked_list.empty());
#endif
		doubly_linked_list.copy(cluster_linked_list);
		DoublyLinkedList<AREA_COEFFICIENT> result_linked_list;
		for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
			if (doubly_linked_list[segment_id].y_projection_coefficient.is_flat && doubly_linked_list[segment_id].rectangle_width >= input_argument.time_series_length / 2) {
				temp_coefficient.right_endpoint = doubly_linked_list[segment_id].segment_right_point.id;
				temp_coefficient.rectangle_width = temp_coefficient.right_endpoint + 1;
				result_linked_list.add(temp_coefficient);
				temp_coefficient.right_endpoint = input_argument.time_series_length - 1;
				temp_coefficient.rectangle_width = temp_coefficient.right_endpoint - result_linked_list.back().right_endpoint;
				result_linked_list.add(temp_coefficient);
				doubly_linked_list.swap(result_linked_list);
				return;
			}
		}
	}
	/*-------------------------------------------------------------------------------------------------------*/

	//????????????????????????????Needs improvement
	//temp_coefficient.~AREA_COEFFICIENT();
	map<double, int> height_difference_id_map;// get shortest segment
	/*=============================================================   Merge Segemnt   ===================================================================================*/
#if _DEBUG
	assert(doubly_linked_list.empty());
#endif
	doubly_linked_list.copy(cluster_linked_list);
	if (doubly_linked_list.size() > input_argument.point_dimension) {
		while (doubly_linked_list.size() > input_argument.point_dimension) {
			height_difference_id_map.clear();
			/*------------------------------Find Merge Candidate ID--------------------------------------------*/
#if _DEBUG
			assert(height_difference_id_map.empty());
			/*cout << "Segment left difference: " << endl;
			for_each_n(merged_area_vector.begin(), merged_area_vector.size(), [](auto&& au) {cout << au.y_projection_coefficient.segment_left_height_difference << ","; });
			cout << endl;*/
#endif
			for (segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
#if _DEBUG
				assert(doubly_linked_list[segment_id].rectangle_height != INF && doubly_linked_list[segment_id].right_endpoint != INF);
				if (doubly_linked_list[segment_id].y_projection_coefficient.is_flat)
					assert(doubly_linked_list[segment_id].y_projection_coefficient.sub_segment_vector.empty());
				if (!doubly_linked_list[segment_id].y_projection_coefficient.sub_segment_vector.empty()) {
					//assert(merged_area_vector[segment_id].y_projection_coefficient.segment_left_height_difference == merged_area_vector[segment_id].y_projection_coefficient.sub_segment_vector.front().y_projection_coefficient.segment_left_height_difference);
					assert(doubly_linked_list[segment_id].y_projection_coefficient.segment_right_height_difference == doubly_linked_list[segment_id].y_projection_coefficient.sub_segment_vector.back().y_projection_coefficient.segment_right_height_difference);
				}
#endif
				//height_difference_id_map.emplace(merged_area_vector[segment_id].rectangle_height, segment_id); segment height
				height_difference_id_map.emplace(fabs(doubly_linked_list[segment_id].y_projection_coefficient.segment_left_height_difference), segment_id); //segment right difference
			}
			/*.................................................................................................*/
			/*-----------------------------------Merge Operation-----------------------------------------------*/
#if _DEBUG
			/*for_each_n(height_difference_id_map.begin(), height_difference_id_map.size(), [](auto&& au) {cout << au.first<<":"<< au.second <<", "; });
			cout << endl;*/
			assert(!height_difference_id_map.empty());
#endif
			const auto& const shortest_segment_id = height_difference_id_map.begin()->second;

			//?? Needs improvement; merge 3 segments, top in the center.
			int left_segment_id = shortest_segment_id - 1;
			int left_left_segment_id = shortest_segment_id - 2;
			left_left_segment_id > -1 ? left_left_segment_id : left_left_segment_id = 0;
			auto& const left_segment = doubly_linked_list[left_left_segment_id];
			auto& const middle_segment = doubly_linked_list[left_segment_id];
			auto& const right_segment = doubly_linked_list[shortest_segment_id];
			double middle_difference = fabs(original_time_series[int(right_segment.right_endpoint)] - original_time_series[int(middle_segment.right_endpoint)]);
			double left_difference = fabs(original_time_series[int(right_segment.right_endpoint)] - original_time_series[int(left_segment.right_endpoint)]);
			if (left_difference > middle_difference || left_left_segment_id == left_segment_id) {
				doubly_linked_list[shortest_segment_id].rectangle_width += doubly_linked_list[left_segment_id].rectangle_width;
				doubly_linked_list[shortest_segment_id].segment_left_point = doubly_linked_list[left_segment_id].segment_left_point;
				doubly_linked_list[shortest_segment_id].y_projection_coefficient.segment_left_height_difference = doubly_linked_list[left_segment_id].y_projection_coefficient.segment_left_height_difference;
				doubly_linked_list[shortest_segment_id].min_point.value = min(doubly_linked_list[shortest_segment_id].min_point.value, doubly_linked_list[left_segment_id].min_point.value);
				doubly_linked_list[shortest_segment_id].max_point.value = max(doubly_linked_list[shortest_segment_id].max_point.value, doubly_linked_list[left_segment_id].max_point.value);
				doubly_linked_list[shortest_segment_id].rectangle_height = doubly_linked_list[shortest_segment_id].max_point.value - doubly_linked_list[shortest_segment_id].min_point.value;
				/*-------               Left segment           --------*/
				doubly_linked_list[left_segment_id].right_endpoint = INF;
				doubly_linked_list[left_segment_id].rectangle_width = INF;
				/*-----------------------------------------------------*/
				doubly_linked_list.remove(left_segment_id);
#if _DEBUG
				assert(doubly_linked_list[left_segment_id].right_endpoint != INF && doubly_linked_list[left_segment_id].rectangle_width != INF && doubly_linked_list[left_segment_id].rectangle_height != INF && doubly_linked_list[left_segment_id].min_point.value != INF && doubly_linked_list[left_segment_id].max_point.value != INF);
#endif 
			}
			else if (doubly_linked_list.size() - 2 >= input_argument.point_dimension) {
				doubly_linked_list[shortest_segment_id].rectangle_width = (doubly_linked_list[shortest_segment_id].rectangle_width + doubly_linked_list[left_segment_id].rectangle_width + doubly_linked_list[left_left_segment_id].rectangle_width);
				doubly_linked_list[shortest_segment_id].segment_left_point = doubly_linked_list[left_left_segment_id].segment_left_point;
				doubly_linked_list[shortest_segment_id].y_projection_coefficient.segment_left_height_difference = doubly_linked_list[left_left_segment_id].y_projection_coefficient.segment_left_height_difference;
				doubly_linked_list[shortest_segment_id].min_point.value = min(doubly_linked_list[shortest_segment_id].min_point.value, doubly_linked_list[left_segment_id].min_point.value);
				doubly_linked_list[shortest_segment_id].max_point.value = max(doubly_linked_list[shortest_segment_id].max_point.value, doubly_linked_list[left_segment_id].max_point.value);
				doubly_linked_list[shortest_segment_id].min_point.value = min(doubly_linked_list[shortest_segment_id].min_point.value, doubly_linked_list[left_left_segment_id].min_point.value);
				doubly_linked_list[shortest_segment_id].max_point.value = max(doubly_linked_list[shortest_segment_id].max_point.value, doubly_linked_list[left_left_segment_id].max_point.value);
				doubly_linked_list[shortest_segment_id].rectangle_height = doubly_linked_list[shortest_segment_id].max_point.value - doubly_linked_list[shortest_segment_id].min_point.value;
				/*-------               Left segment           --------*/
				doubly_linked_list[left_segment_id].right_endpoint = INF;
				doubly_linked_list[left_segment_id].rectangle_width = INF;
				doubly_linked_list[left_left_segment_id].right_endpoint = INF;
				doubly_linked_list[left_left_segment_id].rectangle_width = INF;
				/*----------------------------------------------------*/
				doubly_linked_list.remove(left_segment_id);
				doubly_linked_list.remove(left_left_segment_id);
#if _DEBUG
				assert(doubly_linked_list[left_left_segment_id].right_endpoint != INF && doubly_linked_list[left_left_segment_id].rectangle_width != INF && doubly_linked_list[left_left_segment_id].rectangle_height != INF && doubly_linked_list[left_left_segment_id].min_point.value != INF && doubly_linked_list[left_left_segment_id].max_point.value != INF);
#endif 
			}
			else {
				double min_area = INF;
				int min_id = INF;
				for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
					double min_value = min(doubly_linked_list[segment_id - 1].min_point.value, doubly_linked_list[segment_id].min_point.value);
					double max_value = max(doubly_linked_list[segment_id - 1].max_point.value, doubly_linked_list[segment_id].max_point.value);
					int merged_width = doubly_linked_list[segment_id - 1].rectangle_width + doubly_linked_list[segment_id].rectangle_width;
					double area = merged_width * (max_value - min_value);
					if (area < min_area) {
						min_area = area;
						min_id = segment_id;
					}
				}
				int left_segment_id = min_id - 1;
				doubly_linked_list[min_id].rectangle_width += doubly_linked_list[left_segment_id].rectangle_width;
				doubly_linked_list[min_id].segment_left_point = doubly_linked_list[left_segment_id].segment_left_point;
				doubly_linked_list[min_id].y_projection_coefficient.segment_left_height_difference = doubly_linked_list[left_segment_id].y_projection_coefficient.segment_left_height_difference;
				doubly_linked_list[min_id].min_point.value = min(doubly_linked_list[min_id].min_point.value, doubly_linked_list[left_segment_id].min_point.value);
				doubly_linked_list[min_id].max_point.value = max(doubly_linked_list[min_id].max_point.value, doubly_linked_list[left_segment_id].max_point.value);
				doubly_linked_list[min_id].rectangle_height = doubly_linked_list[min_id].max_point.value - doubly_linked_list[min_id].min_point.value;
				/*-------               Left segment           --------*/
				doubly_linked_list[left_segment_id].right_endpoint = INF;
				doubly_linked_list[left_segment_id].rectangle_width = INF;
				/*-----------------------------------------------------*/
				doubly_linked_list.remove(left_segment_id);
#if _DEBUG
				assert(doubly_linked_list[left_segment_id].right_endpoint != INF && doubly_linked_list[left_segment_id].rectangle_width != INF && doubly_linked_list[left_segment_id].rectangle_height != INF && doubly_linked_list[left_segment_id].min_point.value != INF && doubly_linked_list[left_segment_id].max_point.value != INF);
#endif 
			}
#if _DEBUG
			/*cout << "Y-Projection right endpoint: " << doubly_linked_list.size() << "\n";
			for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
				cout << doubly_linked_list[segment_id].right_endpoint + 1<< ",";
			}
			cout << endl;
			cout << "Y-Projection rectangle width: "<< "\n";
			for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
				cout << doubly_linked_list[segment_id].rectangle_width << ",";
			}
			cout <<"-------------------------------------------------------"<< endl;*/
#endif
			//??????????????????????????
			/*.................................................................................................*/
		}
		/*..............................................................................................................................................................................................*/
	}/*================================================================================Split Segment====================================================================================================*/
	else if (cluster_linked_list.size() < input_argument.point_dimension) {
		while (doubly_linked_list.size() < input_argument.point_dimension) {
			height_difference_id_map.clear();
			/*-----------------------------------Find highest segment to split--------------------------------*/
#if _DEBUG
			assert(height_difference_id_map.empty());
#endif
			for (segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
#if _DEBUG
				assert(doubly_linked_list[segment_id].rectangle_height != INF);
#endif
				if (doubly_linked_list[segment_id].rectangle_height > 0 && doubly_linked_list[segment_id].y_projection_coefficient.sub_segment_vector.size() > 1) {
#if _DEBUG
					assert(!doubly_linked_list[segment_id].y_projection_coefficient.is_flat && !doubly_linked_list[segment_id].y_projection_coefficient.sub_segment_vector.empty() && doubly_linked_list[segment_id].rectangle_height != INF);
					if (segment_id > 0)
						assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint);
#endif
					height_difference_id_map.emplace(doubly_linked_list[segment_id].rectangle_height, segment_id);
				}
			}
			/*---------------------------------------------------------------------------------------------------*/
#if _DEBUG
			assert(!height_difference_id_map.empty());
#endif
			/*-----------------------------------Split Operation-----------------------------------------------*/
			auto highest_segment_id = height_difference_id_map.rbegin()->second;
			auto& const sub_vector = doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector;
			//?? Needs improvement; merge 3 segments, top in the center.
#if _DEBUG
			assert(!doubly_linked_list[highest_segment_id].y_projection_coefficient.is_flat && !doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.empty());
			assert(doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.front().segment_left_point.id == doubly_linked_list[highest_segment_id].segment_left_point.id && doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.front().segment_left_point.value == doubly_linked_list[highest_segment_id].segment_left_point.value);
			assert(doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.back().segment_right_point.id == doubly_linked_list[highest_segment_id].segment_right_point.id && doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.back().segment_right_point.value == doubly_linked_list[highest_segment_id].segment_right_point.value);
			assert(doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.back().y_projection_coefficient.segment_right_height_difference == doubly_linked_list[highest_segment_id].y_projection_coefficient.segment_right_height_difference && doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.front().y_projection_coefficient.segment_left_height_difference == doubly_linked_list[highest_segment_id].y_projection_coefficient.segment_left_height_difference);
			if (highest_segment_id > 0)
				assert(sub_vector.front().segment_left_point.id == doubly_linked_list[highest_segment_id - 1].right_endpoint + 1);
#endif
			//AREA_COEFFICIENT left_coefficient, middle_coefficient;
			if (doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.size() == 1) {
				continue;
			}

			map<double, int> sub_height_difference_id_map;
			int sub_segment_id = INF;
			int highest_difference_sub_segment_id = INF;

			/*----------------------------------------------Find highest segment difference in sub segment----------------------------------------------*/
			for (sub_segment_id = 0; sub_segment_id < doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.size() - 1; sub_segment_id++) {
#if _DEBUG
				assert(doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector[sub_segment_id].y_projection_coefficient.segment_right_height_difference != INF);
#endif
				sub_height_difference_id_map.emplace(fabs(doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector[sub_segment_id].y_projection_coefficient.segment_right_height_difference), sub_segment_id);
			}
			/*..........................................................................................................................................*/

			//temp_coefficient.~AREA_COEFFICIENT();
			//get highest sub segment id
			temp_coefficient.y_projection_coefficient.sub_segment_vector.clear();
			temp_coefficient.y_projection_coefficient.sub_segment_vector.shrink_to_fit();
			highest_difference_sub_segment_id = sub_height_difference_id_map.rbegin()->second;

			/*=================================Splited left sub segment====================================*/
			temp_coefficient.right_endpoint = doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector[highest_difference_sub_segment_id].right_endpoint;
			temp_coefficient.rectangle_width = temp_coefficient.right_endpoint - doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.front().segment_left_point.id + 1;
			temp_coefficient.segment_right_point = doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector[highest_difference_sub_segment_id].segment_right_point;
			temp_coefficient.segment_left_point = doubly_linked_list[highest_segment_id].segment_left_point;
			temp_coefficient.y_projection_coefficient.segment_left_height_difference = doubly_linked_list[highest_segment_id].y_projection_coefficient.segment_left_height_difference;
			temp_coefficient.y_projection_coefficient.segment_right_height_difference = doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector[highest_difference_sub_segment_id].y_projection_coefficient.segment_right_height_difference;
#if _DEBUG
			assert(temp_coefficient.right_endpoint == doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector[highest_difference_sub_segment_id].segment_right_point.id);
			if (highest_segment_id > 0)
				assert(temp_coefficient.rectangle_width == temp_coefficient.right_endpoint - doubly_linked_list[highest_segment_id - 1].right_endpoint);
#endif
			/*...............................................................................................*/
			/*=================================Splited right sub segment====================================*/
			doubly_linked_list[highest_segment_id].rectangle_width -= temp_coefficient.rectangle_width;
			doubly_linked_list[highest_segment_id].segment_left_point = doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector[highest_difference_sub_segment_id + 1].segment_left_point;
			doubly_linked_list[highest_segment_id].y_projection_coefficient.segment_left_height_difference = doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector[highest_difference_sub_segment_id + 1].y_projection_coefficient.segment_left_height_difference;
#if _DEBUG
			assert(doubly_linked_list[highest_segment_id].rectangle_width == doubly_linked_list[highest_segment_id].right_endpoint - temp_coefficient.right_endpoint);
#endif
			/*...............................................................................................*/

			/*-------------------Split highest segment Sub Segments------------*/
			// copy first several sub segments
			temp_coefficient.y_projection_coefficient.sub_segment_vector.assign(doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.begin(), doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.begin() + highest_difference_sub_segment_id + 1);
			// erase first several sub elements:
			doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.erase(doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.begin(), doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.begin() + highest_difference_sub_segment_id + 1);
			/*................................................................*/

			/*------   Min Max point, rectangle height. get left sub segment & right sub segment    -------*/
			temp_coefficient.min_point.value = doubly_linked_list[highest_segment_id].min_point.value = INF;
			temp_coefficient.max_point.value = doubly_linked_list[highest_segment_id].max_point.value = -INF;

			for (auto&& au : temp_coefficient.y_projection_coefficient.sub_segment_vector) {
#if _DEBUG
				assert(au.segment_left_point.value == au.segment_right_point.value && au.min_point.value == au.max_point.value);
#endif
				temp_coefficient.min_point.value = min(temp_coefficient.min_point.value, au.min_point.value);
				temp_coefficient.max_point.value = max(temp_coefficient.max_point.value, au.max_point.value);
			}

			for (auto&& au : doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector) {
#if _DEBUG
				assert(au.segment_left_point.value == au.segment_right_point.value && au.min_point.value == au.max_point.value);
#endif
				doubly_linked_list[highest_segment_id].min_point.value = min(doubly_linked_list[highest_segment_id].min_point.value, au.min_point.value);
				doubly_linked_list[highest_segment_id].max_point.value = max(doubly_linked_list[highest_segment_id].max_point.value, au.max_point.value);
			}

			temp_coefficient.rectangle_height = temp_coefficient.max_point.value - temp_coefficient.min_point.value;
			doubly_linked_list[highest_segment_id].rectangle_height = doubly_linked_list[highest_segment_id].max_point.value - doubly_linked_list[highest_segment_id].min_point.value;
			/*.............................................................................................*/
#if _DEBUG
			assert(temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id + 1 == doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.front().segment_left_point.id);
			assert(temp_coefficient.y_projection_coefficient.sub_segment_vector.back().right_endpoint == temp_coefficient.right_endpoint);
			assert(temp_coefficient.y_projection_coefficient.sub_segment_vector.back().segment_right_point.id == temp_coefficient.segment_right_point.id);
			assert(temp_coefficient.y_projection_coefficient.sub_segment_vector.front().segment_left_point.id == temp_coefficient.segment_left_point.id);
			assert(temp_coefficient.segment_right_point.id + 1 == doubly_linked_list[highest_segment_id].segment_left_point.id);
			assert(temp_coefficient.y_projection_coefficient.sub_segment_vector.back().y_projection_coefficient.segment_right_height_difference == temp_coefficient.y_projection_coefficient.segment_right_height_difference);
			assert(temp_coefficient.y_projection_coefficient.sub_segment_vector.front().y_projection_coefficient.segment_left_height_difference == temp_coefficient.y_projection_coefficient.segment_left_height_difference);

			assert(temp_coefficient.rectangle_height >= 0 && doubly_linked_list[highest_segment_id].rectangle_height >= 0);
			assert(doubly_linked_list[highest_segment_id].segment_left_point.id == doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.front().segment_left_point.id);
			assert(doubly_linked_list[highest_segment_id].segment_right_point.id == doubly_linked_list[highest_segment_id].y_projection_coefficient.sub_segment_vector.back().segment_right_point.id);

			//assert(temp_coefficient.y_projection_coefficient.sub_segment_vector.back().right_endpoint + 1 == assert(merged_area_vector[highest_segment_id].segment_left_point.id);
			assert(temp_coefficient.y_projection_coefficient.segment_right_height_difference == doubly_linked_list[highest_segment_id].y_projection_coefficient.segment_left_height_difference * -1);
#endif
			doubly_linked_list.add(highest_segment_id, temp_coefficient);
			//merged_area_vector.insert(doubly_linked_list.begin() + highest_segment_id, temp_coefficient);

		/*....................................................................................................*/
		}
	}
	else {
		//doubly_linked_list.swap(merged_linked_list);
#if _DEBUG
		assert(doubly_linked_list.size() == input_argument.point_dimension);
#endif
		return;
		assert(0);
	}
	/*..................................................................................................................................................................................................*/
	//??????
	//doubly_linked_list.swap(merged_linked_list);
#if _DEBUG
	assert(doubly_linked_list.size() == input_argument.point_dimension);
#endif
}


//************************************
// Method:y_projection_merge_split
// Qualifier:merge & split segment through all_linked_list & cluster_linked_list
// Input: y_projection_argument, all_linked_list, cluster_linked_list
// Output: APLA Linked list
// date:191209
// author:
//************************************
//191209 merge & split segment by y_projection
TEMPLATE
template<typename T>
void APLA::y_projection_merge_split(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, const DoublyLinkedList<T>& const all_linked_list, const DoublyLinkedList<T>& const cluster_linked_list, DoublyLinkedList<T>& const doubly_linked_list) {
#if _DEBUG
	//assert(!all_linked_list.empty() && !cluster_linked_list.empty()  && doubly_linked_list.empty() && y_projection_argument.initial_N != INF && y_projection_argument.flat_segment_min != INF && y_projection_argument.flat_segment_max != INF); //threshhold);
	assert_linkedlist_rightEndpoint_Width_rightHeightDifference(input_argument, all_linked_list);
	assert_linkedlist_rightEndpoint_Width_rightHeightDifference(input_argument, cluster_linked_list);

	assert(!all_linked_list.empty() && !cluster_linked_list.empty() && doubly_linked_list.empty() && all_linked_list.size() >= cluster_linked_list.size());//&& y_projection_argument.initial_N != INF && y_projection_argument.flat_segment_min != INF && y_projection_argument.flat_segment_max != INF); //threshhold);

	int all_test_flat_number = 0;
	int cluster_test_flat_number = 0;
	int test_all_flat_segment_length = 0;
	int test_cluster_flat_segment_length = 0;
	assert(all_linked_list[0].segment_right_height_difference != INF && cluster_linked_list[0].segment_right_height_difference != INF);
	if (all_linked_list.front().is_flat) {
		all_test_flat_number++;
		test_all_flat_segment_length += all_linked_list.front().rectangle_width;
	}
	for (int segment_id = 1; segment_id < all_linked_list.size(); segment_id++) {
		const auto& const all_left_segment = all_linked_list[segment_id - 1];
		const auto& const all_right_segment = all_linked_list[segment_id];
		assert(all_right_segment.segment_right_height_difference != INF && all_left_segment.right_endpoint == all_right_segment.right_endpoint - all_right_segment.rectangle_width);
		if (all_right_segment.is_flat) {
			all_test_flat_number++;
			test_all_flat_segment_length += all_right_segment.rectangle_width;
		}
	}

	if (cluster_linked_list.front().is_flat) {
		cluster_test_flat_number++;
		test_cluster_flat_segment_length += cluster_linked_list.front().rectangle_width;
	}
	for (int segment_id = 1; segment_id < cluster_linked_list.size(); segment_id++) {
		const auto& const cluster_left_segment = cluster_linked_list[segment_id - 1];
		const auto& const cluster_right_segment = cluster_linked_list[segment_id];
		assert(cluster_right_segment.segment_right_height_difference != INF && cluster_left_segment.right_endpoint == cluster_right_segment.right_endpoint - cluster_right_segment.rectangle_width);
		if (cluster_right_segment.is_flat) {
			cluster_test_flat_number++;
			test_cluster_flat_segment_length += cluster_right_segment.rectangle_width;
		}
	}
	assert(all_test_flat_number == cluster_test_flat_number && test_all_flat_segment_length == test_cluster_flat_segment_length);
#endif

	AREA_COEFFICIENT temp_coefficient;
	int segment_id = INF;

	/*==========================================================  segment number <= N, split flat segment  ============================================================================*/
	if (all_linked_list.size() <= input_argument.point_dimension) {
		doubly_linked_list.copy(all_linked_list);// keep all list & cluster list are unchanged 

		int segment_middle_id = INF;
		while (doubly_linked_list.size() < input_argument.point_dimension) {
			for (segment_id = 0; segment_id < doubly_linked_list.size() && doubly_linked_list.size() < input_argument.point_dimension; segment_id++) {
				/*----------------------------------------------------Flat segment ---------------------------------------------------------------------*/
				auto& const all_segment = doubly_linked_list[segment_id];
				if (all_segment.rectangle_width > 3) {
#if _DEBUG
					assert(all_segment.rectangle_width > 1);
#endif
					/*-----------------------------------Splited left sub segment------------------------------------*/
					segment_middle_id = findSegmentMiddleID(all_segment);
					temp_coefficient.is_flat = all_segment.is_flat;
					int temp_width = all_segment.right_endpoint - segment_middle_id;

					temp_coefficient.right_endpoint = segment_middle_id;
					temp_coefficient.rectangle_width = all_segment.rectangle_width - temp_width;
					all_segment.rectangle_width = temp_width;
					//temp_coefficient.segment_right_point.id = segment_middle_id;
					//temp_coefficient.segment_right_point.value = original_time_series[segment_middle_id];
					//temp_coefficient.segment_left_point = doubly_linked_list[segment_id].segment_left_point;
					//temp_coefficient.y_projection_coefficient.segment_left_height_difference = doubly_linked_list[segment_id].y_projection_coefficient.segment_left_height_difference;
					//temp_coefficient.y_projection_coefficient.segment_right_height_difference = temp_coefficient.segment_right_point.value - original_time_series[segment_middle_id + 1];

					/*-------------------------------------------------------------------------------------------------*/
					/*---------------------------------Splited right sub segment---------------------------------------*/
					//doubly_linked_list[segment_id].segment_left_point.id = segment_middle_id + 1;
					//doubly_linked_list[segment_id].segment_left_point.value = original_time_series[segment_middle_id + 1];
					//doubly_linked_list[segment_id].y_projection_coefficient.segment_left_height_difference = doubly_linked_list[segment_id].segment_left_point.value - original_time_series[segment_middle_id];
#if _DEBUG
					assert(all_segment.rectangle_width == all_segment.right_endpoint - temp_coefficient.right_endpoint);
#endif
					/*------------------------------------------------------------------------------------------------*/

					/*---------   Min Max point, rectangle height. get left sub segment & right sub segment ----------*/
					//temp_coefficient.min_point.value = doubly_linked_list[segment_id].min_point.value;
					//temp_coefficient.max_point.value = doubly_linked_list[segment_id].max_point.value;
					//temp_coefficient.rectangle_height = doubly_linked_list[segment_id].rectangle_height;
					/*-------------------------------------------------------------------------------------------------*/
					doubly_linked_list.insertValueBeforeNode(temp_coefficient, doubly_linked_list.getNode(segment_id));
				}
				/*---------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
			}
		}
#if _DEBUG
		assert(doubly_linked_list.size() == input_argument.point_dimension && doubly_linked_list.back().right_endpoint == input_argument.time_series_length - 1);
#endif
		return;
	}
	/*========================================================================================================================================================================================================*/

	map<double, int> height_difference_id_map;// get shortest segment

	/*=========================================================================== N < All size &  N >= Cluster size=============================================================================================*/
	if (input_argument.point_dimension < all_linked_list.size() && input_argument.point_dimension >= cluster_linked_list.size()) {
		doubly_linked_list.copy(all_linked_list);// keep all list & cluster list are unchanged 
		while (doubly_linked_list.size() > input_argument.point_dimension) {
			// Only count burst segments
			for (segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
				const auto& const left_segment = doubly_linked_list[segment_id - 1];
				auto& const right_segment = doubly_linked_list[segment_id];
				if (!left_segment.is_flat && !right_segment.is_flat && left_segment.segment_right_height_difference != INF) {
					height_difference_id_map.emplace(left_segment.segment_right_height_difference, segment_id);
				}
			}
			if (height_difference_id_map.empty()) {
				for (segment_id = 1; segment_id < doubly_linked_list.size() - 1; segment_id++) {
					const auto& const left_segment = doubly_linked_list[segment_id - 1];
					const auto& const middle_segment = doubly_linked_list[segment_id];
					auto& const right_segment = doubly_linked_list[segment_id + 1];
					if (left_segment.is_flat && right_segment.is_flat) {
						assert(!middle_segment.is_flat && left_segment.segment_right_height_difference != INF);
						height_difference_id_map.emplace(fabs(left_segment.segment_right_height_difference), segment_id + 1);
					}
				}

				const int right_id = height_difference_id_map.cbegin()->second;
				const int middle_id = right_id - 1;
				const int left_id = middle_id - 1;
				assert(left_id >= 0 && middle_id >= 0);

				doubly_linked_list[right_id].rectangle_width = (doubly_linked_list[left_id].rectangle_width + doubly_linked_list[middle_id].rectangle_width + doubly_linked_list[right_id].rectangle_width);
				doubly_linked_list.remove(middle_id);
				doubly_linked_list.remove(left_id);
				height_difference_id_map.clear();

				continue;
			}
			const int right_id = height_difference_id_map.cbegin()->second;
			const int left_id = right_id - 1;
			assert(left_id >= 0);
			doubly_linked_list[right_id].rectangle_width += doubly_linked_list[left_id].rectangle_width;
			doubly_linked_list.remove(left_id);
			height_difference_id_map.clear();
		}

		if (doubly_linked_list.size() < input_argument.point_dimension) {
			int segment_middle_id = INF;
			for (segment_id = 0; segment_id < doubly_linked_list.size() && doubly_linked_list.size() < input_argument.point_dimension; segment_id++) {
				auto& const segment = doubly_linked_list[segment_id];

				if (!segment.is_flat) {
					segment_middle_id = findSegmentMiddleID(segment);
					temp_coefficient.right_endpoint = segment_middle_id;
					int right_width = segment.right_endpoint - segment_middle_id;
					temp_coefficient.rectangle_width = segment.rectangle_width - right_width;
					segment.rectangle_width = right_width;
					doubly_linked_list.insertValueBeforeNode(temp_coefficient, doubly_linked_list.getNode(segment_id));
				}

			}

		}

#if _DEBUG
		assert(doubly_linked_list.size() == input_argument.point_dimension && doubly_linked_list.back().right_endpoint == input_argument.time_series_length - 1);
#endif
		return;
	}
	/*=========================================================================================================================================================================================================*/

	/*===========================================================================    N < Cluster size   =======================================================================================================*/
	height_difference_id_map.clear();
	if (input_argument.point_dimension < cluster_linked_list.size()) {
		doubly_linked_list.copy(cluster_linked_list);// keep all list & cluster list are unchanged 
		while (input_argument.point_dimension < doubly_linked_list.size()) {
			//Only count flat burst flat segments
			for (segment_id = 1; segment_id < doubly_linked_list.size() - 1; segment_id++) {
				const auto& const left_segment = doubly_linked_list[segment_id - 1];
				const auto& const middle_segment = doubly_linked_list[segment_id];
				auto& const right_segment = doubly_linked_list[segment_id + 1];
				if (left_segment.is_flat && right_segment.is_flat) {
					assert(left_segment.segment_right_height_difference != INF && middle_segment.segment_right_height_difference != INF);
					double total_height_difference = fabs(left_segment.segment_right_height_difference + middle_segment.segment_right_height_difference);
					height_difference_id_map.emplace(total_height_difference, segment_id + 1);
				}
#if _DEBUG
				for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
					assert(doubly_linked_list[segment_id - 1].right_endpoint == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id].rectangle_width);
				}
#endif
			}
#if _DEBUG
			assert(!height_difference_id_map.empty());
#endif
			const int right_id = height_difference_id_map.cbegin()->second;
			const int middle_id = right_id - 1;
			const int left_id = middle_id - 1;
			assert(left_id >= 0 && middle_id >= 0);
#if _DEBUG
			//cout << "before width: " << doubly_linked_list[left_id].rectangle_width << ", right id: " << doubly_linked_list[left_id].right_endpoint << ", width: " << doubly_linked_list[middle_id].rectangle_width << ", right id: " << doubly_linked_list[middle_id].right_endpoint << ", width: " << doubly_linked_list[right_id].rectangle_width << ", right id: " << doubly_linked_list[right_id].right_endpoint << endl;
#endif
			if (doubly_linked_list.size() - 2 < input_argument.point_dimension) {
				doubly_linked_list[right_id].rectangle_width = (doubly_linked_list[middle_id].rectangle_width + doubly_linked_list[right_id].rectangle_width);
				doubly_linked_list.remove(middle_id);
				//doubly_linked_list.remove(left_id);
			}
			else {
				doubly_linked_list[right_id].rectangle_width = (doubly_linked_list[left_id].rectangle_width + doubly_linked_list[middle_id].rectangle_width + doubly_linked_list[right_id].rectangle_width);
				doubly_linked_list.remove(middle_id);
				doubly_linked_list.remove(left_id);
			}
			//cout << "after width: " << doubly_linked_list[left_id].rectangle_width << ", right id: " << doubly_linked_list[left_id].right_endpoint << endl;
			height_difference_id_map.clear();
#if _DEBUG
			for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
				assert(doubly_linked_list[segment_id - 1].right_endpoint == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id].rectangle_width);
			}
#endif
		}
#if _DEBUG
		assert(doubly_linked_list.size() == input_argument.point_dimension && doubly_linked_list.back().right_endpoint == input_argument.time_series_length - 1);
#endif
		return;
	}
	/*=========================================================================================================================================================================================================*/
#if _DEBUG
	assert(doubly_linked_list.size() == input_argument.point_dimension && doubly_linked_list.back().right_endpoint == input_argument.time_series_length - 1);
#endif
}

//200212 merge & split segment by y_projection
//************************************
// Method:y_projection_merge_split
// Qualifier:merge & split segment through all_linked_list & cluster_linked_list
// Input: y_projection_argument, all_linked_list, cluster_linked_list
// Output: APLA Linked list
// date:200212
// author:
//************************************
//191209 merge & split segment by y_projection
TEMPLATE
template<typename T, typename Y, typename U>
void APLA::y_projection_merge_split(U& input_argument, const vector<T>& const original_time_series_vector, const DoublyLinkedList<Y>& const all_linked_list, const DoublyLinkedList<Y>& const cluster_linked_list, DoublyLinkedList<Y>& const doubly_linked_list) {
	/*.........................................................................................................*/
#if _DEBUG
	//assert(!all_linked_list.empty() && !cluster_linked_list.empty()  && doubly_linked_list.empty() && y_projection_argument.initial_N != INF && y_projection_argument.flat_segment_min != INF && y_projection_argument.flat_segment_max != INF); //threshhold);
	assert_linkedlist_rightEndpoint_Width_rightHeightDifference(input_argument, all_linked_list);
	assert_linkedlist_rightEndpoint_Width_rightHeightDifference(input_argument, cluster_linked_list);

	assert(!all_linked_list.empty() && !cluster_linked_list.empty() && doubly_linked_list.empty() && all_linked_list.size() >= cluster_linked_list.size());//&& y_projection_argument.initial_N != INF && y_projection_argument.flat_segment_min != INF && y_projection_argument.flat_segment_max != INF); //threshhold);

	int all_test_flat_number = 0;
	int cluster_test_flat_number = 0;
	int test_all_flat_segment_length = 0;
	int test_cluster_flat_segment_length = 0;

	assert(all_linked_list[0].segment_right_height_difference != INF && cluster_linked_list[0].segment_right_height_difference != INF);

	if (all_linked_list.front().is_flat) {
		all_test_flat_number++;
		test_all_flat_segment_length += all_linked_list.front().rectangle_width;
	}
	for (int segment_id = 1; segment_id < all_linked_list.size(); segment_id++) {
		const auto& const all_left_segment = all_linked_list[segment_id - 1];
		const auto& const all_right_segment = all_linked_list[segment_id];
		assert(all_right_segment.segment_right_height_difference != INF && all_left_segment.right_endpoint == all_right_segment.right_endpoint - all_right_segment.rectangle_width);
		if (all_right_segment.is_flat) {
			all_test_flat_number++;
			test_all_flat_segment_length += all_right_segment.rectangle_width;
		}
	}

	if (cluster_linked_list.front().is_flat) {
		cluster_test_flat_number++;
		test_cluster_flat_segment_length += cluster_linked_list.front().rectangle_width;
	}
	for (int segment_id = 1; segment_id < cluster_linked_list.size(); segment_id++) {
		const auto& const cluster_left_segment = cluster_linked_list[segment_id - 1];
		const auto& const cluster_right_segment = cluster_linked_list[segment_id];
		assert(cluster_right_segment.segment_right_height_difference != INF && cluster_left_segment.right_endpoint == cluster_right_segment.right_endpoint - cluster_right_segment.rectangle_width);
		if (cluster_right_segment.is_flat) {
			cluster_test_flat_number++;
			test_cluster_flat_segment_length += cluster_right_segment.rectangle_width;
		}
	}
	assert(all_test_flat_number == cluster_test_flat_number && test_all_flat_segment_length == test_cluster_flat_segment_length);
#endif
	/*.........................................................................................................*/

	Y temp_coefficient;
	int segment_id = INF;

	/*========================================================== All size: segment number <= N, split flat segment  ============================================================================*/
	if (all_linked_list.size() <= input_argument.point_dimension) {
		doubly_linked_list.copy(all_linked_list);// keep all list & cluster list are unchanged 

		int segment_middle_id = INF;
		while (doubly_linked_list.size() < input_argument.point_dimension) {
			for (segment_id = 0; segment_id < doubly_linked_list.size() && doubly_linked_list.size() < input_argument.point_dimension; segment_id++) {
				/*----------------------------------------------------Flat segment ---------------------------------------------------------------------*/
				auto& const all_segment = doubly_linked_list[segment_id];
				if (all_segment.rectangle_width > 3) {
#if _DEBUG
					assert(all_segment.rectangle_width > 1);
#endif
					/*-----------------------------------Splited left sub segment------------------------------------*/
					segment_middle_id = findSegmentMiddleID(all_segment);
					temp_coefficient.is_flat = all_segment.is_flat;
					int temp_width = all_segment.right_endpoint - segment_middle_id;

					temp_coefficient.right_endpoint = segment_middle_id;
					temp_coefficient.rectangle_width = all_segment.rectangle_width - temp_width;
					all_segment.rectangle_width = temp_width;
					//temp_coefficient.segment_right_point.id = segment_middle_id;
					//temp_coefficient.segment_right_point.value = original_time_series[segment_middle_id];
					//temp_coefficient.segment_left_point = doubly_linked_list[segment_id].segment_left_point;
					//temp_coefficient.y_projection_coefficient.segment_left_height_difference = doubly_linked_list[segment_id].y_projection_coefficient.segment_left_height_difference;
					//temp_coefficient.y_projection_coefficient.segment_right_height_difference = temp_coefficient.segment_right_point.value - original_time_series[segment_middle_id + 1];

					/*-------------------------------------------------------------------------------------------------*/
					/*---------------------------------Splited right sub segment---------------------------------------*/
					//doubly_linked_list[segment_id].segment_left_point.id = segment_middle_id + 1;
					//doubly_linked_list[segment_id].segment_left_point.value = original_time_series[segment_middle_id + 1];
					//doubly_linked_list[segment_id].y_projection_coefficient.segment_left_height_difference = doubly_linked_list[segment_id].segment_left_point.value - original_time_series[segment_middle_id];
#if _DEBUG
					assert(all_segment.rectangle_width == all_segment.right_endpoint - temp_coefficient.right_endpoint);
#endif
					/*------------------------------------------------------------------------------------------------*/

					/*---------   Min Max point, rectangle height. get left sub segment & right sub segment ----------*/
					//temp_coefficient.min_point.value = doubly_linked_list[segment_id].min_point.value;
					//temp_coefficient.max_point.value = doubly_linked_list[segment_id].max_point.value;
					//temp_coefficient.rectangle_height = doubly_linked_list[segment_id].rectangle_height;
					/*-------------------------------------------------------------------------------------------------*/
					doubly_linked_list.insertValueBeforeNode(temp_coefficient, doubly_linked_list.getNode(segment_id));
				}
				/*---------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
			}
		}
#if _DEBUG
		assert(doubly_linked_list.size() == input_argument.point_dimension && doubly_linked_list.back().right_endpoint == input_argument.time_series_length - 1);
#endif
		return;
	}
	/*==============================================================================================================================================================================================================*/

	map<double, int> height_difference_id_map;// get shortest segment

	/*####################################################### N < All size &  N >= Cluster size#####################################################################################*/
	if (input_argument.point_dimension < all_linked_list.size() && input_argument.point_dimension >= cluster_linked_list.size()) {
		doubly_linked_list.copy(all_linked_list);// keep all list & cluster list are unchanged 
		while (doubly_linked_list.size() > input_argument.point_dimension) {
			// Only count burst segments
			/*++++++++++++++++++++++++++++++++++++++++++get height difference+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			for (segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
				const auto& const left_segment = doubly_linked_list[segment_id - 1];
				auto& const right_segment = doubly_linked_list[segment_id];
				//MAP insert: for two adjacent burst segment, the height difference between them
				if (!left_segment.is_flat && !right_segment.is_flat && left_segment.segment_right_height_difference != INF) {
					height_difference_id_map.emplace(left_segment.segment_right_height_difference, segment_id);
				}
			}
			/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			/*+++++++++++++++++++++++++++++++++++++++IF there are no adjacent burst segments+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			if (height_difference_id_map.empty()) {
				/*===============================MAP Insert: Loop to merge flat-burst-flat segments height difference==================================================*/
				for (segment_id = 1; segment_id < doubly_linked_list.size() - 1; segment_id++) {
					const auto& const left_segment = doubly_linked_list[segment_id - 1];
					const auto& const middle_segment = doubly_linked_list[segment_id];
					auto& const right_segment = doubly_linked_list[segment_id + 1];
					if (left_segment.is_flat && right_segment.is_flat) {
#if _DEBUG
						assert(!middle_segment.is_flat && left_segment.segment_right_height_difference != INF);
#endif
						height_difference_id_map.emplace(fabs(left_segment.segment_right_height_difference), segment_id + 1);
					}
				}
				/*====================================================================================================================================================*/
				/*===============================MAP Top get: get shortest height difference and merge================================================================*/
				const int right_id = height_difference_id_map.cbegin()->second;
				const int middle_id = right_id - 1;
				const int left_id = middle_id - 1;
#if _DEBUG
				assert(left_id >= 0 && middle_id >= 0);
#endif
				doubly_linked_list[right_id].rectangle_width = (doubly_linked_list[left_id].rectangle_width + doubly_linked_list[middle_id].rectangle_width + doubly_linked_list[right_id].rectangle_width);
				doubly_linked_list.remove(middle_id);
				doubly_linked_list.remove(left_id);
				height_difference_id_map.clear();
				/*=====================================================================================================================================================*/
				continue;
			}
			/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			/*++++++++++++++++++++++++++++++Merge adjacent burst segments with smallest height differnce segments++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			const int right_id = height_difference_id_map.cbegin()->second;
			const int left_id = right_id - 1;
#if _DEBUG
			assert(left_id >= 0);
#endif
			doubly_linked_list[right_id].rectangle_width += doubly_linked_list[left_id].rectangle_width;
			doubly_linked_list.remove(left_id);
			height_difference_id_map.clear();
			/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		}
		/*======================================   All size < N, split burst segment    =================================================================*/
		if (doubly_linked_list.size() < input_argument.point_dimension) {
			int segment_middle_id = INF;
			for (segment_id = 0; segment_id < doubly_linked_list.size() && doubly_linked_list.size() < input_argument.point_dimension; segment_id++) {
				auto& const segment = doubly_linked_list[segment_id];

				if (!segment.is_flat) {
					segment_middle_id = findSegmentMiddleID(segment);
					temp_coefficient.right_endpoint = segment_middle_id;
					int right_width = segment.right_endpoint - segment_middle_id;
					temp_coefficient.rectangle_width = segment.rectangle_width - right_width;
					segment.rectangle_width = right_width;
					doubly_linked_list.insertValueBeforeNode(temp_coefficient, doubly_linked_list.getNode(segment_id));
				}
			}
		}
		/*==================================================================================================================================================*/
#if _DEBUG
		assert(doubly_linked_list.size() == input_argument.point_dimension && doubly_linked_list.back().right_endpoint == input_argument.time_series_length - 1);
#endif
		return;
	}
	/*###############################################################################################################################################################################*/

	/*===========================================================================    N < Cluster size   =======================================================================================================*/
	height_difference_id_map.clear();
	if (input_argument.point_dimension < cluster_linked_list.size()) {
		doubly_linked_list.copy(cluster_linked_list);// keep all list & cluster list are unchanged 
		while (input_argument.point_dimension < doubly_linked_list.size()) {
			/*===============================MAP Insert: Loop to merge flat-burst-flat segments height difference==================================================================================*/
			//Only count flat-burst-flat segments
			for (segment_id = 1; segment_id < doubly_linked_list.size() - 1; segment_id++) {
				const auto& const left_segment = doubly_linked_list[segment_id - 1];
				const auto& const middle_segment = doubly_linked_list[segment_id];
				auto& const right_segment = doubly_linked_list[segment_id + 1];
				if (left_segment.is_flat && right_segment.is_flat) {
					assert(left_segment.segment_right_height_difference != INF && middle_segment.segment_right_height_difference != INF);
					double total_height_difference = fabs(left_segment.segment_right_height_difference + middle_segment.segment_right_height_difference);
					height_difference_id_map.emplace(total_height_difference, segment_id + 1);
				}
#if _DEBUG
				for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
					assert(doubly_linked_list[segment_id - 1].right_endpoint == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id].rectangle_width);
				}
#endif
			}
#if _DEBUG
			assert(!height_difference_id_map.empty());
#endif
			/*=====================================================================================================================================================================*/
			/*===============================MAP Top get: get shortest height difference and merge=================================================================================*/
			const int right_id = height_difference_id_map.cbegin()->second;
			const int middle_id = right_id - 1;
			const int left_id = middle_id - 1;

#if _DEBUG
			assert(left_id >= 0 && middle_id >= 0);
			//cout << "before width: " << doubly_linked_list[left_id].rectangle_width << ", right id: " << doubly_linked_list[left_id].right_endpoint << ", width: " << doubly_linked_list[middle_id].rectangle_width << ", right id: " << doubly_linked_list[middle_id].right_endpoint << ", width: " << doubly_linked_list[right_id].rectangle_width << ", right id: " << doubly_linked_list[right_id].right_endpoint << endl;
#endif
			//if segment number < N + 2, segment number -= 1, merge middle burst segment and right flat segment
			if (doubly_linked_list.size() - 2 < input_argument.point_dimension) {
				doubly_linked_list[right_id].rectangle_width = (doubly_linked_list[middle_id].rectangle_width + doubly_linked_list[right_id].rectangle_width);
				doubly_linked_list.remove(middle_id);
				//doubly_linked_list.remove(left_id);
			}
			else {//if segment number >= N + 2, segment number -= 2,  merge left flat segment, middle burst segment and right flat segment
				doubly_linked_list[right_id].rectangle_width = (doubly_linked_list[left_id].rectangle_width + doubly_linked_list[middle_id].rectangle_width + doubly_linked_list[right_id].rectangle_width);
				doubly_linked_list.remove(middle_id);
				doubly_linked_list.remove(left_id);
			}
			//cout << "after width: " << doubly_linked_list[left_id].rectangle_width << ", right id: " << doubly_linked_list[left_id].right_endpoint << endl;
			height_difference_id_map.clear();
#if _DEBUG
			for (int segment_id = 1; segment_id < doubly_linked_list.size(); segment_id++) {
				assert(doubly_linked_list[segment_id - 1].right_endpoint == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id].rectangle_width);
			}
#endif
			/*=====================================================================================================================================================================*/
		}
#if _DEBUG
		assert(doubly_linked_list.size() == input_argument.point_dimension && doubly_linked_list.back().right_endpoint == input_argument.time_series_length - 1);
#endif
		return;
	}
	/*=========================================================================================================================================================================================================*/
#if _DEBUG
	assert(doubly_linked_list.size() == input_argument.point_dimension && doubly_linked_list.back().right_endpoint == input_argument.time_series_length - 1);
#endif
}


//************************************
// Method:y_projection_merge_line
// Qualifier: only one value 
// Input: y_projection_argument, all_linked_list, cluster_linked_list
// Output: APLA Linked list
// date:191209
// author:
//************************************
//191209 merge & split segment by y_projection
//191116 when the time series only has one value
TEMPLATE
template<typename T>
void APLA::y_projection_merge_line(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, DoublyLinkedList<T>& const doubly_linked_list) {
#ifdef _DEBUG
	assert(input_argument.segment_length_second != INF && (doubly_linked_list.empty() || doubly_linked_list.size() == 1));
#endif

	if (doubly_linked_list.size() == 1) {
		doubly_linked_list.clear();
	}
	T temp_segemnt;

	/*---------------191124 for every segment, a&b, width is same ---------------------*/
	temp_segemnt.rectangle_width = input_argument.segment_length_second;
	temp_segemnt.apla.a = 0;
	temp_segemnt.apla.b = temp_segemnt.min_point.value = temp_segemnt.max_point.value = original_time_series[0];
	/*---------------------------------------------------------------------------------*/

	for (int segment_num = 1; segment_num < input_argument.point_dimension; segment_num++) {
		temp_segemnt.right_endpoint = temp_segemnt.min_point.id = temp_segemnt.max_point.id = input_argument.segment_length_second * segment_num - 1;
		doubly_linked_list.add(temp_segemnt);
	}

	temp_segemnt.right_endpoint = temp_segemnt.min_point.id = temp_segemnt.max_point.id = input_argument.time_series_length - 1;
	temp_segemnt.rectangle_width = temp_segemnt.right_endpoint - doubly_linked_list.back().right_endpoint;
	doubly_linked_list.add(temp_segemnt);
#ifdef _DEBUG
	assert(doubly_linked_list.size() == input_argument.point_dimension);
#endif
}

//191116 when the time series only has one value
//200213 Use vector to instead pointer.
//191209 merge & split segment by y_projection.
//************************************
// Method:y_projection_merge_line
// Qualifier: only one value 
// Input: y_projection_argument, all_linked_list, cluster_linked_list
// Output: APLA Linked list
// date:200914
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
void APLA::y_projection_merge_line(U& input_argument, const vector<T>& const original_time_series_vector, DoublyLinkedList<Y>& const doubly_linked_list) {

	/*.....................................................................................*/
#ifdef _DEBUG
	assert(input_argument.segment_length_second != INF && (doubly_linked_list.size() == 1 || doubly_linked_list.size() == 0));// && doubly_linked_list.front().apla.a == 0 && doubly_linked_list.front().apla.b == original_time_series_vector.front());
#endif
	/*.....................................................................................*/

	//if (!doubly_linked_list.empty()) {
	doubly_linked_list.clear();
	//}

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&        191124 for every segment, a&b, width is same       &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	Y temp_segemnt;

	/*###########################         a&b, width       ##################################*/
	temp_segemnt.rectangle_width = input_argument.segment_length_second;
	temp_segemnt.apla.a = original_time_series_vector[1] - original_time_series_vector.front();
	//200314 minmax point
	//temp_segemnt.apla.b = temp_segemnt.min_point.value = temp_segemnt.max_point.value = original_time_series_vector[0];
	temp_segemnt.apla.b = original_time_series_vector.front();
	/*######################################################################################*/

	/*###########################  Area difference = 0 #################################*/
	temp_segemnt.area_difference = 0;
	/*######################################################################################*/

	/*###########################  210203    min&max point value #################################*/
	//temp_segemnt.min_point.value = temp_segemnt.max_point.value = temp_segemnt.apla.b;
	/*######################################################################################*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&                   Loop                        &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	if (temp_segemnt.apla.a == 0) {

		for (int i_segment = 1; i_segment < input_argument.point_dimension; i_segment++) {
			//200314 minmax point
			//temp_segemnt.right_endpoint = temp_segemnt.min_point.id = temp_segemnt.max_point.id = input_argument.segment_length_second * i_segment - 1;
			temp_segemnt.right_endpoint = input_argument.segment_length_second * i_segment - 1;
			get_apla_coefficients_segment(temp_segemnt);
			doubly_linked_list.add(temp_segemnt);
		}

	}
	else if (temp_segemnt.apla.a > 0) {

		for (int i_segment = 1; i_segment < input_argument.point_dimension; i_segment++) {

			//200314 minmax point
			/*++++++++++++++++++++++++++        210203      right end point          ++++++++++++++++++++++++++++++++++++*/
			//temp_segemnt.right_endpoint = temp_segemnt.max_point.id = input_argument.segment_length_second * i_segment - 1;
			temp_segemnt.right_endpoint = input_argument.segment_length_second * i_segment - 1;
			/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

			/*++++++++++++++++++++++++++       210203         id min point           ++++++++++++++++++++++++++++++++++++*/
			//temp_segemnt.min_point.id = i_segment > 1 ? input_argument.segment_length_second * (i_segment - 1) : 0;
			const size_t id_min_temp = i_segment > 1 ? input_argument.segment_length_second * (i_segment - 1) : 0;
			/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

			/*+++++++++++++++++++++++++        210203         b, value min point      +++++++++++++++++++++++++++++++++++*/
			//temp_segemnt.apla.b = temp_segemnt.min_point.value = original_time_series_vector[temp_segemnt.min_point.id];
			temp_segemnt.apla.b = original_time_series_vector[id_min_temp];
			/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

			/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			//temp_segemnt.max_point.value = original_time_series_vector[temp_segemnt.max_point.id]; 210203
			/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			get_apla_coefficients_segment(temp_segemnt);
			doubly_linked_list.add(temp_segemnt);
		}

	}
	else if (temp_segemnt.apla.a < 0) {
		for (int i_segment = 1; i_segment < input_argument.point_dimension; i_segment++) {

			//200314 minmax point
			/*++++++++++++++++++++++++++   210203           right end point          ++++++++++++++++++++++++++++++++++++*/
			//temp_segemnt.right_endpoint = temp_segemnt.min_point.id = input_argument.segment_length_second * i_segment - 1;
			temp_segemnt.right_endpoint = input_argument.segment_length_second * i_segment - 1;
			/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

			/*++++++++++++++++++++++++++  210203              id max point           ++++++++++++++++++++++++++++++++++++*/
			//temp_segemnt.max_point.id = i_segment > 1 ? input_argument.segment_length_second * (i_segment - 1) + 1 : 0;
			const size_t id_max_temp = i_segment > 1 ? input_argument.segment_length_second * (i_segment - 1) + 1 : 0;
			/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

			/*+++++++++++++++++++++++++    210203             b, value max point      +++++++++++++++++++++++++++++++++++*/
			//temp_segemnt.apla.b = temp_segemnt.max_point.value = original_time_series_vector[temp_segemnt.max_point.id];
			temp_segemnt.apla.b = original_time_series_vector[id_max_temp];
			/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

			/*+++++++++++++++++++++++++++++++      210203      value min point          ++++++++++++++++++++++++++++++++++*/
			//temp_segemnt.min_point.value = original_time_series_vector[temp_segemnt.min_point.id];
			/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			get_apla_coefficients_segment(temp_segemnt);
			doubly_linked_list.add(temp_segemnt);
		}
	}
	else {
		assert(0);
	}
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	//200314 minmax point
	//temp_segemnt.right_endpoint = temp_segemnt.min_point.id = temp_segemnt.max_point.id = input_argument.time_series_length - 1;
	temp_segemnt.right_endpoint = input_argument.time_series_length - 1;
	temp_segemnt.rectangle_width = temp_segemnt.right_endpoint - doubly_linked_list.back().right_endpoint;

	//if (temp_segemnt.apla.a == 0) { 210203
	//	//200314 minmax point
	//	temp_segemnt.min_point.id = temp_segemnt.max_point.id = temp_segemnt.right_endpoint;
	//}

	if (temp_segemnt.apla.a >= 0) {
		//200314 minmax point
		/*+++++++++++++++++++++++++++   210203           id max point          ++++++++++++++++++++++++++++++++++++++*/
		//temp_segemnt.max_point.id = temp_segemnt.right_endpoint;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*+++++++++++++++++++++++++++   210203            id min point           ++++++++++++++++++++++++++++++++++++*/
		//temp_segemnt.min_point.id = temp_segemnt.right_endpoint - temp_segemnt.rectangle_width + 1;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*+++++++++++++++++++++++++     210203            b, value min point      +++++++++++++++++++++++++++++++++++*/
		//temp_segemnt.apla.b = temp_segemnt.min_point.value = original_time_series_vector[temp_segemnt.min_point.id];
		temp_segemnt.apla.b = original_time_series_vector[temp_segemnt.right_endpoint - temp_segemnt.rectangle_width + 1];
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*+++++++++++++++++++++++++++++++++++++  210203    value max point          +++++++++++++++++++++++++++++++++*/
		//temp_segemnt.max_point.value = original_time_series_vector[temp_segemnt.max_point.id];
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	}
	else if (temp_segemnt.apla.a < 0) {
		//200314 minmax point
		/*++++++++++++++++++++++++++++  210203            id min point          +++++++++++++++++++++++++++++++++++++*/
		//temp_segemnt.min_point.id = temp_segemnt.right_endpoint;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*++++++++++++++++++++++++++    210203            id max point           ++++++++++++++++++++++++++++++++++++*/
		//temp_segemnt.max_point.id = temp_segemnt.right_endpoint - temp_segemnt.rectangle_width + 1;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*+++++++++++++++++++++++++                 b, value max point      +++++++++++++++++++++++++++++++++++*/
		//temp_segemnt.apla.b = temp_segemnt.max_point.value = original_time_series_vector[temp_segemnt.max_point.id];
		temp_segemnt.apla.b = original_time_series_vector[temp_segemnt.right_endpoint - temp_segemnt.rectangle_width + 1];
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*+++++++++++++++++++++++++++++++++        value min point        +++++++++++++++++++++++++++++++++++++*/
		//temp_segemnt.min_point.value = original_time_series_vector[temp_segemnt.min_point.id];
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	}

	get_apla_coefficients_segment(temp_segemnt);
	doubly_linked_list.add(temp_segemnt);

	/*.....................................................................................*/
#ifdef _DEBUG
	assert(doubly_linked_list.size() == input_argument.point_dimension);
	assert_endpoint_a_b(original_time_series_vector, doubly_linked_list);
#endif
	/*.....................................................................................*/

}

//***********************************************
// Method:mergeOperationJump1
// Qualifier:190610  APLA merge operation loop+=2
// date:190610
// author:
//***********************************************
TEMPLATE
void APLA::mergeOperationJump1(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, AREA_COEFFICIENT& const temp_coefficient) {//190610 loop +=2
	typename GEOMETRY::POINT pair_density;
	pair_density.value = INF;
	int segment_number = 2;
	double lower_bound_density = INF;
	//vector<AREA_COEFFICIENT> max_density_vector = { temp_coefficient };
	priority_queue<double> up_lower_bound_density_queue;//190328
	priority_queue<double*> pointer_up_lower_bound_density_queue;
	std::set<double> density_max_set;//190328
	priority_queue<typename GEOMETRY::POINT, std::vector<typename GEOMETRY::POINT>, typename GEOMETRY::ValueDecrease> min_segment_density_queue;//190607
	vector<AREA_COEFFICIENT> temp_coefficient_vector;
	temp_coefficient_vector.resize(input_argument.point_dimension, AREA_COEFFICIENT());
	//AREA_COEFFICIENT max_density_coefficient;

	for (int vector_id = 1; vector_id < area_vector.size(); vector_id++) {
		getMergedInfor0ForParallelogram(original_time_series, area_vector, vector_id, segment_number, temp_coefficient);
		//temp_coefficient_vector[vector_id] = temp_coefficient;
		if (lower_bound_density > temp_coefficient.segment_density) {
			//pair_density.id = vector_id;
			//pair_density.value = temp_coefficient.segment_density;
			//max_density_vector[0] = temp_coefficient;
			lower_bound_density = temp_coefficient.segment_density;
		}

		//min_segment_density_queue.push(pair_density);
	}

	while (area_vector.size() > input_argument.point_dimension) {
		pair_density.id = 0;
		pair_density.value = 0;
		int merge_count = 0;//decide when to finish for loop to erase extra vector
		auto original_size = area_vector.size();
		for (int vector_id = 1; vector_id < area_vector.size() && area_vector.size() > input_argument.point_dimension; vector_id++) {
			getMergedInfor0ForParallelogram(original_time_series, area_vector, vector_id, segment_number, temp_coefficient);
			//temp_coefficient_vector[vector_id] = temp_coefficient;
			if (area_vector.size() - merge_count <= input_argument.point_dimension) {
				//area_vector.erase(area_vector.begin() + left_id);
#if _DEBUG
				//cout << "End loop!!!!!!!!!!!!!!" << endl;
#endif
				break;
			}
			/*============================================Begin merge================================================*/
			if (temp_coefficient.segment_density > lower_bound_density) {
				merge_count++;
				//mergeRectangle2(area_vector, vector_id, temp_coefficient, original_time_series);
#ifdef TIME_H
				//TOOL::recordStartTime(TOOL::time_record[14]);
#endif
				//mergeRectangle0ForParallelogram(area_vector, vector_id, temp_coefficient, original_time_series);
				/*----------------------------------------------------------*Megrge Process*------------------------------------------------------------*/
				mergeRectangle0ForParallelogramNoErase(area_vector, vector_id, segment_number, temp_coefficient, original_time_series);
				vector_id++;
#ifdef TIME_H
				//area_vector.erase(area_vector.begin() + left_id);
				//time4 += TOOL::recordFinishTime(TOOL::time_record[14]);
#endif
#if _DEBUG
				//cout << "3 after merge id: " << vector_id << " " << temp_coefficient.right_endpoint << endl;
#endif
#ifdef TIME_H
				//TOOL::recordStartTime(TOOL::time_record[17]);
#endif
				/*****************************update queue***************************************/
				if (!up_lower_bound_density_queue.empty()) {
					if (up_lower_bound_density_queue.top() > temp_coefficient.segment_density) {
						up_lower_bound_density_queue.pop();
						//up_lower_bound_density_queue.push(temp_coefficient.segment_density);
						up_lower_bound_density_queue.emplace(temp_coefficient.segment_density);
					}
				}
				/*.................................................................*/
#ifdef TIME_H
				//time7 += TOOL::recordFinishTime(TOOL::time_record[17]);
#endif
			}
			else {
#ifdef TIME_H
				//TOOL::recordStartTime(TOOL::time_record[18]);
#endif
				//if(density_max_set.size()< input_argument.point_dimension)
				//density_max_set.insert(temp_coefficient.segment_density);
				//density_max_set.emplace(temp_coefficient.segment_density);//need clear() function at loop begin.
				density_max_set.emplace_hint(density_max_set.begin(), temp_coefficient.segment_density);
				//else {
					//density_max_set.erase(density_max_set.begin());
					//density_max_set.emplace(temp_coefficient.segment_density);
				//}
#if _DEBUG
				//cout << "2 not merge, set size: " << density_max_set.size()<<" inserted density: "<< temp_coefficient.segment_density  << endl;
#endif
#ifdef TIME_H
				//time8 += TOOL::recordFinishTime(TOOL::time_record[18]);
#endif
			}
			//if (pair_density.value < temp_coefficient.segment_density) {
				//pair_density.id = vector_id;
				//pair_density.value = temp_coefficient.segment_density;
				//max_density_vector[0] = temp_coefficient;
			//}

			//min_segment_density_queue.push(pair_density);
		}
		//int left_id = pair_density.id - 1;
		//cout << "erase id: " << left_id << endl;
		//area_vector[pair_density.id] = temp_coefficient_vector[pair_density.id];
		//area_vector[pair_density.id] = max_density_vector[0];
		//area_vector.erase(area_vector.begin() + left_id);
		//area_vector[left_id].right_endpoint = INF;// .at(0);
		//area_vector[left_id].rectangle_width = INF;// .at(0);
		//min_segment_density_queue.clear();
		area_vector.erase(std::remove_if(area_vector.begin(), area_vector.end(), [](AREA_COEFFICIENT& i) { return i.right_endpoint == INF && i.rectangle_width == INF; }), area_vector.end());
		if (!up_lower_bound_density_queue.empty()) {
			lower_bound_density = up_lower_bound_density_queue.top();
			//up_lower_bound_density_queue.pop();
#if _DEBUG
			//cout << "8 queue size: " << up_lower_bound_density_queue.size() << endl;
#endif
		}
		if (original_size <= area_vector.size() || area_vector.size() <= density_max_set.size() + 1) {
			//assert(area_vector.size() == density_max_set.size() + 1);
			//cout << "*********************************************" << endl;
			if (!up_lower_bound_density_queue.empty()) {
				up_lower_bound_density_queue.pop();
				//lower_bound_density = up_lower_bound_density_queue.top();
			}
			else {
				//cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << endl;
				lower_bound_density = *(density_max_set.cbegin());
				for (auto it = density_max_set.rbegin(); up_lower_bound_density_queue.size() <= input_argument.point_dimension && it != density_max_set.rend(); ++it) {
					//up_lower_bound_density_queue.push(*it);
					up_lower_bound_density_queue.emplace(*it);
				}
			}
		}
	}
	//cout <<"vector size: " <<area_vector.size() << endl;

	//area_vector.erase(std::remove_if(area_vector.begin(), area_vector.end(), [](AREA_COEFFICIENT& i) { return i.right_endpoint == INF && i.rectangle_width == INF; }), area_vector.end());
	/*for (auto&& i : area_vector) {
		cout << i.right_endpoint << " "<<i.rectangle_width << endl;
	}*/
}
//************************************
// Method:getAPLAAreaPLAImprove
// Qualifier:190606  APLA based on PLA
// date:190606
// author:
//************************************
TEMPLATE
void APLA::getAPLAAreaPLAImprove(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series) {//190606, APLA based on PLA
#ifdef _DEBUG
	assert(input_argument.time_series_length % 2 == 0);//n is even
#endif

	/*===================time & count====================*/
	double loop_time = 0;
	double time1 = 0;
	double time2 = 0;
	double time3 = 0;
	double time4 = 0;
	double time5 = 0;
	double time6 = 0;
	double time7 = 0;
	double time8 = 0;
	double time9 = 0;
	double time10 = 0;//update queue time
	double time11 = 0;
	double time12 = 0;
	double time13 = 0;
	double time14 = 0;

	int while_count = 0;
	int for_count = 0;
	/*...................................................*/

	/*=======================Test parameter===========================*/
	vector<int> count_break_point_vector;//190613 11:16
	count_break_point_vector.resize(input_argument.time_series_length, 0);//190613 11:16
	/*................................................................*/

	/*===================Test parameter====================*/
	int same_deviation_id_count = 0;//190515
	int diff_deviation_id_count = 0;//190515
	int total_merge_infor_count = 0;
	int deviaiton_min_max_count = 0;
	int deviation_all_count = 0;
	/*...................................................*/

	int segment_number = 2;
	int array_id = 0;
	long double lower_bound_density = INF;
	//long double max_density = INF;
	vector<AREA_COEFFICIENT> area_vector;
	AREA_COEFFICIENT temp_coefficient;

	priority_queue<double> up_lower_bound_density_queue;//190328
	priority_queue<double*> pointer_up_lower_bound_density_queue;
	std::set<double> density_max_set;//190328

	/*========================Test=============================================*/
	//typename GEOMETRY::ValueIncrease density_increase;//190313
	DensityIncrease density_increase;//190313
	priority_queue<typename GEOMETRY::POINT, std::vector<typename GEOMETRY::POINT>, typename GEOMETRY::ValueDecrease> min_segment_density_queue;//190607
	vector<AREA_COEFFICIENT> temp_coefficient_vector;
	temp_coefficient_vector.resize(input_argument.point_dimension, AREA_COEFFICIENT());
	area_vector.resize(input_argument.point_dimension, AREA_COEFFICIENT());
	for (auto&& au : temp_coefficient_vector) {
		au.right_subsegment = new AREA_COEFFICIENT;
	}
	/*for (auto&&au : area_vector) {
		au.right_subsegment = new AREA_COEFFICIENT;
	}*/
	typename GEOMETRY::POINT pair_density;
	/*..................................................................*/

	output_argument.min_density_segment.value = INF;
	output_argument.min_density_segment.id = INF;

	//merge
	TOOL::recordStartTime(TOOL::time_record[0]);//compare percentage time
	//initial
	//initialRecArea(input_argument, original_time_series, area_vector);//181211
	/*===================Initial====================*/
	//initialRecArea0ForParallelogram(input_argument, original_time_series, area_vector);//190404
	//initialRecArea0ForParallelogramNoPush(input_argument, original_time_series, area_vector);//190417
#ifdef TIME_H
	TOOL::recordStartTime(TOOL::time_record[1]);//compare percentage time
#endif
	//initialRecArea0ForParallelogramArrayVector(input_argument, original_time_series, area_vector);//190430
	initialRecAreaPLAImprove(input_argument, original_time_series, area_vector);//190606
#ifdef TIME_H
	time1 = TOOL::recordFinishTime(TOOL::time_record[1]);
#endif
	/*...................................................*/
	//lower_bound_density = output_argument.min_density_segment.value;
	//output_argument.min_density_segment.id;
	/*===========================================Loop==========================================================================*/
	input_argument.point_dimension /= 2;
	mergeOperation0(input_argument, original_time_series, area_vector, temp_coefficient);//190609
	// mergeOperationJump1(input_argument, original_time_series, area_vector, temp_coefficient);//190610
	//mergeOperationBatch2(input_argument, original_time_series, area_vector, temp_coefficient_vector, temp_coefficient);//190610
	//mergeOperationBatch2SetSpeed(input_argument, area_vector, temp_coefficient_vector, temp_coefficient);//190611 1516
	//mergeOperationBatch2Set(input_argument, area_vector, temp_coefficient_vector, temp_coefficient);//190612 09:57
	//mergeOperationBatch2SetPointer(input_argument, area_vector, temp_coefficient_vector, temp_coefficient,count_break_point_vector);//190612 10:16
	mergeOperationBatch2SetSpeedPointer(input_argument, area_vector, temp_coefficient_vector, temp_coefficient);//190612 16:07
	output_argument.run_time = TOOL::recordFinishTime(TOOL::time_record[0]);
	/*...........................................................................................................*/
		//cout << "APLA running Time: " << output_argument.run_time << endl;// compare percentage time
		//cout << "vector size: " << area_vector.size() << endl;
	assert(area_vector.size() == input_argument.point_dimension);
	/*========================Reconstruction====================================*/
	getAPLA(input_argument, original_time_series, area_vector);
	/*..........................................................................*/

	/*========================Write Result=================================*/
	double* temp_endpoint = new double[area_vector.size()];
	array_id = 0;
	for (auto&& i : area_vector) {
		temp_endpoint[array_id] = i.right_endpoint;
		array_id++;
	}
	TOOL::writeSingleResult("./200706AllAPLAEvaluation/APLAEndPoint181218", temp_endpoint, area_vector.size());
	array_id = 0;
	for (auto&& i : area_vector) {
		//temp_endpoint[array_id] = i.lowest_id;
		temp_endpoint[array_id] = 0;
		array_id++;
	}
	TOOL::writeSingleResult("APLAMinId181221", temp_endpoint, area_vector.size());

	array_id = 0;
	for (auto&& i : area_vector) {
		//temp_endpoint[array_id] = i.heightest_id;
		temp_endpoint[array_id] = 0;
		array_id++;
	}
	TOOL::writeSingleResult("APLAMaxId181221", temp_endpoint, area_vector.size());
	TOOL::deleteArray(temp_endpoint);
	/*..............................................................................*/

	/*====================Print vector result=======================*/
	//cout << "initial time: " << time9 << "< ***<<<< loop time: " << loop_time << " mergerd information time: " << time3 << " Merge segmnet time: " << time1 << " Change threshold id time: " << time2 << " merge operation: " << time4 << " while count: " << while_count << " for count: " << for_count << " == operation time: " << time5 << " erease time: " << time6 << " merged id time: " << time7 << " not merge time: " << time8 << endl;
	cout << "============Test================" << endl;
	cout << "Total merge count: " << total_merge_infor_count << endl;
	cout << "deviation minmax, deviation, endpoint id: " << deviation_all_count << endl;
	cout << "same deviation id: " << same_deviation_id_count << endl;
	cout << "different deviation id: " << diff_deviation_id_count << endl;
	cout << "deviation minmax id: " << deviaiton_min_max_count << endl;
	cout << "................................" << endl;
	cout << "Whole time: " << output_argument.run_time
		<< "\n 1 initial time: " << time1
		//<< "\n 2 loop time: " << loop_time
		//<< "\n 3 Threshhold time: " << time10
		//<< "\n 2.1 mergerd information time: " << time3
		//<< "\n 2.1.1 get width: " << time12
		//<< "\n 2.1.2 get a&b time: " << time13
		//<< "\n 2.1.3 mergerd information time: " << time14
		//<< "\n 2.2 Whole merge segmnet time: " << time9
		//<< "\n 2.2.0 Whole merge segmnet time: " << time11
		//<< "\n 2.2.1 merge operation time: " << time4
		//<< "\n 2.2.2 change queue time: " << time7
		//<< "\n 2.2.3 not merge time: " << time8
		//<< "\n 3.1 erease time: " << time6
		<< "\n 3.2 Change threshold time: " << time2 << endl;

	//cout << "Finish! \n size: " << area_vector.size() << endl;

	/*cout << endl << "Min: ";
	for (auto&& i : area_vector) {
		cout << i.min_point.id << " ";
	}
	cout << endl << "Max: ";
	for (auto&& i : area_vector) {
		cout << i.max_point.id << " ";
	}
	cout << endl << "Area: ";
	for (auto&& i : area_vector) {
		cout << i.rectangle_area << " ";
	}
	cout << endl;*/
	/*cout << "right end point: ";
	for (auto&& i : area_vector) {
		cout << i.right_endpoint << " ";
	}*/
	/*array_id = 0;
	cout << "parallelogram_height: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.parallelogram_height << ", ";
		array_id++;
	}
	cout << endl;*/
	/*array_id = 0;
	cout << "rectangle_width: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.rectangle_width << ", ";
		array_id++;
	}
	cout << endl;*/
	/*array_id = 0;
	cout << "APLA deviation: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.rec_deviation << ", ";
		array_id++;
	}
	cout << endl;*/
	/*............................................................*/
	/*=======================Print Test============================*/
	cout << "Original time: " << endl;
	for (int i = 0; i < input_argument.time_series_length; i++) {
		cout << original_time_series[i] << ", ";
	}
	cout << endl;

	array_id = 0;
	cout << "Break point count: " << endl;
	for (auto&& au : count_break_point_vector) {
		cout << au << ", ";
		//cout << array_id << ": " << au << ", ";
		//array_id++;
	}
	cout << endl;
	/*............................................................*/
}

//************************************
// Method:getAPLAAreaPLAImproveNoPointer
// Qualifier:190612 Speed up above algorithm
// date:190612
// author:
//************************************
TEMPLATE
void APLA::getAPLAAreaPLAImproveNoPointer(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series) {//190612, APLA based on PLA, minimize struct, no pointer
#ifdef _DEBUG
	assert(input_argument.time_series_length % 2 == 0);//n is even
#endif

	/*===================time & count====================*/
	double loop_time = 0;
	double time1 = 0;
	double time2 = 0;
	double time3 = 0;
	double time4 = 0;
	double time5 = 0;
	double time6 = 0;

	int while_count = 0;
	int for_count = 0;
	/*...................................................*/

	/*===================Test parameter====================*/
	int same_deviation_id_count = 0;//190515
	int diff_deviation_id_count = 0;//190515
	int total_merge_infor_count = 0;
	int deviaiton_min_max_count = 0;
	int deviation_all_count = 0;
	/*...................................................*/

	int segment_number = 2;
	int array_id = 0;
	long double lower_bound_density = INF;
	//long double max_density = INF;
	vector<AREA_COEFFICIENT> area_vector;
	AREA_COEFFICIENT temp_coefficient;

	priority_queue<double> up_lower_bound_density_queue;//190328
	priority_queue<double*> pointer_up_lower_bound_density_queue;
	std::set<double> density_max_set;//190328

	/*========================Test=============================================*/
	//typename GEOMETRY::ValueIncrease density_increase;//190313
	DensityIncrease density_increase;//190313
	priority_queue<typename GEOMETRY::POINT, std::vector<typename GEOMETRY::POINT>, typename GEOMETRY::ValueDecrease> min_segment_density_queue;//190607
	vector<AREA_COEFFICIENT> temp_coefficient_vector;
	temp_coefficient_vector.resize(input_argument.point_dimension, AREA_COEFFICIENT());
	area_vector.resize(input_argument.point_dimension, AREA_COEFFICIENT());
	for (auto&& au : temp_coefficient_vector) {
		au.right_subsegment = new AREA_COEFFICIENT;
	}
	/*for (auto&&au : area_vector) {
		au.right_subsegment = new AREA_COEFFICIENT;
	}*/
	typename GEOMETRY::POINT pair_density;
	/*..................................................................*/

	output_argument.min_density_segment.value = INF;
	output_argument.min_density_segment.id = INF;

	//merge
	TOOL::recordStartTime(TOOL::time_record[0]);//compare percentage time
	//initial
#ifdef TIME_H
	TOOL::recordStartTime(TOOL::time_record[1]);//compare percentage time
#endif
	//initialRecArea0ForParallelogramArrayVector(input_argument, original_time_series, area_vector);//190430
	//initialRecAreaPLAImprove(input_argument, original_time_series, area_vector);//190606
	initialAPLARightEndpoint(input_argument, original_time_series, area_vector);//190617
#ifdef TIME_H
	time1 = TOOL::recordFinishTime(TOOL::time_record[1]);
#endif
	/*...................................................*/
	//lower_bound_density = output_argument.min_density_segment.value;
	//output_argument.min_density_segment.id;
	/*===========================================Loop==========================================================================*/
	input_argument.point_dimension /= 2;
	//mergeOperation0(input_argument, original_time_series, area_vector, temp_coefficient);//190609
	//mergeOperationJump1(input_argument, original_time_series, area_vector, temp_coefficient);//190610
	//mergeOperationBatch2(input_argument, original_time_series, area_vector, temp_coefficient_vector, temp_coefficient);//190610
	//mergeOperationBatch2SetSpeed(input_argument, area_vector, temp_coefficient_vector, temp_coefficient);//190611 1516
	//mergeOperationBatch2Set(input_argument, area_vector, temp_coefficient_vector, temp_coefficient);//190612 09:57
	mergeOperationBatch2SetPointer(input_argument, area_vector, temp_coefficient_vector, temp_coefficient);//190612 10:16
	//mergeOperationBatch2SetSpeedPointer(input_argument, area_vector, temp_coefficient_vector, temp_coefficient);//190612 16:07
	output_argument.run_time = TOOL::recordFinishTime(TOOL::time_record[0]);
	/*...........................................................................................................*/
		//cout << "APLA running Time: " << output_argument.run_time << endl;// compare percentage time
		//cout << "vector size: " << area_vector.size() << endl;
	assert(area_vector.size() == input_argument.point_dimension);
	/*========================Reconstruction====================================*/
	getAPLA(input_argument, original_time_series, area_vector);
	/*..........................................................................*/

	/*========================Write Result=================================*/
	double* temp_endpoint = new double[area_vector.size()];
	array_id = 0;
	for (auto&& i : area_vector) {
		temp_endpoint[array_id] = i.right_endpoint;
		array_id++;
	}
	TOOL::writeSingleResult("./200706AllAPLAEvaluation/APLAEndPoint181218", temp_endpoint, area_vector.size());
	array_id = 0;
	for (auto&& i : area_vector) {
		//temp_endpoint[array_id] = i.lowest_id;
		temp_endpoint[array_id] = 0;
		array_id++;
	}
	TOOL::writeSingleResult("APLAMinId181221", temp_endpoint, area_vector.size());

	array_id = 0;
	for (auto&& i : area_vector) {
		//temp_endpoint[array_id] = i.heightest_id;
		temp_endpoint[array_id] = 0;
		array_id++;
	}
	TOOL::writeSingleResult("APLAMaxId181221", temp_endpoint, area_vector.size());
	TOOL::deleteArray(temp_endpoint);
	/*..............................................................................*/

	/*====================Print vector result=======================*/
	//cout << "initial time: " << time9 << "< ***<<<< loop time: " << loop_time << " mergerd information time: " << time3 << " Merge segmnet time: " << time1 << " Change threshold id time: " << time2 << " merge operation: " << time4 << " while count: " << while_count << " for count: " << for_count << " == operation time: " << time5 << " erease time: " << time6 << " merged id time: " << time7 << " not merge time: " << time8 << endl;
	cout << "============Test================" << endl;
	cout << "Total merge count: " << total_merge_infor_count << endl;
	cout << "deviation minmax, deviation, endpoint id: " << deviation_all_count << endl;
	cout << "same deviation id: " << same_deviation_id_count << endl;
	cout << "different deviation id: " << diff_deviation_id_count << endl;
	cout << "deviation minmax id: " << deviaiton_min_max_count << endl;
	cout << "................................" << endl;
	cout << "Whole time: " << output_argument.run_time
		<< "\n 1 initial time: " << time1
		//<< "\n 2 loop time: " << loop_time
		//<< "\n 3 Threshhold time: " << time10
		//<< "\n 2.1 mergerd information time: " << time3
		//<< "\n 2.1.1 get width: " << time12
		//<< "\n 2.1.2 get a&b time: " << time13
		//<< "\n 2.1.3 mergerd information time: " << time14
		//<< "\n 2.2 Whole merge segmnet time: " << time9
		//<< "\n 2.2.0 Whole merge segmnet time: " << time11
		//<< "\n 2.2.1 merge operation time: " << time4
		//<< "\n 2.2.2 change queue time: " << time7
		//<< "\n 2.2.3 not merge time: " << time8
		//<< "\n 3.1 erease time: " << time6
		<< "\n 3.2 Change threshold time: " << time2 << endl;

	//cout << "Finish! \n size: " << area_vector.size() << endl;
}

//************************************
// Method:getAPLAByMinMax
// Qualifier:190617 For every segment, use minmax point as endpoint. Then for every segment use same subsegemnt number to merge.
// date:190617
// author:
//************************************
TEMPLATE
void APLA::getAPLAByMinMax(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series) {
#ifdef _DEBUG
	assert(input_argument.time_series_length % 2 == 0);//n is even
#endif

	/*=================Random get endpoint====================================*/
	//getBestEndpoint(input_argument, original_time_series);//190623
	/*..................................................*/

	/*===================time & count====================*/
	double loop_time = 0;
	double time1 = 0;
	double time2 = 0;
	double time3 = 0;
	double time4 = 0;
	double time5 = 0;
	double time6 = 0;
	double time7 = 0;
	double time8 = 0;
	double time9 = 0;
	double time10 = 0;//update queue time
	double time11 = 0;
	double time12 = 0;
	double time13 = 0;
	double time14 = 0;

	int while_count = 0;
	int for_count = 0;
	/*...................................................*/

	/*=======================Test parameter===========================*/
	vector<int> count_break_point_vector;//190613 11:16
	count_break_point_vector.resize(input_argument.time_series_length, 0);//190613 11:16

	int same_deviation_id_count = 0;//190515
	int diff_deviation_id_count = 0;//190515
	int total_merge_infor_count = 0;
	int deviaiton_min_max_count = 0;
	int deviation_all_count = 0;
	/*................................................................*/

	int segment_size_coefficient = input_argument.point_dimension < 3 ? 3 : input_argument.point_dimension;
	int array_id = 0;
	long double lower_bound_density = INF;
	//long double max_density = INF;
	vector<AREA_COEFFICIENT> area_vector;
	AREA_COEFFICIENT temp_coefficient;
	/*190820 Linked list & Pointer*/
	DoublyLinkedList<AREA_COEFFICIENT> doubly_linked_list = DoublyLinkedList<AREA_COEFFICIENT>();
	/*............................*/
	priority_queue<double> up_lower_bound_density_queue;//190328
	priority_queue<double*> pointer_up_lower_bound_density_queue;
	std::set<double> density_max_set;//190328

	/*========================Test=============================================*/
	//typename GEOMETRY::ValueIncrease density_increase;//190313
	DensityIncrease density_increase;//190313
	//priority_queue<typename GEOMETRY::POINT, std::vector<typename GEOMETRY::POINT>, typename GEOMETRY::ValueDecrease> min_segment_density_queue;//190607
	vector<AREA_COEFFICIENT> temp_coefficient_vector;
	temp_coefficient_vector.resize(input_argument.point_dimension * 4, AREA_COEFFICIENT());

	for (auto&& au : temp_coefficient_vector) {
		au.right_subsegment = new AREA_COEFFICIENT;
	}
	/*for (auto&&au : area_vector) {
		au.right_subsegment = new AREA_COEFFICIENT;
	}*/
	typename GEOMETRY::POINT pair_density;
	/*..................................................................*/

	output_argument.min_density_segment.value = INF;
	output_argument.min_density_segment.id = INF;

	auto start = std::chrono::system_clock::now();
	//merge
	TOOL::recordStartTime(TOOL::time_record[0]);//compare percentage time
	//initial
	//initialRecArea(input_argument, original_time_series, area_vector);//181211
	/*========================================================Initial=================================================================*/
	//*Input: original time series, N, n
	//*Output: width, right endpoint, a&b, min&max point, sum value, new *right_subsegment

	//initialRecArea0ForParallelogram(input_argument, original_time_series, area_vector);//190404
	//initialRecArea0ForParallelogramNoPush(input_argument, original_time_series, area_vector);//190417
#ifdef TIME_H
	TOOL::recordStartTime(TOOL::time_record[1]);//compare percentage time
#endif
	//initialRecArea0ForParallelogramArrayVector(input_argument, original_time_series, area_vector);//190430
	//initialRecAreaPLAImprove(input_argument, original_time_series, area_vector);//190606
	//initialAPLARightEndpoint(input_argument, original_time_series, area_vector);//190617 12:00

	//area_vector.resize(segment_size_coefficient, AREA_COEFFICIENT());
	//initialAPLARightEndpoint3Sub(input_argument, original_time_series, area_vector);//190617 16:48
	//initialAPLARightEndpoint3SubAdaptive(input_argument, original_time_series, area_vector); //190705 12:32
	//initialAPLARightEndpoint3SubAdaptiveMergeSplit(input_argument, original_time_series, area_vector);//190711 16:59
	//initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursive(input_argument, original_time_series, area_vector);//190719 16:35
	//initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursiveSpeed(input_argument, original_time_series, area_vector);//190812 10:40
	initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursiveSpeed(input_argument, original_time_series, area_vector, doubly_linked_list);//190812 10:40
	//initialAPLARightEndpoint3SubNoMerge(input_argument, original_time_series, area_vector);//190628

	//cout  <<  format(elapsed(), places(), format_string()) << endl;
#ifdef _DEBUG
	if (input_argument.is_y_projection == false)
		assert(area_vector.size() >= input_argument.point_dimension);
#endif
	/*--------------------------------Write & Print Result------------------------------------------------*/
#ifdef _DEBUG

	/*==============Reconstruct time series=================*/
	vector<double> initial_reconstruct_time_series_vector;
	getAPLAReconstructSeries(area_vector, initial_reconstruct_time_series_vector);
	//cout << "" << endl;
	TOOL::writeResultNoCover("./200706AllAPLAEvaluation/AllAPLAInitialEndpoint", initial_reconstruct_time_series_vector);
	initial_reconstruct_time_series_vector.clear();
	initial_reconstruct_time_series_vector.shrink_to_fit();
	/*.....................................................*/

	getAPLASegmentDeviation(original_time_series, area_vector);
	getAPLASegmentDeviation(original_time_series, doubly_linked_list);
	/*---------------Get PLA line rectagnle area & density----------------------*/
	getPLALineRectangleAreaDensity(area_vector);
	getPLALineRectangleAreaDensity(doubly_linked_list);
	getSegmentMinMaxRectangleAreaDensity(original_time_series, area_vector);//190701
	getSegmentMinMaxRectangleAreaDensity(original_time_series, doubly_linked_list);//

	cout << "Initial minmax width Rectangle Area: ";
	for (auto&& au : area_vector) {
		cout << au.minmax_width_area << ", ";
	}
	cout << endl;

	cout << "Initial minmax dist Rectangle Area: ";
	for (auto&& au : area_vector) {
		cout << au.minmax_distance_area << ", ";
	}
	cout << endl;

	cout << "Initial PLA Rectangle         Area: ";
	for (auto&& au : area_vector) {
		cout << au.rectangle_area << ", ";
	}
	cout << endl;

	cout << "Initial Rectangle Density: ";
	for (auto&& au : area_vector) {
		cout << au.rectangle_density << ", ";
	}
	cout << endl;
	/*..........................................................................*/
	cout << "Initial Segment devation: ";
	for (auto&& au : area_vector) {
		cout << au.rec_deviation << ", ";
	}
	cout << endl;
	cout << "Initial APLA Right endpoint: ";
	for (auto&& au : area_vector) {
		cout << au.right_endpoint << ", ";
	}
	cout << endl;
	cout << "Initial APLA Rectangle width: ";
	for (auto&& au : area_vector) {
		cout << au.rectangle_width << ", ";
	}
	cout << endl;
	cout << "Initial APLA Split ID: ";
	vector<int> split_id_vector;// (segment_size_coefficient);

	for (auto&& au : area_vector) {
		auto split_id = findSplitSegmentByEndpoint2length(original_time_series, au);
		if (split_id != INF)
			split_id_vector.emplace_back(split_id);
		cout << split_id + 1 << ", ";
	}
	cout << endl;
	TOOL::writeResultNoCover("./200206DrawPlotChart/AllAPLAInitialSplitID", split_id_vector);
	split_id_vector.clear();
	split_id_vector.shrink_to_fit();
	/*=====Write Split ID====*/

	/*......................*/
#endif
	/*......................................................................................................*/
#ifdef TIME_H
	time1 = TOOL::recordFinishTime(TOOL::time_record[1]);
#endif
	/*...................................................*/
	//lower_bound_density = output_argument.min_density_segment.value;
	//output_argument.min_density_segment.id;
	/*===========================================Merge & Split==========================================================================*/
	//*Input a&b, width, right endpoint, sum value, min&max point
	//*Output split&merge

	//input_argument.point_dimension /= 2;

	//mergeOperation0(input_argument, original_time_series, area_vector, temp_coefficient);//190609
	//mergeOperationJump1(input_argument, original_time_series, area_vector, temp_coefficient);//190610
	//mergeOperationBatch2(input_argument, original_time_series, area_vector, temp_coefficient_vector, temp_coefficient);//190610
	//mergeOperationBatch2SetSpeed(input_argument, area_vector, temp_coefficient_vector, temp_coefficient);//190611 1516
	//mergeOperationBatch2Set(input_argument, original_time_series,area_vector, temp_coefficient_vector, temp_coefficient);//190612 09:57
	//mergeOperationBatch2SetPointer(input_argument, area_vector, temp_coefficient_vector, temp_coefficient, count_break_point_vector);//190612 10:16 id+=2

	//+++ Input:
	//+++ Output:
#ifdef TIME_H
	TOOL::recordStartTime(TOOL::time_record[2]);//compare percentage time
#endif
	if (input_argument.is_y_projection == false) {
		//for_each_n(area_vector.begin(), area_vector.size(), [](auto&& au) {assert(au.min_point.id != INF && au.min_point.id != INF && au.min_point.value != INF && au.max_point.value != INF);});
		mergeOperationBatch2SetSpeedPointer(input_argument, original_time_series, area_vector, temp_coefficient_vector, temp_coefficient);//190723 16:07 id+=1
		//190826
		//mergeOperationBatch2SetSpeedPointer(input_argument, original_time_series, temp_coefficient_vector, segment_linked_list);//190826
		//190827
		mergeSplitOperationLink(input_argument, original_time_series, doubly_linked_list);
	}
#ifdef TIME_H
	time2 = TOOL::recordFinishTime(TOOL::time_record[2]);
#endif
	output_argument.run_time = TOOL::recordFinishTime(TOOL::time_record[0]);
	auto end = std::chrono::system_clock::now();
	std::chrono::duration<double> elapsed_seconds = end - start;
	/*...........................................................................................................*/
		//cout << "APLA running Time: " << output_argument.run_time << endl;// compare percentage time
		//cout << "vector size: " << area_vector.size() << endl;
	if (input_argument.is_y_projection == false)
		assert(area_vector.size() == input_argument.point_dimension);
	/*========================get SUM deviation, max devaition & reconstruct series====================================*/
	getAPLA(input_argument, original_time_series, area_vector);
	/*................................................................................................................*/

	/*========================Write & Print reconstruct series====================================*/
	getPLALineRectangleAreaDensity(area_vector);
	getSegmentMinMaxRectangleAreaDensity(original_time_series, area_vector);//190701
	/*----------------------------------------APLA reconstruct series---------------------------------------------------------------*/
	vector<double> reconstruct_time_series_vector;
	getAPLAReconstructSeries(area_vector, reconstruct_time_series_vector);
	assert(reconstruct_time_series_vector.size() == input_argument.time_series_length);
	TOOL::writeResultNoCover("./200706AllAPLAEvaluation/APLAReconstructSeries", reconstruct_time_series_vector);
	reconstruct_time_series_vector.clear();
	reconstruct_time_series_vector.shrink_to_fit();
	/*..............................................................................................................................*/

	/*----------------------------------------APLA right endpoint---------------------------------------------------------------*/
	vector<int> right_endpoint_vector;
	for (auto&& au : area_vector) {
		right_endpoint_vector.emplace_back(au.right_endpoint);
	}
	TOOL::writeResultNoCover("./200706AllAPLAEvaluation/AllAPLARightEndpoint", right_endpoint_vector);
	right_endpoint_vector.clear();
	right_endpoint_vector.shrink_to_fit();
	/*..............................................................................................................................*/
	/*----------------------------------------APLA  minmax width Rectangle Area---------------------------------------------------------------*/
	/*cout << "APLA minmax width Rectangle Area: ";
	for (auto&& au : area_vector) {
		cout << au.minmax_width_area << ", ";
	}
	cout << endl;*/
	/*..............................................................................................................................*/
	/*----------------------------------------APLA minmax distance Area---------------------------------------------------------------*/
	/*cout << "APLA minmax dist Area: ";
	for (auto&& au : area_vector) {
		cout << au.minmax_distance_area << ", ";
	}
	cout << endl;*/
	/*..............................................................................................................................*/
	/*----------------------------------------APLA PLA Rectangle Area---------------------------------------------------------------*/
	/*cout << "APLA PLA Rectangle Area: ";
	for (auto&& au : area_vector) {
		cout << au.rectangle_area << ", ";
	}
	cout << endl;*/
	/*-----------------------------------------------------------------------------------------------------------------------------*/
	/*----------------------------------------APLA increament Area------------------------------------------------------------------*/
	/*cout << "APLA Segment increament area: ";
	vector<double> increament_area_vector;
	for (auto&& au : area_vector) {
		increament_area_vector.emplace_back(au.increment_area);
		cout << au.increment_area << ", ";
	}
	cout << endl;
	TOOL::writeResultNoCover("AllAPLAIncreamentArea", increament_area_vector);
	increament_area_vector.clear();
	increament_area_vector.shrink_to_fit();*/
	/*------------------------------------------------------------------------------------------------------------------------------*/
	/*-------------------------------------------APLA segment Density---------------------------------------------------------------*/
	/*cout << "APLA segment density: ";
	vector<double> segment_density_vector;
	for (auto&& au : area_vector) {
		segment_density_vector.emplace_back(au.segment_density);
		cout << au.segment_density << ", ";
	}
	cout << endl;
	TOOL::writeResultNoCover("AllAPLASegmentDensity", segment_density_vector);
	segment_density_vector.clear();
	segment_density_vector.shrink_to_fit();*/
	/*..............................................................................................................................*/

	/*----------------------------------------APLA sum deviation---------------------------------------------------------------*/
	vector<double> sum_deviation_vector;
	sum_deviation_vector.emplace_back(output_argument.sum_deviation);
	TOOL::writeResultNoCover("./200706AllAPLAEvaluation/AllAPLASumDeviation", sum_deviation_vector);
	sum_deviation_vector.clear();
	sum_deviation_vector.shrink_to_fit();
	/*..............................................................................................................................*/

	/*................................................................................................................*/

	/*========================Write Result=================================*/
	double* temp_endpoint = new double[area_vector.size()];
	array_id = 0;
	for (auto&& i : area_vector) {
		temp_endpoint[array_id] = i.right_endpoint;
		array_id++;
	}
	TOOL::writeSingleResult("./200706AllAPLAEvaluation/APLAEndPoint181218", temp_endpoint, area_vector.size());
	array_id = 0;
	for (auto&& i : area_vector) {
		//temp_endpoint[array_id] = i.lowest_id;
		temp_endpoint[array_id] = 0;
		array_id++;
	}
	TOOL::writeSingleResult("APLAMinId181221", temp_endpoint, area_vector.size());

	array_id = 0;
	for (auto&& i : area_vector) {
		//temp_endpoint[array_id] = i.heightest_id;
		temp_endpoint[array_id] = 0;
		array_id++;
	}
	TOOL::writeSingleResult("APLAMaxId181221", temp_endpoint, area_vector.size());
	TOOL::deleteArray(temp_endpoint);
	/*..............................................................................*/

	/*====================Print vector result=======================*/
	//cout << "initial time: " << time9 << "< ***<<<< loop time: " << loop_time << " mergerd information time: " << time3 << " Merge segmnet time: " << time1 << " Change threshold id time: " << time2 << " merge operation: " << time4 << " while count: " << while_count << " for count: " << for_count << " == operation time: " << time5 << " erease time: " << time6 << " merged id time: " << time7 << " not merge time: " << time8 << endl;
	//cout << "============Test================" << endl;
	//cout << "Total merge count: " << total_merge_infor_count << endl;
	//cout << "deviation minmax, deviation, endpoint id: " << deviation_all_count << endl;
	//cout << "same deviation id: " << same_deviation_id_count << endl;
	//cout << "different deviation id: " << diff_deviation_id_count << endl;
	//cout << "deviation minmax id: " << deviaiton_min_max_count << endl;
	cout << "---------------------------------------------" << endl;
	cout << elapsed_seconds.count() << "s\n";
	cout << "Whole time: " << output_argument.run_time
		<< " ms\n 1 initial time: " << time1 << " ms"
		//<< "\n 2 loop time: " << loop_time
		//<< "\n 3 Threshhold time: " << time10
		//<< "\n 2.1 mergerd information time: " << time3
		//<< "\n 2.1.1 get width: " << time12
		//<< "\n 2.1.2 get a&b time: " << time13
		//<< "\n 2.1.3 mergerd information time: " << time14
		//<< "\n 2.2 Whole merge segmnet time: " << time9
		//<< "\n 2.2.0 Whole merge segmnet time: " << time11
		//<< "\n 2.2.1 merge operation time: " << time4
		//<< "\n 2.2.2 change queue time: " << time7
		//<< "\n 2.2.3 not merge time: " << time8
		//<< "\n 3.1 erease time: " << time6
		<< "\n 3.2 Change threshold time: " << time2 << " ms" << endl;
	cout << ".................................." << endl;

	//cout << "Finish! \n size: " << area_vector.size() << endl;

	/*cout << endl << "Min: ";
	for (auto&& i : area_vector) {
		cout << i.min_point.id << " ";
	}
	cout << endl << "Max: ";
	for (auto&& i : area_vector) {
		cout << i.max_point.id << " ";
	}
	cout << endl << "Area: ";
	for (auto&& i : area_vector) {
		cout << i.rectangle_area << " ";
	}
	cout << endl;*/
	cout << "APLA right endpoint: ";
	//cout <<output_argument.sum_deviation <<endl;
	for (auto&& i : area_vector) {
		cout << i.right_endpoint + 1 << ", ";
	}
	cout << endl;
	/*array_id = 0;
	cout << "parallelogram_height: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.parallelogram_height << ", ";
		array_id++;
	}
	cout << endl;*/
	/*array_id = 0;
	cout << "rectangle_width: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.rectangle_width << ", ";
		array_id++;
	}
	cout << endl;*/

	vector<double> segment_deviaiton_vector;
	getAPLASegmentDeviation(original_time_series, area_vector);
	array_id = 0;
	//cout << "APLA segment deviation: ";
	for (auto&& i : area_vector) {
		segment_deviaiton_vector.emplace_back(i.rec_deviation);
		//cout << array_id << ": " << i.rec_deviation << ", ";
		array_id++;
	}
	//cout << endl;
	TOOL::writeResultNoCover("AllAPLASegmentDeviation", segment_deviaiton_vector);
	segment_deviaiton_vector.clear();
	segment_deviaiton_vector.shrink_to_fit();
	/*............................................................*/
	/*=======================Print Test============================*/
	//cout << "Original time: " << endl;
	//for (int i = 0; i < input_argument.time_series_length; i++) {
	//	cout << original_time_series[i] << ", ";
	//}
	//cout << endl;

	//array_id = 0;
	//cout << "Break point count: " << endl;
	//for (auto&& au : count_break_point_vector) {
	//	cout << au << ", ";
	//	//cout << array_id << ": " << au << ", ";
	//	//array_id++;
	//}
	//cout << endl;
	/*............................................................*/
}

//190911
//************************************
// Method:getAPLAByMinMaxLinkedList
// Qualifier:Use Linked List ot instead Vector. For every segment, use minmax point as endpoint. Then for every segment use same subsegemnt number to merge.
// date:190911
// author:
//************************************
TEMPLATE
template<typename T>
void APLA::getAPLAByMinMaxLinkedList(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<T>& const all_linked_list, DoublyLinkedList<T>& const cluster_linked_list, typename TOOL::OUTPUT_ARGUMENT& output_argument) {// Use Linked List to instead vector, For every segment, use minmax point as endpoint. Then for every segment use same subsegemnt number to merge.
#ifdef _DEBUG
	assert(input_argument.time_series_length % 2 == 0 && y_projection_argument.initial_N != INF && input_argument.time_series_length != INF);//n is even
#endif
	/*=================Random get endpoint====================================*/
	//getBestEndpoint(input_argument, original_time_series);//190623
	vector<DataType> original_time_series_vector(original_time_series, original_time_series + input_argument.time_series_length);
	/*========================================================================*/

	/*======  time & count  ====*/
	double loop_time = 0;
	double time1 = 0;
	double time2 = 0;
	double time3 = 0;
	double time4 = 0;
	double time5 = 0;
	double time6 = 0;
	double time7 = 0;
	double time8 = 0;
	double time9 = 0;
	double time10 = 0;//update queue time
	double time11 = 0;
	double time12 = 0;
	double time13 = 0;
	double time14 = 0;
	int while_count = 0;
	int for_count = 0;
	/*=========================*/

	/*=======================Test parameter===========================*/
	vector<int> count_break_point_vector;//190613 11:16
	count_break_point_vector.resize(input_argument.time_series_length, 0);//190613 11:16
	int same_deviation_id_count = 0;//190515
	int diff_deviation_id_count = 0;//190515
	int total_merge_infor_count = 0;
	int deviaiton_min_max_count = 0;
	int deviation_all_count = 0;
	/*================================================================*/

	int segment_size_coefficient = input_argument.point_dimension < 3 ? 3 : input_argument.point_dimension;
	int array_id = 0;
	long double lower_bound_density = INF;
	//long double max_density = INF;
	//vector<AREA_COEFFICIENT> area_vector;
	T temp_coefficient;
	/*-----------------------         190820 Linked list & Pointer       -----------------------*/
	DoublyLinkedList<T> doubly_linked_list = DoublyLinkedList<T>();
	/*------------------------------------------------------------------------------------------*/
	priority_queue<double> up_lower_bound_density_queue;//190328
	priority_queue<double*> pointer_up_lower_bound_density_queue;
	std::set<double> density_max_set;//190328

	/*===================================  Test  =============================================*/
	//typename GEOMETRY::ValueIncrease density_increase;//190313
	DensityIncrease density_increase;//190313
	//priority_queue<typename GEOMETRY::POINT, std::vector<typename GEOMETRY::POINT>, typename GEOMETRY::ValueDecrease> min_segment_density_queue;//190607
	/*vector<AREA_COEFFICIENT> temp_coefficient_vector;
	temp_coefficient_vector.resize(input_argument.point_dimension * 4, AREA_COEFFICIENT());
	for (auto&& au : temp_coefficient_vector) {
		au.right_subsegment = new AREA_COEFFICIENT;
	}*/
	/*for (auto&&au : area_vector) {
		au.right_subsegment = new AREA_COEFFICIENT;
	}*/
	typename GEOMETRY::POINT pair_density;
	/*=======================================================================================*/

	output_argument.min_density_segment.value = INF;
	output_argument.min_density_segment.id = INF;

	auto start = std::chrono::system_clock::now();
	//merge
	TOOL::recordStartTime(TOOL::time_record[0]);//compare percentage time
	//initial
	//initialRecArea(input_argument, original_time_series, area_vector);//181211

	/*###############################################           Initial Part            ####################################################################################*/

	//*Input: original time series, N, n
	//*Output: width, right endpoint, a&b, min&max point, sum value, new *right_subsegment

	//initialRecArea0ForParallelogram(input_argument, original_time_series, area_vector);//190404
	//initialRecArea0ForParallelogramNoPush(input_argument, original_time_series, area_vector);//190417


#ifdef TIME_H
	TOOL::recordStartTime(TOOL::time_record[1]);//compare percentage time
#endif
	//initialRecArea0ForParallelogramArrayVector(input_argument, original_time_series, area_vector);//190430
	//initialRecAreaPLAImprove(input_argument, original_time_series, area_vector);//190606
	//initialAPLARightEndpoint(input_argument, original_time_series, area_vector);//190617 12:00

	//area_vector.resize(segment_size_coefficient, AREA_COEFFICIENT());
	//initialAPLARightEndpoint3Sub(input_argument, original_time_series, area_vector);//190617 16:48
	//initialAPLARightEndpoint3SubAdaptive(input_argument, original_time_series, area_vector); //190705 12:32
	//initialAPLARightEndpoint3SubAdaptiveMergeSplit(input_argument, original_time_series, area_vector);//190711 16:59
	//initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursive(input_argument, original_time_series, area_vector);//190719 16:35
	//initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursiveSpeed(input_argument, original_time_series, area_vector);//190812 10:40
	//initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursiveSpeed(input_argument, original_time_series, area_vector, doubly_linked_list);//190812 10:40
	//initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursiveSpeed(input_argument, original_time_series, doubly_linked_list);//190918 12:16
	//initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursiveSpeed1(input_argument, original_time_series, doubly_linked_list);//190918 12:16
	//initialAPLARightEndpoint3SubAdaptiveMergeSplitRecursiveSpeed2(input_argument, original_time_series, doubly_linked_list);//191002 13:20
	//initialAPLAYProjection(input_argument, original_time_series, y_projection_argument, all_linked_list, cluster_linked_list, doubly_linked_list);//191028 Check & initial Y-Projection method
	//all_linked_list.clear();
	//cluster_linked_list.clear();
	//y_projection_argument.whole_difference_map.clear();

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!           Initial Function        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	initialMSPLA(input_argument, original_time_series_vector, y_projection_argument, all_linked_list, cluster_linked_list, doubly_linked_list, output_argument);//191209
	//initialAPLARightEndpoint3SubNoMerge(input_argument, original_time_series, area_vector);//190628
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	//cout  <<  format(elapsed(), places(), format_string()) << endl;

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!           191208 New Y-Projection        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	/*typename TOOL::Y_PROJECTION_ARGUMENT testr_y_projection_argument;
	DoublyLinkedList<AREA_COEFFICIENT> test_all_segment_linked_list;
	DoublyLinkedList<AREA_COEFFICIENT> test_cluster_segment_linked_list;
	DoublyLinkedList<AREA_COEFFICIENT> test_doubly_linked_list;
	vector<DataType> test_original_time_series_vector(input_argument.time_series_length, INF);
	copy_n(original_time_series, input_argument.time_series_length, test_original_time_series_vector.begin());

	for (int array_id = 0; array_id < input_argument.time_series_length; array_id++) {
		assert(original_time_series[array_id] == test_original_time_series_vector[array_id]);
	}*/
	//APLA::initialMSPLA(input_argument, original_time_series, testr_y_projection_argument, test_all_segment_linked_list, test_cluster_segment_linked_list, test_doubly_linked_list);
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*##########################################################################################################################################################################*/

	/*.....................................................................*/
#ifdef TIME_H
	TOOL::recordStartTime(TOOL::time_record[3]); //compare percentage time
#endif
	/*.....................................................................*/

	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// Output: Min Max Point
	/*for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		getSegmentMinMaxPoint(original_time_series, doubly_linked_list[segment_id]);
	}*/
	//evaluate_linkedlist_for_loop(doubly_linked_list);
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	// input: width right endpoint
	// Output: a&b apla coefficient, sum value
	// getPLAByAdaptiveSegment(input_argument, original_time_series, doubly_linked_list);//190822 sum_value, a, b, apla_coefficient

	/*........................................................*/
#ifdef TIME_H
	time3 = TOOL::recordFinishTime(TOOL::time_record[3]);
#endif
	/*........................................................*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&       Evaluation:   Write & Print Result           &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*......................................................................................................................................................*/
#ifdef _DEBUG

	/*#########################             copy of linked list                ########################*/
	DoublyLinkedList<T> temp_doubly_linked_list = DoublyLinkedList<T>();
	temp_doubly_linked_list.copy(doubly_linked_list);
	/*#################################################################################################*/

	/*####################################             Reconstruct time series         ##########################################*/
	/*----------------------------------------Y-Projection--------------------------------------------------*/
	if (y_projection_argument.is_y_projection) {
		//temp_doubly_linked_list.clear();
		assert(temp_doubly_linked_list.empty());
		temp_doubly_linked_list.copy(all_linked_list);
		getPLAByAdaptiveSegment(input_argument, original_time_series_vector, temp_doubly_linked_list);//190822 sum_value, a, b, apla_coefficient
	}
	else {
		getPLAByAdaptiveSegment(input_argument, original_time_series_vector, temp_doubly_linked_list);//190822 sum_value, a, b, apla_coefficient
	}
	/*------------------------------------------------------------------------------------------------------*/

	/*--------------------------------Reconstruct time series: get & write----------------------------------*/
	vector<double> initial_reconstruct_time_series_vector;
	getAPLAReconstructSeries(temp_doubly_linked_list, initial_reconstruct_time_series_vector);
	//cout << "" << endl;
	TOOL::writeResultNoCover("./200706AllAPLAEvaluation/AllAPLAInitialEndpoint", initial_reconstruct_time_series_vector);
	initial_reconstruct_time_series_vector.clear();
	initial_reconstruct_time_series_vector.shrink_to_fit();
	/*-----------------------------------------------------------------------------------------------------*/
	/*###########################################################################################################################*/

	/*..........................get segment sum deviation....................*/
	//getAPLASegmentDeviation(original_time_series, area_vector);
	//getAPLASegmentDeviation(original_time_series_vector, temp_doubly_linked_list);
	/*.......................................................................*/

	/*---------------------Get PLA line rectagnle area & density----------------------*/
	//getPLALineRectangleAreaDensity(area_vector);
	//getPLALineRectangleAreaDensity(temp_doubly_linked_list);
	//getSegmentMinMaxRectangleAreaDensity(original_time_series, area_vector);//190701
	//getSegmentMinMaxRectangleAreaDensity(original_time_series, temp_doubly_linked_list);//
	/*-------------------------------------------------------------------------------*/
	int vector_id = 0;
	int initial_vector_size = input_argument.point_dimension;// = input_argument.point_dimension < 3 ? 3 : input_argument.point_dimension;//190812
	while (initial_vector_size % 3 != 0) {
		++initial_vector_size;
	}
	/*---------------------------------Write Initial Right Endpoint---------------------*/
	cout << "Initial APLA Right endpoint: ";
	vector<int> initial_right_endpoint_vector;
	//initial_right_endpoint_vector.resize(initial_vector_size, input_argument.time_series_length + 20);// (segment_size_coefficient);
	for (int segment_id = 0; segment_id < temp_doubly_linked_list.size(); segment_id++) {
		//cout << temp_doubly_linked_list[segment_id].right_endpoint + 1 << ", ";
		initial_right_endpoint_vector.emplace_back(temp_doubly_linked_list[segment_id].right_endpoint);
	}
	cout << endl;
	//doubly_linkedlist_iterator<AREA_COEFFICIENT> au(temp_doubly_linked_list.get_head_node());
	int segment_count = 0;
	//doubly_linkedlist_iterator<AREA_COEFFICIENT> au = temp_doubly_linked_list.begin();
	for (auto&& au = temp_doubly_linked_list.begin(); au != temp_doubly_linked_list.end(); ++au) {
		//cout << au.current_node_pointer->_value.right_endpoint<<endl;
		//cout << (*au).right_endpoint + 1 << " " << au->right_endpoint + 1 << ",  ";
		segment_count++;
	}
	cout << endl;
	for_each(temp_doubly_linked_list.begin(), temp_doubly_linked_list.end(), [](auto&& au) {
		//cout << au.right_endpoint + 1 << ",  ";
		});
	cout << endl;
	for_each_n(temp_doubly_linked_list.begin(), temp_doubly_linked_list.size(), [](auto&& au) {
		//cout << au.right_endpoint + 1 << ",  ";
		});
	cout << endl;
	for (auto&& au : temp_doubly_linked_list) {
		cout << au.right_endpoint + 1 << " ";
	}
	cout << endl;
	TOOL::writeResultNoCover("./200706AllAPLAEvaluation/AllAPLAInitialSegmentRightEndpoint", initial_right_endpoint_vector);
	initial_right_endpoint_vector.clear();
	initial_right_endpoint_vector.shrink_to_fit();
	/*--------------------------------------------------------------------------------------------*/
//#endif
	/*=====================================================================Evaluate Split method===================================================================*/
	/*-------------------------------------Write Split Point ID-----------------------------------------*/
	cout << "Initial APLA Split ID: ";
	assert(!temp_doubly_linked_list.empty());
	vector<int> split_id_vector;
	vector<int> split_id_intersection_vector;//200220 Intersection point as the split point
	vector<int> split_id_best_vector;//200205
	vector<int> split_id_min_density_fast_vector;//200211 split id from fast fiind min density 
	vector<int> split_id_middle_vector;//200221 split id from middle point of segment 
	vector<int> split_right_endpoint_vector = { 0 };

	for (int segment_id = 0; segment_id < temp_doubly_linked_list.size(); segment_id++) {
		auto& const current_segment = temp_doubly_linked_list[segment_id];
		const int begin_id = current_segment.right_endpoint - current_segment.rectangle_width + 1;
		const int end_id = current_segment.right_endpoint;

		double split_id = findSplitSegmentByEndpoint2length(original_time_series_vector, temp_doubly_linked_list[segment_id]);
		double split_id_intersection = find_split_point_by_direct_intersection_point(original_time_series_vector, temp_doubly_linked_list[segment_id]);// directly find intersection point as split point
		////200205 find best split point
		////int split_id = APLA::findSplitSegmentBaseline(original_time_series_vector, temp_doubly_linked_list[segment_id], 1);// min triangle density id
		int split_id_best = findSplitSegmentBaseline(original_time_series_vector, temp_doubly_linked_list[segment_id], 0);//best split id

		AREA_COEFFICIENT sub_left_segment, sub_right_segment;
		int split_id_min_density_fast = find_split_point_by_min_density_fast(original_time_series_vector, sub_left_segment, sub_right_segment, temp_doubly_linked_list[segment_id]);// fast wany to find min density split point 

		//double split_id = group_find_split_point_methods(original_time_series_vector, current_segment, 1);
		// directly find intersection point as split point
		//int split_id_intersection = group_find_split_point_methods(original_time_series_vector, current_segment, 2);
		//200205 find best split point
		//int split_id_best = group_find_split_point_methods(original_time_series_vector, current_segment, 4);
		// fast wany to find min density split point 
		//int split_id_min_density_fast = group_find_split_point_methods(original_time_series_vector, current_segment, 0);
		//assert(split_id == test_split_id && split_id_intersection == test_split_id_intersection && split_id_best == test_split_id_best && split_id_min_density_fast == test_split_id_min_density_fast);

		/*................................Insert Split point, If not split point...............................................*/
		if (split_id != INF) {
			split_id_vector.emplace_back(split_id);
			split_id_best_vector.emplace_back(split_id_best);
			split_id_min_density_fast_vector.emplace_back(split_id_min_density_fast);
			split_right_endpoint_vector.emplace_back(split_id);
		}
		else {
			split_id_vector.emplace_back(input_argument.time_series_length + 20);
			split_id_best_vector.emplace_back(input_argument.time_series_length + 20);
			split_id_min_density_fast_vector.emplace_back(input_argument.time_series_length + 20);
		}
		/*........Intersection point......*/
		if (split_id_intersection != INF && begin_id <= split_id_intersection && split_id_intersection <= end_id) {
			split_id_intersection_vector.emplace_back(split_id_intersection);
		}
		else {
			split_id_intersection_vector.emplace_back(input_argument.time_series_length + 20);
		}
		/*................................*/

		/*................................................................................................................*/
		split_right_endpoint_vector.emplace_back(temp_doubly_linked_list[segment_id].right_endpoint);
		//cout << split_id + 1 << ", ";
	}
	cout << endl;
	TOOL::writeResultNoCover("./200206DrawPlotChart/AllAPLAInitialSplitID", split_id_vector);// Binary search split point method
	TOOL::writeResultNoCover("./200206DrawPlotChart/AllAPLAInitialSplitIDIntersection", split_id_intersection_vector);//200220 Intersection Point search split point method
	TOOL::writeResultNoCover("./200206DrawPlotChart/AllAPLAInitialSplitIDBest", split_id_best_vector);
	TOOL::writeResultNoCover("./200206DrawPlotChart/AllAPLAInitialSplitIDFast", split_id_min_density_fast_vector);
	split_id_vector.clear();
	split_id_vector.shrink_to_fit();
	split_id_intersection_vector.clear();
	split_id_intersection_vector.shrink_to_fit();
	split_id_best_vector.clear();
	split_id_best_vector.shrink_to_fit();
	split_id_min_density_fast_vector.clear();
	split_id_min_density_fast_vector.shrink_to_fit();

	/*--------------------------------------Write Split point reconstruct time series-------------------------------------------------------*/
	vector<DataType> reconstruct_time_series_split_point;
	APLA::get_PLA_reconstruct_series_by_endpoint(original_time_series_vector, split_right_endpoint_vector, reconstruct_time_series_split_point);
	TOOL::writeResultNoCover("./200206DrawPlotChart/ReconstructTimeSeriesSplitPoint", reconstruct_time_series_split_point);
	reconstruct_time_series_split_point.clear();
	reconstruct_time_series_split_point.shrink_to_fit();
	/*--------------------------------------------------------------------------------------------------------------------------------------*/

	//if (y_projection_argument.is_y_projection) {
	temp_doubly_linked_list.clear();
	//}
	split_right_endpoint_vector.clear();
	split_right_endpoint_vector.shrink_to_fit();

	/*====================================================================================================================================================================*/
#endif
	/*......................................................................................................................................................*/
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*...................................................*/
#ifdef TIME_H
	time1 = TOOL::recordFinishTime(TOOL::time_record[1]);
#endif
	/*...................................................*/

	//lower_bound_density = output_argument.min_density_segment.value;
	//output_argument.min_density_segment.id;

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&                 Merge & Split              &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	//*Input a&b, width, right endpoint, sum value, min&max point

	/*................................................................*/
#ifdef TIME_H
	TOOL::recordStartTime(TOOL::time_record[2]);//compare percentage time
#endif
	/*...............................................................*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!        Merge&Split Operation      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	if (!y_projection_argument.is_y_projection) {
		//190827
		mergeSplitOperationLink(input_argument, original_time_series_vector, doubly_linked_list, output_argument);
		//mergeSplitOperationLink(input_argument, original_time_series, doubly_linked_list);
	}
	else {

		/*................................................................*/
#ifdef _DEBUG
		assert(doubly_linked_list.empty());//compare percentage time
#endif
		/*...............................................................*/

		y_projection_merge_split(input_argument, original_time_series_vector, all_linked_list, cluster_linked_list, doubly_linked_list);
		getPLAByAdaptiveSegment(input_argument, original_time_series_vector, doubly_linked_list);//190617 sum_value, a, b, apla_coefficient
	}
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*.....................................................................*/
#ifdef TIME_H
	time2 = TOOL::recordFinishTime(TOOL::time_record[2]);
#endif
	/*.....................................................................*/

	/*--------------------------------------------------------------------*/
	output_argument.run_time = TOOL::recordFinishTime(TOOL::time_record[0]);
	input_argument.whole_run_time = output_argument.run_time;
	auto end = std::chrono::system_clock::now();
	std::chrono::duration<double> elapsed_seconds = end - start;
	/*-------------------------------------------------------------------*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

		//cout << "APLA running Time: " << output_argument.run_time << endl;// compare percentage time
		//cout << "vector size: " << area_vector.size() << endl;

	/*================200313 assert min & max value of each segment===============================*/
	//200314 minmax point
	//assert_minmax_value(original_time_series_vector, doubly_linked_list);
	/*============================================================================================*/

	/*========================Write & Print reconstruct series====================================*/
	//getPLALineRectangleAreaDensity(area_vector);
	//200303
	//getSegmentMinMaxRectangleAreaDensity(original_time_series, doubly_linked_list);//190701

	/*----------------------------------------APLA reconstruct series---------------------------------------------------------------*/
	vector<double> reconstruct_time_series_vector;
	getAPLAReconstructSeries(doubly_linked_list, reconstruct_time_series_vector);
	assert(reconstruct_time_series_vector.size() == input_argument.time_series_length);
	TOOL::writeResultNoCover("./200706AllAPLAEvaluation/APLAReconstructSeries", reconstruct_time_series_vector);
	/*.------------------------------------------------------------------------------------------------------------------------------*/

	/*===========================================================get Sum Deviation, max devaition ================================================================================*/
	/*vector<DataType> original_time_series_vector;
	for (int array_id = 0; array_id < input_argument.time_series_length; array_id++) {
		original_time_series_vector.emplace_back(original_time_series[array_id]);
	}*/

	assert(original_time_series_vector.size() == input_argument.time_series_length && doubly_linked_list.size() == input_argument.point_dimension);

	/*---------------  get a&b of every segment & get sum deviation & get reconstruction time series  ------------------*/
	//getAPLA(input_argument, original_time_series, doubly_linked_list);
	output_argument.sum_deviation = get_sum_deviation_no_ab(original_time_series_vector, doubly_linked_list);
	/*------------------------------------------------------------------------------------------------------------------*/
	/*-----------------------------------   get test sum deviation     -------------------------------------------------*/
	//float test_deviation = PLA_QUAL::getPLASumDeviation(original_time_series_vector, doubly_linked_list);
	float test_deviation = TOOL::getDeviation(original_time_series_vector, reconstruct_time_series_vector);
	reconstruct_time_series_vector.clear();
	reconstruct_time_series_vector.shrink_to_fit();
	/*------------------------------------------------------------------------------------------------------------------*/
	//cout << test_deviation << endl;
	//assert(fabs(test_deviation - float(output_argument.sum_deviation)) <= MIN_D);
	/*====================================================================================================================================================================================================*/

	/*----------------------------------------APLA right endpoint----------------------------------------------------------------*/
	vector<int> right_endpoint_vector;
	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		right_endpoint_vector.emplace_back(doubly_linked_list[segment_id].right_endpoint);
	}
	TOOL::writeResultNoCover("./200706AllAPLAEvaluation/AllAPLARightEndpoint", right_endpoint_vector);
	right_endpoint_vector.clear();
	right_endpoint_vector.shrink_to_fit();
	/*----------------------------------------------------------------------------------------------------------------------------*/
	/*----------------------------------------APLA increament Area----------------------------------------------------------------*/
	cout << "APLA Segment increament area: ";
	vector<double> increament_area_vector;
	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		//increament_area_vector.emplace_back(doubly_linked_list[segment_id].increment_area);
		//cout << doubly_linked_list[segment_id].increment_area << ", ";
	}
	cout << endl;
	//TOOL::writeResultNoCover("AllAPLAIncreamentArea", increament_area_vector);
	increament_area_vector.clear();
	increament_area_vector.shrink_to_fit();
	/*------------------------------------------------------------------------------------------------------------------------------*/

	/*++++++++++++++++++++++++++                        APLA segment Density                       +++++++++++++++++++++++++++++++++*/
	cout << "APLA segment density: ";
	vector<double> segment_density_vector;
	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		if (doubly_linked_list[segment_id].right_subsegment == nullptr)
			segment_density_vector.emplace_back(0);
		else {
			segment_density_vector.emplace_back(doubly_linked_list[segment_id].right_subsegment->segment_density);
			//cout << doubly_linked_list[segment_id].right_subsegment->segment_density << ", ";
		}
	}
	cout << endl;
	//TOOL::writeResultNoCover("AllAPLASegmentDensity", segment_density_vector);
	segment_density_vector.clear();
	segment_density_vector.shrink_to_fit();
	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*+++++++++++++++++++++++++                           APLA sum deviation                        +++++++++++++++++++++++++++++++++*/
	vector<double> sum_deviation_vector;
	sum_deviation_vector.emplace_back(output_argument.sum_deviation);
	TOOL::writeResultNoCover("./200706AllAPLAEvaluation/AllAPLASumDeviation", sum_deviation_vector);
	sum_deviation_vector.clear();
	sum_deviation_vector.shrink_to_fit();
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*++++++++++++++++++++++++                               Write Result                             ++++++++++++++++++++++++++++++++*/
	double* temp_endpoint = new double[doubly_linked_list.size()];
	array_id = 0;
	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		temp_endpoint[array_id] = doubly_linked_list[segment_id].right_endpoint;
		array_id++;
	}
	TOOL::writeSingleResult("./200706AllAPLAEvaluation/APLAEndPoint181218", temp_endpoint, doubly_linked_list.size());
	TOOL::deleteArray(temp_endpoint);
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&           Print vector result         &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	//cout << "initial time: " << time9 << "< ***<<<< loop time: " << loop_time << " mergerd information time: " << time3 << " Merge segmnet time: " << time1 << " Change threshold id time: " << time2 << " merge operation: " << time4 << " while count: " << while_count << " for count: " << for_count << " == operation time: " << time5 << " erease time: " << time6 << " merged id time: " << time7 << " not merge time: " << time8 << endl;
	//cout << "============Test================" << endl;
	//cout << "Total merge count: " << total_merge_infor_count << endl;
	//cout << "deviation minmax, deviation, endpoint id: " << deviation_all_count << endl;
	//cout << "same deviation id: " << same_deviation_id_count << endl;
	//cout << "different deviation id: " << diff_deviation_id_count << endl;
	//cout << "deviation minmax id: " << deviaiton_min_max_count << endl;

	cout << "======================== Running time =====================================" << endl;
	cout << elapsed_seconds.count() << "s\n";
	cout << "Whole time: " << output_argument.run_time
		<< " ms\n 1 initial time: " << time1 << " ms"
		//<< "\n 2 loop time: " << loop_time
		//<< "\n 3 Threshhold time: " << time10
		//<< "\n 2.1 mergerd information time: " << time3
		//<< "\n 2.1.1 get width: " << time12
		//<< "\n 2.1.2 get a&b time: " << time13
		//<< "\n 2.1.3 mergerd information time: " << time14
		//<< "\n 2.2 Whole merge segmnet time: " << time9
		//<< "\n 2.2.0 Whole merge segmnet time: " << time11
		//<< "\n 2.2.1 merge operation time: " << time4
		//<< "\n 2.2.2 change queue time: " << time7
		//<< "\n 2.2.3 not merge time: " << time8
		//<< "\n 3.1 erease time: " << time6
		<< "\n 3.1 ini              time: " << time3 << " ms"
		<< "\n 3.2 Change threshold time: " << time2 << " ms" << endl;
	cout << "===========================================================================" << endl;

	//cout << "Finish! \n size: " << area_vector.size() << endl;

	/*###################################           Print linked list          ###########################*/
	cout << "APLA segment coefficients: \n";
	TOOL::print_each_segment_coefficient(doubly_linked_list);
	/*####################################################################################################*/

	/*############################           Y-projection all cluster          ###########################*/
	if (!all_linked_list.empty()) {

		//cout << "All right endpoint: " << endl;
		for (int segment_id = 0; segment_id < all_linked_list.size(); segment_id++) {
			//cout << all_linked_list[segment_id].right_endpoint + 1 << ",";
		}
		cout << endl;

	}

	if (!cluster_linked_list.empty()) {

		//cout << "Cluster right endpoint: " << endl;
		for (int segment_id = 0; segment_id < cluster_linked_list.size(); segment_id++) {
			//cout << cluster_linked_list[segment_id].right_endpoint + 1 << ",";
		}
		cout << endl;

		//cout << "Merged vector Rright endpoint: " << endl;
		for (int segment_id = 0; segment_id < cluster_linked_list.size(); segment_id++) {
			//cout << ";{" << cluster_linked_list[segment_id].right_endpoint + 1 << "}; ";
			//if (!cluster_linked_list[segment_id].y_projection_coefficient.sub_segment_vector.empty()) {
				//cout << "(";
				//for_each(cluster_linked_list[segment_id].y_projection_coefficient.sub_segment_vector.begin(), cluster_linked_list[segment_id].y_projection_coefficient.sub_segment_vector.end(), [](const AREA_COEFFICIENT& const segment) {cout << segment.right_endpoint + 1 << ","; });
				//cout << ")";
			//}
		}
		cout << endl;
	}
	/*####################################################################################################*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/********************************200303 segment sum deviation*************************************/
	//vector<double> segment_deviaiton_vector;
	//getAPLASegmentDeviation(original_time_series, doubly_linked_list);
	//cout << "APLA segment deviation: ";
	//for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
	//	segment_deviaiton_vector.emplace_back(doubly_linked_list[segment_id].rec_deviation);
	//	//cout << segment_id << ": " << doubly_linked_list[segment_id].rec_deviation << ", ";
	//}
	//cout << endl;
	//TOOL::writeResultNoCover("AllAPLASegmentDeviation", segment_deviaiton_vector);
	//segment_deviaiton_vector.clear();
	//segment_deviaiton_vector.shrink_to_fit();
	/*************************************************************************************************/

	/*+++++++++++++++++++      clear memory     +++++++++++++++++++++++++++++++++*/
	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		delete doubly_linked_list[segment_id].right_subsegment;
	}
	doubly_linked_list.clear();
	original_time_series_vector.clear();
	original_time_series_vector.shrink_to_fit();
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*+++++++++++++++       Print Test      ++++++++++++++++++++++++*/
	//cout << "Original time: " << endl;
	//for (int i = 0; i < input_argument.time_series_length; i++) {
	//	cout << original_time_series[i] << ", ";
	//}
	//cout << endl;

	//array_id = 0;
	//cout << "Break point count: " << endl;
	//for (auto&& au : count_break_point_vector) {
	//	cout << au << ", ";
	//	//cout << array_id << ": " << au << ", ";
	//	//array_id++;
	//}
	//cout << endl;
	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
}

//191108 no other evaluation method. directly get APLA approximation
//190911
//************************************
// Method:get_APLA_point
// Qualifier: Use APLA & Y_projection method to get right endpoint & a b directly.
// Notes: inital_N & Y_projction coefficient cannot be dismissed.
// Input: time series, inital_N,
// Output: right endpoint & a b
// date:190911
// author:
//************************************
TEMPLATE
template<typename T>
void APLA::get_APLA_point(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<T>& const all_linked_list, DoublyLinkedList<T>& const cluster_linked_list, DoublyLinkedList<T>& const doubly_linked_list) {
#ifdef _DEBUG
	assert(input_argument.time_series_length % 2 == 0 && y_projection_argument.initial_N != INF && input_argument.point_dimension != INF);//n is even
#endif
	//initialAPLAYProjection(input_argument, original_time_series, y_projection_argument, all_linked_list, cluster_linked_list, doubly_linked_list);//191028 Check & initial Y-Projection method
	//TOOL::recordStartTime(TOOL::time_record[3]);
	initial_apla_yprojection_knn(input_argument, original_time_series, y_projection_argument, all_linked_list, cluster_linked_list, doubly_linked_list);//191115
	//double initial_time = TOOL::recordFinishTime(TOOL::time_record[3]);


	/*===================================================           191208 New Y-Projection        =====================================*/

	/*--------------------Test Y projection ----------------------*/
	typename TOOL::Y_PROJECTION_ARGUMENT testr_y_projection_argument;
	DoublyLinkedList<T> test_all_segment_linked_list;
	DoublyLinkedList<T> test_cluster_segment_linked_list;
	DoublyLinkedList<T> test_doubly_linked_list;
	/*------------------------------------------------------------*/

	vector<DataType> original_time_series_vector(input_argument.time_series_length, INF);
	copy_n(original_time_series, input_argument.time_series_length, original_time_series_vector.begin());

	for (int array_id = 0; array_id < input_argument.time_series_length; array_id++) {
		assert(original_time_series[array_id] == original_time_series_vector[array_id]);
	}

	/*-----------------------------------------------------initial MSPLA----------------------------------------------------------------------------------*/
	//initialMSPLA(input_argument, original_time_series, testr_y_projection_argument, test_all_segment_linked_list, test_cluster_segment_linked_list, test_doubly_linked_list);
	/*----------------------------------------------------------------------------------------------------------------------------------------------------*/

	/*====================================================================================================================================*/


	//TOOL::recordStartTime(TOOL::time_record[4]);
	/*---------------------------------------for line segment, only has one value---------------*/
	if (y_projection_argument.whole_difference_map.size() == 1 || doubly_linked_list.size() == 1) {
		y_projection_merge_line(input_argument, original_time_series, doubly_linked_list);
		return;
	}
	/*------------------------------------------------------------------------------------------*/

	/*-----------------------------------------------------initial MSPLA----------------------------------------------------------------------------------*/
	/*if (testr_y_projection_argument.is_y_projection){
		test_doubly_linked_list.clear();
		y_projection_merge_split(input_argument, original_time_series, test_all_segment_linked_list, test_cluster_segment_linked_list, test_doubly_linked_list);
	}*/
	/*----------------------------------------------------------------------------------------------------------------------------------------------------*/

	if (!y_projection_argument.is_y_projection) {

		//for_each_n(area_vector.begin(), area_vector.size(), [](auto&& au) {assert(au.min_point.id != INF && au.min_point.id != INF && au.min_point.value != INF && au.max_point.value != INF);});
		//mergeOperationBatch2SetSpeedPointer(input_argument, original_time_series, area_vector, temp_coefficient_vector, temp_coefficient);//190723 16:07 id+=1
		//190826
		//mergeOperationBatch2SetSpeedPointer(input_argument, original_time_series, temp_coefficient_vector, segment_linked_list);//190826
		//190827
		mergeSplitOperationLink(input_argument, original_time_series, doubly_linked_list);
	}
	else {
#ifdef _DEBUG
		//cout << "y projection: " << y_projection_argument.is_y_projection << endl;
#endif
		//if(doubly_linked_list.empty())
		//doubly_linked_list.copy(all_linked_list);
		//YProjectionAPLALink(input_argument,  original_time_series, y_projection_argument, doubly_linked_list);
		//doubly_linked_list.clear();
		//y_projection_argument.whole_difference_map.clear();
		YProjectionMerge(input_argument, original_time_series, all_linked_list, cluster_linked_list, doubly_linked_list);

		getPLAByAdaptiveSegment(input_argument, original_time_series, doubly_linked_list);//190617 sum_value, a, b, apla_coefficient
		//getPLAByAdaptiveSegmentAndMinMax(input_argument, original_time_series, doubly_linked_list);//sum_value, a, b, apla_coefficient, min & max points

		//y_projection_argument.is_y_projection = false;
	}
	//double ms_time = TOOL::recordFinishTime(TOOL::time_record[4]);

	/*cout << "Yprojection time: \n";
	cout << initial_time << " us\n";
	cout << ms_time << " us\n";*/
#ifdef _DEBUG
	assert(doubly_linked_list.size() == input_argument.point_dimension);
#endif
}

//191209 Merge y projeciton & MSPLA
//************************************
// Method:get_APLA_point_new_y_projection
// Qualifier: 
// Notes: 
// Input: 
// Output: 
// date:191209
// author:
//************************************
//TEMPLATE
//template<typename T>
//void APLA::get_APLA_point_new_y_projection(int nothing, typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series, TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<T>& const all_linked_list, DoublyLinkedList<T>& const cluster_linked_list, DoublyLinkedList<T>& const doubly_linked_list) {
//#ifdef _DEBUG
//	assert(input_argument.time_series_length % 2 == 0 && y_projection_argument.initial_N != INF && input_argument.point_dimension != INF);//n is even
//#endif
//	//initialAPLAYProjection(input_argument, original_time_series, y_projection_argument, all_linked_list, cluster_linked_list, doubly_linked_list);//191028 Check & initial Y-Projection method
//	//TOOL::recordStartTime(TOOL::time_record[3]);
//	//initial_apla_yprojection_knn(input_argument, original_time_series, y_projection_argument, all_linked_list, cluster_linked_list, doubly_linked_list);//191115
//	//all_linked_list.clear();
//	//cluster_linked_list.clear();
//	//y_projection_argument.whole_difference_map.clear();
//
//	initialMSPLA(input_argument, original_time_series, y_projection_argument, all_linked_list, cluster_linked_list, doubly_linked_list);
//	//double initial_time = TOOL::recordFinishTime(TOOL::time_record[3]);
//
//
//	/*===================================================           191208 New Y-Projection        =====================================*/
//	/*--------------------Test Y projection ----------------------*/
//	//typename TOOL::Y_PROJECTION_ARGUMENT testr_y_projection_argument;
//	//DoublyLinkedList<T> test_all_segment_linked_list;
//	//DoublyLinkedList<T> test_cluster_segment_linked_list;
//	//DoublyLinkedList<T> test_doubly_linked_list;
//	/*------------------------------------------------------------*/
//
//	//vector<DataType> original_time_series_vector(input_argument.time_series_length, INF);
//	//copy_n(original_time_series, input_argument.time_series_length, original_time_series_vector.begin());
//
//	//for (int array_id = 0; array_id < input_argument.time_series_length; array_id++) {
//		//assert(original_time_series[array_id] == original_time_series_vector[array_id]);
//	//}
//
//	/*-----------------------------------------------------initial MSPLA----------------------------------------------------------------------------------*/
//	//initialMSPLA(input_argument, original_time_series, testr_y_projection_argument, test_all_segment_linked_list, test_cluster_segment_linked_list, test_doubly_linked_list);
//	/*----------------------------------------------------------------------------------------------------------------------------------------------------*/
//	/*=====================================================================================================================================*/
//
//
//	//TOOL::recordStartTime(TOOL::time_record[4]);
//	/*---------------------------------------for line segment, only has one value---------------*/
//	if (y_projection_argument.whole_difference_map.size() == 1 || doubly_linked_list.size() == 1) {
//		y_projection_merge_line(input_argument, original_time_series, doubly_linked_list);
//		getPLAByAdaptiveSegmentAndMinMax(input_argument, original_time_series, doubly_linked_list);//sum_value, a, b, apla_coefficient, min & max points
//		return;
//	}
//	/*------------------------------------------------------------------------------------------*/
//
//	/*-----------------------------------------------------initial MSPLA----------------------------------------------------------------------------------*/
//	/*if (testr_y_projection_argument.is_y_projection) {
//		test_doubly_linked_list.clear();
//		y_projection_merge_split(input_argument, original_time_series, test_all_segment_linked_list, test_cluster_segment_linked_list, test_doubly_linked_list);
//	}*/
//	/*----------------------------------------------------------------------------------------------------------------------------------------------------*/
//	if (!y_projection_argument.is_y_projection) {
//		//for_each_n(area_vector.begin(), area_vector.size(), [](auto&& au) {assert(au.min_point.id != INF && au.min_point.id != INF && au.min_point.value != INF && au.max_point.value != INF);});
//		//mergeOperationBatch2SetSpeedPointer(input_argument, original_time_series, area_vector, temp_coefficient_vector, temp_coefficient);//190723 16:07 id+=1
//		//190826
//		//mergeOperationBatch2SetSpeedPointer(input_argument, original_time_series, temp_coefficient_vector, segment_linked_list);//190826
//		//190827
//		mergeSplitOperationLink(input_argument, original_time_series, doubly_linked_list);
//	}
//	else {
//#ifdef _DEBUG
//		//cout << "y projection: " << y_projection_argument.is_y_projection << endl;
//#endif
//		//if(doubly_linked_list.empty())
//		//doubly_linked_list.copy(all_linked_list);
//		//YProjectionAPLALink(input_argument,  original_time_series, y_projection_argument, doubly_linked_list);
//		//doubly_linked_list.clear();
//		//y_projection_argument.whole_difference_map.clear();
//		//doubly_linked_list.clear();//aleady done in initial method
//		y_projection_merge_split(input_argument, original_time_series, all_linked_list, cluster_linked_list, doubly_linked_list);
//		//YProjectionMerge(input_argument, original_time_series, all_linked_list, cluster_linked_list, doubly_linked_list);
//		/*...........................................get a&b sum deviation......................................................*/
//		//getPLAByAdaptiveSegment(input_argument, original_time_series, doubly_linked_list);//190617 sum_value, a, b, apla_coefficient
//		/*......................................................................................................................*/
//		getPLAByAdaptiveSegmentAndMinMax(input_argument, original_time_series, doubly_linked_list);//sum_value, a, b, apla_coefficient, min & max points
//
//		//y_projection_argument.is_y_projection = false;
//	}
//	//double ms_time = TOOL::recordFinishTime(TOOL::time_record[4]);
//
//	/*cout << "Yprojection time: \n";
//	cout << initial_time << " us\n";
//	cout << ms_time << " us\n";*/
//
//
//#ifdef _DEBUG
//
//	for (auto&& au : doubly_linked_list) {
//		assert(au.sum_value != INF);
//	}
//	assert(doubly_linked_list.size() == input_argument.point_dimension);
//	assert_a_b(doubly_linked_list);
//#endif
//}
//
//// 191209 Merge y projeciton & MSPLA
////200213 Use vector to instead pointer for time series. Add template
////************************************
//// Method:get_APLA_point_new_y_projection
//// Qualifier: 
//// Notes: 
//// Input: 
//// Output: 
//// date:191209
//// author:
////************************************
//TEMPLATE
//template<typename T, typename Y, typename U>
//void APLA::get_APLA_point_new_y_projection(int nothing, U& input_argument, const vector<T>& const original_time_series_vector, TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<Y>& const all_linked_list, DoublyLinkedList<Y>& const cluster_linked_list, DoublyLinkedList<Y>& const doubly_linked_list) {
//#ifdef _DEBUG
//	assert(input_argument.time_series_length % 2 == 0 && y_projection_argument.initial_N != INF && input_argument.point_dimension != INF && input_argument.time_series_length == original_time_series_vector.size());//n is even
//#endif
//	//initialAPLAYProjection(input_argument, original_time_series, y_projection_argument, all_linked_list, cluster_linked_list, doubly_linked_list);//191028 Check & initial Y-Projection method
//	//TOOL::recordStartTime(TOOL::time_record[3]);
//	//initial_apla_yprojection_knn(input_argument, original_time_series, y_projection_argument, all_linked_list, cluster_linked_list, doubly_linked_list);//191115
//	//all_linked_list.clear();
//	//cluster_linked_list.clear();
//	//y_projection_argument.whole_difference_map.clear();
//
//	initialMSPLA(input_argument, original_time_series_vector, y_projection_argument, all_linked_list, cluster_linked_list, doubly_linked_list);
//	//double initial_time = TOOL::recordFinishTime(TOOL::time_record[3]);
//
//
//	/*===================================================           191208 New Y-Projection        =====================================*/
//	/*--------------------Test Y projection ----------------------*/
//	//typename TOOL::Y_PROJECTION_ARGUMENT testr_y_projection_argument;
//	//DoublyLinkedList<T> test_all_segment_linked_list;
//	//DoublyLinkedList<T> test_cluster_segment_linked_list;
//	//DoublyLinkedList<T> test_doubly_linked_list;
//	/*------------------------------------------------------------*/
//
//	//vector<DataType> original_time_series_vector(input_argument.time_series_length, INF);
//	//copy_n(original_time_series, input_argument.time_series_length, original_time_series_vector.begin());
//
//	//for (int array_id = 0; array_id < input_argument.time_series_length; array_id++) {
//		//assert(original_time_series[array_id] == original_time_series_vector[array_id]);
//	//}
//
//	/*-----------------------------------------------------initial MSPLA----------------------------------------------------------------------------------*/
//	//initialMSPLA(input_argument, original_time_series, testr_y_projection_argument, test_all_segment_linked_list, test_cluster_segment_linked_list, test_doubly_linked_list);
//	/*----------------------------------------------------------------------------------------------------------------------------------------------------*/
//	/*=====================================================================================================================================*/
//
//
//	//TOOL::recordStartTime(TOOL::time_record[4]);
//	/*---------------------------------------for line segment, only has one value---------------*/
//	if (y_projection_argument.whole_difference_map.size() == 1 || doubly_linked_list.size() == 1) {
//		y_projection_merge_line(input_argument, original_time_series_vector, doubly_linked_list);
//		getPLAByAdaptiveSegmentAndMinMax(input_argument, original_time_series_vector, doubly_linked_list);//sum_value, a, b, apla_coefficient, min & max points
//		return;
//	}
//	/*------------------------------------------------------------------------------------------*/
//
//	/*-----------------------------------------------------initial MSPLA----------------------------------------------------------------------------------*/
//	/*if (testr_y_projection_argument.is_y_projection) {
//		test_doubly_linked_list.clear();
//		y_projection_merge_split(input_argument, original_time_series, test_all_segment_linked_list, test_cluster_segment_linked_list, test_doubly_linked_list);
//	}*/
//	/*----------------------------------------------------------------------------------------------------------------------------------------------------*/
//	if (!y_projection_argument.is_y_projection) {
//		//for_each_n(area_vector.begin(), area_vector.size(), [](auto&& au) {assert(au.min_point.id != INF && au.min_point.id != INF && au.min_point.value != INF && au.max_point.value != INF);});
//		//mergeOperationBatch2SetSpeedPointer(input_argument, original_time_series, area_vector, temp_coefficient_vector, temp_coefficient);//190723 16:07 id+=1
//		//190826
//		//mergeOperationBatch2SetSpeedPointer(input_argument, original_time_series, temp_coefficient_vector, segment_linked_list);//190826
//		//190827
//		mergeSplitOperationLink(input_argument, original_time_series_vector, doubly_linked_list);
//	}
//	else {
//#ifdef _DEBUG
//		//cout << "y projection: " << y_projection_argument.is_y_projection << endl;
//#endif
//		//if(doubly_linked_list.empty())
//		//doubly_linked_list.copy(all_linked_list);
//		//YProjectionAPLALink(input_argument,  original_time_series, y_projection_argument, doubly_linked_list);
//		//doubly_linked_list.clear();
//		//y_projection_argument.whole_difference_map.clear();
//		//doubly_linked_list.clear();//aleady done in initial method
//		y_projection_merge_split(input_argument, original_time_series_vector, all_linked_list, cluster_linked_list, doubly_linked_list);
//		//YProjectionMerge(input_argument, original_time_series, all_linked_list, cluster_linked_list, doubly_linked_list);
//		/*...........................................get a&b sum deviation......................................................*/
//		//getPLAByAdaptiveSegment(input_argument, original_time_series, doubly_linked_list);//190617 sum_value, a, b, apla_coefficient
//		/*......................................................................................................................*/
//		getPLAByAdaptiveSegmentAndMinMax(input_argument, original_time_series_vector, doubly_linked_list);//sum_value, a, b, apla_coefficient, min & max points
//
//		//y_projection_argument.is_y_projection = false;
//	}
//	//double ms_time = TOOL::recordFinishTime(TOOL::time_record[4]);
//
//	/*cout << "Yprojection time: \n";
//	cout << initial_time << " us\n";
//	cout << ms_time << " us\n";*/
//
//
//#ifdef _DEBUG
//
//	for (auto&& au : doubly_linked_list) {
//		assert(au.sum_value != INF);
//	}
//	assert(doubly_linked_list.size() == input_argument.point_dimension);
//	assert_a_b(doubly_linked_list);
//#endif
//}


// 191209 Merge y projeciton & MSPLA
//200213 Use vector to instead pointer for time series. Add template
//************************************
// Method:get_APLA_point_new_y_projection
// Qualifier: 
// Notes: 
// Input: 
// Output: 
// date:191209
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U, typename U1, typename U2>
void APLA::get_APLA_point_new_y_projection(U& input_argument, const vector<T>& const original_time_series_vector, typename TOOL::Y_PROJECTION_ARGUMENT& const y_projection_argument, DoublyLinkedList<Y>& const all_linked_list, DoublyLinkedList<Y>& const cluster_linked_list, DoublyLinkedList<U2>& const doubly_linked_list, U1& output_argument) {
#ifdef _DEBUG
	assert(input_argument.time_series_length % 2 == 0 && y_projection_argument.initial_N != INF && input_argument.point_dimension != INF && input_argument.time_series_length == original_time_series_vector.size());//n is even
#endif
	//initialAPLAYProjection(input_argument, original_time_series, y_projection_argument, all_linked_list, cluster_linked_list, doubly_linked_list);//191028 Check & initial Y-Projection method
	//TOOL::recordStartTime(TOOL::time_record[3]);
	//initial_apla_yprojection_knn(input_argument, original_time_series, y_projection_argument, all_linked_list, cluster_linked_list, doubly_linked_list);//191115
	//all_linked_list.clear();
	//cluster_linked_list.clear();
	//y_projection_argument.whole_difference_map.clear();

	initialMSPLA(input_argument, original_time_series_vector, y_projection_argument, all_linked_list, cluster_linked_list, doubly_linked_list, output_argument);
	//double initial_time = TOOL::recordFinishTime(TOOL::time_record[3]);

	/*===================================================           191208 New Y-Projection        =======================================*/
	/*--------------------Test Y projection ----------------------*/
	//typename TOOL::Y_PROJECTION_ARGUMENT testr_y_projection_argument;
	//DoublyLinkedList<T> test_all_segment_linked_list;
	//DoublyLinkedList<T> test_cluster_segment_linked_list;
	//DoublyLinkedList<T> test_doubly_linked_list;
	/*------------------------------------------------------------*/

	//vector<DataType> original_time_series_vector(input_argument.time_series_length, INF);
	//copy_n(original_time_series, input_argument.time_series_length, original_time_series_vector.begin());

	//for (int array_id = 0; array_id < input_argument.time_series_length; array_id++) {
		//assert(original_time_series[array_id] == original_time_series_vector[array_id]);
	//}

	/*-----------------------------------------------------initial MSPLA----------------------------------------------------------------------------------*/
	//initialMSPLA(input_argument, original_time_series, testr_y_projection_argument, test_all_segment_linked_list, test_cluster_segment_linked_list, test_doubly_linked_list);
	/*----------------------------------------------------------------------------------------------------------------------------------------------------*/
	/*=====================================================================================================================================*/


	//TOOL::recordStartTime(TOOL::time_record[4]);
	/*---------------------------------------for line segment, only has one value---------------*/
	if (y_projection_argument.whole_difference_map.size() == 1 || doubly_linked_list.size() == 1) {
		y_projection_merge_line(input_argument, original_time_series_vector, doubly_linked_list);
		getPLAByAdaptiveSegmentAndMinMax(input_argument, original_time_series_vector, doubly_linked_list);//sum_value, a, b, apla_coefficient, min & max points
		return;
	}
	/*------------------------------------------------------------------------------------------*/

	/*-----------------------------------------------------initial MSPLA----------------------------------------------------------------------------------*/
	/*if (testr_y_projection_argument.is_y_projection) {
		test_doubly_linked_list.clear();
		y_projection_merge_split(input_argument, original_time_series, test_all_segment_linked_list, test_cluster_segment_linked_list, test_doubly_linked_list);
	}*/
	/*----------------------------------------------------------------------------------------------------------------------------------------------------*/
	if (!y_projection_argument.is_y_projection) {
		//for_each_n(area_vector.begin(), area_vector.size(), [](auto&& au) {assert(au.min_point.id != INF && au.min_point.id != INF && au.min_point.value != INF && au.max_point.value != INF);});
		//mergeOperationBatch2SetSpeedPointer(input_argument, original_time_series, area_vector, temp_coefficient_vector, temp_coefficient);//190723 16:07 id+=1
		//190826
		//mergeOperationBatch2SetSpeedPointer(input_argument, original_time_series, temp_coefficient_vector, segment_linked_list);//190826
		//190827
		mergeSplitOperationLink(input_argument, original_time_series_vector, doubly_linked_list, output_argument);
	}
	else {
#ifdef _DEBUG
		//cout << "y projection: " << y_projection_argument.is_y_projection << endl;
#endif
		//if(doubly_linked_list.empty())
		//doubly_linked_list.copy(all_linked_list);
		//YProjectionAPLALink(input_argument,  original_time_series, y_projection_argument, doubly_linked_list);
		//doubly_linked_list.clear();
		//y_projection_argument.whole_difference_map.clear();
		//doubly_linked_list.clear();//aleady done in initial method
		y_projection_merge_split(input_argument, original_time_series_vector, all_linked_list, cluster_linked_list, doubly_linked_list);
		//YProjectionMerge(input_argument, original_time_series, all_linked_list, cluster_linked_list, doubly_linked_list);
		/*...........................................get a&b sum deviation......................................................*/
		//getPLAByAdaptiveSegment(input_argument, original_time_series, doubly_linked_list);//190617 sum_value, a, b, apla_coefficient
		/*......................................................................................................................*/
		getPLAByAdaptiveSegmentAndMinMax(input_argument, original_time_series_vector, doubly_linked_list);//sum_value, a, b, apla_coefficient, min & max points
		//y_projection_argument.is_y_projection = false;
	}
	//double ms_time = TOOL::recordFinishTime(TOOL::time_record[4]);

	/*cout << "Yprojection time: \n";
	cout << initial_time << " us\n";
	cout << ms_time << " us\n";*/


#ifdef _DEBUG
	//200316 sum value
	/*for (auto&& au : doubly_linked_list) {
		assert(au.sum_value != INF);
	}*/
	assert(doubly_linked_list.size() == input_argument.point_dimension);
	assert_a_b(original_time_series_vector, doubly_linked_list);
#endif
}

//************************************
// Method:get_apla_projection
// Qualifier: 
// Notes: 
// Input: query time series, candidate APLA 
// Output: query projection APLA of candiate APLA
// date:191112
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
vector<Y>& APLA::get_apla_projection(const vector<DataType>& const query_time_series_vector, const DoublyLinkedList<T>& const doubly_linked_list, vector<Y>& const area_vector) {
	area_vector.resize(doubly_linked_list.size());
#ifdef _DEBUG
	assert(!query_time_series_vector.empty() && doubly_linked_list.size() == area_vector.size());
#endif
	auto&& const au_list = doubly_linked_list.begin();
	for (auto&& const au_vector = area_vector.begin(); au_vector != area_vector.end(); au_vector++, au_list++) {
		//200316 sum value
		//assert(au_list->sum_value != INF);
		au_vector->right_endpoint = au_list->right_endpoint;
		au_vector->rectangle_width = au_list->rectangle_width;
		getAAndBByPLA(query_time_series_vector, *au_vector);
	}
	return area_vector;
}


//211228 project APCA
TEMPLATE
template<typename T, typename Y>
vector<Y>& APLA::get_apla_average_projection(const vector<DataType>& const query_time_series_vector, const DoublyLinkedList<T>& const doubly_linked_list, vector<Y>& const area_vector) {
	area_vector.resize(doubly_linked_list.size());
#ifdef _DEBUG
	assert(!query_time_series_vector.empty() && doubly_linked_list.size() == area_vector.size());
#endif
	auto&& const au_list = doubly_linked_list.begin();
	for (auto&& const au_vector = area_vector.begin(); au_vector != area_vector.end(); au_vector++, au_list++) {
		//200316 sum value
		//assert(au_list->sum_value != INF);
		au_vector->right_endpoint = au_list->right_endpoint;
		au_vector->rectangle_width = au_list->rectangle_width;
		get_average_segment(query_time_series_vector, *au_vector);
	}
	return area_vector;
}

//************************************
// Method:get_segment_distance_LB
// Qualifier: get difference pow for one segment
// Notes: 
// Input: query time series, candidate APLA 
// Output: query projection APLA of candiate APLA
// date:191112
// author:
//************************************
//191114 compue distance LB for two segments.
TEMPLATE
template<typename T, typename Y>
inline long double APLA::get_segment_distance_LB(const T& const segment_1, const Y& const segment_2) {

	/*................................................................................................................................................*/
#ifdef _DEBUG
	assert(segment_1.right_endpoint == segment_2.right_endpoint && segment_1.rectangle_width == segment_2.rectangle_width && segment_1.apla.a != INF && segment_1.apla.b != INF && segment_2.apla.a != INF && segment_2.apla.b != INF);
#endif
	/*...................................................................................................................................................*/

	const long double formula_coefficient_1 = segment_1.rectangle_width * (segment_1.rectangle_width - 1);// l(l-1)
	//const long double formula_coefficient_2 = formula_coefficient_1 * (2 * segment_1.rectangle_width - 1) / 6; // l(l-1)(2l-1)/6
	const long double difference_a = segment_1.apla.a - segment_2.apla.a;// a1-a2
	const long double difference_b = segment_1.apla.b - segment_2.apla.b;// b1-b2

	const long double distance_segment_pow = formula_coefficient_1 * (2 * segment_1.rectangle_width - 1) * powl(difference_a, 2) / 6 + formula_coefficient_1 * difference_a * difference_b + segment_1.rectangle_width * powl(difference_b, 2);

	/*................................................................................................................................................*/
#ifdef _DEBUG
	long double distance_segment_pow_test = 0;
	for (int id = 0; id < segment_1.rectangle_width; id++) {
		distance_segment_pow_test += powl((segment_1.apla.a - segment_2.apla.a) * id + segment_1.apla.b - segment_2.apla.b, 2);
	}
	assert(fabs(distance_segment_pow_test - distance_segment_pow) < 0.001);
#endif
	/*...................................................................................................................................................*/


	return distance_segment_pow;//^2
}



//************************************
// Method:get_sqrt_distance_sapla_same_endpoints
// Qualifier: get difference pow for one segment
// Notes: 
// Input: query time series, candidate APLA 
// Output: query projection APLA of candiate APLA
// date:191112
// author:
//************************************
//210721 compue distance with power for two approximations with same right endpoints.
TEMPLATE
template<typename T, typename Y>
long double APLA::get_sqrt_distance_sapla_same_endpoints(const DoublyLinkedList<T>& const doubly_linked_list_1, const DoublyLinkedList<Y>& const doubly_linked_list_2) {
	/*...................................................................................................................................................*/
#ifdef _DEBUG
	assert(doubly_linked_list_1.size() == doubly_linked_list_2.size());
#endif
	/*...................................................................................................................................................*/

	long double distance_power = 0;

	for (int id_segment = 0; id_segment < doubly_linked_list_1.size(); id_segment++) {
		distance_power += get_segment_distance_LB(doubly_linked_list_1[id_segment], doubly_linked_list_2[id_segment]);
	}

	return sqrtl(distance_power);
}

//************************************
// Method:get_distance_LB
// Qualifier: 
// Notes: they have samne right endpoints
// Input: two APLA points, one is original APLA point, other is projected APLA point, 
// Output: 
// date:191114 
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
double APLA::get_distance_LB(const DoublyLinkedList<T>& const doubly_linked_list, const vector<Y>& const area_vector) {
#ifdef _DEBUG
	assert(doubly_linked_list.size() == area_vector.size());
#endif
	long double distance = 0;
	auto&& const au_list = doubly_linked_list.begin();
	for (auto&& const au_vector = area_vector.begin(); au_vector != area_vector.end(); au_vector++, au_list++) {
		distance += get_segment_distance_LB(*au_vector, *au_list);
	}

	return std::sqrt(distance);
}
//************************************
// Method:get_distance_LB_by_series_apla
// Qualifier: directly get distanceLB from query time series & original APLA point, combine(get_apla_projection, get_segment_distance_LB, get_distance_LB)
// Notes: they have samne right endpoints
// Input: two APLA points, one is original APLA point, other is projected APLA point, 
// Output: 
// date:191114 
// author:
//************************************
TEMPLATE
template<typename T>
double APLA::get_distance_LB_by_series_apla(const vector<DataType>& const query_time_series_vector, const DoublyLinkedList<T>& const doubly_linked_list) {
#ifdef _DEBUG
	assert(!query_time_series_vector.empty());
#endif
	double distance = 0;
	T temp_segment;
	for (auto&& const au : doubly_linked_list) {
		temp_segment.right_endpoint = au.right_endpoint;
		temp_segment.rectangle_width = au.rectangle_width;
		getAAndBByPLA(query_time_series_vector, temp_segment);
		distance += get_segment_distance_LB(temp_segment, au);
	}
	return std::sqrt(distance);
}

//191129 compue PLA distance LB for two APLA points.
//************************************
// Method:get_distance_LB_pla
// Qualifier: PLA method to get distance LB
// Notes: 
// Input: two APLA points, one is original APLA point, other is query APLA point, 
// Output: 
// date:191128
// author:
//************************************
TEMPLATE
template<typename T>
double APLA::get_distance_LB_pla(const DoublyLinkedList<T>& const query_linked_list, const DoublyLinkedList<T>& const doubly_linked_list) {
#ifdef _DEBUG
	assert(query_linked_list.size() == doubly_linked_list.size() && query_linked_list.back().right_endpoint != INF);
#endif
	vector<double> reconstruct_query_time_series_vector(query_linked_list.back().right_endpoint + 1, INF);
	vector<double> reconstruct_time_series_vector(query_linked_list.back().right_endpoint + 1, INF);
	getAPLAReconstructSeries(query_linked_list, reconstruct_query_time_series_vector);
	getAPLAReconstructSeries(doubly_linked_list, reconstruct_time_series_vector);

#ifdef _DEBUG
	assert(reconstruct_query_time_series_vector.size() == reconstruct_time_series_vector.size());
#endif

	return TOOL::distanceEUC(reconstruct_query_time_series_vector, reconstruct_time_series_vector);
}

//************************************
// Method:get_distance_LB_pla
// Qualifier: PLA method to get distance AE
// Notes: 
// Input: compue query time series with reconstruct time series. APCA distance AE
// Output: 
// date:200109
// author:
//************************************
TEMPLATE
template<typename T>
long double APLA::get_distance_AE(const vector<DataType>& const query_time_series_vector, const DoublyLinkedList<T>& const doubly_linked_list) {
#ifdef _DEBUG
	assert(!query_time_series_vector.empty() && doubly_linked_list.back().right_endpoint != INF);
#endif
	//vector<double> reconstruct_query_time_series_vector(query_linked_list.back().right_endpoint + 1, INF);
	vector<DataType> reconstruct_time_series_vector(query_time_series_vector.size(), INF);
	//getAPLAReconstructSeries(query_linked_list, reconstruct_query_time_series_vector);
	getAPLAReconstructSeries(doubly_linked_list, reconstruct_time_series_vector);

#ifdef _DEBUG
	assert(query_time_series_vector.size() == reconstruct_time_series_vector.size());
#endif

	return TOOL::distanceEUC(query_time_series_vector, reconstruct_time_series_vector);

}

//191205 compue PLA distance LB for two APLA points fast.
//191129 compue PLA distance LB for two APLA points.
//************************************
// Method:get_distance_LB_pla
// Qualifier: PLA method to get distance LB
// Notes: 
// Input: two APLA points, one is original APLA point, other is query APLA point, 
// Output: 
// date:191128
// author:
//************************************
TEMPLATE
template<typename T>
double APLA::get_distance_LB_pla_speed(const DoublyLinkedList<T>& const query_linked_list, const DoublyLinkedList<T>& const doubly_linked_list) {
#ifdef _DEBUG
	assert(query_linked_list.size() == doubly_linked_list.size());
#endif

	int query_id = 0;
	int list_id = 0;
	double difference = INF;
	double distance = 0;
	double temp_b = INF;

	T temp_query = query_linked_list[query_id];
	T temp_list = doubly_linked_list[list_id];

	while (query_id < query_linked_list.size() && list_id < doubly_linked_list.size()) {
#ifdef _DEBUG
		assert(temp_query.rectangle_width != INF && temp_list.rectangle_width != INF);
#endif
		if (temp_query.right_endpoint < temp_list.right_endpoint) {
			for (int array_id = 0; array_id < temp_query.rectangle_width; array_id++) {
#ifdef _DEBUG
				assert(temp_query.apla.a != INF && temp_query.apla.b != INF && temp_list.apla.a != INF && temp_list.apla.b != INF);
#endif
				difference = temp_query.apla.a * array_id + temp_query.apla.b - (temp_list.apla.a * array_id + temp_list.apla.b);
				distance += difference * difference;
			}
			temp_list.apla.b = temp_list.apla.a * temp_query.rectangle_width + temp_list.apla.b;
			temp_list.rectangle_width -= temp_query.rectangle_width;
			query_id++;
			temp_query = query_linked_list[query_id];
		}
		else if (temp_query.right_endpoint > temp_list.right_endpoint) {
			for (int array_id = 0; array_id < temp_list.rectangle_width; array_id++) {
#ifdef _DEBUG
				assert(temp_query.apla.a != INF && temp_query.apla.b != INF && temp_list.apla.a != INF && temp_list.apla.b != INF);
#endif
				difference = temp_query.apla.a * array_id + temp_query.apla.b - (temp_list.apla.a * array_id + temp_list.apla.b);
				distance += difference * difference;
			}
			temp_query.apla.b = temp_query.apla.a * temp_list.rectangle_width + temp_query.apla.b;
			temp_query.rectangle_width -= temp_list.rectangle_width;
			list_id++;
			temp_list = doubly_linked_list[list_id];
		}
		else {
#ifdef _DEBUG
			assert(temp_query.rectangle_width == temp_list.rectangle_width);
#endif
			for (int array_id = 0; array_id < temp_query.rectangle_width; array_id++) {
#ifdef _DEBUG
				assert(temp_query.apla.a != INF && temp_query.apla.b != INF && temp_list.apla.a != INF && temp_list.apla.b != INF);
#endif
				difference = temp_query.apla.a * array_id + temp_query.apla.b - (temp_list.apla.a * array_id + temp_list.apla.b);
				distance += difference * difference;
			}
			if (query_id == query_linked_list.size() - 1) {
#ifdef _DEBUG
				assert(list_id == query_linked_list.size() - 1);
#endif
				break;

			}

			temp_query = query_linked_list[++query_id];
			temp_list = doubly_linked_list[++list_id];
		}
	}

#ifdef _DEBUG
	assert(float(sqrt(distance)) == float(get_distance_LB_pla(query_linked_list, doubly_linked_list)));
#endif
	return sqrt(distance);
}

//200110 compue PLA distance LB for two APLA points lower bound.
//************************************
// Method:get_distance_lower_bound
// Qualifier: //200110 
// Notes: 
// Input: two APLA points, ocompue distance LB for two APLA points by APCA(average value). guarantee lower bound
// Output: 
// date:200110
// author:
//************************************
TEMPLATE
template<typename T>
double APLA::get_distance_lower_bound(const DoublyLinkedList<T>& const query_linked_list, const DoublyLinkedList<T>& const doubly_linked_list) {
#ifdef _DEBUG
	assert(query_linked_list.size() == doubly_linked_list.size());
#endif

	for (int segment_id = 0; segment_id < query_linked_list.size(); segment_id++) {
		cout << query_linked_list[segment_id].right_endpoint << ",";
	}
	cout << endl;
	cout << "=====================================================================\n";
	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		cout << doubly_linked_list[segment_id].right_endpoint << ",";
	}
	cout << endl;

	for (int segment_id = 0; segment_id < query_linked_list.size(); segment_id++) {
		cout << query_linked_list[segment_id].apla.a << "," << query_linked_list[segment_id].apla.b << "; ";
	}
	cout << endl;
	cout << "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n";
	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		cout << doubly_linked_list[segment_id].apla.a << "," << doubly_linked_list[segment_id].apla.b << "; ";
	}
	cout << endl;

	DoublyLinkedList<T> test_query_linked_list;
	DoublyLinkedList<T> test_doubly_linked_list;

	vector<double> time_series_query_vector;
	vector<double> time_series_normal_vector;

	int query_id = 0;
	int list_id = 0;
	double difference = INF;
	double distance = 0;
	double temp_b = INF;

	T temp_query = query_linked_list[query_id];
	T temp_list = doubly_linked_list[list_id];
	T candidate_temp_list;

	while (query_id < query_linked_list.size() && list_id < doubly_linked_list.size()) {
#ifdef _DEBUG
		assert(temp_query.rectangle_width != INF && temp_list.rectangle_width != INF);
#endif
		if (temp_query.right_endpoint < temp_list.right_endpoint) {

			test_query_linked_list.add(temp_query);

			candidate_temp_list.rectangle_width = temp_query.rectangle_width;
			candidate_temp_list.right_endpoint = temp_query.right_endpoint;

			vector<double> time_series_vector;

			for (int array_id = 0; array_id < temp_query.rectangle_width; array_id++) {
#ifdef _DEBUG
				assert(temp_query.apla.a != INF && temp_query.apla.b != INF && temp_list.apla.a != INF && temp_list.apla.b != INF);
#endif
				difference = temp_query.apla.a * array_id + temp_query.apla.b - (temp_list.apla.a * array_id + temp_list.apla.b);
				distance += difference * difference;

				time_series_query_vector.emplace_back(temp_query.apla.a * array_id + temp_query.apla.b);

				if (array_id < temp_query.rectangle_width - 1 && array_id >0) {
					time_series_vector.emplace_back(temp_list.apla.a * array_id + temp_list.apla.b);
					time_series_normal_vector.emplace_back(temp_list.apla.a * array_id + temp_list.apla.b);
				}
				else {
					double middle_distance = temp_list.apla.a * array_id + temp_list.apla.b + temp_query.apla.a * array_id + temp_query.apla.b;
					middle_distance /= 2;
					time_series_normal_vector.emplace_back(middle_distance);
					time_series_vector.emplace_back(temp_query.apla.a * array_id + temp_query.apla.b);
				}

			}
			assert(time_series_vector.size() == temp_query.rectangle_width);

			candidate_temp_list.apla = get_PLA_coefficient(time_series_vector);
			test_doubly_linked_list.add(candidate_temp_list);

			temp_list.apla.b = temp_list.apla.a * temp_query.rectangle_width + temp_list.apla.b;
			temp_list.rectangle_width -= temp_query.rectangle_width;
			query_id++;
			temp_query = query_linked_list[query_id];
		}
		else if (temp_query.right_endpoint > temp_list.right_endpoint) {

			test_doubly_linked_list.add(temp_list);

			candidate_temp_list.rectangle_width = temp_list.rectangle_width;
			candidate_temp_list.right_endpoint = temp_list.right_endpoint;

			vector<double> time_series_vector;

			for (int array_id = 0; array_id < temp_list.rectangle_width; array_id++) {
#ifdef _DEBUG
				assert(temp_query.apla.a != INF && temp_query.apla.b != INF && temp_list.apla.a != INF && temp_list.apla.b != INF);
#endif
				difference = temp_query.apla.a * array_id + temp_query.apla.b - (temp_list.apla.a * array_id + temp_list.apla.b);
				distance += difference * difference;

				time_series_normal_vector.emplace_back(temp_list.apla.a * array_id + temp_list.apla.b);

				if (array_id < temp_list.rectangle_width - 1 && array_id >0) {
					time_series_vector.emplace_back(temp_query.apla.a * array_id + temp_query.apla.b);
					time_series_query_vector.emplace_back(temp_query.apla.a * array_id + temp_query.apla.b);
				}
				else {
					double middle_distance = temp_list.apla.a * array_id + temp_list.apla.b + temp_query.apla.a * array_id + temp_query.apla.b;
					middle_distance /= 2;
					time_series_query_vector.emplace_back(middle_distance);
					time_series_vector.emplace_back(temp_list.apla.a * array_id + temp_list.apla.b);
				}

			}
			assert(time_series_vector.size() == temp_list.rectangle_width);
			candidate_temp_list.apla = get_PLA_coefficient(time_series_vector);
			test_query_linked_list.add(candidate_temp_list);

			temp_query.apla.b = temp_query.apla.a * temp_list.rectangle_width + temp_query.apla.b;
			temp_query.rectangle_width -= temp_list.rectangle_width;
			list_id++;
			temp_list = doubly_linked_list[list_id];
		}
		else {
#ifdef _DEBUG
			assert(temp_query.rectangle_width == temp_list.rectangle_width);
#endif
			test_query_linked_list.add(temp_query);
			test_doubly_linked_list.add(temp_list);

			for (int array_id = 0; array_id < temp_query.rectangle_width; array_id++) {
#ifdef _DEBUG
				assert(temp_query.apla.a != INF && temp_query.apla.b != INF && temp_list.apla.a != INF && temp_list.apla.b != INF);
#endif
				difference = temp_query.apla.a * array_id + temp_query.apla.b - (temp_list.apla.a * array_id + temp_list.apla.b);
				distance += difference * difference;

				time_series_query_vector.emplace_back(temp_query.apla.a * array_id + temp_query.apla.b);
				time_series_normal_vector.emplace_back(temp_list.apla.a * array_id + temp_list.apla.b);
			}


			if (query_id == query_linked_list.size() - 1) {
#ifdef _DEBUG
				assert(list_id == query_linked_list.size() - 1);
#endif
				break;

			}

			temp_query = query_linked_list[++query_id];
			temp_list = doubly_linked_list[++list_id];
		}
	}

	//#ifdef _DEBUG
	assert(test_query_linked_list.size() == test_doubly_linked_list.size() && time_series_query_vector.size() == time_series_normal_vector.size());

	for (int segment_id = 0; segment_id < test_query_linked_list.size(); segment_id++) {
		assert(test_query_linked_list[segment_id].rectangle_width == test_doubly_linked_list[segment_id].rectangle_width && test_query_linked_list[segment_id].right_endpoint == test_doubly_linked_list[segment_id].right_endpoint);
	}

	for (int segment_id = 0; segment_id < test_query_linked_list.size(); segment_id++) {
		cout << test_query_linked_list[segment_id].right_endpoint << ",";
	}
	cout << endl;
	cout << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n";
	for (int segment_id = 0; segment_id < test_query_linked_list.size(); segment_id++) {
		cout << test_doubly_linked_list[segment_id].right_endpoint << ",";
	}
	cout << endl;

	for (int segment_id = 0; segment_id < test_query_linked_list.size(); segment_id++) {
		cout << test_query_linked_list[segment_id].apla.a << "," << test_query_linked_list[segment_id].apla.b << "; ";
	}
	cout << endl;
	cout << "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n";
	for (int segment_id = 0; segment_id < test_query_linked_list.size(); segment_id++) {
		cout << test_doubly_linked_list[segment_id].apla.a << "," << test_doubly_linked_list[segment_id].apla.b << "; ";
	}
	cout << endl;


	getAPLAReconstructSeries(test_query_linked_list, time_series_query_vector);
	getAPLAReconstructSeries(test_doubly_linked_list, time_series_normal_vector);

	for (auto&& au : time_series_query_vector) {
		cout << au << ",";
	}
	cout << endl;
	cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n";
	for (auto&& au : time_series_normal_vector) {
		cout << au << ",";
	}
	cout << endl;
	//return  TOOL::distanceEUC(time_series_query_vector, time_series_normal_vector);



	return  APLA::get_distance_LB_pla(test_query_linked_list, test_doubly_linked_list);
	assert(float(sqrt(distance)) == float(get_distance_LB_pla(query_linked_list, doubly_linked_list)));
	//#endif
	return sqrt(distance);

}

//************************************
// Method:get_distance_apca_LB
// Qualifier: //200107 compute adaptive segment endpoint distance.
// Notes: 
// Input: two APLA points, one is original APLA point, other is query APLA point, 
// Output: 
// date:200113
// author:
//************************************
TEMPLATE
template<typename T>
double APLA::get_apla_endpoint_distance(const DoublyLinkedList<T>& const query_linked_list, const DoublyLinkedList<T>& const doubly_linked_list) {
#ifdef _DEBUG
	assert(query_linked_list.size() == doubly_linked_list.size());
#endif
	double time_series_length = query_linked_list.back().right_endpoint + 1;
	double distance = 0;
	for (int segment_id = 0; segment_id < query_linked_list.size(); segment_id++) {
		int query_id = query_linked_list[segment_id].right_endpoint / time_series_length;
		int linked_id = doubly_linked_list[segment_id].right_endpoint / time_series_length;
		double query_value = (query_linked_list[segment_id].rectangle_width - 1) * query_linked_list[segment_id].apla.a + query_linked_list[segment_id].apla.b;
		double linked_value = (doubly_linked_list[segment_id].rectangle_width - 1) * doubly_linked_list[segment_id].apla.a + doubly_linked_list[segment_id].apla.b;
		distance += (query_id - linked_id) * (query_id - linked_id) + (query_value - linked_value) * (query_value - linked_value);
	}

	return sqrt(distance);
}

//************************************
// Method:get_distance_apca_LB
// Qualifier: //200107 compue distance LB for two APLA points by APCA(average value).
// Notes: 
// Input: two APLA points, one is original APLA point, other is query APLA point, 
// Output: 
// date:200107
// author:
//************************************
TEMPLATE
template<typename T>
double APLA::get_distance_apca_LB(const DoublyLinkedList<T>& const doubly_linked_list, const vector<T>& const area_vector) {
#ifdef _DEBUG
	assert(doubly_linked_list.size() == area_vector.size());
#endif
	double distance = 0;
	for (int segment_id = 0; segment_id < area_vector.size(); segment_id++) {
#ifdef _DEBUG
		assert(doubly_linked_list[segment_id].rectangle_width == area_vector[segment_id].rectangle_width && area_vector[segment_id].rectangle_width != INF && doubly_linked_list[segment_id].sum_value != INF && area_vector[segment_id].sum_value != INF);
		//doubly_linked_list[segment_id].sum_value = area_vector[segment_id].rectangle_width*(area_vector[segment_id].rectangle_width-1)*0.5*
#endif
		distance += (doubly_linked_list[segment_id].sum_value - area_vector[segment_id].sum_value) * (doubly_linked_list[segment_id].sum_value - area_vector[segment_id].sum_value) / area_vector[segment_id].rectangle_width;
	}

	return sqrt(distance);
}

//***************************************************************
	// Method:get_last_segment_right_endpoint
	// Qualifier:  Lower bound distance between SAPLA (Approximation)
	// Input:
	// Output:
	// notice:
	// date:210518
	// author:
	//***************************************************************
TEMPLATE
template<typename T>
inline double APLA::get_last_segment_right_endpoint(const DoublyListNode<T>& const current_node) {
#ifdef _DEBUG
	if (current_node._prev) {
		assert(current_node._prev->_value.right_endpoint == current_node._value.right_endpoint - current_node._value.rectangle_width);
	}
	else {
		assert(-1 == current_node._value.right_endpoint - current_node._value.rectangle_width);
	}
#endif

	return current_node._prev ? current_node._prev->_value.right_endpoint : -1;
}

//***************************************************************
// Method:get_id_vector_short_segment
// Qualifier:  
// Input: id_short_begin : id of first segment
// Output: id_short_begin: id of next first segment
// notice: 1 skipt id of current(first) short segment. 2 last short segment right endpoint < long right endpoint 
// date:210519
// author:
//***************************************************************
TEMPLATE
template<typename T, typename Y, typename U, typename T1>
void APLA::get_id_vector_short_segment(const T& const segment_long, const Y& const linked_list_short, U& const id_short_begin, T1& const id_segment_vec) {

	/*....................................................................................*/
#ifdef _DEBUG
	assert(id_segment_vec.empty());
#endif
	/*....................................................................................*/

	id_short_begin++;//210603 skipt current(first) short segment

	while (id_short_begin < linked_list_short.size() && linked_list_short[id_short_begin].right_endpoint < segment_long.right_endpoint) {
		id_segment_vec.emplace_back(id_short_begin);
		id_short_begin++;
	}

	/*....................................................................................*/
#ifdef _DEBUG
			//if (id_1 > 0) {
	assert(segment_long.right_endpoint <= linked_list_short[id_short_begin].right_endpoint);
	//}
#endif
	/*....................................................................................*/
}

//***************************************************************
// Method:get_id_vector_segments_equal_endpoint
// Qualifier:  compute SAPLA triangle distance when right endpoints are equal
// Input:
// Output:
// notice:
// date:210519
// author:
//***************************************************************
TEMPLATE
template<typename T, typename Y, typename U, typename T1>
void APLA::get_id_vector_segments_equal_endpoint(const vector<T>& const series_long, Y& const segment_long, const DoublyLinkedList<Y>& const linked_list_short, T1& const id_segment_vec, U& const distance_SAPLA) {

	/*....................................................................................*/
#ifdef _DEBUG
	assert(linked_list_short[id_segment_vec.back()].right_endpoint == segment_long.right_endpoint);
#endif
	/*....................................................................................*/


	if (id_segment_vec.empty()) {
		return;
	}
	else if (id_segment_vec.size() == 1) {
		distance_SAPLA += get_triangle_area(segment_long, linked_list_short[id_segment_vec.front()]);
		return;
	}

	Y left_seg, right_seg;

	int firt_width = linked_list_short[id_segment_vec.front()].rectangle_width;
	int last_width = linked_list_short[id_segment_vec.back()].rectangle_width;

	if (firt_width > last_width) {
		// endpoint, width
		left_seg.right_endpoint = linked_list_short[id_segment_vec.back()].right_endpoint;
		left_seg.rectangle_width = segment_long.rectangle_width - last_width;

		right_seg.right_endpoint = segment_long.right_endpoint;
		right_seg.rectangle_width = last_width;

		getSubAAndBByPLA(series_long, left_seg, right_seg, segment_long);

		distance_SAPLA += get_triangle_area(right_seg, linked_list_short[id_segment_vec.back()]);
		id_segment_vec.pop_back();
		get_id_vector_segments_equal_endpoint(series_long, left_seg, linked_list_short, id_segment_vec, distance_SAPLA);
	}
	else {

		left_seg.right_endpoint = linked_list_short[id_segment_vec.front()].right_endpoint;
		left_seg.rectangle_width = linked_list_short[id_segment_vec.front()].rectangle_width;

		right_seg.right_endpoint = segment_long.right_endpoint;
		right_seg.rectangle_width = segment_long.right_endpoint - left_seg.right_endpoint;

		getSubAAndBByPLA(series_long, left_seg, right_seg, segment_long);

		distance_SAPLA += get_triangle_area(left_seg, linked_list_short[id_segment_vec.front()]);
		id_segment_vec.erase(id_segment_vec.begin());

		get_id_vector_segments_equal_endpoint(series_long, right_seg, linked_list_short, id_segment_vec, distance_SAPLA);
	}

	/*....................................................................................*/
#ifdef _DEBUG

#endif
	/*....................................................................................*/
}

//***************************************************************
// Method:get_distance_SAPLA_segments
// Qualifier:  get SAPLA distance between 1 long segment and several short segments.
// Input:
// Output:
// notice:
// date:210519
// author:
//***************************************************************
TEMPLATE
template<typename T, typename Y, typename U, typename T1, typename T2, typename T3, typename T4, typename T5>
void APLA::get_distance_SAPLA_segments(const T4& const type_distance, const vector<T>& const original_time_series_long, const T2 right_endpoint_long_original, Y& const segment_long, DoublyLinkedList<Y>& const doubly_linked_list_long, DoublyLinkedList<Y>& const doubly_linked_list_short, T3& const id_begin_long, T3& const id_begin_short, T1& const id_segment_vector, U& const distance_SAPLA, T5& const number_points) {

	if (id_segment_vector.empty()) {
		if (segment_long.right_endpoint == right_endpoint_long_original) {
			//new_current_seg = segment_long;
			doubly_linked_list_long[id_begin_long] = segment_long;
		}
		return;
	}

	/*....................................................................................*/
#ifdef _DEBUG
	const Y& const segment_evaluation_0 = doubly_linked_list_short[id_segment_vector.back()];
	assert(segment_evaluation_0.right_endpoint <= segment_long.right_endpoint);
#endif
	/*....................................................................................*/

	int firt_width, last_width;
	Y segment_left, segment_right;

	/*+++++++++++++++++++++++++++++  get first & last width ++++++++++++++++++++++++++++++++++++++++*/
	if (doubly_linked_list_short[id_segment_vector.back()].right_endpoint != segment_long.right_endpoint) {// right endpoints are not equal
		last_width = segment_long.right_endpoint - doubly_linked_list_short[id_segment_vector.back()].right_endpoint;
	}
	else {// long segment endpoints == short segment endpoitns

		if (id_segment_vector.size() == 1) {
			//distance_SAPLA += get_triangle_area(segment_long, doubly_linked_list_short[id_segment_vector.front()]);
			switch (type_distance) {
			case 0:
				distance_SAPLA += get_segment_distance_LB(segment_long, doubly_linked_list_short[id_segment_vector.front()]);//is ^2
				break;
			case 1:
				//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) << endl;
				distance_SAPLA += get_triangle_area(segment_long, doubly_linked_list_short[id_segment_vector.front()]);
				break;
			default:
				assert(0);
			}

			id_segment_vector.clear();
			return;
		}
		last_width = doubly_linked_list_short[id_segment_vector.back()].rectangle_width;
	}
	firt_width = doubly_linked_list_short[id_segment_vector.front()].rectangle_width;
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	if (firt_width > last_width) {//the last segment in long segment is short, regard as new begin segment
		// endpoint, width
		number_points += last_width;

		if (doubly_linked_list_short[id_segment_vector.back()].right_endpoint != segment_long.right_endpoint) {
			segment_left.right_endpoint = doubly_linked_list_short[id_segment_vector.back()].right_endpoint;
		}
		else {

			/*.......................................*/
#ifdef _DEBUG
			assert(id_segment_vector.back() > 0);
			const Y& const segment_evaluation_1 = doubly_linked_list_short[id_segment_vector.back() - 1];
#endif
			/*........................................*/

			segment_left.right_endpoint = doubly_linked_list_short[id_segment_vector.back() - 1].right_endpoint;
		}
		segment_left.rectangle_width = segment_long.rectangle_width - last_width;

		segment_right.right_endpoint = segment_long.right_endpoint;
		segment_right.rectangle_width = last_width;

		/*....................................................................................*/
#ifdef _DEBUG
		assert(segment_left.rectangle_width >= segment_right.rectangle_width);
#endif
		/*....................................................................................*/

		getSubAAndBByPLA(original_time_series_long, segment_left, segment_right, segment_long);

		//left long, right short
		if (segment_right.right_endpoint == right_endpoint_long_original) {
			//new_current_seg = segment_right;
			doubly_linked_list_long[id_begin_long] = segment_right;
		}
		else {
			/*....................................................................................*/
#ifdef _DEBUG
			const Y& const segment_evaluation_2 = doubly_linked_list_short[id_segment_vector.back()];
			assert(segment_right.right_endpoint == segment_evaluation_2.right_endpoint);
#endif
			/*....................................................................................*/


			//distance_SAPLA += get_triangle_area(segment_right, doubly_linked_list_short[id_segment_vector.back()]);
			switch (type_distance) {
			case 0:
				distance_SAPLA += get_segment_distance_LB(segment_right, doubly_linked_list_short[id_segment_vector.back()]);//is ^2
				break;
			case 1:
				//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
				distance_SAPLA += get_triangle_area(segment_right, doubly_linked_list_short[id_segment_vector.back()]);
				break;
			default:
				assert(0);
			}
			id_segment_vector.pop_back();
		}
		segment_long = segment_left;
		//get_id_vector_segments_equal_endpoint(original_time_series_long, left_seg, doubly_linked_list_short, id_segment_vector, distance_SAPLA);
		get_distance_SAPLA_segments(type_distance, original_time_series_long, right_endpoint_long_original, segment_long, doubly_linked_list_long, doubly_linked_list_short, id_begin_long, id_begin_short, id_segment_vector, distance_SAPLA, number_points);
	}
	else {//left short, right long

		number_points += firt_width;

		segment_left.right_endpoint = doubly_linked_list_short[id_segment_vector.front()].right_endpoint;
		segment_left.rectangle_width = doubly_linked_list_short[id_segment_vector.front()].rectangle_width;

		segment_right.right_endpoint = segment_long.right_endpoint;
		segment_right.rectangle_width = segment_long.right_endpoint - segment_left.right_endpoint;

		/*....................................................................................*/
#ifdef _DEBUG
		assert(segment_left.rectangle_width <= segment_right.rectangle_width && firt_width == doubly_linked_list_short[id_segment_vector.front()].rectangle_width && segment_right.rectangle_width >= last_width);
#endif
		/*....................................................................................*/

		getSubAAndBByPLA(original_time_series_long, segment_left, segment_right, segment_long);

		//distance_SAPLA += get_triangle_area(segment_left, doubly_linked_list_short[id_segment_vector.front()]);
		switch (type_distance) {
		case 0:
			distance_SAPLA += get_segment_distance_LB(segment_left, doubly_linked_list_short[id_segment_vector.front()]);//is ^2
			break;
		case 1:
			//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
			distance_SAPLA += get_triangle_area(segment_left, doubly_linked_list_short[id_segment_vector.front()]);
			break;
		default:
			assert(0);
		}

		id_segment_vector.erase(id_segment_vector.begin());
		segment_long = segment_right;

		get_distance_SAPLA_segments(type_distance, original_time_series_long, right_endpoint_long_original, segment_long, doubly_linked_list_long, doubly_linked_list_short, id_begin_long, id_begin_short, id_segment_vector, distance_SAPLA, number_points);
	}
	/*................................*/
#ifdef _DEBUG
	assert(id_segment_vector.empty());
	//assert(0);
#endif
	/*...............................*/
}


//210817 get segment distance by option
TEMPLATE
template<typename T, typename Y, typename U>
inline long double APLA::get_distance_SAPLA_segment_by_option(const T& const type_distance, const Y& const segment_1, const U& const segment_2) {
	switch (type_distance) {
	case 0:
		return get_segment_distance_LB(segment_1, segment_2);//is ^2
		break;
	case 1:
		//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
		return get_triangle_area(segment_1, segment_2);
		break;
	default:
		assert(0);
	}
}


//***************************************************************
// Method:get_distance_SAPLA_segments
// Qualifier:  get SAPLA distance between 1 long segment and several short segments.
// Input:
// Output: 
// notice: In use in SAPLA distance. Not change list
// date:210531
// author:
//***************************************************************
TEMPLATE
template<typename T, typename Y, typename U, typename T1, typename T2, typename T3, typename T4>
void APLA::get_distance_SAPLA_segments(const T3& const type_distance, const vector<T>& const original_time_series_long, const T2 right_endpoint_long_original, const DoublyLinkedList<Y>& const doubly_linked_list_short, T1& const id_segment_vector, Y& const segment_long, Y& const segment_short_begin_current, Y& const segment_short_begin_next, U& const distance_SAPLA, T4& const number_points) {
	/*....................................................................................*/
#ifdef _DEBUG
	assert(segment_short_begin_current.right_endpoint - segment_short_begin_current.rectangle_width == segment_long.right_endpoint - segment_long.rectangle_width && segment_short_begin_current.right_endpoint <= segment_long.right_endpoint);
#endif
	/*....................................................................................*/

	int firt_width, last_width;
	Y segment_left, segment_right;

	if (id_segment_vector.empty()) {// short segment number == 1, only one short segment now

		/*+++++++++++++++++++++++++++++  get first & last width ++++++++++++++++++++++++++++++++++++++++*/
		if (segment_short_begin_current.right_endpoint != segment_long.right_endpoint) {// right endpoints are not equal
			/*.................................................................*/
#ifdef _DEBUG
			assert(right_endpoint_long_original == segment_long.right_endpoint);
#endif
			/*.................................................................*/
			
			last_width = segment_long.right_endpoint - segment_short_begin_current.right_endpoint;
			firt_width = segment_short_begin_current.rectangle_width;

			segment_left.right_endpoint = segment_short_begin_current.right_endpoint;
			segment_left.rectangle_width = segment_short_begin_current.rectangle_width;
			segment_right.right_endpoint = segment_long.right_endpoint;
			segment_right.rectangle_width = last_width;

			if (firt_width > last_width) {//the last segment in long segment is short, regard as new begin segment
				// endpoint, width
				number_points += last_width;
			}
			else {//left short, right long
				number_points += firt_width;
			}

			getSubAAndBByPLA(original_time_series_long, segment_left, segment_right, segment_long);

			segment_short_begin_next = segment_right;

			distance_SAPLA += get_distance_SAPLA_segment_by_option(type_distance, segment_left, segment_short_begin_current);

			return;
		}
		else {// long segment endpoints == short segment endpoitns, and width are equal
			/*..........................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_short_begin_current.rectangle_width == segment_long.rectangle_width && right_endpoint_long_original > segment_long.right_endpoint && right_endpoint_long_original == segment_short_begin_next.right_endpoint);
#endif
			/*..........................................................................................................................................*/

			distance_SAPLA += get_distance_SAPLA_segment_by_option(type_distance, segment_long, segment_short_begin_current);
			return;
		}
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	}
	else {// short segment number >=2
		/*....................................................................................*/
#ifdef _DEBUG
		assert(!id_segment_vector.empty());
		const Y& const segment_evaluation_0 = doubly_linked_list_short[id_segment_vector.back()];
		const Y& const segment_evaluation_1 = doubly_linked_list_short[id_segment_vector.front()];
		assert(segment_evaluation_0.right_endpoint <= segment_long.right_endpoint && segment_short_begin_current.right_endpoint == segment_evaluation_1.right_endpoint - segment_evaluation_1.rectangle_width);
#endif
		/*....................................................................................*/

		/*+++++++++++++++++++++++++++++  get first & last width ++++++++++++++++++++++++++++++++++++++++*/
		if (doubly_linked_list_short[id_segment_vector.back()].right_endpoint != segment_long.right_endpoint) {// right endpoints are not equal
			last_width = segment_long.right_endpoint - doubly_linked_list_short[id_segment_vector.back()].right_endpoint;
		}
		else {// long segment endpoints == short segment endpoitns
			last_width = doubly_linked_list_short[id_segment_vector.back()].rectangle_width;
		}
		firt_width = segment_short_begin_current.rectangle_width;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*+++++++++++++++++++++++++++++++++++++ Compute Area ++++++++++++++++++++++++++++++++++++++++++++++*/
		if (firt_width > last_width) {//the last segment in long segment is short, regard as new begin short segment
			// endpoint, width
			number_points += last_width;

			if (doubly_linked_list_short[id_segment_vector.back()].right_endpoint != segment_long.right_endpoint) {
				segment_left.right_endpoint = doubly_linked_list_short[id_segment_vector.back()].right_endpoint;
			}
			else {// long right endpoint == short right endpoint
				if (id_segment_vector.size() > 1) {
					segment_left.right_endpoint = doubly_linked_list_short[id_segment_vector.back() - 1].right_endpoint;
				}
				else {
					segment_left.right_endpoint = segment_short_begin_current.right_endpoint;
				}
			}
			segment_left.rectangle_width = segment_long.rectangle_width - last_width;

			segment_right.right_endpoint = segment_long.right_endpoint;
			segment_right.rectangle_width = last_width;

			/*....................................................................................*/
#ifdef _DEBUG
			assert(segment_left.rectangle_width >= segment_right.rectangle_width);
#endif
			/*....................................................................................*/

			getSubAAndBByPLA(original_time_series_long, segment_left, segment_right, segment_long);

			//left long, right short
			if (segment_right.right_endpoint == right_endpoint_long_original) {// long right segment is next short segment.
				segment_short_begin_next = segment_right;
				//doubly_linked_list_long[id_begin_long] = segment_right;210603
				//segment_long = segment_left;
			}
			else {//short endpoint == sub right endpoint == long right
				/*....................................................................................*/
#ifdef _DEBUG
				const Y& const segment_evaluation_2 = doubly_linked_list_short[id_segment_vector.back()];
				assert(segment_right.right_endpoint == segment_evaluation_2.right_endpoint);
#endif
				/*....................................................................................*/

				distance_SAPLA += get_distance_SAPLA_segment_by_option(type_distance, segment_right, doubly_linked_list_short[id_segment_vector.back()]);
				id_segment_vector.pop_back();
			}
			segment_long = segment_left;
			//get_id_vector_segments_equal_endpoint(original_time_series_long, left_seg, doubly_linked_list_short, id_segment_vector, distance_SAPLA);
			get_distance_SAPLA_segments(type_distance, original_time_series_long, right_endpoint_long_original, doubly_linked_list_short, id_segment_vector, segment_long, segment_short_begin_current, segment_short_begin_next, distance_SAPLA, number_points);
		}
		else {//left width < right width, cut first segment
			number_points += firt_width;

			segment_left.right_endpoint = segment_short_begin_current.right_endpoint;
			segment_left.rectangle_width = segment_short_begin_current.rectangle_width;

			segment_right.right_endpoint = segment_long.right_endpoint;
			segment_right.rectangle_width = segment_long.right_endpoint - segment_left.right_endpoint;

			/*.............................................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_left.rectangle_width <= segment_right.rectangle_width && firt_width == segment_short_begin_current.rectangle_width && segment_right.rectangle_width >= last_width);
#endif
			/*.............................................................................................................................................................*/

			getSubAAndBByPLA(original_time_series_long, segment_left, segment_right, segment_long);

			distance_SAPLA += get_distance_SAPLA_segment_by_option(type_distance, segment_left, segment_short_begin_current);
	
			segment_short_begin_current = doubly_linked_list_short[id_segment_vector[0]];

			id_segment_vector.erase(id_segment_vector.begin());

			segment_long = segment_right;

			get_distance_SAPLA_segments(type_distance, original_time_series_long, right_endpoint_long_original, doubly_linked_list_short, id_segment_vector, segment_long, segment_short_begin_current, segment_short_begin_next, distance_SAPLA, number_points);
		}
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	}

	/*................................*/
#ifdef _DEBUG
	assert(id_segment_vector.empty());
	//assert(0);
#endif
	/*...............................*/
}

// 210910 In use now. Not change list. get SAPLA distance between 1 long segment and several short segments.
TEMPLATE
template<typename T, typename Y, typename U, typename T1, typename T2, typename T3, typename T4>
void APLA::get_distance_SAPLA_segments_average(const T3& const type_distance, const vector<T>& const original_time_series_long, const T2 right_endpoint_long_original, const DoublyLinkedList<Y>& const doubly_linked_list_short, T1& const id_segment_vector, Y& const segment_long, Y& const segment_short_begin_current, Y& const segment_short_begin_next, U& const distance_SAPLA, T4& const number_points) {
	/*....................................................................................*/
#ifdef _DEBUG
	assert(segment_short_begin_current.right_endpoint - segment_short_begin_current.rectangle_width == segment_long.right_endpoint - segment_long.rectangle_width && segment_short_begin_current.right_endpoint <= segment_long.right_endpoint);
#endif
	/*....................................................................................*/

	int firt_width, last_width;
	Y segment_left, segment_right;

	if (id_segment_vector.empty()) {// short segment number == 1, only one short segment now

		/*+++++++++++++++++++++++++++++  get first & last width ++++++++++++++++++++++++++++++++++++++++*/
		if (segment_short_begin_current.right_endpoint != segment_long.right_endpoint) {// right endpoints are not equal
			/*.................................................................*/
#ifdef _DEBUG
			assert(right_endpoint_long_original == segment_long.right_endpoint);
#endif
			/*.................................................................*/

			last_width = segment_long.right_endpoint - segment_short_begin_current.right_endpoint;
			firt_width = segment_short_begin_current.rectangle_width;

			segment_left.right_endpoint = segment_short_begin_current.right_endpoint;
			segment_left.rectangle_width = segment_short_begin_current.rectangle_width;
			segment_right.right_endpoint = segment_long.right_endpoint;
			segment_right.rectangle_width = last_width;

			if (firt_width > last_width) {//the last segment in long segment is short, regard as new begin segment
				// endpoint, width
				number_points += last_width;
			}
			else {//left short, right long
				number_points += firt_width;
			}

			getSubAAndBByPLA_average(original_time_series_long, segment_left, segment_right, segment_long);

			segment_short_begin_next = segment_right;

			distance_SAPLA += get_distance_SAPLA_segment_by_option(type_distance, segment_left, segment_short_begin_current);

			return;
		}
		else {// long segment endpoints == short segment endpoitns, and width are equal
			/*..........................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_short_begin_current.rectangle_width == segment_long.rectangle_width && right_endpoint_long_original > segment_long.right_endpoint && right_endpoint_long_original == segment_short_begin_next.right_endpoint);
#endif
			/*..........................................................................................................................................*/

			distance_SAPLA += get_distance_SAPLA_segment_by_option(type_distance, segment_long, segment_short_begin_current);
			return;
		}
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	}
	else {// short segment number >=2
		/*....................................................................................*/
#ifdef _DEBUG
		assert(!id_segment_vector.empty());
		const Y& const segment_evaluation_0 = doubly_linked_list_short[id_segment_vector.back()];
		const Y& const segment_evaluation_1 = doubly_linked_list_short[id_segment_vector.front()];
		assert(segment_evaluation_0.right_endpoint <= segment_long.right_endpoint && segment_short_begin_current.right_endpoint == segment_evaluation_1.right_endpoint - segment_evaluation_1.rectangle_width);
#endif
		/*....................................................................................*/

		/*+++++++++++++++++++++++++++++  get first & last width ++++++++++++++++++++++++++++++++++++++++*/
		if (doubly_linked_list_short[id_segment_vector.back()].right_endpoint != segment_long.right_endpoint) {// right endpoints are not equal
			last_width = segment_long.right_endpoint - doubly_linked_list_short[id_segment_vector.back()].right_endpoint;
		}
		else {// long segment endpoints == short segment endpoitns
			last_width = doubly_linked_list_short[id_segment_vector.back()].rectangle_width;
		}
		firt_width = segment_short_begin_current.rectangle_width;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*+++++++++++++++++++++++++++++++++++++ Compute Area ++++++++++++++++++++++++++++++++++++++++++++++*/
		if (firt_width > last_width) {//the last segment in long segment is short, regard as new begin short segment
			// endpoint, width
			number_points += last_width;

			if (doubly_linked_list_short[id_segment_vector.back()].right_endpoint != segment_long.right_endpoint) {
				segment_left.right_endpoint = doubly_linked_list_short[id_segment_vector.back()].right_endpoint;
			}
			else {// long right endpoint == short right endpoint
				if (id_segment_vector.size() > 1) {
					segment_left.right_endpoint = doubly_linked_list_short[id_segment_vector.back() - 1].right_endpoint;
				}
				else {
					segment_left.right_endpoint = segment_short_begin_current.right_endpoint;
				}
			}
			segment_left.rectangle_width = segment_long.rectangle_width - last_width;

			segment_right.right_endpoint = segment_long.right_endpoint;
			segment_right.rectangle_width = last_width;

			/*....................................................................................*/
#ifdef _DEBUG
			assert(segment_left.rectangle_width >= segment_right.rectangle_width);
#endif
			/*....................................................................................*/

			getSubAAndBByPLA_average(original_time_series_long, segment_left, segment_right, segment_long);

			//left long, right short
			if (segment_right.right_endpoint == right_endpoint_long_original) {// long right segment is next short segment.
				segment_short_begin_next = segment_right;
				//doubly_linked_list_long[id_begin_long] = segment_right;210603
				//segment_long = segment_left;
			}
			else {//short endpoint == sub right endpoint == long right
				/*....................................................................................*/
#ifdef _DEBUG
				const Y& const segment_evaluation_2 = doubly_linked_list_short[id_segment_vector.back()];
				assert(segment_right.right_endpoint == segment_evaluation_2.right_endpoint);
#endif
				/*....................................................................................*/

				distance_SAPLA += get_distance_SAPLA_segment_by_option(type_distance, segment_right, doubly_linked_list_short[id_segment_vector.back()]);
				id_segment_vector.pop_back();
			}
			segment_long = segment_left;
			//get_id_vector_segments_equal_endpoint(original_time_series_long, left_seg, doubly_linked_list_short, id_segment_vector, distance_SAPLA);
			get_distance_SAPLA_segments_average(type_distance, original_time_series_long, right_endpoint_long_original, doubly_linked_list_short, id_segment_vector, segment_long, segment_short_begin_current, segment_short_begin_next, distance_SAPLA, number_points);
		}
		else {//left width < right width, cut first segment
			number_points += firt_width;

			segment_left.right_endpoint = segment_short_begin_current.right_endpoint;
			segment_left.rectangle_width = segment_short_begin_current.rectangle_width;

			segment_right.right_endpoint = segment_long.right_endpoint;
			segment_right.rectangle_width = segment_long.right_endpoint - segment_left.right_endpoint;

			/*.............................................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_left.rectangle_width <= segment_right.rectangle_width && firt_width == segment_short_begin_current.rectangle_width && segment_right.rectangle_width >= last_width);
#endif
			/*.............................................................................................................................................................*/

			getSubAAndBByPLA_average(original_time_series_long, segment_left, segment_right, segment_long);

			distance_SAPLA += get_distance_SAPLA_segment_by_option(type_distance, segment_left, segment_short_begin_current);

			segment_short_begin_current = doubly_linked_list_short[id_segment_vector[0]];

			id_segment_vector.erase(id_segment_vector.begin());

			segment_long = segment_right;

			get_distance_SAPLA_segments_average(type_distance, original_time_series_long, right_endpoint_long_original, doubly_linked_list_short, id_segment_vector, segment_long, segment_short_begin_current, segment_short_begin_next, distance_SAPLA, number_points);
		}
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	}

	/*................................*/
#ifdef _DEBUG
	assert(id_segment_vector.empty());
	//assert(0);
#endif
	/*...............................*/
}


//210818 Change list, 1 partition linked list. 2 minimum segment limitation
//Add long id and linekd list. //Adaptive length method: SAPLA, ICDE07, APCA. No equal length methods: PAA PAALM SAX CHEBy
TEMPLATE
template<typename T, typename Y, typename U, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
void APLA::get_distance_SAPLA_segments_210818(const T3& const option_struct, const vector<T>& const original_time_series_long, const T2 right_endpoint_long_original, const DoublyLinkedList<Y>& const doubly_linked_list_short, DoublyLinkedList<T6>& const doubly_linked_list_long, DoublyListNode<T5>& const node_long, T1& const id_segment_vector, Y& const segment_long, Y& const segment_short_begin_current, Y& const segment_short_begin_next, U& const distance_SAPLA, T4& const number_points) {
	/*....................................................................................*/
#ifdef _DEBUG
	assert(segment_short_begin_current.right_endpoint - segment_short_begin_current.rectangle_width == segment_long.right_endpoint - segment_long.rectangle_width && segment_short_begin_current.right_endpoint <= segment_long.right_endpoint);
	assert_adjacent_nodes_endpoint(node_long);
	assert_segment_equal(segment_long, node_long._value);
	assert(option_struct.type_representation > 1);
	switch (option_struct.type_representation) {
	case 3: {//APCA
		assert_endpoint_average(original_time_series_long, doubly_linked_list_long);
		break;
	}
	default:// SAPLA, ICDE07,
		assert_endpoint_a_b(original_time_series_long, doubly_linked_list_long);
		break;
	}
#endif
	/*....................................................................................*/

	int firt_width, last_width;
	Y segment_left, segment_right;

	if (id_segment_vector.empty()) {// short segment number == 1, only one short segment now. Long segment split to 2 short segments

		/*+++++++++++++++++++++++++++++  get first & last width ++++++++++++++++++++++++++++++++++++++++*/
		if (segment_short_begin_current.right_endpoint != segment_long.right_endpoint) {// right endpoints are not equal. long segment is right endpoint
			/*.................................................................*/
#ifdef _DEBUG
			assert(right_endpoint_long_original == segment_long.right_endpoint && segment_short_begin_current.right_endpoint < segment_long.right_endpoint);
#endif
			/*.................................................................*/
			
			firt_width = segment_short_begin_current.rectangle_width;
			last_width = segment_long.right_endpoint - segment_short_begin_current.right_endpoint;
			
			segment_left.right_endpoint = segment_short_begin_current.right_endpoint;
			segment_left.rectangle_width = segment_short_begin_current.rectangle_width;
			segment_right.right_endpoint = segment_long.right_endpoint;
			segment_right.rectangle_width = last_width;

			if (firt_width > last_width) {//the last segment in long segment is short, regard as new begin segment
				// endpoint, width
				number_points += last_width;
			}
			else {//left short, right long
				number_points += firt_width;
			}

			switch (option_struct.type_representation) {
			case 3: {//APCA
				getSubAAndBByPLA_average(original_time_series_long, segment_left, segment_right, segment_long);
				break;
			}
			default:// SAPLA, ICDE07,
				getSubAAndBByPLA(original_time_series_long, segment_left, segment_right, segment_long);
				break;
			}

			distance_SAPLA += get_distance_SAPLA_segment_by_option(option_struct.type_distance, segment_left, segment_short_begin_current);

			segment_short_begin_next = segment_right;// sub right in long segment

			segment_long = segment_right;
			/*=========     210831  Insert linked list   ==============*/
			node_long._value = segment_right;
			doubly_linked_list_long.insertValueBeforeNode(segment_left, node_long);
			/*==========================================================*/

			return;
		}
		else {// long segment endpoints == short segment endpoitns, and width are equal. segment_short_begin_current is left short segment.  segment_long segment is also left sub segment
			/*..........................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_short_begin_current.rectangle_width == segment_long.rectangle_width && right_endpoint_long_original > segment_long.right_endpoint && right_endpoint_long_original == segment_short_begin_next.right_endpoint);
#endif
			/*..........................................................................................................................................*/
		
			distance_SAPLA += get_distance_SAPLA_segment_by_option(option_struct.type_distance, segment_long, segment_short_begin_current);
			return;
		}
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	}
	else {// short segment number >= 2
		/*....................................................................................*/
#ifdef _DEBUG
		assert(!id_segment_vector.empty());
		const Y& const segment_evaluation_0 = doubly_linked_list_short[id_segment_vector.back()];
		const Y& const segment_evaluation_1 = doubly_linked_list_short[id_segment_vector.front()];
		assert(segment_evaluation_0.right_endpoint <= segment_long.right_endpoint && segment_short_begin_current.right_endpoint == segment_evaluation_1.right_endpoint - segment_evaluation_1.rectangle_width);
#endif
		/*....................................................................................*/

		/*+++++++++++++++++++++++++++++  get first & last width ++++++++++++++++++++++++++++++++++++++++*/
		if (doubly_linked_list_short[id_segment_vector.back()].right_endpoint != segment_long.right_endpoint) {// right endpoints are not equal
			/*....................................................................................*/
#ifdef _DEBUG
			assert(doubly_linked_list_short[id_segment_vector.back()].right_endpoint < segment_long.right_endpoint);
#endif
			/*....................................................................................*/

			last_width = segment_long.right_endpoint - doubly_linked_list_short[id_segment_vector.back()].right_endpoint;
		}
		else {// long segment endpoints == short segment endpoitns
			/*....................................................................................*/
#ifdef _DEBUG
			assert(segment_long.right_endpoint < right_endpoint_long_original);
#endif
			/*....................................................................................*/
			last_width = doubly_linked_list_short[id_segment_vector.back()].rectangle_width;
		}
		firt_width = segment_short_begin_current.rectangle_width;//left first segment
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*+++++++++++++++++++++++++++++++++++++ Compute Area ++++++++++++++++++++++++++++++++++++++++++++++*/
		if (firt_width > last_width) {//the last segment in long segment is short, regard as new begin short segment
			// endpoint, width
			number_points += last_width;

			if (doubly_linked_list_short[id_segment_vector.back()].right_endpoint != segment_long.right_endpoint) {
				segment_left.right_endpoint = doubly_linked_list_short[id_segment_vector.back()].right_endpoint;
			}
			else {// long right endpoint == short right endpoint
				if (id_segment_vector.size() > 1) {// short segment number > 2
					segment_left.right_endpoint = doubly_linked_list_short[id_segment_vector.back() - 1].right_endpoint;
				}
				else {// short segment number = 2 / 1
					segment_left.right_endpoint = segment_short_begin_current.right_endpoint;
				}
			}
			segment_left.rectangle_width = segment_long.rectangle_width - last_width;

			segment_right.right_endpoint = segment_long.right_endpoint;
			segment_right.rectangle_width = last_width;

			/*....................................................................................*/
#ifdef _DEBUG
			assert(segment_left.rectangle_width >= segment_right.rectangle_width);
#endif
			/*....................................................................................*/

			switch (option_struct.type_representation) {
			case 3: {//APCA
				getSubAAndBByPLA_average(original_time_series_long, segment_left, segment_right, segment_long);
				break;
			}
			default:// SAPLA, ICDE07,
				getSubAAndBByPLA(original_time_series_long, segment_left, segment_right, segment_long);
				break;
			}

			//left long, right short
			if (segment_right.right_endpoint == right_endpoint_long_original) {// long sub right segment is next short segment.
				segment_short_begin_next = segment_right;
			}
			else {//short endpoint == sub right endpoint == long right
				/*....................................................................................*/
#ifdef _DEBUG
				const Y& const segment_evaluation_2 = doubly_linked_list_short[id_segment_vector.back()];
				assert(segment_right.right_endpoint == segment_evaluation_2.right_endpoint);
#endif
				/*....................................................................................*/

				distance_SAPLA += get_distance_SAPLA_segment_by_option(option_struct.type_distance, segment_right, doubly_linked_list_short[id_segment_vector.back()]);
				id_segment_vector.pop_back();
			}

			segment_long = segment_left;// sub left longer than sub right

			/*=========     210831  Insert linked list   ==============*/
			node_long._value = segment_left;
			doubly_linked_list_long.insert_new_value_after_current_node(segment_right, node_long);
			/*==========================================================*/

			//get_id_vector_segments_equal_endpoint(original_time_series_long, left_seg, doubly_linked_list_short, id_segment_vector, distance_SAPLA);
			get_distance_SAPLA_segments_210818(option_struct, original_time_series_long, right_endpoint_long_original, doubly_linked_list_short, doubly_linked_list_long, node_long, id_segment_vector, segment_long, segment_short_begin_current, segment_short_begin_next, distance_SAPLA, number_points);
		}
		else {//first width < last width, cut first segment
			number_points += firt_width;

			segment_left.right_endpoint = segment_short_begin_current.right_endpoint;
			segment_left.rectangle_width = segment_short_begin_current.rectangle_width;

			segment_right.right_endpoint = segment_long.right_endpoint;
			segment_right.rectangle_width = segment_long.right_endpoint - segment_left.right_endpoint;

			/*.............................................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_left.rectangle_width <= segment_right.rectangle_width && firt_width == segment_short_begin_current.rectangle_width && segment_right.rectangle_width >= last_width);
#endif
			/*.............................................................................................................................................................*/

			switch (option_struct.type_representation) {
			case 3: {//APCA
				getSubAAndBByPLA_average(original_time_series_long, segment_left, segment_right, segment_long);
				break;
			}
			default:// SAPLA, ICDE07,
				getSubAAndBByPLA(original_time_series_long, segment_left, segment_right, segment_long);
				break;
			}

			distance_SAPLA += get_distance_SAPLA_segment_by_option(option_struct.type_distance, segment_left, segment_short_begin_current);

			segment_short_begin_current = doubly_linked_list_short[id_segment_vector.front()];

			id_segment_vector.erase(id_segment_vector.begin());

			segment_long = segment_right;//sub right  longer than sub left

			/*=========     210831  Insert linked list   ==============*/
			node_long._value = segment_right;
			doubly_linked_list_long.insertValueBeforeNode(segment_left, node_long);
			/*==========================================================*/

			get_distance_SAPLA_segments_210818(option_struct, original_time_series_long, right_endpoint_long_original, doubly_linked_list_short, doubly_linked_list_long, node_long, id_segment_vector, segment_long, segment_short_begin_current, segment_short_begin_next, distance_SAPLA, number_points);
		}
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	}

	/*................................*/
#ifdef _DEBUG
	assert(id_segment_vector.empty());
	assert_adjacent_nodes_endpoint(node_long);
	assert_segment_equal(segment_long, node_long._value);
	

	switch (option_struct.type_representation) {
	case 3: {//APCA
		assert_endpoint_average(original_time_series_long, doubly_linked_list_long);
		break;
	}
	default:// SAPLA, ICDE07,
		assert_endpoint_a_b(original_time_series_long, doubly_linked_list_long);
		break;
	}
#endif
	/*...............................*/
}

//***************************************************************
// Method:get_distance_SAPLA
// Qualifier:  Lower bound distance between SAPLA (Approximation)
// Input:
// Output:
// notice: In use
// date:210506
// author:
//***************************************************************
TEMPLATE
template<typename T, typename Y, typename U, typename T1, typename T2>
long double APLA::get_distance_SAPLA(const vector<T>& const original_time_series_vector_1, const vector<T1>& const original_time_series_vector_2, const DoublyLinkedList<Y>& const doubly_linked_list_1, const DoublyLinkedList<T2>& const doubly_linked_list_2, U& const number_points) {

	/*...........................................................................................................................................................................*/
#ifdef _DEBUG
	assert(original_time_series_vector_1.size() == original_time_series_vector_2.size() && doubly_linked_list_1.size() == doubly_linked_list_2.size());
#endif
	/*...........................................................................................................................................................................*/

	number_points = 0;
	long double number_points_query = 0;// In KNN, query time seriees do not I/O

	const size_t type_distance = 0; //0 LB distance; 1 SAPLA distance;
	int id_begin_1 = 0, id_begin_2 = 0;
	long double distance_SAPLA = 0;
	//DoublyLinkedList<Y> doubly_linked_list_1_temp, doubly_linked_list_2_temp;
	Y segment_begin_1, segment_begin_2, segment_short_begin_next;

	//doubly_linked_list_1_temp.emplace_back(doubly_linked_list_1[0]);
	//doubly_linked_list_2_temp.emplace_back(doubly_linked_list_2[0]);
	vector<int> id_segment_vector;

	//doubly_linked_list_1_temp.copy(doubly_linked_list_1);
	//doubly_linked_list_2_temp.copy(doubly_linked_list_2);

	segment_begin_1 = doubly_linked_list_1[0];
	segment_begin_2 = doubly_linked_list_2[0];

	while (segment_begin_1.right_endpoint <= doubly_linked_list_1.back().right_endpoint || segment_begin_2.right_endpoint <= doubly_linked_list_2.back().right_endpoint) {
		//while (doubly_linked_list_1_temp[id_1] < doubly_linked_list_1.size() || doubly_linked_list_2_temp[id_2] < doubly_linked_list_1.size()) {
		/*.........................................................*/
#ifdef _DEBUG
		//double right_endpoint_last_1 = get_last_segment_right_endpoint(doubly_linked_list_1_temp.getNode(id_1));
		//double right_endpoint_last_2 = get_last_segment_right_endpoint(doubly_linked_list_2_temp.getNode(id_2));
		assert(segment_begin_1.right_endpoint - segment_begin_1.rectangle_width == segment_begin_2.right_endpoint - segment_begin_2.rectangle_width);//has same left endpoint
		assert(id_segment_vector.empty());
#endif
		/*.........................................................*/

		if (segment_begin_1.right_endpoint == segment_begin_2.right_endpoint) {

			/*.........................................................*/
#ifdef _DEBUG
			assert(segment_begin_1.rectangle_width == segment_begin_2.rectangle_width);
#endif
			/*.........................................................*/

			/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
			switch (type_distance) {
			case 0:
				distance_SAPLA += get_segment_distance_LB(segment_begin_1, segment_begin_2);//is ^2
				break;
			case 1:
				//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
				distance_SAPLA += get_triangle_area(segment_begin_1, segment_begin_2);
				break;
			default:
				assert(0);
			}
			/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

			if (segment_begin_1.right_endpoint == doubly_linked_list_1.back().right_endpoint) break;

			id_begin_1++;
			id_begin_2++;
			segment_begin_1 = doubly_linked_list_1[id_begin_1];
			segment_begin_2 = doubly_linked_list_2[id_begin_2];
			continue;
		}
		else {
			// time series 1 is query time series, so we only counts pruning power for time series 2
			if (segment_begin_1.right_endpoint > segment_begin_2.right_endpoint) {// segment 1 is longer, segment 2 is short. 
				get_id_vector_short_segment(segment_begin_1, doubly_linked_list_2, id_begin_2, id_segment_vector);
				get_distance_SAPLA_segments(type_distance, original_time_series_vector_1, segment_begin_1.right_endpoint, doubly_linked_list_2, id_segment_vector, segment_begin_1, segment_begin_2, segment_short_begin_next, distance_SAPLA, number_points_query);
				segment_begin_1 = segment_short_begin_next;// long segment -> short new segment
				segment_begin_2 = doubly_linked_list_2[id_begin_2];// short segment -> long segment
			}
			else if (segment_begin_1.right_endpoint < segment_begin_2.right_endpoint) {//segment 1 is short, segment 2 is long 
				get_id_vector_short_segment(segment_begin_2, doubly_linked_list_1, id_begin_1, id_segment_vector);
				get_distance_SAPLA_segments(type_distance, original_time_series_vector_2, segment_begin_2.right_endpoint, doubly_linked_list_1, id_segment_vector, segment_begin_2, segment_begin_1, segment_short_begin_next, distance_SAPLA, number_points);
				segment_begin_1 = doubly_linked_list_1[id_begin_1];// short segment -> long segment
				segment_begin_2 = segment_short_begin_next;// long segment -> short new segment
			}
			else {
				assert(0);
			}

			//segment_begin_1 = doubly_linked_list_1[id_begin_1];210603
			//segment_begin_2 = doubly_linked_list_2[id_begin_2];
		}
	}


	/*..................................................................................................................................*/
#ifdef _DEBUG
	assert(number_points <= original_time_series_vector_1.size() * 2 && number_points >= 0 && number_points_query <= original_time_series_vector_1.size() * 2 && number_points_query >= 0);
	//cout << "Degbug distance: " << endl;
	long double distance_SAPLA_evaluation = get_distance_SAPLA_debug(original_time_series_vector_1, original_time_series_vector_2, doubly_linked_list_1, doubly_linked_list_2);

	switch (type_distance) {
	case 0:
		assert(float(sqrt(distance_SAPLA)) == float(distance_SAPLA_evaluation));
		break;
	case 1:
		//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
		assert(float(distance_SAPLA) == float(distance_SAPLA_evaluation));
		break;
	default:
		assert(0);
	}

#endif
	/*...............................................................................................................................*/
	number_points /= original_time_series_vector_1.size();

	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	switch (type_distance) {
	case 0:
		return sqrt(distance_SAPLA);
		break;
	case 1:
		//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
		return distance_SAPLA / sqrt(original_time_series_vector_1.size());
		break;
	default:
		assert(0);
	}
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
}

// 210910 // For APCA. Lower bound distance between APCA (Approximation) average distance
TEMPLATE
template<typename T, typename Y, typename U>
long double APLA::get_distance_SAPLA_average(const vector<T>& const original_time_series_vector_1, const vector<T>& const original_time_series_vector_2, const DoublyLinkedList<Y>& const doubly_linked_list_1, const DoublyLinkedList<Y>& const doubly_linked_list_2, U& const number_points) {
	/*...........................................................................................................................................................................*/
#ifdef _DEBUG
	assert(original_time_series_vector_1.size() == original_time_series_vector_2.size() && doubly_linked_list_1.size() == doubly_linked_list_2.size());
#endif
	/*...........................................................................................................................................................................*/

	number_points = 0;
	long double number_points_query = 0;// In KNN, query time seriees do not I/O

	const size_t type_distance = 0; //0 LB distance; 1 SAPLA distance;
	int id_begin_1 = 0, id_begin_2 = 0;
	long double distance_SAPLA = 0;
	//DoublyLinkedList<Y> doubly_linked_list_1_temp, doubly_linked_list_2_temp;
	Y segment_begin_1, segment_begin_2, segment_short_begin_next;

	//doubly_linked_list_1_temp.emplace_back(doubly_linked_list_1[0]);
	//doubly_linked_list_2_temp.emplace_back(doubly_linked_list_2[0]);
	vector<int> id_segment_vector;

	//doubly_linked_list_1_temp.copy(doubly_linked_list_1);
	//doubly_linked_list_2_temp.copy(doubly_linked_list_2);

	segment_begin_1 = doubly_linked_list_1[0];
	segment_begin_2 = doubly_linked_list_2[0];

	while (segment_begin_1.right_endpoint <= doubly_linked_list_1.back().right_endpoint || segment_begin_2.right_endpoint <= doubly_linked_list_2.back().right_endpoint) {
		//while (doubly_linked_list_1_temp[id_1] < doubly_linked_list_1.size() || doubly_linked_list_2_temp[id_2] < doubly_linked_list_1.size()) {
		/*.........................................................*/
#ifdef _DEBUG
		//double right_endpoint_last_1 = get_last_segment_right_endpoint(doubly_linked_list_1_temp.getNode(id_1));
		//double right_endpoint_last_2 = get_last_segment_right_endpoint(doubly_linked_list_2_temp.getNode(id_2));
		assert(segment_begin_1.right_endpoint - segment_begin_1.rectangle_width == segment_begin_2.right_endpoint - segment_begin_2.rectangle_width);//has same left endpoint
		assert(id_segment_vector.empty());
#endif
		/*.........................................................*/

		if (segment_begin_1.right_endpoint == segment_begin_2.right_endpoint) {

			/*.........................................................*/
#ifdef _DEBUG
			assert(segment_begin_1.rectangle_width == segment_begin_2.rectangle_width);
#endif
			/*.........................................................*/

			/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
			switch (type_distance) {
			case 0:
				distance_SAPLA += get_segment_distance_LB(segment_begin_1, segment_begin_2);//is ^2
				break;
			case 1:
				//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
				distance_SAPLA += get_triangle_area(segment_begin_1, segment_begin_2);
				break;
			default:
				assert(0);
			}
			/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

			if (segment_begin_1.right_endpoint == doubly_linked_list_1.back().right_endpoint) break;

			id_begin_1++;
			id_begin_2++;
			segment_begin_1 = doubly_linked_list_1[id_begin_1];
			segment_begin_2 = doubly_linked_list_2[id_begin_2];
			continue;
		}
		else {
			// time series 1 is query time series, so we only counts pruning power for time series 2
			if (segment_begin_1.right_endpoint > segment_begin_2.right_endpoint) {// segment 1 is longer, segment 2 is short. 
				get_id_vector_short_segment(segment_begin_1, doubly_linked_list_2, id_begin_2, id_segment_vector);
				get_distance_SAPLA_segments_average(type_distance, original_time_series_vector_1, segment_begin_1.right_endpoint, doubly_linked_list_2, id_segment_vector, segment_begin_1, segment_begin_2, segment_short_begin_next, distance_SAPLA, number_points_query);
				segment_begin_1 = segment_short_begin_next;// long segment -> short new segment
				segment_begin_2 = doubly_linked_list_2[id_begin_2];// short segment -> long segment
			}
			else if (segment_begin_1.right_endpoint < segment_begin_2.right_endpoint) {//segment 1 is short, segment 2 is long 
				get_id_vector_short_segment(segment_begin_2, doubly_linked_list_1, id_begin_1, id_segment_vector);
				get_distance_SAPLA_segments_average(type_distance, original_time_series_vector_2, segment_begin_2.right_endpoint, doubly_linked_list_1, id_segment_vector, segment_begin_2, segment_begin_1, segment_short_begin_next, distance_SAPLA, number_points);
				segment_begin_1 = doubly_linked_list_1[id_begin_1];// short segment -> long segment
				segment_begin_2 = segment_short_begin_next;// long segment -> short new segment
			}
			else {
				assert(0);
			}

			//segment_begin_1 = doubly_linked_list_1[id_begin_1];210603
			//segment_begin_2 = doubly_linked_list_2[id_begin_2];
		}
	}


	/*..................................................................................................................................*/
#ifdef _DEBUG
	//assert(number_points <= original_time_series_vector_1.size() * 2 && number_points >= 0 && number_points_query <= original_time_series_vector_1.size() * 2 && number_points_query >= 0);
	////cout << "Degbug distance: " << endl;
	//long double distance_SAPLA_evaluation = get_distance_SAPLA_debug(original_time_series_vector_1, original_time_series_vector_2, doubly_linked_list_1, doubly_linked_list_2);

	//switch (type_distance) {
	//case 0:
	//	assert(float(sqrt(distance_SAPLA)) == float(distance_SAPLA_evaluation));
	//	break;
	//case 1:
	//	//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
	//	assert(float(distance_SAPLA) == float(distance_SAPLA_evaluation));
	//	break;
	//default:
	//	assert(0);
	//}
	assert_endpoint_average(original_time_series_vector_1, doubly_linked_list_1);
	assert_endpoint_average(original_time_series_vector_2, doubly_linked_list_2);
#endif
	/*...............................................................................................................................*/
	number_points /= original_time_series_vector_1.size();

	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	switch (type_distance) {
	case 0:
		return sqrt(distance_SAPLA);
		break;
	case 1:
		//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
		return distance_SAPLA / sqrt(original_time_series_vector_1.size());
		break;
	default:
		assert(0);
	}
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
}


//210603
//TEMPLATE
//template<typename T, typename Y, typename U, typename T1, typename T2>
//long double APLA::get_distance_SAPLA(const vector<T>& const original_time_series_vector_1, const T1& const original_time_series_vector_id, const T2& const address, const DoublyLinkedList<Y>& const doubly_linked_list_1, const DoublyLinkedList<Y>& const doubly_linked_list_2, U& const number_points) {
//	fstream file(address);
//
//	////TOOL::GotoLine(file, f_temp_APLA_Pair.original_time_series_id);
//	file.seekg(std::ios::beg);
//	for (int i = 0; i < original_time_series_vector_id; ++i) {
//		file.ignore((std::numeric_limits<std::streamsize>::max)(), '\n');
//	}
//	string fs_row_string;
//	file >> fs_row_string;
//
//	std::vector<double> original_time_series_vector_2;
//
//	std::stringstream sstr(fs_row_string);
//	string fs_row_number;
//	int string_id = 0;// miss first point value
//	while (getline(sstr, fs_row_number, ',') && string_id < original_time_series_vector_1.size()) {
//		//original_time_series[string_id + int(single_series_length * file_id)] = stod(fs_row_number);
//		original_time_series_vector_2.emplace_back(stod(fs_row_number));
//		//assert(original_time_series[string_id] != NULL);
//
//		string_id++;
//	}
//
//	/*.........................................................*/
//#ifdef _DEBUG
//	assert(original_time_series_vector_1.size() == original_time_series_vector_2.size() && doubly_linked_list_1.size() == doubly_linked_list_2.size());
//#endif
//	/*.........................................................*/

//	number_points = 0;
//	long double number_points_query = 0;
//
//	const size_t type_distance = 0; //0 LB distance; 1 SAPLA distance;
//	int id_begin_1 = 0, id_begin_2 = 0;
//	long double distance_SAPLA = 0;
//	DoublyLinkedList<Y> doubly_linked_list_1_temp, doubly_linked_list_2_temp;
//	Y segment_begin_1, segment_begin_2;
//
//	//doubly_linked_list_1_temp.emplace_back(doubly_linked_list_1[0]);
//	//doubly_linked_list_2_temp.emplace_back(doubly_linked_list_2[0]);
//	vector<int> id_segment_vector;
//
//	doubly_linked_list_1_temp.copy(doubly_linked_list_1);
//	doubly_linked_list_2_temp.copy(doubly_linked_list_2);
//
//	segment_begin_1 = doubly_linked_list_1[0];
//	segment_begin_2 = doubly_linked_list_2[0];
//
//	while (segment_begin_1.right_endpoint <= doubly_linked_list_1.back().right_endpoint || segment_begin_2.right_endpoint <= doubly_linked_list_2.back().right_endpoint) {
//		//while (doubly_linked_list_1_temp[id_1] < doubly_linked_list_1.size() || doubly_linked_list_2_temp[id_2] < doubly_linked_list_1.size()) {
//		/*.........................................................*/
//#ifdef _DEBUG
//		//double right_endpoint_last_1 = get_last_segment_right_endpoint(doubly_linked_list_1_temp.getNode(id_1));
//		//double right_endpoint_last_2 = get_last_segment_right_endpoint(doubly_linked_list_2_temp.getNode(id_2));
//		assert(segment_begin_1.right_endpoint - segment_begin_1.rectangle_width == segment_begin_2.right_endpoint - segment_begin_2.rectangle_width);//has same left endpoint
//		assert(id_segment_vector.empty());
//#endif
//		/*.........................................................*/
//
//		if (segment_begin_1.right_endpoint == segment_begin_2.right_endpoint) {
//
//			/*.........................................................*/
//#ifdef _DEBUG
//			assert(segment_begin_1.rectangle_width == segment_begin_2.rectangle_width);
//#endif
//			/*.........................................................*/
//
//			switch (type_distance) {
//			case 0:
//				distance_SAPLA += get_segment_distance_LB(segment_begin_1, segment_begin_2);//is ^2
//				break;
//			case 1:
//				//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
//				distance_SAPLA += get_triangle_area(segment_begin_1, segment_begin_2);
//				break;
//			default:
//				assert(0);
//			}
//
//			if (segment_begin_1.right_endpoint == doubly_linked_list_1.back().right_endpoint) break;
//
//			id_begin_1++;
//			id_begin_2++;
//			segment_begin_1 = doubly_linked_list_1[id_begin_1];
//			segment_begin_2 = doubly_linked_list_2[id_begin_2];
//			continue;
//		}
//		else {
//			// time series 1 is query time series, so we only counts pruning power for time series 2
//			if (segment_begin_1.right_endpoint > segment_begin_2.right_endpoint) {// segment 1 is longer, segment 2 is short. 
//				get_id_vector_short_segment(segment_begin_1, id_begin_2, doubly_linked_list_2, id_segment_vector);
//				get_distance_SAPLA_segments(type_distance, original_time_series_vector_1, segment_begin_1.right_endpoint, segment_begin_1, doubly_linked_list_1_temp, doubly_linked_list_2_temp, id_begin_1, id_begin_2, id_segment_vector, distance_SAPLA, number_points_query);
//			}
//			else if (segment_begin_1.right_endpoint < segment_begin_2.right_endpoint) {//segment 1 is short, segment 2 is long 
//				get_id_vector_short_segment(segment_begin_2, id_begin_1, doubly_linked_list_1, id_segment_vector);
//				get_distance_SAPLA_segments(type_distance, original_time_series_vector_2, segment_begin_2.right_endpoint, segment_begin_2, doubly_linked_list_2_temp, doubly_linked_list_1_temp, id_begin_2, id_begin_1, id_segment_vector, distance_SAPLA, number_points);
//			}
//			else {
//				assert(0);
//			}
//
//			segment_begin_1 = doubly_linked_list_1_temp[id_begin_1];
//			segment_begin_2 = doubly_linked_list_2_temp[id_begin_2];
//		}
//	}
//
//
//	/*..................................................................................................................................*/
//#ifdef _DEBUG
//	assert(number_points <= original_time_series_vector_1.size() * 2 && number_points >= 0 && number_points_query <= original_time_series_vector_1.size() * 2 && number_points_query >= 0);
//	//cout << "Degbug distance: " << endl;
//	long double distance_SAPLA_evaluation = get_distance_SAPLA_debug(original_time_series_vector_1, original_time_series_vector_2, doubly_linked_list_1, doubly_linked_list_2);
//
//	switch (type_distance) {
//	case 0:
//		assert(float(sqrt(distance_SAPLA)) == float(distance_SAPLA_evaluation));
//		break;
//	case 1:
//		//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
//		assert(float(distance_SAPLA) == float(distance_SAPLA_evaluation));
//		break;
//	default:
//		assert(0);
//	}
//
//#endif
//	/*...............................................................................................................................*/
//	number_points /= original_time_series_vector_1.size();
//
//	switch (type_distance) {
//	case 0:
//		return sqrt(distance_SAPLA);
//		break;
//	case 1:
//		//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
//		return distance_SAPLA / sqrt(original_time_series_vector_1.size());
//		break;
//	default:
//		assert(0);
//	}
//}

//***************************************************************
	// Method:get_same_partition_SAPLA
	// Qualifier: get equal endpoint SAPLA approximation for 2 approximation points.  Change original linked list 
	// Input:
	// Output:
	// notice:
	// date:210622
	// author:
	//***************************************************************
TEMPLATE
template<typename T, typename Y, typename U>
void APLA::get_same_partition_SAPLA(const vector<T>& const original_time_series_vector_1, const vector<T>& const original_time_series_vector_2, DoublyLinkedList<Y>& const doubly_linked_list_1, DoublyLinkedList<Y>& const doubly_linked_list_2, U& const number_points) {
	/*...........................................................................................................................................................................*/
#ifdef _DEBUG
	assert(original_time_series_vector_1.size() == original_time_series_vector_2.size() && doubly_linked_list_1.size() == doubly_linked_list_2.size());
#endif
	/*...........................................................................................................................................................................*/

	number_points = 0;
	long double number_points_query = 0;// In KNN, query time seriees do not I/O

	const size_t type_distance = 0; //0 LB distance; 1 SAPLA distance;
	int id_begin_1 = 0, id_begin_2 = 0;
	long double distance_SAPLA = 0;
	//DoublyLinkedList<Y> doubly_linked_list_1_temp, doubly_linked_list_2_temp;
	Y segment_begin_1, segment_begin_2, segment_short_begin_next;//segment_short_begin_next: when long segment was partitioned, the rest right part is first short segment of next iteration

	vector<int> id_segment_vector;

	//doubly_linked_list_1_temp.copy(doubly_linked_list_1);
	//doubly_linked_list_2_temp.copy(doubly_linked_list_2);

	segment_begin_1 = doubly_linked_list_1[0];
	segment_begin_2 = doubly_linked_list_2[0];

	while (segment_begin_1.right_endpoint <= doubly_linked_list_1.back().right_endpoint || segment_begin_2.right_endpoint <= doubly_linked_list_2.back().right_endpoint) {
		//while (doubly_linked_list_1_temp[id_1] < doubly_linked_list_1.size() || doubly_linked_list_2_temp[id_2] < doubly_linked_list_1.size()) {
		/*.........................................................*/
#ifdef _DEBUG
		//double right_endpoint_last_1 = get_last_segment_right_endpoint(doubly_linked_list_1_temp.getNode(id_1));
		//double right_endpoint_last_2 = get_last_segment_right_endpoint(doubly_linked_list_2_temp.getNode(id_2));
		assert(segment_begin_1.right_endpoint - segment_begin_1.rectangle_width == segment_begin_2.right_endpoint - segment_begin_2.rectangle_width);//has same left endpoint
		assert(id_segment_vector.empty());
#endif
		/*.........................................................*/

		if (segment_begin_1.right_endpoint == segment_begin_2.right_endpoint) {

			/*.........................................................*/
#ifdef _DEBUG
			assert(segment_begin_1.rectangle_width == segment_begin_2.rectangle_width);
#endif
			/*.........................................................*/

			/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
			switch (type_distance) {
			case 0:
				distance_SAPLA += get_segment_distance_LB(segment_begin_1, segment_begin_2);//is ^2
				break;
			case 1:
				//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
				distance_SAPLA += get_triangle_area(segment_begin_1, segment_begin_2);
				break;
			default:
				assert(0);
			}
			/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

			if (segment_begin_1.right_endpoint == doubly_linked_list_1.back().right_endpoint) break;

			id_begin_1++;
			id_begin_2++;
			segment_begin_1 = doubly_linked_list_1[id_begin_1];
			segment_begin_2 = doubly_linked_list_2[id_begin_2];
			continue;
		}
		else {
			// time series 1 is query time series, so we only counts pruning power for time series 2, we only consider number_points, not number_points_query.
			if (segment_begin_1.right_endpoint > segment_begin_2.right_endpoint) {// segment 1 is longer, segment 2 is short. 
				// get id of short segments
				 //segment_long, id_short_begin, linked_list_short, id_segment_vec
				get_id_vector_short_segment(segment_begin_1, doubly_linked_list_2, id_begin_2, id_segment_vector);
				//ditanceLB, long time series, long segment righnt endpoint, short linked list, short id vector, long  sergment , short segment, next short segemnt,
				get_distance_SAPLA_segments(type_distance, original_time_series_vector_1, segment_begin_1.right_endpoint, doubly_linked_list_2, id_segment_vector, segment_begin_1, segment_begin_2, segment_short_begin_next, distance_SAPLA, number_points_query);
				segment_begin_1 = segment_short_begin_next;// long segment -> short new segment
				segment_begin_2 = doubly_linked_list_2[id_begin_2];// short segment -> long segment
			}
			else if (segment_begin_1.right_endpoint < segment_begin_2.right_endpoint) {//segment 1 is short, segment 2 is long
				 //segment_long, id_short_begin, linked_list_short, id_segment_vec
				get_id_vector_short_segment(segment_begin_2, doubly_linked_list_1, id_begin_1, id_segment_vector);
				get_distance_SAPLA_segments(type_distance, original_time_series_vector_2, segment_begin_2.right_endpoint, doubly_linked_list_1, id_segment_vector, segment_begin_2, segment_begin_1, segment_short_begin_next, distance_SAPLA, number_points);
				segment_begin_1 = doubly_linked_list_1[id_begin_1];// short segment -> long segment
				segment_begin_2 = segment_short_begin_next;// long segment -> short new segment
			}
			else {
				assert(0);
			}

			//segment_begin_1 = doubly_linked_list_1[id_begin_1];210603
			//segment_begin_2 = doubly_linked_list_2[id_begin_2];
		}
	}


	/*..................................................................................................................................*/
#ifdef _DEBUG
	assert_has_same_endpoints(doubly_linked_list_1, doubly_linked_list_2);//210622
	assert(number_points <= original_time_series_vector_1.size() * 2 && number_points >= 0 && number_points_query <= original_time_series_vector_1.size() * 2 && number_points_query >= 0);
	//cout << "Degbug distance: " << endl;
	long double distance_SAPLA_evaluation = get_distance_SAPLA_debug(original_time_series_vector_1, original_time_series_vector_2, doubly_linked_list_1, doubly_linked_list_2);

	switch (type_distance) {
	case 0:
		assert(float(sqrt(distance_SAPLA)) == float(distance_SAPLA_evaluation));
		break;
	case 1:
		//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
		assert(float(distance_SAPLA) == float(distance_SAPLA_evaluation));
		break;
	default:
		assert(0);
	}

#endif
	/*...............................................................................................................................*/

	number_points /= original_time_series_vector_1.size();

	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	switch (type_distance) {
	case 0:
		return sqrt(distance_SAPLA);
		break;
	case 1:
		//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
		return distance_SAPLA / sqrt(original_time_series_vector_1.size());
		break;
	default:
		assert(0);
	}
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
}

//210818 add minimum segment lenght limitation, and change linked list
TEMPLATE
template<typename T, typename Y, typename U>
long double APLA::get_same_partition_SAPLA_210818(const vector<T>& const original_time_series_vector_1, const vector<T>& const original_time_series_vector_2, DoublyLinkedList<Y>& const doubly_linked_list_1, DoublyLinkedList<Y>& const doubly_linked_list_2, U& const number_points) {
	/*....................................................................................*/
#ifdef _DEBUG
	assert(original_time_series_vector_1.size() == original_time_series_vector_2.size());
	DoublyLinkedList<Y> doubly_linked_list_1_temp, doubly_linked_list_2_temp;
	doubly_linked_list_1_temp.copy(doubly_linked_list_1);
	doubly_linked_list_2_temp.copy(doubly_linked_list_2);
#endif
	/*....................................................................................*/
	
	number_points = 0;
	long double number_points_query = 0;// In KNN, query time seriees do not I/O
	const size_t type_distance = 0; //0 LB distance; 1 SAPLA distance;
	int id_begin_1 = 0, id_begin_2 = 0, id_begin_new_1 = 0, id_begin_new_2 = 0;
	long double distance_SAPLA = 0;
	
	Y segment_begin_1, segment_begin_2, segment_short_begin_next;//segment_short_begin_next: when long segment was partitioned, the rest right part is first short segment of next loop iteration

	//doubly_linked_list_1_temp.emplace_back(doubly_linked_list_1[0]);
	//doubly_linked_list_2_temp.emplace_back(doubly_linked_list_2[0]);
	vector<int> id_segment_vector;
	segment_begin_1 = doubly_linked_list_1[0];
	segment_begin_2 = doubly_linked_list_2[0];

	while (segment_begin_1.right_endpoint <= doubly_linked_list_1.back().right_endpoint || segment_begin_2.right_endpoint <= doubly_linked_list_2.back().right_endpoint) {
		//while (doubly_linked_list_1_temp[id_1] < doubly_linked_list_1.size() || doubly_linked_list_2_temp[id_2] < doubly_linked_list_1.size()) {
		/*.............................................................*/
#ifdef _DEBUG
		//double right_endpoint_last_1 = get_last_segment_right_endpoint(doubly_linked_list_1_temp.getNode(id_1));
		//double right_endpoint_last_2 = get_last_segment_right_endpoint(doubly_linked_list_2_temp.getNode(id_2));
		assert(segment_begin_1.right_endpoint - segment_begin_1.rectangle_width == segment_begin_2.right_endpoint - segment_begin_2.rectangle_width);//has same left endpoint
		assert(id_segment_vector.empty());
#endif
		/*............................................................*/

		if (segment_begin_1.right_endpoint == segment_begin_2.right_endpoint) {

			/*.........................................................*/
#ifdef _DEBUG
			assert(segment_begin_1.rectangle_width == segment_begin_2.rectangle_width);
#endif
			/*.........................................................*/

			distance_SAPLA += get_distance_SAPLA_segment_by_option(type_distance, segment_begin_1, segment_begin_2);

			if (segment_begin_1.right_endpoint == doubly_linked_list_1.back().right_endpoint) break;

			id_begin_1++;
			id_begin_2++;
			segment_begin_1 = doubly_linked_list_1[id_begin_1];
			segment_begin_2 = doubly_linked_list_2[id_begin_2];
			continue;
		}
		else {
			OPTION_DISTANCE_STRUCT<int,int,int> option_struct(0,0,0);

			// time series 1 is query time series, so we only counts pruning power for time series 2, we only consider number_points, not number_points_query.
			if (segment_begin_1.right_endpoint > segment_begin_2.right_endpoint) {// segment 1 is longer, segment 2 is short. 
				//get id of short segments. 1 skip id of first short segment. 2 the last short segment right endpoint < long segment right endpoint, means long segment lefe short right part.
				//segment_long, id_short_begin, linked_list_short, id_segment_vec
				get_id_vector_short_segment(segment_begin_1, doubly_linked_list_2, id_begin_2, id_segment_vector);
				id_begin_new_1 = id_segment_vector.size() + 1; // new current id of long list after split and insertion
				//ditanceLB, long time series, long segment righnt endpoint, short linked list, short id vector, long sergment, short segment, next short segemnt,
				//Add long id and linekd list
				get_distance_SAPLA_segments_210818(option_struct, original_time_series_vector_1, segment_begin_1.right_endpoint, doubly_linked_list_2, doubly_linked_list_1, doubly_linked_list_1.getNode(id_begin_1), id_segment_vector, segment_begin_1, segment_begin_2, segment_short_begin_next, distance_SAPLA, number_points_query);
				/*.........................................................*/
#ifdef _DEBUG
				assertRightEndpoint_Width(doubly_linked_list_1);
				assert_a_b(original_time_series_vector_1, doubly_linked_list_1);
#endif
				/*.........................................................*/
				//get_distance_SAPLA_segments(type_distance, original_time_series_vector_1, segment_begin_1.right_endpoint, doubly_linked_list_2, id_segment_vector, segment_begin_1, segment_begin_2, segment_short_begin_next, distance_SAPLA, number_points_query);
				segment_begin_1 = segment_short_begin_next;// long segment -> short new segment
				segment_begin_2 = doubly_linked_list_2[id_begin_2];// short segment -> long segment
				id_begin_1 += id_begin_new_1;// after insertion
			}
			else if (segment_begin_1.right_endpoint < segment_begin_2.right_endpoint) {//segment 1 is short, segment 2 is long
				 //segment_long, id_short_begin, linked_list_short, id_segment_vec
				get_id_vector_short_segment(segment_begin_2, doubly_linked_list_1, id_begin_1, id_segment_vector);
				id_begin_new_2 = id_segment_vector.size() + 1;// new current id of long list after split and insertion
				get_distance_SAPLA_segments_210818(option_struct, original_time_series_vector_2, segment_begin_2.right_endpoint, doubly_linked_list_1, doubly_linked_list_2, doubly_linked_list_2.getNode(id_begin_2), id_segment_vector, segment_begin_2, segment_begin_1, segment_short_begin_next, distance_SAPLA, number_points);
				/*.........................................................*/
#ifdef _DEBUG
				assertRightEndpoint_Width(doubly_linked_list_2);
				assert_a_b(original_time_series_vector_2, doubly_linked_list_2);
#endif
				/*.........................................................*/
				//get_distance_SAPLA_segments(type_distance, original_time_series_vector_2, segment_begin_2.right_endpoint, doubly_linked_list_1, id_segment_vector, segment_begin_2, segment_begin_1, segment_short_begin_next, distance_SAPLA, number_points);
				segment_begin_1 = doubly_linked_list_1[id_begin_1];// short segment -> long segment
				segment_begin_2 = segment_short_begin_next;// long segment -> short new segment
				id_begin_2 += id_begin_new_2;// after insertion
			}
			else {
				assert(0);
			}
			//segment_begin_1 = doubly_linked_list_1[id_begin_1];210603
			//segment_begin_2 = doubly_linked_list_2[id_begin_2];
		}
	}


	/*..................................................................................................................................*/
#ifdef _DEBUG
	assert_has_same_endpoints(doubly_linked_list_1, doubly_linked_list_2);//210622
	assert(number_points <= original_time_series_vector_1.size() * 2 && number_points >= 0 && number_points_query <= original_time_series_vector_1.size() * 2 && number_points_query >= 0);
	//cout << "Degbug distance: " << endl;
	
	long double distance_SAPLA_evaluation = get_same_partition_SAPLA_debug(original_time_series_vector_1, original_time_series_vector_2, doubly_linked_list_1_temp, doubly_linked_list_2_temp);
	assert_has_same_endpoints(doubly_linked_list_1, doubly_linked_list_1_temp);

	switch (type_distance) {
	case 0:
		assert(float(sqrt(distance_SAPLA)) == float(distance_SAPLA_evaluation));
		break;
	case 1:
		//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
		assert(float(distance_SAPLA) == float(distance_SAPLA_evaluation));
		break;
	default:
		assert(0);
	}

#endif
	/*...............................................................................................................................*/

	number_points /= original_time_series_vector_1.size();

	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	switch (type_distance) {
	case 0:
		return sqrt(distance_SAPLA);
		break;
	case 1:
		//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
		return distance_SAPLA / sqrt(original_time_series_vector_1.size());
		break;
	default:
		assert(0);
	}
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
}

//210831 add minimum segment lenght limitation, and change linked list
TEMPLATE
template<typename T, typename Y, typename U, typename T1, typename T2>
long double APLA::get_same_partition_SAPLA_limit(const vector<T>& const original_time_series_vector_1, const vector<T1>& const original_time_series_vector_2, DoublyLinkedList<Y>& const doubly_linked_list_1, DoublyLinkedList<T2>& const doubly_linked_list_2, U& const number_points) {
	/*....................................................................................*/
#ifdef _DEBUG
	assert(original_time_series_vector_1.size() == original_time_series_vector_2.size());
	DoublyLinkedList<Y> doubly_linked_list_1_temp, doubly_linked_list_2_temp;
	//doubly_linked_list_1_temp.copy(doubly_linked_list_1);
	//doubly_linked_list_2_temp.copy(doubly_linked_list_2);
#endif
	/*....................................................................................*/

	OPTION_DISTANCE_STRUCT<int,int, long double> option_struct;

	const int width_min = 2;//minimal segment width >= limiation_width
	number_points = 0;
	long double number_points_query = 0;// In KNN, query time seriees do not I/O
	const size_t type_distance = 0; //0 LB distance; 1 SAPLA distance;
	int id_begin_1 = 0, id_begin_2 = 0, id_begin_new_1 = 0, id_begin_new_2 = 0;
	long double distance_SAPLA = 0;

	Y segment_begin_1, segment_begin_2, segment_short_begin_next;//segment_short_begin_next: when long segment was partitioned, the rest right part is first short segment of next loop iteration

	//doubly_linked_list_1_temp.emplace_back(doubly_linked_list_1[0]);
	//doubly_linked_list_2_temp.emplace_back(doubly_linked_list_2[0]);
	vector<int> id_segment_vector;
	segment_begin_1 = doubly_linked_list_1[0];
	segment_begin_2 = doubly_linked_list_2[0];

	while (segment_begin_1.right_endpoint <= doubly_linked_list_1.back().right_endpoint || segment_begin_2.right_endpoint <= doubly_linked_list_2.back().right_endpoint) {
		//while (doubly_linked_list_1_temp[id_1] < doubly_linked_list_1.size() || doubly_linked_list_2_temp[id_2] < doubly_linked_list_1.size()) {
		/*.............................................................*/
#ifdef _DEBUG
		//double right_endpoint_last_1 = get_last_segment_right_endpoint(doubly_linked_list_1_temp.getNode(id_1));
		//double right_endpoint_last_2 = get_last_segment_right_endpoint(doubly_linked_list_2_temp.getNode(id_2));
		assert(id_begin_1 == id_begin_2);
		assert(segment_begin_1.right_endpoint - segment_begin_1.rectangle_width == segment_begin_2.right_endpoint - segment_begin_2.rectangle_width);//has same left endpoint
		assert(id_segment_vector.empty());
		assert_list_min_width(width_min, doubly_linked_list_1);
		assert_list_min_width(width_min, doubly_linked_list_2);

#endif
		/*............................................................*/

		if (segment_begin_1.right_endpoint == segment_begin_2.right_endpoint) {

			/*.........................................................*/
#ifdef _DEBUG
			assert(segment_begin_1.rectangle_width == segment_begin_2.rectangle_width);
			assert(segment_begin_1.rectangle_width >= width_min);
			assert(id_begin_1 == id_begin_2);
#endif
			/*.........................................................*/

			distance_SAPLA += get_distance_SAPLA_segment_by_option(type_distance, segment_begin_1, segment_begin_2);

			if (segment_begin_1.right_endpoint == doubly_linked_list_1.back().right_endpoint) break;

			id_begin_1++;
			id_begin_2++;
			segment_begin_1 = doubly_linked_list_1[id_begin_1];
			segment_begin_2 = doubly_linked_list_2[id_begin_2];
			continue;
		}
		else {// segment_begin_1, segment_begin_2 have same left endpoint
			/*.........................................................*/
#ifdef _DEBUG
			assert_segment_same_left_endpoint(segment_begin_1, segment_begin_2);
			assert_list_min_width(width_min, doubly_linked_list_1);
			assert_list_min_width(width_min, doubly_linked_list_2);
			assert_segment_equal(segment_begin_1, doubly_linked_list_1[id_begin_1]);
			assert_segment_equal(segment_begin_2, doubly_linked_list_2[id_begin_2]);
			assert(id_begin_1 == id_begin_2);
#endif
			/*.........................................................*/

			OPTION_DISTANCE_STRUCT<int, int, int> option_struct(0, 0, 0);

			// time series 1 is query time series, so we only counts pruning power for time series 2, we only consider number_points, not number_points_query.
			if (segment_begin_1.right_endpoint > segment_begin_2.right_endpoint) {// segment 1 is longer, segment 2 is short. 
				//get id of short segments. 1 skip id of first short segment. 2 the last short segment right endpoint < long segment right endpoint, means long segment lefe short right part.
				//segment_long, id_short_begin, linked_list_short, id_segment_vec
				get_id_vector_short_segment(segment_begin_1, doubly_linked_list_2, id_begin_2, id_segment_vector);

				/*------------ mvoe -----------------*/
				int width_difference = segment_begin_1.right_endpoint - doubly_linked_list_2[id_begin_2 - 1].right_endpoint;
				if (width_difference < width_min) {
					id_begin_2--;
					move_merge_short_segment_no_min_width(option_struct.option_emthod, original_time_series_vector_2, width_min, width_difference, id_begin_2, doubly_linked_list_2);
					if (id_segment_vector.empty()) {
						segment_begin_2 = doubly_linked_list_2[id_begin_2];// short segment move or merged
						continue;
					}
					else {
						assert(doubly_linked_list_2[id_segment_vector.back()].right_endpoint >= segment_begin_1.right_endpoint);
						id_segment_vector.pop_back();
					}
				}

				/*----------------------------------*/

				id_begin_new_1 = id_segment_vector.size() + 1; // new current id of long list after split and insertion
				//ditanceLB, long time series, long segment righnt endpoint, short linked list, short id vector, long sergment, short segment, next short segemnt,
				//Add long id and linekd list
				get_distance_SAPLA_segments_210818(option_struct, original_time_series_vector_1, segment_begin_1.right_endpoint, doubly_linked_list_2, doubly_linked_list_1, doubly_linked_list_1.getNode(id_begin_1), id_segment_vector, segment_begin_1, segment_begin_2, segment_short_begin_next, distance_SAPLA, number_points_query);
				/*.........................................................*/
#ifdef _DEBUG
				assert_endpoint_a_b(original_time_series_vector_1, doubly_linked_list_1);
#endif
				/*.........................................................*/
				//get_distance_SAPLA_segments(type_distance, original_time_series_vector_1, segment_begin_1.right_endpoint, doubly_linked_list_2, id_segment_vector, segment_begin_1, segment_begin_2, segment_short_begin_next, distance_SAPLA, number_points_query);

				segment_begin_1 = segment_short_begin_next;// long segment -> short new segment
				segment_begin_2 = doubly_linked_list_2[id_begin_2];// short segment -> long segment
				id_begin_1 = id_begin_2;// after insertion

			}
			else if (segment_begin_1.right_endpoint < segment_begin_2.right_endpoint) {//segment 1 is short, segment 2 is long
				 //segment_long, id_short_begin, linked_list_short, id_segment_vec
				get_id_vector_short_segment(segment_begin_2, doubly_linked_list_1, id_begin_1, id_segment_vector);

				/*------------ mvoe -----------------*/
				int width_difference = segment_begin_2.right_endpoint - doubly_linked_list_1[id_begin_1 - 1].right_endpoint;
				if (width_difference < width_min) {
					id_begin_1--;
					move_merge_short_segment_no_min_width(option_struct.option_emthod, original_time_series_vector_1, width_min, width_difference, id_begin_1, doubly_linked_list_1);
					if (id_segment_vector.empty()) {
						segment_begin_1 = doubly_linked_list_1[id_begin_1];// short segment move or merged
						continue;
					}
					else {
						assert(doubly_linked_list_1[id_segment_vector.back()].right_endpoint >= segment_begin_2.right_endpoint);
						id_segment_vector.pop_back();
					}
				}

				/*----------------------------------*/

				id_begin_new_2 = id_segment_vector.size() + 1;// new current id of long list after split and insertion
				get_distance_SAPLA_segments_210818(option_struct, original_time_series_vector_2, segment_begin_2.right_endpoint, doubly_linked_list_1, doubly_linked_list_2, doubly_linked_list_2.getNode(id_begin_2), id_segment_vector, segment_begin_2, segment_begin_1, segment_short_begin_next, distance_SAPLA, number_points);
				/*.........................................................*/
#ifdef _DEBUG
				assert_endpoint_a_b(original_time_series_vector_2, doubly_linked_list_2);
#endif
				/*.........................................................*/
				//get_distance_SAPLA_segments(type_distance, original_time_series_vector_2, segment_begin_2.right_endpoint, doubly_linked_list_1, id_segment_vector, segment_begin_2, segment_begin_1, segment_short_begin_next, distance_SAPLA, number_points);
				segment_begin_1 = doubly_linked_list_1[id_begin_1];// short segment -> long segment
				segment_begin_2 = segment_short_begin_next;// long segment -> short new segment
				id_begin_2 = id_begin_1;// after insertion
			}
			else {
				assert(0);
			}
			//segment_begin_1 = doubly_linked_list_1[id_begin_1];210603
			//segment_begin_2 = doubly_linked_list_2[id_begin_2];
		}
	}
	


	/*..................................................................................................................................*/
#ifdef _DEBUG

	assert_endpoint_a_b(original_time_series_vector_1, doubly_linked_list_1);
	assert_endpoint_a_b(original_time_series_vector_2, doubly_linked_list_2);

	assert_has_same_endpoints(doubly_linked_list_1, doubly_linked_list_2);//210622
	assert(number_points <= original_time_series_vector_1.size() * 2 && number_points >= 0 && number_points_query <= original_time_series_vector_1.size() * 2 && number_points_query >= 0);
	
	assert_list_min_width(width_min, doubly_linked_list_1);
	assert_list_min_width(width_min, doubly_linked_list_2);
	//cout << "Degbug distance: " << endl;

	//long double distance_SAPLA_evaluation = get_same_partition_SAPLA_debug(original_time_series_vector_1, original_time_series_vector_2, doubly_linked_list_1_temp, doubly_linked_list_2_temp);
	//assert_has_same_endpoints(doubly_linked_list_1, doubly_linked_list_1_temp);

	//switch (type_distance) {
	//case 0:
	//	assert(float(sqrt(distance_SAPLA)) == float(distance_SAPLA_evaluation));
	//	break;
	//case 1:
		//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
	//	assert(float(distance_SAPLA) == float(distance_SAPLA_evaluation));
	//	break;
	//default:
	//	assert(0);
	//}

#endif
	/*...............................................................................................................................*/

	number_points /= original_time_series_vector_1.size();

	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	switch (type_distance) {
	case 0:
		return sqrt(distance_SAPLA);
		break;
	case 1:
		//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
		return distance_SAPLA / sqrt(original_time_series_vector_1.size());
		break;
	default:
		assert(0);
	}
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
}

//210901 add minimum segment with limitation, and change linked list, only move list 1 when smaller than min with
// SAPLA has benn sqrt
TEMPLATE
template<typename T, typename Y, typename U, typename T1, typename T2>
long double APLA::get_same_partition_SAPLA_limit_only_move_1(const vector<T>& const original_time_series_vector_1, const vector<T1>& const original_time_series_vector_2, DoublyLinkedList<Y>& const doubly_linked_list_1, DoublyLinkedList<T2>& const doubly_linked_list_2, U& const option_struct) {
	/*....................................................................................*/
#ifdef _DEBUG
	assert(original_time_series_vector_1.size() == original_time_series_vector_2.size());
	assert(option_struct.number_point == 0);
	assert(option_struct.type_distance == 0); //0 LB distance; 1 SAPLA distance;
	//assert(option_struct.type_representation == 0); //0 SAPLA / APLA / PLA / PAA / PAALM / SAX / CHEBY, 1 APCA(average)
	//DoublyLinkedList<Y> doubly_linked_list_1_temp, doubly_linked_list_2_temp;
	//TOOL::assert_option_tree(option_struct);

	if (option_struct.type_representation == 6 || option_struct.type_representation == 8) {
		assert_endpoint_a_b(original_time_series_vector_1, doubly_linked_list_1);
		assert_endpoint_a_b(original_time_series_vector_2, doubly_linked_list_2);
	}
#endif
	/*....................................................................................*/
	const int width_min = 2;//minimal segment width >= limiation_width
	
	long double number_points_query = 0;// In KNN, query time seriees do not I/O
	int id_begin_1 = 0, id_begin_2 = 0;
	long double distance_SAPLA = 0;

	Y segment_begin_1, segment_begin_2, segment_short_begin_next;//segment_short_begin_next: when long segment was partitioned, the rest right part is first short segment of next loop iteration

	vector<int> id_segment_vector;
	segment_begin_1 = doubly_linked_list_1[0];
	segment_begin_2 = doubly_linked_list_2[0];

	const int end_value = doubly_linked_list_1.back().right_endpoint;

	while (segment_begin_1.right_endpoint <= doubly_linked_list_1.back().right_endpoint || segment_begin_2.right_endpoint <= doubly_linked_list_2.back().right_endpoint) {
		//while (doubly_linked_list_1_temp[id_1] < doubly_linked_list_1.size() || doubly_linked_list_2_temp[id_2] < doubly_linked_list_1.size()) {
		/*.............................................................*/
#ifdef _DEBUG
		assert(id_begin_1 == id_begin_2);
		assert(segment_begin_1.right_endpoint - segment_begin_1.rectangle_width == segment_begin_2.right_endpoint - segment_begin_2.rectangle_width);//has same left endpoint
		assert(id_segment_vector.empty());
		assert_list_min_width(width_min, doubly_linked_list_1);
		assert_list_min_width(width_min, doubly_linked_list_2);
#endif
		/*............................................................*/

		if (segment_begin_1.right_endpoint == segment_begin_2.right_endpoint) {//PLA, PAA, CHBY, PAALM, SAX

			/*.........................................................*/
#ifdef _DEBUG
			assert(segment_begin_1.rectangle_width == segment_begin_2.rectangle_width);
			assert(segment_begin_1.rectangle_width >= width_min);
			assert(id_begin_1 == id_begin_2);
#endif
			/*.........................................................*/

			distance_SAPLA += get_distance_SAPLA_segment_by_option(option_struct.type_distance, segment_begin_1, segment_begin_2);

			if (segment_begin_1.right_endpoint == doubly_linked_list_1.back().right_endpoint) break;

			id_begin_1++;
			id_begin_2 = id_begin_1;
			segment_begin_1 = doubly_linked_list_1[id_begin_1];
			segment_begin_2 = doubly_linked_list_2[id_begin_2];
			continue;
		}
		else {// segment_begin_1, segment_begin_2 have same left endpoint
			/*.........................................................*/
#ifdef _DEBUG
			assert_segment_same_left_endpoint(segment_begin_1, segment_begin_2);
			assert_list_min_width(width_min, doubly_linked_list_1);
			assert_list_min_width(width_min, doubly_linked_list_2);
			assert_segment_equal(segment_begin_1, doubly_linked_list_1[id_begin_1]);
			assert_segment_equal(segment_begin_2, doubly_linked_list_2[id_begin_2]);
			assert(id_begin_1 == id_begin_2);
			if (option_struct.type_representation == 6 || option_struct.type_representation == 8) {
				assert_endpoint_a_b(original_time_series_vector_1, doubly_linked_list_1);
				assert_endpoint_a_b(original_time_series_vector_2, doubly_linked_list_2);
			}
#endif
			/*.........................................................*/

			// time series 1 is query time series, so we only counts pruning power for time series 2, we only consider number_points, not number_points_query.
			if (segment_begin_1.right_endpoint > segment_begin_2.right_endpoint) {// segment 1 is longer, segment 2 is short. 
				//get id of short segments. 1 skip id of first short segment. 2 the last short segment right endpoint < long segment right endpoint, means long segment lefe short right part.
				//segment_long, id_short_begin, linked_list_short, id_segment_vec
				get_id_vector_short_segment(segment_begin_1, doubly_linked_list_2, id_begin_2, id_segment_vector);

				/*------------ mvoe -----------------*/
				int width_difference = segment_begin_1.right_endpoint - doubly_linked_list_2[id_begin_2 - 1].right_endpoint;
				if (width_difference < width_min && segment_begin_1.right_endpoint != end_value) {
					id_begin_2--;
					move_merge_long_segment_no_min_width(option_struct.type_representation, original_time_series_vector_1, width_min, width_difference, id_begin_1, doubly_linked_list_1);
					segment_begin_1 = doubly_linked_list_1[id_begin_1];// short segment move or merged
					if (id_segment_vector.empty()) { continue; }
					else { id_segment_vector.pop_back();}
				}

				/*----------------------------------*/

				//ditanceLB, long time series, long segment righnt endpoint, short linked list, short id vector, long sergment, short segment, next short segemnt,
				//Add long id and linekd list
				//Adaptive length method: SAPLA, ICDE07, APCA. No equal length methods: PAA PAALM SAX CHEBy
				get_distance_SAPLA_segments_210818(option_struct, original_time_series_vector_1, segment_begin_1.right_endpoint, doubly_linked_list_2, doubly_linked_list_1, doubly_linked_list_1.getNode(id_begin_1), id_segment_vector, segment_begin_1, segment_begin_2, segment_short_begin_next, distance_SAPLA, number_points_query);
				/*.........................................................*/
#ifdef _DEBUG
				if (option_struct.type_representation == 6 || option_struct.type_representation == 8) {
					assert_endpoint_a_b(original_time_series_vector_1, doubly_linked_list_1);
					assert_endpoint_a_b(original_time_series_vector_2, doubly_linked_list_2);
				}
#endif
				/*.........................................................*/
				//get_distance_SAPLA_segments(option_struct.type_distance, original_time_series_vector_1, segment_begin_1.right_endpoint, doubly_linked_list_2, id_segment_vector, segment_begin_1, segment_begin_2, segment_short_begin_next, distance_SAPLA, number_points_query);

				segment_begin_1 = segment_short_begin_next;// long segment -> short new segment
				segment_begin_2 = doubly_linked_list_2[id_begin_2];// short segment -> long segment
				id_begin_1 = id_begin_2;// after insertion
			}
			else if (segment_begin_1.right_endpoint < segment_begin_2.right_endpoint) {//segment 1 is short, segment 2 is long
				 //segment_long, id_short_begin, linked_list_short, id_segment_vec
				get_id_vector_short_segment(segment_begin_2, doubly_linked_list_1, id_begin_1, id_segment_vector);

				/*------------ mvoe -----------------*/
				int width_difference = segment_begin_2.right_endpoint - doubly_linked_list_1[id_begin_1 - 1].right_endpoint;
				if (width_difference < width_min && segment_begin_2.right_endpoint != end_value) {
					id_begin_1--;
					/*.........................................................*/
#ifdef _DEBUG
					if(option_struct.type_representation == 6 || option_struct.type_representation == 8) {
						assert_endpoint_a_b(original_time_series_vector_1, doubly_linked_list_1);
						assert_endpoint_a_b(original_time_series_vector_2, doubly_linked_list_2);
					}
#endif
					/*.........................................................*/
					move_merge_short_segment_no_min_width(option_struct.type_representation, original_time_series_vector_1, width_min, width_difference, id_begin_1, doubly_linked_list_1);
					/*.........................................................*/
#ifdef _DEBUG
					if (option_struct.type_representation == 6 || option_struct.type_representation == 8) {
						assert_endpoint_a_b(original_time_series_vector_1, doubly_linked_list_1);
						assert_endpoint_a_b(original_time_series_vector_2, doubly_linked_list_2);
					}
#endif
					/*.........................................................*/
					if (id_segment_vector.empty()) {
						segment_begin_1 = doubly_linked_list_1[id_begin_1];// short segment move or merged
						continue;
					}
					else {
						assert(doubly_linked_list_1[id_segment_vector.back()].right_endpoint >= segment_begin_2.right_endpoint);
						id_segment_vector.pop_back();
					}
				}

				/*----------------------------------*/
				/*.........................................................*/
#ifdef _DEBUG
				if (option_struct.type_representation == 6 || option_struct.type_representation == 8) {
					assert_endpoint_a_b(original_time_series_vector_1, doubly_linked_list_1);
					assert_endpoint_a_b(original_time_series_vector_2, doubly_linked_list_2);
				}
#endif
				/*.........................................................*/

				get_distance_SAPLA_segments_210818(option_struct, original_time_series_vector_2, segment_begin_2.right_endpoint, doubly_linked_list_1, doubly_linked_list_2, doubly_linked_list_2.getNode(id_begin_2), id_segment_vector, segment_begin_2, segment_begin_1, segment_short_begin_next, distance_SAPLA, option_struct.number_point);
				/*.........................................................*/
#ifdef _DEBUG
				if (option_struct.type_representation == 6 || option_struct.type_representation == 8) {
					assert_endpoint_a_b(original_time_series_vector_1, doubly_linked_list_1);
					assert_endpoint_a_b(original_time_series_vector_2, doubly_linked_list_2);
				}
#endif
				/*.........................................................*/
				//get_distance_SAPLA_segments(option_struct.type_distance, original_time_series_vector_2, segment_begin_2.right_endpoint, doubly_linked_list_1, id_segment_vector, segment_begin_2, segment_begin_1, segment_short_begin_next, distance_SAPLA, option_struct.number_point);
				segment_begin_1 = doubly_linked_list_1[id_begin_1];// short segment -> long segment
				segment_begin_2 = segment_short_begin_next;// long segment -> short new segment
				id_begin_2 = id_begin_1;// after insertion

			}
			else {
				assert(0);
			}
		}
	}

	/*..................................................................................................................................*/
#ifdef _DEBUG

	//assert_endpoint_a_b(original_time_series_vector_1, doubly_linked_list_1);
	//assert_endpoint_a_b(original_time_series_vector_2, doubly_linked_list_2);

	if (option_struct.type_representation == 6 || option_struct.type_representation == 8) {
		assert_endpoint_a_b(original_time_series_vector_1, doubly_linked_list_1);
		assert_endpoint_a_b(original_time_series_vector_2, doubly_linked_list_2);
	}

	assert_has_same_endpoints(doubly_linked_list_1, doubly_linked_list_2);//210622
	assert(option_struct.number_point <= original_time_series_vector_1.size() * 2 && option_struct.number_point >= 0 && number_points_query <= original_time_series_vector_1.size() * 2 && number_points_query >= 0);

	assert_list_min_width(width_min, doubly_linked_list_1);
	assert_list_min_width(width_min, doubly_linked_list_2);
	long double distance_SAPLA_evaluation = APLA::get_sqrt_distance_sapla_same_endpoints(doubly_linked_list_1, doubly_linked_list_2);
	//long double distance_SAPLA_evaluation = get_same_partition_SAPLA_debug(original_time_series_vector_1, original_time_series_vector_2, doubly_linked_list_1_temp, doubly_linked_list_2_temp);
	//assert_has_same_endpoints(doubly_linked_list_1, doubly_linked_list_1_temp);

	switch (option_struct.type_distance) {
	case 0:
		assert(float(sqrtl(distance_SAPLA)) == float(distance_SAPLA_evaluation));
		break;
	case 1:
		//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
		//assert(float(distance_SAPLA) == float(distance_SAPLA_evaluation));
		break;
	default:
		assert(0);
	}

#endif
	/*...............................................................................................................................*/

	option_struct.number_point /= original_time_series_vector_1.size();

	/*~~~~~~~~~~~~~~~~~~~~~  Return Distance ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	switch (option_struct.type_distance) {
	case 0:
		return sqrtl(distance_SAPLA);
		break;
	case 1:
		assert(0);
		//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
		return distance_SAPLA / sqrtl(original_time_series_vector_1.size());
		break;
	default:
		assert(0);
	}
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
}

//2112228 Only change linked list 1, only move list 1 (query).
//TEMPLATE
//template<typename T, typename Y, typename U, typename T1, typename T2>
//long double APLA::get_same_partition_SAPLA_limit_only_project(const vector<T>& const original_time_series_vector_1, const vector<T1>& const original_time_series_vector_2, DoublyLinkedList<Y>& const doubly_linked_list_1, DoublyLinkedList<T2>& const doubly_linked_list_2, U& const option_struct) {
//	
//}

//***************************************************************
	// Method:get_same_partition_SAPLA_debug
	// Qualifier: get equal endpoint SAPLA approximation for 2 approximation points
	// Input:
	// Output:
	// notice:Brute force to get. Change original approximation point
	// date:210622
	// author:
	//***************************************************************
TEMPLATE
template<typename T, typename Y>
long double APLA::get_same_partition_SAPLA_debug(const vector<T>& const original_time_series_vector_1, const vector<T>& const original_time_series_vector_2, DoublyLinkedList<Y>& const doubly_linked_list_1, DoublyLinkedList<Y>& const doubly_linked_list_2) {
	/*..................................................................................*/
#ifdef _DEBUG
	assert(original_time_series_vector_1.size() == original_time_series_vector_2.size());
#endif
	/*..................................................................................*/

	bool compute_distance_bool = true;

	size_t type_distance = 0; //0 LB distance; 1 SAPLA distance;

	Y seg_temp_1, seg_temp_2;

	int id_1 = 0, id_2 = 0;

	long double distance_LB = 0;

	long double distance_SAPLA = 0;

	vector<int> right_endpoint_vec;

	/*++++++++++++++++++++++++++++++ get partition ID ++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	while (id_1 < doubly_linked_list_1.size() || id_2 < doubly_linked_list_2.size()) {
		if (doubly_linked_list_1[id_1].right_endpoint > doubly_linked_list_2[id_2].right_endpoint) {
			right_endpoint_vec.emplace_back(doubly_linked_list_2[id_2].right_endpoint);
			id_2++;
		}
		else if (doubly_linked_list_1[id_1].right_endpoint < doubly_linked_list_2[id_2].right_endpoint) {
			right_endpoint_vec.emplace_back(doubly_linked_list_1[id_1].right_endpoint);
			id_1++;
		}
		else {
			right_endpoint_vec.emplace_back(doubly_linked_list_1[id_1].right_endpoint);
			id_1++;
			id_2++;
		}
	}
	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	/*....................................................................................*/
#ifdef _DEBUG
	if (id_1 > 0) {
		assert(right_endpoint_vec.size() >= doubly_linked_list_1.size() && right_endpoint_vec.size() <= doubly_linked_list_1.size() * 2);
	}
#endif
	/*....................................................................................*/

	/*++++++++++++++++++++++++++++++ get partitioned segment ++++++++++++++++++++++++++++++++++++++++++++++*/
	doubly_linked_list_1.clear();
	doubly_linked_list_2.clear();

	seg_temp_1.right_endpoint = seg_temp_2.right_endpoint = right_endpoint_vec[0];
	seg_temp_1.rectangle_width = seg_temp_2.rectangle_width = seg_temp_1.right_endpoint + 1;

	doubly_linked_list_1.emplace_back(get_ab_segment(original_time_series_vector_1, seg_temp_1));
	doubly_linked_list_2.emplace_back(get_ab_segment(original_time_series_vector_2, seg_temp_2));

	if (compute_distance_bool) {
		switch (type_distance) {
		case 0:
			distance_LB += get_segment_distance_LB(seg_temp_1, seg_temp_2);//is ^2
			break;
		case 1:
			//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
			distance_SAPLA += get_triangle_area(seg_temp_1, seg_temp_2);
			break;
		default:
			assert(0);
		}
	}

	for (int id_seg = 1; id_seg < right_endpoint_vec.size(); id_seg++) {
		seg_temp_1.right_endpoint = seg_temp_2.right_endpoint = right_endpoint_vec[id_seg];
		seg_temp_1.rectangle_width = seg_temp_2.rectangle_width = seg_temp_1.right_endpoint - right_endpoint_vec[id_seg - 1];

		doubly_linked_list_1.emplace_back(get_ab_segment(original_time_series_vector_1, seg_temp_1));
		doubly_linked_list_2.emplace_back(get_ab_segment(original_time_series_vector_2, seg_temp_2));

		if (compute_distance_bool) {
			switch (type_distance) {
			case 0:
				distance_LB += get_segment_distance_LB(seg_temp_1, seg_temp_2);//is ^2
				break;
			case 1:
				//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
				distance_SAPLA += get_triangle_area(seg_temp_1, seg_temp_2);
				break;
			default:
				assert(0);
			}
		}
	}

	/*....................................................................................*/
#ifdef _DEBUG
	assert(right_endpoint_vec.size() == doubly_linked_list_1.size());
	assert_has_same_endpoints(doubly_linked_list_1, doubly_linked_list_2);//210622
#endif
	/*....................................................................................*/

	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	right_endpoint_vec.clear();
	right_endpoint_vec.shrink_to_fit();

	switch (type_distance) {
	case 0:
		return sqrt(distance_LB);
		break;
	case 1:
		return distance_SAPLA;
		break;
	default:
		assert(0);
	}
}

//***************************************************************
// Method:get_distance_SAPLA_debug
// Qualifier:  Lower bound distance between SAPLA (Approximation) Debug improved SAPLA distance
// Input:
// Output:
// notice:
// date:210518
// author:
//***************************************************************
TEMPLATE
template<typename T, typename Y>
long double APLA::get_distance_SAPLA_debug(const vector<T>& const original_time_series_vector_1, const vector<T>& const original_time_series_vector_2, const DoublyLinkedList<Y>& const doubly_linked_list_1, const DoublyLinkedList<Y>& const doubly_linked_list_2) {
	/*..........................................................................*/
#ifdef _DEBUG
	assert(original_time_series_vector_1.size() == original_time_series_vector_2.size() && doubly_linked_list_1.size() == doubly_linked_list_2.size());
#endif
	/*..........................................................................*/

	size_t type_distance = 0; //0 LB distance; 1 SAPLA distance;

	Y seg_temp_1, seg_temp_2;

	int id_1 = 0, id_2 = 0;

	long double distance_LB = 0;

	long double distance_SAPLA = 0;

	vector<int> right_endpoint_vec;

	while (id_1 < doubly_linked_list_1.size() || id_2 < doubly_linked_list_2.size()) {
		if (doubly_linked_list_1[id_1].right_endpoint > doubly_linked_list_2[id_2].right_endpoint) {
			right_endpoint_vec.emplace_back(doubly_linked_list_2[id_2].right_endpoint);
			id_2++;
		}
		else if (doubly_linked_list_1[id_1].right_endpoint < doubly_linked_list_2[id_2].right_endpoint) {
			right_endpoint_vec.emplace_back(doubly_linked_list_1[id_1].right_endpoint);
			id_1++;
		}
		else {
			right_endpoint_vec.emplace_back(doubly_linked_list_1[id_1].right_endpoint);
			id_1++;
			id_2++;
		}
	}

	/*....................................................................................*/
#ifdef _DEBUG
	if (id_1 > 0) {
		assert(right_endpoint_vec.size() >= doubly_linked_list_1.size() && right_endpoint_vec.size() <= doubly_linked_list_1.size() * 2);
	}
#endif
	/*....................................................................................*/



	seg_temp_1.right_endpoint = seg_temp_2.right_endpoint = right_endpoint_vec[0];
	seg_temp_1.rectangle_width = seg_temp_2.rectangle_width = seg_temp_1.right_endpoint + 1;

	get_ab_segment(original_time_series_vector_1, seg_temp_1);
	get_ab_segment(original_time_series_vector_2, seg_temp_2);


	switch (type_distance) {
	case 0:
		distance_LB += get_segment_distance_LB(seg_temp_1, seg_temp_2);//is ^2
		break;
	case 1:
		//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
		distance_SAPLA += get_triangle_area(seg_temp_1, seg_temp_2);
		break;
	default:
		assert(0);
	}

	for (int id_seg = 1; id_seg < right_endpoint_vec.size(); id_seg++) {
		seg_temp_1.right_endpoint = seg_temp_2.right_endpoint = right_endpoint_vec[id_seg];
		seg_temp_1.rectangle_width = seg_temp_2.rectangle_width = seg_temp_1.right_endpoint - right_endpoint_vec[id_seg - 1];

		get_ab_segment(original_time_series_vector_1, seg_temp_1);

		get_ab_segment(original_time_series_vector_2, seg_temp_2);

		switch (type_distance) {
		case 0:
			distance_LB += get_segment_distance_LB(seg_temp_1, seg_temp_2);//is ^2
			break;
		case 1:
			//cout << "Debug: " << get_triangle_area(seg_temp_1, seg_temp_2) <<endl;
			distance_SAPLA += get_triangle_area(seg_temp_1, seg_temp_2);
			break;
		default:
			assert(0);
		}
	}

	right_endpoint_vec.clear();
	right_endpoint_vec.shrink_to_fit();

	switch (type_distance) {
	case 0:
		return sqrt(distance_LB);
		break;
	case 1:
		return distance_SAPLA;
		break;
	default:
		assert(0);
	}
}

TEMPLATE
template<typename T, typename Y>
long double APLA::get_distance_SAPLA_pub(const vector<T>& const original_time_series_vector_1, const vector<T>& const original_time_series_vector_2, const DoublyLinkedList<Y>& const doubly_linked_list_1, const DoublyLinkedList<Y>& const doubly_linked_list_2) {

}

//210901
TEMPLATE
template<typename T, typename Y, typename U, typename T1, typename T2, typename T3>
void APLA::move_merge_short_segment_no_min_width(const T3& const type_representation, const vector<T>& const original_time_series_short_vector, const Y&const width_min, const U& const width_difference, const T1 id_segment_short, DoublyLinkedList<T2>& const doubly_linked_list_short) {
	/*.....................................................................*/
#ifdef _DEBUG
	assert(id_segment_short >= 0 && width_difference < width_min && width_difference > 0);
	assert_endpoint_a_b(original_time_series_short_vector, doubly_linked_list_short);
#endif
	/*.....................................................................*/

	DoublyListNode<T2>& const node_left = doubly_linked_list_short.getNode(id_segment_short);
	T2& const segment_left = node_left._value;
	T2& const segment_right = node_left._next->_value;
	
	switch (type_representation) {
	case 6: // ICDE07
	case 8:{// SAPLA, . No equal method, beacuae no need partition
		if (segment_right.rectangle_width >= width_min + width_difference) {// short segment increase right endpoint width_min-1 times
			endpoint_increase_right_adjacent_segment(original_time_series_short_vector, width_difference, segment_left, segment_right);
			/*.................................................*/
#ifdef _DEBUG
			assert(segment_right.rectangle_width >= width_min);
#endif
			/*.................................................*/
		}
		else {// MERGE current short and next short
			T2 segment_merged;

			segment_merged.rectangle_width = segment_left.rectangle_width + segment_right.rectangle_width;
			segment_merged.right_endpoint = segment_right.right_endpoint;

			getAAndBByPLAShortSegSpeed(segment_left, segment_right, segment_merged);
			segment_right = segment_merged;
			doubly_linked_list_short.removeNode(node_left);
		}

		/*.........................................................*/
#ifdef _DEBUG
		assert_endpoint_a_b(original_time_series_short_vector, doubly_linked_list_short);
#endif
		/*.........................................................*/
		break;
	}
	case 3: {//APCA
		if (segment_right.rectangle_width >= width_min + width_difference) {// short segment increase right endpoint width_min-1 times
			endpoint_increase_right_adjacent_segment_average(original_time_series_short_vector, width_difference, segment_left, segment_right);
			/*.........................................................*/
#ifdef _DEBUG
			assert(segment_right.rectangle_width >= width_min);
#endif
			/*.........................................................*/
		}
		else {// MERGE current short and next short
			T2 segment_merged;

			segment_merged.rectangle_width = segment_left.rectangle_width + segment_right.rectangle_width;
			segment_merged.right_endpoint = segment_right.right_endpoint;

			getAAndBByPLAShortSegSpeed_average(segment_left, segment_right, segment_merged);
			segment_right = segment_merged;
			doubly_linked_list_short.removeNode(node_left);
		}
		/*.........................................................*/
#ifdef _DEBUG
		assert_endpoint_a_b(original_time_series_short_vector, doubly_linked_list_short);
#endif
		/*.........................................................*/
		break;
	}
	default:
		assert(0);
	}
}

//210901 long segment decrease right endpoint with width_difference, next sement increase left
TEMPLATE
template<typename T, typename Y, typename U, typename T1, typename T2, typename T3>
void APLA::move_merge_long_segment_no_min_width(const T3& const type_representation, const vector<T>& const original_time_series_long_vector, const Y& const width_min, const U& const width_difference, const T1 id_segment_long, DoublyLinkedList<T2>& const doubly_linked_list_long) {
	/*.........................................................*/
#ifdef _DEBUG
	assert(id_segment_long >= 0 && width_difference < width_min && width_difference > 0);
#endif
	/*.........................................................*/

	DoublyListNode<T2>& const node_left = doubly_linked_list_long.getNode(id_segment_long);
	T2& const segment_left = node_left._value;
	T2& const segment_right = node_left._next->_value;

	/*.........................................................*/
#ifdef _DEBUG
	assert(segment_left.rectangle_width - width_difference >= width_min);
#endif
	/*.........................................................*/

	switch (type_representation) {
	case 6: // ICDE07
	case 8: {// SAPLA, ICDE07. No equal method, beacuae no need partition
		endpoint_decrease_right_adjacent_segment(original_time_series_long_vector, width_difference, segment_left, segment_right);
		/*.........................................................*/
#ifdef _DEBUG
		assert_endpoint_a_b(original_time_series_long_vector, doubly_linked_list_long);
#endif
		/*.........................................................*/
		break;
	}
	case 3: {//APCA
		endpoint_decrease_right_adjacent_segment_average(original_time_series_long_vector, width_difference, segment_left, segment_right);
		break;
	}
	default:
		assert(0);
	}

	assert(segment_left.rectangle_width >= width_min);
}

//210908 for APCA, elimite one point segment
TEMPLATE
template<typename T, typename Y>
void APLA::move_one_point_segment_mo_min_width_average(const vector<T>& const original_time_series_vector, DoublyLinkedList<Y>& const doubly_linked_list) {
	/*.........................................................*/
#ifdef _DEBUG
	assert_endpoint_average(original_time_series_vector, doubly_linked_list);
#endif
	/*.........................................................*/
	for (int id_segment = 0; id_segment < doubly_linked_list.size() - 1; id_segment++) {
		DoublyListNode<Y>& const node_left = doubly_linked_list.getNode(id_segment);
		Y& const segment_left = node_left._value;
		Y& const segment_right = node_left._next->_value;

		if (segment_left.rectangle_width == 1 || segment_right.rectangle_width == 1) {
			Y segment_merged;
			segment_merged.rectangle_width = segment_left.rectangle_width + segment_right.rectangle_width;
			segment_merged.right_endpoint = segment_right.right_endpoint;

			getAAndBByPLAShortSegSpeed_average(segment_left, segment_right, segment_merged);
			segment_right = segment_merged;
			doubly_linked_list.removeNode(node_left);
		}
	}

	//211217 For the last segment
	//DoublyListNode<Y>*& const node_tail = doubly_linked_list.get_tail_node();
	DoublyListNode<Y>*& const node_left = doubly_linked_list.get_tail_node()->_prev;
	Y& const segment_left = node_left->_value;
	Y& const segment_right = node_left->_next->_value;

	if (segment_right.rectangle_width == 1) {
		Y segment_merged;
		segment_merged.rectangle_width = segment_left.rectangle_width + segment_right.rectangle_width;
		segment_merged.right_endpoint = segment_right.right_endpoint;

		getAAndBByPLAShortSegSpeed_average(segment_left, segment_right, segment_merged);
		segment_right = segment_merged;
		doubly_linked_list.removeNode(*node_left);
	}

	//211217 For the last segment
	/*.........................................................*/
#ifdef _DEBUG
	assert_endpoint_average(original_time_series_vector, doubly_linked_list);
	assert_list_min_width(2, doubly_linked_list);
#endif
	/*.........................................................*/
}

TEMPLATE
//For struct Length
void APLA::getRandomEndpoint(const int& const  time_series_length, const int& const endpoint_size, set<int>& const result_endpoint_set) {//190623 get random end point
	//int data[time_series_length] = { 0 };
	assert(time_series_length >= endpoint_size && result_endpoint_set.size() == 0);
	int new_length = time_series_length - 2;
	int* data = new int[new_length];
	int i = 0, index = INF;
	for (int j = 0; j < new_length; j++) {//
		data[j] = j;
		//cout << j << ":" << data[j] << ",";
	}
	cout << endl;
	for (i = 0; i < endpoint_size - 1; i++) {
		index = rand() % (new_length - i);
		//cout << index << ":" << data[index] << ",";
		assert(index >= 0 && index < new_length);
		//cout << index << endl;
		result_endpoint_set.insert(data[index] + 1);//dataindexresult[i]
		data[index] = data[new_length - i - 1];
	}

	assert(result_endpoint_set.size() > 0);
	if (data != nullptr) {
		delete[] data;
		data = nullptr;
	}
	/*cout << "!!!!!!!!!!!!" << endl;
	for (auto&&au : result_endpoint_set) {
		cout << au << ",";
	}
	cout << endl;*/
}

//************************************
// Method:getBestEndpoint
// Qualifier:190621 compare all situation, find best result.
// date:190621
// author:
//************************************
TEMPLATE
void APLA::getBestEndpoint(typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series) {//190621 compare all situation, find best result.
	int result_size = 10;
	//int endpoint_matrix[result_size][input_argument.point_dimension] = { 0 };
	int result_number = 0;
	set<int> random_result_set;
	map<set<int>, double> endpoint_result_map;
	while (result_number < result_size && endpoint_result_map.size() <= result_size) {
		getRandomEndpoint(input_argument.time_series_length, input_argument.point_dimension, random_result_set);
		//auto int_endpoint = TOOL::transferSetToInt(random_result_set);
		if (!endpoint_result_map.count(random_result_set)) {
			endpoint_result_map.insert(pair<set<int>, double>(random_result_set, 0));
			result_number++;
		}
		random_result_set.clear();
	}
	assert(endpoint_result_map.size() > 0);
	cout << "Possible result: " << endl;
	for (auto&& au : endpoint_result_map) {
		//cout << *au.first.begin() << endl;
		for (auto&& end_point : au.first) {
			cout << end_point << ",";
		}
		cout << endl;
	}
}

//************************************
// Method:combinationUtilJumpVector
// Qualifier:190624 No adjacent combination /* arr[] ---> Input Array data[] ---> Temporary array to store current combination start & end ---> Staring and Ending indexes in arr[] index ---> Current index in data[] r ---> Size of a combination to be printed */

// date:190624
// author:
//************************************
TEMPLATE
void APLA::combinationUtilJumpVector(DataType*& const original_time_series, const vector<int>& const arr, int index, vector<int> data, int i, set<pair<double, vector<int>>>& const endpoint_collection) {//190624 No adjacent combination /* arr[] ---> Input Array data[] ---> Temporary array to store current combination start & end ---> Staring and Ending indexes in arr[] index ---> Current index in data[] r ---> Size of a combination to be printed */
	assert(!data.empty());
	// Current cobination is ready, print it
	if (index == data.size()) {
		vector< AREA_COEFFICIENT>  area_vector;
		data.push_back(input_argument.time_series_length - 1);
		area_vector.resize(data.size());
		getRightEndpointAndWidth(data, area_vector);

		//190624 get sum_deviation very fast
		auto sum_deviation = getAPLASumDeviaiton(original_time_series, area_vector);
		endpoint_collection.insert(make_pair(sum_deviation, data));
		area_vector.clear();
		area_vector.shrink_to_fit();
		/*cout << sum_deviation << ": ";
		for (int j = 0; j < data.size(); j++)
			cout << data[j] << " ";
		cout << endl;
		*/
		return;
	}

	// When no more elements are there to put in data[]
	if (i >= arr.size())
		return;

	// current is included, put next at next location
	data[index] = arr[i];
	combinationUtilJumpVector(original_time_series, arr, index + 1, data, i + 2, endpoint_collection);

	// current is excluded, replace it with next (Note that
	// i+1 is passed, but index is not changed)
	combinationUtilJumpVector(original_time_series, arr, index, data, i + 1, endpoint_collection);
}

//************************************
// Method:getAllAPLAResult
// Qualifier:190624  No adjacent combinationThe main function that prints all combinations of size r in arr[] of size n. This functio
// date:190624
// author:
//************************************
TEMPLATE
void APLA::getAllAPLAResult(DataType*& const original_time_series, const vector<int>& const arr, const int& const r, set<pair<double, vector<int>>>& const endpoint_collection) {//190624 // No adjacent combinationThe main function that prints all combinations of size r in arr[] of size n. This functio
	// A temporary array to store
	// all combination one by one
	vector<int>  data;
	data.resize(r);

	// Print all combination using
	// temprary array 'data[]'
	combinationUtilJumpVector(original_time_series, arr, 0, data, 0, endpoint_collection);
}

//************************************
// Method:combinationUtilJumpVector
// Qualifier:190626  No adjacent combination /* arr[] ---> Input Array data[] ---> Temporary array to store current combination start & end ---> Staring and Ending indexes in arr[] index ---> Current index in data[] r ---> Size of a combination to be printed */
// date:190626
// author:
//************************************
TEMPLATE
void APLA::combinationUtilJumpVector(DataType*& const original_time_series, const vector<int>& const arr, int index, vector<int> data, int i, pair<double, vector<AREA_COEFFICIENT>>& const best_endpoint_pair) { // 190626 No adjacent combination /* arr[] ---> Input Array data[] ---> Temporary array to store current combination start & end ---> Staring and Ending indexes in arr[] index ---> Current index in data[] r ---> Size of a combination to be printed */
	assert(!data.empty());
	// Current cobination is ready, print it
	if (index == data.size()) {
		vector< AREA_COEFFICIENT>  area_vector;
		data.push_back(input_argument.time_series_length - 1);
		area_vector.resize(data.size());
		getRightEndpointAndWidth(data, area_vector);

		//190624 get sum_deviation very fast
		auto sum_deviation = getAPLASumDeviaitonNoAB(original_time_series, area_vector);
		//endpoint_collection.insert(make_pair(sum_deviation, data));

		if (sum_deviation < best_endpoint_pair.first) {
			best_endpoint_pair.first = sum_deviation;
			best_endpoint_pair.second.swap(area_vector);
		}

		area_vector.clear();
		area_vector.shrink_to_fit();
		/*cout << sum_deviation << ": ";
		for (int j = 0; j < data.size(); j++)
			cout << data[j] << " ";
		cout << endl;
		*/
		assert(best_endpoint_pair.second.size() == data.size());
		return;
	}

	// When no more elements are there to put in data[]
	if (i >= arr.size())
		return;

	// current is included, put next at next location
	data[index] = arr[i];
	combinationUtilJumpVector(original_time_series, arr, index + 1, data, i + 2, best_endpoint_pair);

	// current is excluded, replace it with next (Note that
	// i+1 is passed, but index is not changed)
	combinationUtilJumpVector(original_time_series, arr, index, data, i + 1, best_endpoint_pair);
}

//************************************
// Method:combinationUtilJumpVector
// Qualifier:200811  No adjacent combination /* arr[] ---> Input Array data[] ---> Temporary array to store current combination start & end ---> Staring and Ending indexes in arr[] index ---> Current index in data[] r ---> Size of a combination to be printed */
// date:200811  use vector time series
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
void APLA::combinationUtilJumpVector(const vector<T>& const original_time_series_vector, const vector<U>& const arr, U index, vector<U> data, U i, pair<long double, vector<Y>>& const best_endpoint_pair) {//200811 No adjacent combination /* arr[] ---> Input Array data[] ---> Temporary array to store current combination start & end ---> Staring and Ending indexes in arr[] index ---> Current index in data[] r ---> Size of a combination to be printed */
	assert(!data.empty());
	// Current cobination is ready, print it
	if (index == data.size()) {
		vector< AREA_COEFFICIENT>  area_vector;
		data.push_back(input_argument.time_series_length - 1);
		area_vector.resize(data.size());
		getRightEndpointAndWidth(data, area_vector);

		//190624 get sum_deviation very fast
		auto sum_deviation = getAPLASumDeviaitonNoAB(original_time_series_vector, area_vector);
		//endpoint_collection.insert(make_pair(sum_deviation, data));

		if (sum_deviation < best_endpoint_pair.first) {
			best_endpoint_pair.first = sum_deviation;
			best_endpoint_pair.second.swap(area_vector);
		}

		area_vector.clear();
		area_vector.shrink_to_fit();
		/*cout << sum_deviation << ": ";
		for (int j = 0; j < data.size(); j++)
			cout << data[j] << " ";
		cout << endl;
		*/
		assert(best_endpoint_pair.second.size() == data.size());
		return;
	}

	// When no more elements are there to put in data[]
	if (i >= arr.size())
		return;

	// current is included, put next at next location
	data[index] = arr[i];
	combinationUtilJumpVector(original_time_series_vector, arr, index + 1, data, i + 2, best_endpoint_pair);

	// current is excluded, replace it with next (Note that
	// i+1 is passed, but index is not changed)
	combinationUtilJumpVector(original_time_series_vector, arr, index, data, i + 1, best_endpoint_pair);
}

//************************************
// Method:getBestAPLAResult
// Qualifier:190626  // No adjacent combinationThe main function that prints all combinations of size r in arr[] of size n. This function mainly uses combinationUtil()
// date:190626
// author:
//************************************
TEMPLATE
void APLA::getBestAPLAResult(DataType*& const original_time_series, const vector<int>& const arr, const int& const r, pair<double, vector<AREA_COEFFICIENT>>& const best_endpoint_pair) {//190626 // No adjacent combinationThe main function that prints all combinations of size r in arr[] of size n. This function mainly uses combinationUtil()
	// A temporary array to store
	// all combination one by one
	vector<int>  data;
	data.resize(r);

	// Print all combination using
	// temprary array 'data[]'
	combinationUtilJumpVector(original_time_series, arr, 0, data, 0, best_endpoint_pair);
}

//************************************
// Method:getBestAPLAResult
// Qualifier:200811  // No adjacent combination
//                      The main function that prints all combinations of size r in arr[] of size n. 
					//  This function mainly uses combinationUtil()
// date:200811 uset vector time series
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
void APLA::getBestAPLAResult(const vector<T>& const original_time_series_vector, const vector<U>& const arr, const U& const r, pair<long double, vector<Y>>& const best_endpoint_pair) {//190626 // No adjacent combinationThe main function that prints all combinations of size r in arr[] of size n. This function mainly uses combinationUtil()
	// A temporary array to store
	// all combination one by one
	vector<int>  data;
	data.resize(r);

	// Print all combination using
	// temprary array 'data[]'
	combinationUtilJumpVector(original_time_series_vector, arr, 0, data, 0, best_endpoint_pair);
}

//************************************
// Method:getAPLAArea5LowerBoundSpeedNoErase0
// Qualifier:190605 Speed up above algorithm
// date:190605
// author:
//************************************
TEMPLATE
void APLA::getAPLAArea5LowerBoundSpeedNoErase0(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series) {
#ifdef _DEBUG
	assert(input_argument.time_series_length % 2 == 0);//n is even
#endif

	/*===================time & count====================*/
	double loop_time = 0;
	double time1 = 0;
	double time2 = 0;
	double time3 = 0;
	double time4 = 0;
	double time5 = 0;
	double time6 = 0;
	double time7 = 0;
	double time8 = 0;
	double time9 = 0;
	double time10 = 0;//update queue time
	double time11 = 0;
	double time12 = 0;
	double time13 = 0;
	double time14 = 0;

	int while_count = 0;
	int for_count = 0;
	/*...................................................*/

	/*===================Test parameter====================*/
	int same_deviation_id_count = 0;//190515
	int diff_deviation_id_count = 0;//190515
	int total_merge_infor_count = 0;
	int deviaiton_min_max_count = 0;
	int deviation_all_count = 0;
	/*...................................................*/

	int segment_number = 2;
	int array_id = 0;
	long double lower_bound_density = INF;
	//long double max_density = INF;
	vector<AREA_COEFFICIENT> area_vector;
	AREA_COEFFICIENT temp_coefficient;
	AREA_COEFFICIENT temp_coefficient_end;//190606

	priority_queue<double> up_lower_bound_density_queue;//190328
	priority_queue<double*> pointer_up_lower_bound_density_queue;
	std::set<double> density_max_set;//190328
	DensityIncrease density_increase;//190313

	area_vector.resize(input_argument.time_series_length / 2, AREA_COEFFICIENT());
	output_argument.min_density_segment.value = INF;
	output_argument.min_density_segment.id = INF;

	//merge
	TOOL::recordStartTime(TOOL::time_record[1]);//compare percentage time
#ifdef TIME_H
	TOOL::recordStartTime(TOOL::time_record[19]);//compare percentage time
#endif
	initialRecArea0ForParallelogramArrayVector0(input_argument, original_time_series, area_vector);//190430
#ifdef TIME_H
	time9 = TOOL::recordFinishTime(TOOL::time_record[19]);
#endif

	/*...................................................*/
	lower_bound_density = output_argument.min_density_segment.value;
	//output_argument.min_density_segment.id;
#if _DEBUG
	//cout << "initial threshhold: " << lower_bound_density << endl;
#endif
	/*===========================================Loop==========================================================================*/
	while (area_vector.size() > input_argument.point_dimension) {
		int merge_count = 0;//decide when to finish for loop to erase extra vector
		while_count++;
		auto original_size = area_vector.size();
		//density_max_set.clear();
#ifdef TIME_H
		TOOL::recordStartTime(TOOL::time_record[10]);
#endif
		temp_coefficient.segment_magnitude = NULL;
		for (int vector_id = 1, vector_end_id = area_vector.size() - 1; vector_id < vector_end_id - 1 && area_vector.size() > input_argument.point_dimension; vector_id++, vector_end_id--) {
			for_count++;
#if _DEBUG
			//if(up_lower_bound_density_queue.size()>0)
			//cout <<" queue size: " << up_lower_bound_density_queue.size() << " set size: " << density_max_set.size() << endl;
#endif

#ifdef TIME_H
			TOOL::recordStartTime(TOOL::time_record[11]);
#endif
			getMergedInfor0ForParallelogram(original_time_series, area_vector, vector_id, segment_number, temp_coefficient);
			getMergedInfor0ForParallelogram(original_time_series, area_vector, vector_end_id, segment_number, temp_coefficient_end);
#ifdef TIME_H
			time3 += TOOL::recordFinishTime(TOOL::time_record[11]);
#endif

#if _DEBUG
			assert(temp_coefficient.min_point.id == area_vector[vector_id - 1].min_point.id || temp_coefficient.min_point.id == area_vector[vector_id].min_point.id);
			assert(temp_coefficient.max_point.id == area_vector[vector_id - 1].max_point.id || temp_coefficient.max_point.id == area_vector[vector_id].max_point.id);
#endif
#ifdef TIME_H
			TOOL::recordStartTime(TOOL::time_record[12]);
#endif
			//if (isSymmetry(temp_coefficient, original_time_series)) continue;
			/*if (area_vector[vector_id].apla.a / area_vector[vector_id - 1].apla.a < 0) {
				cout << area_vector[vector_id].apla.a << "    " << area_vector[vector_id - 1].apla.a << endl;
				continue;
			}*/

			/*=============================================================N=============================================================*/
			if (area_vector.size() - merge_count <= input_argument.point_dimension && area_vector.size() > input_argument.point_dimension) {
				//area_vector.erase(area_vector.begin() + left_id);
#if _DEBUG
				//cout << "End loop!!!!!!!!!!!!!!" << endl;
#endif
				break;
			}
			/*..............................................................................................................................*/
#ifdef TIME_H
			//TOOL::recordStartTime(TOOL::time_record[15]);
#endif
			/*============================================Begin merge================================================*/
			if (temp_coefficient.segment_density > lower_bound_density) {
				merge_count++;
				//mergeRectangle2(area_vector, vector_id, temp_coefficient, original_time_series);
#ifdef TIME_H
				//TOOL::recordStartTime(TOOL::time_record[14]);
#endif
				//mergeRectangle0ForParallelogram(area_vector, vector_id, temp_coefficient, original_time_series);
				/*----------------------------------------------------------*Megrge Process*------------------------------------------------------------*/

				mergeRectangle0ForParallelogramNoErase(area_vector, vector_id, segment_number, temp_coefficient, original_time_series);
				vector_id++;
#ifdef TIME_H
				//area_vector.erase(area_vector.begin() + left_id);
				//time4 += TOOL::recordFinishTime(TOOL::time_record[14]);
#endif
#if _DEBUG
				//cout << "3 after merge id: " << vector_id << " " << temp_coefficient.right_endpoint << endl;
#endif
#ifdef TIME_H
				//TOOL::recordStartTime(TOOL::time_record[17]);
#endif
				/*****************************update queue***************************************/
				if (!up_lower_bound_density_queue.empty()) {
					if (up_lower_bound_density_queue.top() > temp_coefficient.segment_density) {
						up_lower_bound_density_queue.pop();
						//up_lower_bound_density_queue.push(temp_coefficient.segment_density);
#if _DEBUG
						//assert(0);
						//cout << "Segment Density: " << temp_coefficient.segment_density << endl;
#endif
						up_lower_bound_density_queue.emplace(temp_coefficient.segment_density);
					}
				}
				/*.................................................................*/
#ifdef TIME_H
				//time7 += TOOL::recordFinishTime(TOOL::time_record[17]);
#endif
			}
			else {
#ifdef TIME_H
				//TOOL::recordStartTime(TOOL::time_record[18]);
#endif
				density_max_set.emplace_hint(density_max_set.begin(), temp_coefficient.segment_density);
#if _DEBUG
				//cout << "2 not merge, set size: " << density_max_set.size()<<" inserted density: "<< temp_coefficient.segment_density  << endl;
#endif
#ifdef TIME_H
				//time8 += TOOL::recordFinishTime(TOOL::time_record[18]);
#endif
			}
			/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
			if (area_vector.size() - merge_count <= input_argument.point_dimension && area_vector.size() > input_argument.point_dimension) {
				//area_vector.erase(area_vector.begin() + left_id);
#if _DEBUG
				//cout << "2 End loop!!!!!!!!!!!!!!" << endl;
#endif
				break;
			}
			/*============================================Begin merge================================================*/
			if (temp_coefficient_end.segment_density > lower_bound_density) {
				merge_count++;
				//mergeRectangle2(area_vector, array_end_id, temp_coefficient_end, original_time_series);
#ifdef TIME_H
				//TOOL::recordStartTime(TOOL::time_record[14]);
#endif
				//mergeRectangle0ForParallelogram(area_vector, vector_end_id, temp_coefficient_end, original_time_series);
				/*----------------------------------------------------------*Megrge Process*------------------------------------------------------------*/

				mergeRectangle0ForParallelogramNoErase(area_vector, vector_end_id, segment_number, temp_coefficient_end, original_time_series);
				vector_end_id--;
#ifdef TIME_H
				//area_vector.erase(area_vector.begin() + left_id);
				//time4 += TOOL::recordFinishTime(TOOL::time_record[14]);
#endif
#if _DEBUG
				//cout << "3 after merge id: " << vector_end_id << " " << temp_coefficient_end.right_endpoint << endl;
#endif
#ifdef TIME_H
				//TOOL::recordStartTime(TOOL::time_record[17]);
#endif
				/*****************************update queue***************************************/
				if (!up_lower_bound_density_queue.empty()) {
					if (up_lower_bound_density_queue.top() > temp_coefficient_end.segment_density) {
						up_lower_bound_density_queue.pop();
						//up_lower_bound_density_queue.push(temp_coefficient_end.segment_density);
#if _DEBUG
						//assert(0);
						//cout << "Segment Density: " << temp_coefficient_end.segment_density << endl;
#endif
						up_lower_bound_density_queue.emplace(temp_coefficient_end.segment_density);
					}
				}
				/*.................................................................*/
#ifdef TIME_H
				//time7 += TOOL::recordFinishTime(TOOL::time_record[17]);
#endif
			}
			else {
#ifdef TIME_H
				//TOOL::recordStartTime(TOOL::time_record[18]);
#endif
				density_max_set.emplace_hint(density_max_set.begin(), temp_coefficient_end.segment_density);
#if _DEBUG
				//cout << "2 not merge, set size: " << density_max_set.size()<<" inserted density: "<< temp_coefficient_end.segment_density  << endl;
#endif
#ifdef TIME_H
				//time8 += TOOL::recordFinishTime(TOOL::time_record[18]);
#endif
			}
			/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
#ifdef TIME_H
			//time11 += TOOL::recordFinishTime(TOOL::time_record[15]);
#endif
#ifdef TIME_H
			time1 += TOOL::recordFinishTime(TOOL::time_record[12]);
#endif
			/*.............................................................................................*/
		}
#if _DEBUG
		//cout << "before erase: " << area_vector.size() << endl;
#endif
#ifdef TIME_H
		loop_time += TOOL::recordFinishTime(TOOL::time_record[10]);
		TOOL::recordStartTime(TOOL::time_record[20]);//compare percentage time
		TOOL::recordStartTime(TOOL::time_record[16]);
#endif
		area_vector.erase(std::remove_if(area_vector.begin(), area_vector.end(), [](AREA_COEFFICIENT& i) { return i.right_endpoint == INF && i.rectangle_width == INF; }), area_vector.end());
#ifdef TIME_H
		time6 += TOOL::recordFinishTime(TOOL::time_record[16]);
#endif

#if _DEBUG
		//cout << "after erase: " << area_vector.size() << endl;
#endif
#ifdef TIME_H
		TOOL::recordStartTime(TOOL::time_record[13]);
#endif
		if (!up_lower_bound_density_queue.empty()) {
			lower_bound_density = up_lower_bound_density_queue.top();
			//up_lower_bound_density_queue.pop();
#if _DEBUG
			//cout << "8 queue size: " << up_lower_bound_density_queue.size() << endl;
#endif
		}
		if (original_size <= area_vector.size() || area_vector.size() <= density_max_set.size() + 1) {
			if (!up_lower_bound_density_queue.empty()) {
				up_lower_bound_density_queue.pop();
				//lower_bound_density = up_lower_bound_density_queue.top();
			}
			else {
				lower_bound_density = *(density_max_set.cbegin());
				for (auto it = density_max_set.rbegin(); up_lower_bound_density_queue.size() <= input_argument.point_dimension && it != density_max_set.rend(); ++it) {
					//up_lower_bound_density_queue.push(*it);
					up_lower_bound_density_queue.emplace(*it);
				}
			}
		}
#ifdef TIME_H
		time2 += TOOL::recordFinishTime(TOOL::time_record[13]);
		time10 += TOOL::recordFinishTime(TOOL::time_record[20]);
#endif
#if _DEBUG
		auto [min, max] = minmax_element(area_vector.begin(), area_vector.end(), density_increase);
		//cout <<"Threshhold: " <<lower_bound_density << " min density: " << min->segment_density << " max density" << max->segment_density << endl;
		//cout << " 9 vector old size: " << original_size << " vector new size: " << area_vector.size() << " queue size: " << up_lower_bound_density_queue.size() << " set size: " << density_max_set.size() << endl;
#endif
	}

	output_argument.run_time = TOOL::recordFinishTime(TOOL::time_record[1]);
	/*...........................................................................................................*/
		//cout << "APLA running Time: " << output_argument.run_time << endl;// compare percentage time
	//cout << "vector size: " << area_vector.size() << endl;
	assert(area_vector.size() == input_argument.point_dimension);
	/*========================Reconstruction====================================*/
	getAPLA(input_argument, original_time_series, area_vector);
	/*..........................................................................*/

	/*========================Write Result=================================*/
	double* temp_endpoint = new double[area_vector.size()];
	array_id = 0;
	for (auto&& i : area_vector) {
		temp_endpoint[array_id] = i.right_endpoint;
		array_id++;
	}
	TOOL::writeSingleResult("./200706AllAPLAEvaluation/APLAEndPoint181218", temp_endpoint, area_vector.size());
	array_id = 0;
	for (auto&& i : area_vector) {
		//temp_endpoint[array_id] = i.lowest_id;
		temp_endpoint[array_id] = 0;
		array_id++;
	}
	TOOL::writeSingleResult("APLAMinId181221", temp_endpoint, area_vector.size());

	array_id = 0;
	for (auto&& i : area_vector) {
		//temp_endpoint[array_id] = i.heightest_id;
		temp_endpoint[array_id] = 0;
		array_id++;
	}
	TOOL::writeSingleResult("APLAMaxId181221", temp_endpoint, area_vector.size());
	TOOL::deleteArray(temp_endpoint);
	/*..............................................................................*/

	/*====================Print vector result=======================*/
	//cout << "initial time: " << time9 << "< ***<<<< loop time: " << loop_time << " mergerd information time: " << time3 << " Merge segmnet time: " << time1 << " Change threshold id time: " << time2 << " merge operation: " << time4 << " while count: " << while_count << " for count: " << for_count << " == operation time: " << time5 << " erease time: " << time6 << " merged id time: " << time7 << " not merge time: " << time8 << endl;
	cout << "============Test================" << endl;
	cout << "Total merge count: " << total_merge_infor_count << endl;
	cout << "deviation minmax, deviation, endpoint id: " << deviation_all_count << endl;
	cout << "same deviation id: " << same_deviation_id_count << endl;
	cout << "different deviation id: " << diff_deviation_id_count << endl;
	cout << "deviation minmax id: " << deviaiton_min_max_count << endl;
	cout << "................................" << endl;
	cout << "Whole time: " << output_argument.run_time
		<< "\n 1 initial time: " << time9
		<< "\n 2 loop time: " << loop_time
		<< "\n 3 Threshhold time: " << time10
		<< "\n 2.1 mergerd information time: " << time3
		<< "\n 2.1.1 get width: " << time12
		<< "\n 2.1.2 get a&b time: " << time13
		<< "\n 2.1.3 mergerd information time: " << time14
		<< "\n 2.2 Whole merge segmnet time: " << time1
		<< "\n 2.2.0 Whole merge segmnet time: " << time11
		<< "\n 2.2.1 merge operation time: " << time4
		<< "\n 2.2.2 change queue time: " << time7
		<< "\n 2.2.3 not merge time: " << time8
		<< "\n 3.1 erease time: " << time6
		<< "\n 3.2 Change threshold time: " << time2 << endl;

	//cout << "Finish! \n size: " << area_vector.size() << endl;

	/*cout << endl << "Min: ";
	for (auto&& i : area_vector) {
		cout << i.min_point.id << " ";
	}
	cout << endl << "Max: ";
	for (auto&& i : area_vector) {
		cout << i.max_point.id << " ";
	}
	cout << endl << "Area: ";
	for (auto&& i : area_vector) {
		cout << i.rectangle_area << " ";
	}
	cout << endl;*/
	cout << "right end point: ";
	for (auto&& i : area_vector) {
		cout << i.right_endpoint << " ";
	}
	/*array_id = 0;
	cout << "parallelogram_height: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.parallelogram_height << ", ";
		array_id++;
	}
	cout << endl;*/
	/*array_id = 0;
	cout << "rectangle_width: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.rectangle_width << ", ";
		array_id++;
	}
	cout << endl;*/
	array_id = 0;
	cout << "APLA deviation: ";
	for (auto&& i : area_vector) {
		cout << array_id << ": " << i.rec_deviation << ", ";
		array_id++;
	}
	cout << endl;
	/*............................................................*/
}

//************************************
// Method:getAPLAArea5LowerBoundSpeedNoEraseArray
// Qualifier:190409 Speed up above algorithm
// date:190416
// author:
//************************************
TEMPLATE
void APLA::getAPLAArea5LowerBoundSpeedNoEraseArray(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series) {//190416
#ifdef _DEBUG
	assert(input_argument.time_series_length % 2 == 0);//n is even
#endif

	/*===================time & count====================*/
	double loop_time = 0;
	double time1 = 0;
	double time2 = 0;
	double time3 = 0;
	double time4 = 0;
	double time5 = 0;
	double time6 = 0;
	double time7 = 0;
	double time8 = 0;
	double time9 = 0;
	double time10 = 0;//update queue time
	double time11 = 0;
	double time12 = 0;
	double time13 = 0;
	double time14 = 0;

	int while_count = 0;
	int for_count = 0;
	/*...................................................*/

	int segment_number = 2;
	int array_id = 0;
	long double lower_bound_density = INF;
	int segment_size = input_argument.time_series_length / 2;
	auto total_size = segment_size;
	//long double max_density = INF;
	SEGMENT_COEFFICIENT* area_vector;
	SEGMENT_COEFFICIENT temp_coefficient;

	priority_queue<double> up_lower_bound_density_queue;//190328
	priority_queue<double*> pointer_up_lower_bound_density_queue;
	std::set<double> density_max_set;//190328
	DensityIncrease density_increase;//190313

	//initial
	//initialRecArea(input_argument, original_time_series, area_vector);//181211

	//merge
	TOOL::recordStartTime(TOOL::time_record[1]);//compare percentage time

	TOOL::recordStartTime(TOOL::time_record[19]);//compare percentage time
	initialRecArea0ForParallelogramArray(input_argument, original_time_series, area_vector);//190404
	time9 += TOOL::recordFinishTime(TOOL::time_record[19]);

	lower_bound_density = output_argument.min_density_segment.value;
	output_argument.min_density_segment.id;

	/*===========================================Loop==========================================================================*/
	while (segment_size > input_argument.point_dimension) {
		int merge_count = 0;//The number of merged segment
		while_count++;
		auto original_size = segment_size;
		density_max_set.clear();
		TOOL::recordStartTime(TOOL::time_record[10]);
		for (int vector_id = 1; vector_id < segment_size && segment_size > input_argument.point_dimension; vector_id++) {
			for_count++;
#if _DEBUG
			//cout << "1 current id: " << vector_id << ", vector size: " << area_vector.size() << endl;
			//if(up_lower_bound_density_queue.size()>0)
			//cout<< " queue size: " << up_lower_bound_density_queue.size() << " set size: " << density_max_set.size() << endl;
#endif
			TOOL::recordStartTime(TOOL::time_record[11]);
			//getMergedInfor0ForParallelogramArray(original_time_series, area_vector, vector_id, temp_coefficient);

			//////////////////////
			auto left_id = vector_id - 1;
			temp_coefficient.right_endpoint = area_vector[vector_id].right_endpoint;
			//TOOL::recordStartTime(TOOL::time_record[22]);
			getRecWidth(area_vector, vector_id, temp_coefficient);
			time12 += TOOL::recordFinishTime(TOOL::time_record[22]);

			//TOOL::recordStartTime(TOOL::time_record[23]);
			getAAndBByPLAShortSegArray(original_time_series, area_vector, vector_id, temp_coefficient);
			time13 += TOOL::recordFinishTime(TOOL::time_record[23]);
#if _DEBUG
			cout << "left deviation id: " << area_vector[left_id].deviation_point.id << " right deviation id: " << area_vector[vector_id].deviation_point.id << endl;
#endif
			//TOOL::recordStartTime(TOOL::time_record[24]);
			refreshSegmentCoefficient0ForParallelogram(original_time_series, temp_coefficient);//190404
#if _DEBUG
			cout << "merged id:" << temp_coefficient.deviation_point.id << endl;
#endif
			//time14 += TOOL::recordFinishTime(TOOL::time_record[24]);

			/////////////////
			time3 += TOOL::recordFinishTime(TOOL::time_record[11]);
			//if (isSymmetry(temp_coefficient, original_time_series)) continue;
			/*if (area_vector[vector_id].apla.a / area_vector[vector_id - 1].apla.a < 0) {
				cout << area_vector[vector_id].apla.a << "    " << area_vector[vector_id - 1].apla.a << endl;
				continue;
			}*/

			TOOL::recordStartTime(TOOL::time_record[12]);
			/*----------------------------------------------------------*==N*------------------------------------------------------------*/
			TOOL::recordStartTime(TOOL::time_record[21]);
			if (segment_size - merge_count <= input_argument.point_dimension) {
#if _DEBUG
				cout << "End loop!!!!!!!!!!!!!!" << endl;
#endif
				break;
			}
			time5 += TOOL::recordFinishTime(TOOL::time_record[21]);
			/*____________________________________________________________________________________________________________________________________________*/

			/*============================================Begin merge================================================*/
			if (temp_coefficient.segment_density > lower_bound_density) {
				TOOL::recordStartTime(TOOL::time_record[14]);
				merge_count++;//count new segment size
#if _DEBUG
				//cout << "2 pre merge id: " << vector_id<<" lower_bound_density:"<< lower_bound_density << endl;
#endif
				/*----------------------------------------------------------*Megrge Process*------------------------------------------------------------*/
				mergeRectangle0ForParallelogramNoEraseArray(area_vector, vector_id, temp_coefficient, original_time_series);
				vector_id++;
				//area_vector.erase(area_vector.begin() + left_id);
				time4 += TOOL::recordFinishTime(TOOL::time_record[14]);
#if _DEBUG
				//cout << "3 after merge id: " << vector_id << " " << temp_coefficient.right_endpoint << endl;
#endif
				TOOL::recordStartTime(TOOL::time_record[17]);
				/*****************************update queue***************************************/
				if (!up_lower_bound_density_queue.empty()) {
					if (up_lower_bound_density_queue.top() > temp_coefficient.segment_density) {
						up_lower_bound_density_queue.pop();
						up_lower_bound_density_queue.push(temp_coefficient.segment_density);
					}
				}
				/*.................................................................*/
				time7 += TOOL::recordFinishTime(TOOL::time_record[17]);
			}
			else {
				TOOL::recordStartTime(TOOL::time_record[18]);
				/*if (density_max_set.size()> input_argument.point_dimension) {
					density_max_set.erase(density_max_set.begin());
					density_max_set.insert(temp_coefficient.segment_density);
				}
				else {
					density_max_set.insert(temp_coefficient.segment_density);
				}*/

				density_max_set.insert(temp_coefficient.segment_density);
#if _DEBUG
				cout << "2 not merge, set size: " << density_max_set.size() << endl;
#endif
				time8 += TOOL::recordFinishTime(TOOL::time_record[18]);
			}

			//TOOL::recordStartTime(TOOL::time_record[21]);
			//time11 += TOOL::recordFinishTime(TOOL::time_record[21]);

			time1 += TOOL::recordFinishTime(TOOL::time_record[12]);
			/*.............................................................................................*/
		}
#if _DEBUG
		//cout << "before erase: " << area_vector.size() << endl;
#endif
		loop_time += TOOL::recordFinishTime(TOOL::time_record[10]);

		TOOL::recordStartTime(TOOL::time_record[20]);//compare percentage time
		TOOL::recordStartTime(TOOL::time_record[16]);
		std::remove_if(area_vector, area_vector + segment_size, [](SEGMENT_COEFFICIENT& i) { return i.right_endpoint == INF && i.rectangle_width == INF; });
		segment_size -= merge_count;
		time6 += TOOL::recordFinishTime(TOOL::time_record[16]);

#if _DEBUG
		//cout << "after erase: " << area_vector.size() << endl;
#endif

		TOOL::recordStartTime(TOOL::time_record[13]);
		if (!up_lower_bound_density_queue.empty()) {
			lower_bound_density = up_lower_bound_density_queue.top();
			//up_lower_bound_density_queue.pop();
#if _DEBUG
			cout << "8 queue size: " << up_lower_bound_density_queue.size() << endl;
#endif
		}

		/*if (original_size == area_vector.size()) {
			cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << endl;
			lower_bound_density = *(density_max_set.cbegin());
		}*/
		if (original_size <= segment_size || segment_size <= density_max_set.size() + 1) {
			//assert(area_vector.size() == density_max_set.size() + 1);
			//cout << "*********************************************" << endl;
			if (!up_lower_bound_density_queue.empty()) {
				up_lower_bound_density_queue.pop();
				//lower_bound_density = up_lower_bound_density_queue.top();
			}
			else {
				//cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << endl;
				lower_bound_density = *(density_max_set.cbegin());
				for (auto it = density_max_set.rbegin(); up_lower_bound_density_queue.size() <= input_argument.point_dimension && it != density_max_set.rend(); ++it) {
					up_lower_bound_density_queue.push(*it);
				}
			}
		}

		time2 += TOOL::recordFinishTime(TOOL::time_record[13]);
		time10 += TOOL::recordFinishTime(TOOL::time_record[20]);
#if _DEBUG
		//auto[min, max] = minmax_element(area_vector, area_vector+ segment_size, density_increase);
		//cout << lower_bound_density << " " << min->segment_density << " " << max->segment_density << endl;
		cout << " 9 vector old size: " << original_size << " vector new size: " << segment_size << " queue size: " << up_lower_bound_density_queue.size() << " set size: " << density_max_set.size() << endl;
#endif
	}

	output_argument.run_time = TOOL::recordFinishTime(TOOL::time_record[1]);
	/*...........................................................................................................*/
		//cout << "APLA running Time: " << output_argument.run_time << endl;// compare percentage time
		//cout << "vector size: " << area_vector.size() << endl;
	assert(segment_size == input_argument.point_dimension);
	/*========================Reconstruction====================================*/
	getAPLAArray(input_argument, original_time_series, area_vector);
	/*..........................................................................*/

	/*========================Write Result=================================*/
	double* temp_endpoint = new double[segment_size];
	array_id = 0;
	for (array_id = 0; array_id < segment_size; array_id++) {
		temp_endpoint[array_id] = area_vector[array_id].right_endpoint;
	}
	TOOL::writeSingleResult("./200706AllAPLAEvaluation/APLAEndPoint181218", temp_endpoint, segment_size);
	/*..............................................................................*/

	/*====================Print vector result=======================*/

	cout << "$$$$$$$$$$$$$$$$$$$$$ Whole t: " << output_argument.run_time
		<< " 1 initial time: " << time9
		<< " 2 loop time: " << loop_time
		<< " 3 Threshhold time: " << time10
		<< " 2.1 mergerd information time: " << time3
		<< " 2.1.1 get width: " << time12
		<< " 2.1.2 get a&b time: " << time13
		<< " 2.1.3 mergerd information time: " << time14
		<< " 2.2 Whole merge segmnet time: " << time1
		<< " 2.2.0 Whole merge segmnet time: " << time11
		<< " 2.2.1 merge operation time: " << time4
		<< " 2.2.2 change queue time: " << time7
		<< " 2.2.3 not merge time: " << time8
		<< " 3.1 erease time: " << time6
		<< " 3.2 Change threshold time: " << time2 << endl;
	/*<< " while count: " << while_count
	<< " for count: " << for_count */

	TOOL::deleteArray(area_vector);
}

//************************************
// Method:getAPLADeviation
// Qualifier:190115 try compare with deviation
// date:190115
// author:
//************************************
TEMPLATE
void APLA::getAPLADeviation(const typename TOOL::INPUT_ARGUMENT& input_argument, DataType*& const original_time_series) {//190115 try compare with deviation
	assert(input_argument.time_series_length % 2 == 0);//n is even
	int array_id = 0;
	vector<AREA_COEFFICIENT> area_vector;
	//vector<AREA_COEFFICIENT> temp_area_vector(input_argument.point_dimension);
	//vector<AREA_COEFFICIENT> insert_area_rec;
	//AREA_COEFFICIENT insert_temp;
	AreaIncreasing area_increase;//get min value
	//ParallelogramHeightIncrease height_increase;//190114
	WidthIncreasing width_increase;//190104
	DeviationIncreasing deviation_increase;//190115

	//initial
	initialRecArea(input_argument, original_time_series, area_vector);//181211

	while (area_vector.size() > input_argument.point_dimension) {
		for (int vector_id = 1; vector_id < area_vector.size() && area_vector.size() > input_argument.point_dimension; vector_id += 1) {
			if (vector_id == area_vector.size() - 1) vector_id = area_vector.size() - 2;
			cout << "vector_id: " << vector_id << endl;// << " vector size: " << area_vector.size() << endl;
			compareDeviation(area_vector, vector_id, original_time_series);//190116
			//compareAreaPercentageMinMaxDist(area_vector, vector_id, original_time_series);//181211
			//compareAreaPercentageMinMaxDistNoMove(area_vector, vector_id, original_time_series);//181211
			//compareAreaPercentage(area_vector, vector_id, original_time_series);//**********************
			//compareAreaPercentage0(area_vector, vector_id);
		}
	}
	assert(area_vector.size() == input_argument.point_dimension);

	getAPLA(input_argument, original_time_series, area_vector);

	//*********************************************write result
	double* temp_endpoint = new double[area_vector.size()];
	array_id = 0;
	for (auto&& i : area_vector) {
		temp_endpoint[array_id] = i.right_endpoint;
		array_id++;
	}
	TOOL::writeSingleResult("./200706AllAPLAEvaluation/APLAEndPoint181218", temp_endpoint, area_vector.size());

	array_id = 0;
	for (auto&& i : area_vector) {
		//temp_endpoint[array_id] = i.lowest_id;
		temp_endpoint[array_id] = 0;
		array_id++;
	}
	TOOL::writeSingleResult("APLAMinId181221", temp_endpoint, area_vector.size());

	array_id = 0;
	for (auto&& i : area_vector) {
		//temp_endpoint[array_id] = i.heightest_id;
		temp_endpoint[array_id] = 0;
		array_id++;
	}
	TOOL::writeSingleResult("APLAMaxId181221", temp_endpoint, area_vector.size());
	TOOL::deleteArray(temp_endpoint);
	//********************************************************************************
}

//************************************
// Method:getAPLASumDeviaitonNoAB
// Qualifier:190624 get sum_deviation very fast, no ab, only has right_endpoint & width
// date:190624
// author:
//************************************
TEMPLATE
double APLA::getAPLASumDeviaitonNoAB(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector) {//190624 get sum_deviation very fast
#ifdef _DEBUG
	//assert(area_vector.size() == input_argument.point_dimension);
#endif
	//reconstructed time series
	DataType* reconstruct_time_series = new DataType[input_argument.time_series_length];
	double difference = NULL;
	double sum = 0;
	double sum_deviation = NULL;

	//coefficient of equation
	//a
	double a_minuend = NULL; //(l-1)/2
	double a_divisor = NULL; //l(l-1)(l+1)
	//b
	double b_minuend = NULL; //2l-1
	double b_divisor = NULL; //l(l+1)
	double a_sum = NULL;
	double b_sum = NULL;
	double variable_id = NULL; //[0-segment_length)
	int segment_id = 0;//[0-point_dimension)
	int array_id = NULL;//time series id

	for (segment_id = 0; segment_id < area_vector.size(); segment_id++) {
		//assert
#ifdef _DEBUG
		assert(area_vector[segment_id].rectangle_width > 1);
		if (segment_id == 0)
			//if(area_vector.at(segment_id).right_endpoint>1)
			assert(area_vector[segment_id].rectangle_width == area_vector[segment_id].right_endpoint + 1);
		else {
			//cout << area_vector[segment_id].rectangle_width << " " << area_vector[segment_id].right_endpoint << " " << area_vector[segment_id - 1].right_endpoint << endl;
			assert(area_vector[segment_id].rectangle_width == area_vector[segment_id].right_endpoint - area_vector[segment_id - 1].right_endpoint);
		}
#endif
		a_minuend = (area_vector.at(segment_id).rectangle_width - 1) / 2.0;//(l-1)/2
		a_divisor = (area_vector.at(segment_id).rectangle_width - 1) * (area_vector.at(segment_id).rectangle_width + 1) * area_vector.at(segment_id).rectangle_width;//l(l-1)(l+1)
		b_minuend = 2.0 * area_vector.at(segment_id).rectangle_width - 1;//2l-1
		b_divisor = (area_vector.at(segment_id).rectangle_width + 1) * area_vector.at(segment_id).rectangle_width;//l(l+1)
#ifdef _DEBUG
		assert(a_divisor != 0);
		assert(b_divisor != 0);
#endif

		a_sum = 0;
		b_sum = 0;
		for (variable_id = 0, array_id = segment_id == 0 ? 0 : area_vector.at(segment_id - 1).right_endpoint + 1; array_id <= area_vector.at(segment_id).right_endpoint; array_id++, variable_id++) {
			a_sum += (variable_id - a_minuend) * original_time_series[array_id];
			b_sum += (b_minuend - variable_id * 3.0) * original_time_series[array_id];
		}

		area_vector[segment_id].apla.a = 12.0 * a_sum / a_divisor;
		area_vector[segment_id].apla.b = 2.0 * b_sum / b_divisor;

		//cout << "a_sum: " << a_sum << " a_divisor: " << a_divisor << endl;
		//cout << "a: " << area_vector.at(segment_id).apla.a << " b: " << area_vector.at(segment_id).apla.b << endl;

		//reconstruct APLA time series
		//variable_id = 0;
		for (variable_id = 0, array_id = segment_id == 0 ? 0 : area_vector.at(segment_id - 1).right_endpoint + 1; array_id <= area_vector.at(segment_id).right_endpoint; array_id++, variable_id++) {
			reconstruct_time_series[array_id] = area_vector[segment_id].apla.a * variable_id + area_vector[segment_id].apla.b;
			difference = fabs(reconstruct_time_series[array_id] - original_time_series[array_id]);
			sum += difference * difference;
		}

		//assert(area_vector[segment_id].rec_deviation == sqrt(temp_segment_deviation));
	}
	sum_deviation = sqrt(sum);

	/*=================================Evaluation Result=====================================================================*/
#ifdef _DEBUG
	typename TOOL::getDeviation(input_argument, original_time_series, reconstruct_time_series, output_argument);
	assert(sum_deviation == output_argument.sum_deviation);
#endif
	/*..............................................................................................................*/
	TOOL::deleteArray(reconstruct_time_series);

	return sum_deviation;
}

//************************************
// Method:getAPLASumDeviaitonNoAB
// Qualifier:190624 get sum_deviation very fast, no ab, only has right_endpoint & width
// date:190624
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
long double APLA::getAPLASumDeviaitonNoAB(const vector<T>& const original_time_series_vector, vector<Y>& const area_vector) {//200811 get sum_deviation very fast, No a,b
#ifdef _DEBUG
//assert(area_vector.size() == input_argument.point_dimension);
	assert(input_argument.time_series_length == original_time_series_vector.size());
#endif
	//reconstructed time series
	//DataType* reconstruct_time_series = new DataType[input_argument.time_series_length];
	vector<T> reconstruct_time_series_vector(original_time_series_vector.size(), INF);

	long double difference = INF;
	long double sum = 0;
	long double sum_deviation = INF;

	//coefficient of equation
	//a
	long double a_minuend = INF; //(l-1)/2
	long double a_divisor = INF; //l(l-1)(l+1)
	//b
	long double b_minuend = INF; //2l-1
	long double b_divisor = INF; //l(l+1)
	long double a_sum = INF;
	long double b_sum = INF;
	long double variable_id = INF; //[0-segment_length)
	int segment_id = 0;//[0-point_dimension)
	int array_id = INF;//time series id

	for (segment_id = 0; segment_id < area_vector.size(); segment_id++) {
		//assert
#ifdef _DEBUG
		assert(area_vector[segment_id].rectangle_width > 1);
		if (segment_id == 0)
			//if(area_vector.at(segment_id).right_endpoint>1)
			assert(area_vector[segment_id].rectangle_width == area_vector[segment_id].right_endpoint + 1);
		else {
			//cout << area_vector[segment_id].rectangle_width << " " << area_vector[segment_id].right_endpoint << " " << area_vector[segment_id - 1].right_endpoint << endl;
			assert(area_vector[segment_id].rectangle_width == area_vector[segment_id].right_endpoint - area_vector[segment_id - 1].right_endpoint);
		}
#endif
		a_minuend = (area_vector.at(segment_id).rectangle_width - 1) / 2.0;//(l-1)/2
		a_divisor = (area_vector.at(segment_id).rectangle_width - 1) * (area_vector.at(segment_id).rectangle_width + 1) * area_vector.at(segment_id).rectangle_width;//l(l-1)(l+1)
		b_minuend = 2.0 * area_vector.at(segment_id).rectangle_width - 1;//2l-1
		b_divisor = (area_vector.at(segment_id).rectangle_width + 1) * area_vector.at(segment_id).rectangle_width;//l(l+1)
#ifdef _DEBUG
		assert(a_divisor != 0);
		assert(b_divisor != 0);
#endif

		a_sum = 0;
		b_sum = 0;
		for (variable_id = 0, array_id = segment_id == 0 ? 0 : area_vector.at(segment_id - 1).right_endpoint + 1; array_id <= area_vector.at(segment_id).right_endpoint; array_id++, variable_id++) {
			a_sum += (variable_id - a_minuend) * original_time_series_vector[array_id];
			b_sum += (b_minuend - variable_id * 3.0) * original_time_series_vector[array_id];
		}

		area_vector[segment_id].apla.a = 12.0 * a_sum / a_divisor;
		area_vector[segment_id].apla.b = 2.0 * b_sum / b_divisor;

		//cout << "a_sum: " << a_sum << " a_divisor: " << a_divisor << endl;
		//cout << "a: " << area_vector.at(segment_id).apla.a << " b: " << area_vector.at(segment_id).apla.b << endl;

		//reconstruct APLA time series
		//variable_id = 0;
		for (variable_id = 0, array_id = segment_id == 0 ? 0 : area_vector.at(segment_id - 1).right_endpoint + 1; array_id <= area_vector.at(segment_id).right_endpoint; array_id++, variable_id++) {
			reconstruct_time_series_vector[array_id] = area_vector[segment_id].apla.a * variable_id + area_vector[segment_id].apla.b;
			difference = fabs(reconstruct_time_series_vector[array_id] - original_time_series_vector[array_id]);
			sum += difference * difference;
		}

		//assert(area_vector[segment_id].rec_deviation == sqrt(temp_segment_deviation));
	}
	sum_deviation = sqrt(sum);

	/*=================================Evaluation Result=====================================================================*/
//#ifdef _DEBUG
//	typename TOOL::getDeviation(input_argument, original_time_series, reconstruct_time_series, output_argument);
//	assert(sum_deviation == output_argument.sum_deviation);
//#endif
	/*========================================================================================================================*/
	//TOOL::deleteArray(reconstruct_time_series);

	reconstruct_time_series_vector.clear();
	reconstruct_time_series_vector.shrink_to_fit();

	return sum_deviation;
}

//************************************
// Method:getAPLASumDeviaiton
// Qualifier:190702 get sum_deviation very fast, already has a&b
// date:190702
// author:
//************************************
TEMPLATE
double APLA::getAPLASumDeviaiton(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector) {//190702 get sum_deviation very fast, already has a&b
#ifdef _DEBUG
	assert(area_vector.size() == input_argument.point_dimension);
#endif
	//reconstructed time series
	DataType* reconstruct_time_series = new DataType[input_argument.time_series_length];
	double difference = NULL;
	double sum = 0;
	double sum_deviation = NULL;
	//coefficient of equation

	double variable_id = NULL; //[0-segment_length)
	int segment_id = 0;//[0-point_dimension)
	int array_id = NULL;//time series id

	for (segment_id = 0; segment_id < area_vector.size(); segment_id++) {
		//assert
#ifdef _DEBUG
		assert(area_vector[segment_id].rectangle_width > 1);
		if (segment_id == 0)
			//if(area_vector.at(segment_id).right_endpoint>1)
			assert(area_vector[segment_id].rectangle_width == area_vector[segment_id].right_endpoint + 1);
		else {
			//cout << area_vector[segment_id].rectangle_width << " " << area_vector[segment_id].right_endpoint << " " << area_vector[segment_id - 1].right_endpoint << endl;
			assert(area_vector[segment_id].rectangle_width == area_vector[segment_id].right_endpoint - area_vector[segment_id - 1].right_endpoint);
		}
#endif

		//cout << "a_sum: " << a_sum << " a_divisor: " << a_divisor << endl;
		//cout << "a: " << area_vector.at(segment_id).apla.a << " b: " << area_vector.at(segment_id).apla.b << endl;

		//reconstruct APLA time series
		//variable_id = 0;
		for (variable_id = 0, array_id = segment_id == 0 ? 0 : area_vector.at(segment_id - 1).right_endpoint + 1; array_id <= area_vector.at(segment_id).right_endpoint; array_id++, variable_id++) {
			reconstruct_time_series[array_id] = area_vector[segment_id].apla.a * variable_id + area_vector[segment_id].apla.b;
			difference = fabs(reconstruct_time_series[array_id] - original_time_series[array_id]);
			sum += difference * difference;
		}

		//assert(area_vector[segment_id].rec_deviation == sqrt(temp_segment_deviation));
	}
	sum_deviation = sqrt(sum);

	/*=================================Evaluation Result=====================================================================*/
#ifdef _DEBUG
	typename TOOL::getDeviation(input_argument, original_time_series, reconstruct_time_series, output_argument);
	assert(sum_deviation == output_argument.sum_deviation);
#endif
	/*..............................................................................................................*/
	TOOL::deleteArray(reconstruct_time_series);

	return sum_deviation;
}

//************************************
// Method:getAPLASegmentDeviation
// Qualifier: Get deviation of every segment, Aleady has a&b, right_endpoint, width, sum_value
// date:190626
// author:
//************************************
TEMPLATE
void APLA::getAPLASegmentDeviation(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector) {//190626 Aleady has a&b, right_endpoint, width, sum_value
#ifdef _DEBUG
//assert(area_vector.size() == input_argument.point_dimension && input_argument.time_series_length == area_vector.back().right_endpoint + 1);
#endif
	assert(0);
	//reconstructed time series
	//DataType *reconstruct_time_series = new DataType[input_argument.time_series_length];
	//reconstruct_time_series.resize(area_vector.back().right_endpoint + 1);
	double difference = NULL;
	//double sum = 0;
	//double sum_deviation = NULL;

	//coefficient of equation
	//a
	//double a_minuend = NULL; //(l-1)/2
	//double a_divisor = NULL; //l(l-1)(l+1)
	////b
	//double b_minuend = NULL; //2l-1
	//double b_divisor = NULL; //l(l+1)
	//double a_sum = NULL;
	//double b_sum = NULL;
	double variable_id = NULL; //[0-segment_length)
	int segment_id = 0;//[0-point_dimension)
	int array_id = NULL;//time series id

	for (segment_id = 0; segment_id < area_vector.size(); segment_id++) {
		//assert
#ifdef _DEBUG
		assert(area_vector[segment_id].rectangle_width > 0 && area_vector[segment_id].apla.a != INF && area_vector[segment_id].apla.b != INF);
		if (segment_id == 0)
			//if(area_vector.at(segment_id).right_endpoint>1)
			assert(area_vector[segment_id].rectangle_width == area_vector[segment_id].right_endpoint + 1);
		else {
			//cout << area_vector[segment_id].rectangle_width << " " << area_vector[segment_id].right_endpoint << " " << area_vector[segment_id - 1].right_endpoint << endl;
			assert(area_vector[segment_id].rectangle_width == area_vector[segment_id].right_endpoint - area_vector[segment_id - 1].right_endpoint);
		}
#endif
		//		a_minuend = (area_vector.at(segment_id).rectangle_width - 1) / 2.0;//(l-1)/2
		//		a_divisor = (area_vector.at(segment_id).rectangle_width - 1)*(area_vector.at(segment_id).rectangle_width + 1)*area_vector.at(segment_id).rectangle_width;//l(l-1)(l+1)
		//		b_minuend = 2.0*area_vector.at(segment_id).rectangle_width - 1;//2l-1
		//		b_divisor = (area_vector.at(segment_id).rectangle_width + 1)*area_vector.at(segment_id).rectangle_width;//l(l+1)
		//#ifdef _DEBUG
		//		assert(a_divisor != 0);
		//		assert(b_divisor != 0);
		//#endif

				/*a_sum = 0;
				b_sum = 0;
				for (variable_id = 0, array_id = segment_id == 0 ? 0 : area_vector.at(segment_id - 1).right_endpoint + 1; array_id <= area_vector.at(segment_id).right_endpoint; array_id++, variable_id++) {
					a_sum += (variable_id - a_minuend) * original_time_series[array_id];
					b_sum += (b_minuend - variable_id * 3.0) * original_time_series[array_id];
				}

				area_vector[segment_id].apla.a = 12.0 * a_sum / a_divisor;
				area_vector[segment_id].apla.b = 2.0 * b_sum / b_divisor;*/

				//cout << "a_sum: " << a_sum << " a_divisor: " << a_divisor << endl;
				//cout << "a: " << area_vector.at(segment_id).apla.a << " b: " << area_vector.at(segment_id).apla.b << endl;

				//reconstruct APLA time series
				//variable_id = 0;
		area_vector[segment_id].rec_deviation = 0;
		for (variable_id = 0, array_id = segment_id == 0 ? 0 : area_vector[segment_id - 1].right_endpoint + 1; array_id <= area_vector[segment_id].right_endpoint; array_id++, variable_id++) {
			//reconstruct_time_series[array_id] = area_vector[segment_id].apla.a * variable_id + area_vector[segment_id].apla.b;
			//difference = fabs(reconstruct_time_series[array_id] - original_time_series[array_id]);
			//sum += difference * difference;
			area_vector[segment_id].rec_deviation += fabs(area_vector[segment_id].apla.a * variable_id + area_vector[segment_id].apla.b - original_time_series[array_id]);
		}

		//assert(area_vector[segment_id].rec_deviation == sqrt(temp_segment_deviation));
	}
	//sum_deviation = sqrt(sum);

	/*=================================Evaluation Result=====================================================================*/
//#ifdef _DEBUG
//	typename TOOL::getDeviation(input_argument, original_time_series, reconstruct_time_series, output_argument);
//	assert(sum_deviation == output_argument.sum_deviation);
//#endif
	/*..............................................................................................................*/
	//TOOL::deleteArray(reconstruct_time_series);

	//return sum_deviation;
}

//190826 Linked list
//************************************
// Method:getAPLASegmentDeviation
// Qualifier: Get deviation of every segment, Aleady has a&b, right_endpoint, width, sum_value
// date:190826
// author:
//************************************
TEMPLATE
void APLA::getAPLASegmentDeviation(DataType*& const original_time_series, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list) {//190826 Aleady has a&b, right_endpoint, width, sum_value
#ifdef _DEBUG
//assert(area_vector.size() == input_argument.point_dimension && input_argument.time_series_length == area_vector.back().right_endpoint + 1);
#endif
	assert(0);
	double difference = NULL;

	double variable_id = NULL; //[0-segment_length)
	int segment_id = 0;//[0-point_dimension)
	int array_id = NULL;//time series id

	for (segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		//assert
#ifdef _DEBUG
		assert(doubly_linked_list[segment_id].rectangle_width > 0 && doubly_linked_list[segment_id].apla.a != INF && doubly_linked_list[segment_id].apla.b != INF);
		if (segment_id == 0)
			//if(area_vector.at(segment_id).right_endpoint>1)
			assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint + 1);
		else {
			//cout << area_vector[segment_id].rectangle_width << " " << area_vector[segment_id].right_endpoint << " " << area_vector[segment_id - 1].right_endpoint << endl;
			assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint);
		}
#endif

		doubly_linked_list[segment_id].rec_deviation = 0;
		for (variable_id = 0, array_id = segment_id == 0 ? 0 : doubly_linked_list[segment_id - 1].right_endpoint + 1; array_id <= doubly_linked_list[segment_id].right_endpoint; array_id++, variable_id++) {
			//reconstruct_time_series[array_id] = area_vector[segment_id].apla.a * variable_id + area_vector[segment_id].apla.b;
			//difference = fabs(reconstruct_time_series[array_id] - original_time_series[array_id]);
			//sum += difference * difference;
			doubly_linked_list[segment_id].rec_deviation += fabs(doubly_linked_list[segment_id].apla.a * variable_id + doubly_linked_list[segment_id].apla.b - original_time_series[array_id]);
		}

		//assert(area_vector[segment_id].rec_deviation == sqrt(temp_segment_deviation));
	}
	//sum_deviation = sqrt(sum);

	/*=================================Evaluation Result=====================================================================*/
//#ifdef _DEBUG
//	typename TOOL::getDeviation(input_argument, original_time_series, reconstruct_time_series, output_argument);
//	assert(sum_deviation == output_argument.sum_deviation);
//#endif
	/*..............................................................................................................*/
	//TOOL::deleteArray(reconstruct_time_series);

	//return sum_deviation;
}

//190826 Linked list
//************************************
// Method:getAPLASegmentDeviation
// Qualifier: Add template & use vector time series. Get segment sun deviation. Get deviation of every segment, Aleady has a&b, right_endpoint, width, sum_value
// date:200303
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
void APLA::getAPLASegmentDeviation(const vector<T>& const original_time_series_vector, DoublyLinkedList<Y>& const doubly_linked_list) {//190826 Aleady has a&b, right_endpoint, width, sum_value
#ifdef _DEBUG
//assert(area_vector.size() == input_argument.point_dimension && input_argument.time_series_length == area_vector.back().right_endpoint + 1);
#endif
	double difference = NULL;

	double variable_id = NULL; //[0-segment_length)
	int segment_id = 0;//[0-point_dimension)
	int array_id = NULL;//time series id

	for (segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		//assert
#ifdef _DEBUG
		assert(doubly_linked_list[segment_id].rectangle_width > 0 && doubly_linked_list[segment_id].apla.a != INF && doubly_linked_list[segment_id].apla.b != INF);
		if (segment_id == 0)
			//if(area_vector.at(segment_id).right_endpoint>1)
			assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint + 1);
		else {
			//cout << area_vector[segment_id].rectangle_width << " " << area_vector[segment_id].right_endpoint << " " << area_vector[segment_id - 1].right_endpoint << endl;
			assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint);
		}
#endif

		doubly_linked_list[segment_id].rec_deviation = 0;
		for (variable_id = 0, array_id = segment_id == 0 ? 0 : doubly_linked_list[segment_id - 1].right_endpoint + 1; array_id <= doubly_linked_list[segment_id].right_endpoint; array_id++, variable_id++) {
			//reconstruct_time_series[array_id] = area_vector[segment_id].apla.a * variable_id + area_vector[segment_id].apla.b;
			//difference = fabs(reconstruct_time_series[array_id] - original_time_series[array_id]);
			//sum += difference * difference;
			doubly_linked_list[segment_id].rec_deviation += fabs(doubly_linked_list[segment_id].apla.a * variable_id + doubly_linked_list[segment_id].apla.b - original_time_series_vector[array_id]);
		}

		//assert(area_vector[segment_id].rec_deviation == sqrt(temp_segment_deviation));
	}

}

//200303 get one segment  (sum difference)^2  //getSegmentSumDifferenceSquare
//************************************
// Method:get_segment_difference_square
// Qualifier: already know a,b for every segment, right_endpoin and width. get differece^2 of this segment
// date:200203
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
long double APLA::get_segment_difference_square(const vector<T>& const original_time_series_vector, const Y& const temp_coefficient, U& const max_deviation_seg) {
#ifdef _DEBUG
	//assert(area_vector.size() == input_argument.point_dimension);
	assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF && temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF);
	Y test_segment = temp_coefficient;
	PLA_QUAL::getAAndBByPLASegment(original_time_series_vector, test_segment);
	assert(fabs(float(temp_coefficient.apla.a) - float(test_segment.apla.a)) <= MIN_D && float(temp_coefficient.apla.b) == float(test_segment.apla.b));
#endif

	int variable_id = NULL; //[0-segment_length)
	int array_id = 0;
	int segment_left_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	long double sum_difference = 0;
	max_deviation_seg = -INF;

#ifdef _DEBUG
	assert(segment_left_id > -1);
#endif

	for (variable_id = 0, array_id = segment_left_id; array_id <= temp_coefficient.right_endpoint; variable_id++, array_id++) {
		sum_difference += pow(temp_coefficient.apla.a * variable_id + temp_coefficient.apla.b - original_time_series_vector[array_id], 2.0);// difference ^2
		max_deviation_seg = max(max_deviation_seg, fabs(temp_coefficient.apla.a * variable_id + temp_coefficient.apla.b - original_time_series_vector[array_id]));

		/*--------------------------------------------------------------------------------------------------------------------------------------*/
#ifdef _DEBUG
		assert(sum_difference >= 0 && max_deviation_seg >= 0);
		//rescontruct_time_series.push_back(segment_pla.a * variable_id + segment_pla.b);
		//cout << segment_pla.a * variable_id + segment_pla.b << ",";
#endif
		/*--------------------------------------------------------------------------------------------------------------------------------------*/
	}
#ifdef _DEBUG
	assert(variable_id == temp_coefficient.rectangle_width && array_id == temp_coefficient.right_endpoint + 1);
#endif



	/*=================================Evaluation Result=====================================================================*/
//#ifdef _DEBUG
//	typename TOOL::getDeviation(input_argument, original_time_series, reconstruct_time_series, output_argument);
//	assert(sum_deviation == output_argument.sum_deviation);
//#endif
	/*===============================================================================================================*/
	//cout << sqrt(sum_difference) << ", ";
	//TOOL::deleteArray(reconstruct_time_series);
	return sum_difference;
}

//200303 get a&b of each segment by right endpoint and rectangle width
//************************************
// Method:get_sum_deviation_no_ab
// Qualifier: No a,b for every segment. Only know right_endpoin and width. get sum deviaton by width and right_endpoint
// date:200203
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
long double APLA::get_sum_deviation_no_ab(const vector<T>& const original_time_series_vector, const DoublyLinkedList<Y>& const doubly_linked_list) {
	//cout << "\n Each sum deviation : ";
	//#ifdef _DEBUG
	assert(original_time_series_vector.size() == doubly_linked_list.back().right_endpoint + 1);
	//#endif
	Y test_segment;
	long double max_deviation_seg = -INF;
	long double sum_deviation_square = 0;
	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		const auto& const current_segment = doubly_linked_list[segment_id];
		test_segment.right_endpoint = current_segment.right_endpoint;
		test_segment.rectangle_width = current_segment.rectangle_width;
		//get ab
		get_ab_segment(original_time_series_vector, test_segment);
		assert(test_segment.apla.a != INF && test_segment.apla.b != INF);
		// get difference^2
		sum_deviation_square += get_segment_difference_square(original_time_series_vector, test_segment, max_deviation_seg);
	}
	//cout << endl;
	return sqrt(sum_deviation_square);
}

//200327 get sume deviation & max deviation of apprxomation, No a&b of each segment.  Only know right endpoint and rectangle width
TEMPLATE
template<typename T, typename Y, typename U>
long double APLA::get_sum_deviation_no_ab(const vector<T>& const original_time_series_vector, const DoublyLinkedList<Y>& const doubly_linked_list, U& const result_collection) {
	//cout << "\n Each sum deviation : ";
	//#ifdef _DEBUG
	assert(original_time_series_vector.size() == doubly_linked_list.back().right_endpoint + 1);
	//#endif
	Y test_segment;
	long double max_deviation_seg = -INF;
	long double sum_deviation_square = 0;
	result_collection.max_deviation = 0;
	result_collection.max_deviation_multiple_width = 0;

	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		const auto& const current_segment = doubly_linked_list[segment_id];
		test_segment.right_endpoint = current_segment.right_endpoint;
		test_segment.rectangle_width = current_segment.rectangle_width;
		//get ab
		get_ab_segment(original_time_series_vector, test_segment);
		assert(test_segment.apla.a != INF && test_segment.apla.b != INF);
		// get difference^2
		sum_deviation_square += get_segment_difference_square(original_time_series_vector, test_segment, max_deviation_seg);
		assert(max_deviation_seg >= 0);
		result_collection.max_deviation += max_deviation_seg;
		result_collection.max_deviation_multiple_width += max_deviation_seg * current_segment.rectangle_width;
	}
	//cout << endl;
	result_collection.max_deviation_av = result_collection.max_deviation / double(doubly_linked_list.size());
	//result_collection.max_deviation = result_collection.max_deviation_av;

	result_collection.sum_deviation = sqrt(sum_deviation_square);
	return 	sqrt(sum_deviation_square);
}

//************************************
// Method:get_sum_deviation_no_ab
// Qualifier: get sume deviation of apprxomation, No a&b of each segment.  Only know right endpoint and rectangle width
// date:201005
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
long double APLA::get_sum_deviation_no_ab(const vector<T>& const original_time_series_vector, const vector<Y>& const approximation_vector) {
	assert(0);
	cout << "\n Each sum deviation : ";
	//#ifdef _DEBUG
	assert(original_time_series_vector.size() == approximation_vector.back().right_endpoint + 1);
	//#endif
	Y test_segment;
	long double max_deviation_seg = -INF;
	double sum_deviation_square = 0;

	for (int segment_id = 0; segment_id < approximation_vector.size(); segment_id++) {
		const auto& const current_segment = approximation_vector[segment_id];
		test_segment.right_endpoint = current_segment.right_endpoint;
		test_segment.rectangle_width = current_segment.rectangle_width;
		//get ab
		get_ab_segment(original_time_series_vector, test_segment);
		assert(test_segment.apla.a != INF && test_segment.apla.b != INF);
		// get difference^2
		sum_deviation_square += get_segment_difference_square(original_time_series_vector, test_segment, max_deviation_seg);
	}
	cout << endl;
	return sqrt(sum_deviation_square);
}

//210304
TEMPLATE
template<typename T>
long double APLA::get_sum_upper_bound(const DoublyLinkedList<T>& const doubly_linked_list) {
	long double sum_upper_bound = 0;
	for (auto&& au : doubly_linked_list) {
		sum_upper_bound += au.area_difference;
		assert(au.area_difference == au.bound.upper_bound_area);
	}

	return sum_upper_bound;
}

//************************************
// Method:getAPLAReconstructSeriesNoAB
// Qualifier: No a,b for every segment. Only know right_endpoin and width. get reconstruct time series by width and right_endpoint
// date:190625
// author:
//************************************
TEMPLATE
void APLA::getAPLAReconstructSeriesNoAB(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, vector<double>& const reconstruct_time_series) {//190625 get reconstruct series
#ifdef _DEBUG
	assert(area_vector.size() == input_argument.point_dimension && input_argument.time_series_length == area_vector.back().right_endpoint + 1);
#endif
	//reconstructed time series
	//DataType *reconstruct_time_series = new DataType[input_argument.time_series_length];
	reconstruct_time_series.resize(area_vector.back().right_endpoint + 1);
	//double difference = NULL;
	//double sum = 0;
	//double sum_deviation = NULL;

	//coefficient of equation
	//a
	double a_minuend = NULL; //(l-1)/2
	double a_divisor = NULL; //l(l-1)(l+1)
	//b
	double b_minuend = NULL; //2l-1
	double b_divisor = NULL; //l(l+1)
	double a_sum = NULL;
	double b_sum = NULL;
	double variable_id = NULL; //[0-segment_length)
	int segment_id = 0;//[0-point_dimension)
	int array_id = NULL;//time series id

	for (segment_id = 0; segment_id < area_vector.size(); segment_id++) {
		//assert
#ifdef _DEBUG
		assert(area_vector[segment_id].rectangle_width > 1);
		if (segment_id == 0)
			//if(area_vector.at(segment_id).right_endpoint>1)
			assert(area_vector[segment_id].rectangle_width == area_vector[segment_id].right_endpoint + 1);
		else {
			//cout << area_vector[segment_id].rectangle_width << " " << area_vector[segment_id].right_endpoint << " " << area_vector[segment_id - 1].right_endpoint << endl;
			assert(area_vector[segment_id].rectangle_width == area_vector[segment_id].right_endpoint - area_vector[segment_id - 1].right_endpoint);
		}
#endif
		a_minuend = (area_vector.at(segment_id).rectangle_width - 1) / 2.0;//(l-1)/2
		a_divisor = (area_vector.at(segment_id).rectangle_width - 1) * (area_vector.at(segment_id).rectangle_width + 1) * area_vector.at(segment_id).rectangle_width;//l(l-1)(l+1)
		b_minuend = 2.0 * area_vector.at(segment_id).rectangle_width - 1;//2l-1
		b_divisor = (area_vector.at(segment_id).rectangle_width + 1) * area_vector.at(segment_id).rectangle_width;//l(l+1)
#ifdef _DEBUG
		assert(a_divisor != 0);
		assert(b_divisor != 0);
#endif

		a_sum = 0;
		b_sum = 0;
		for (variable_id = 0, array_id = segment_id == 0 ? 0 : area_vector.at(segment_id - 1).right_endpoint + 1; array_id <= area_vector.at(segment_id).right_endpoint; array_id++, variable_id++) {
			a_sum += (variable_id - a_minuend) * original_time_series[array_id];
			b_sum += (b_minuend - variable_id * 3.0) * original_time_series[array_id];
		}

#ifdef _DEBUG
		assert(area_vector[segment_id].apla.a == 12.0 * a_sum / a_divisor);
		assert(area_vector[segment_id].apla.b == 2.0 * b_sum / b_divisor);
#endif

		area_vector[segment_id].apla.a = 12.0 * a_sum / a_divisor;
		area_vector[segment_id].apla.b = 2.0 * b_sum / b_divisor;

		//cout << "a_sum: " << a_sum << " a_divisor: " << a_divisor << endl;
		//cout << "a: " << area_vector.at(segment_id).apla.a << " b: " << area_vector.at(segment_id).apla.b << endl;

		//reconstruct APLA time series
		//variable_id = 0;
		for (variable_id = 0, array_id = segment_id == 0 ? 0 : area_vector.at(segment_id - 1).right_endpoint + 1; array_id <= area_vector.at(segment_id).right_endpoint; array_id++, variable_id++) {
			reconstruct_time_series[array_id] = area_vector[segment_id].apla.a * variable_id + area_vector[segment_id].apla.b;
			//difference = fabs(reconstruct_time_series[array_id] - original_time_series[array_id]);
			//sum += difference * difference;
		}

		//assert(area_vector[segment_id].rec_deviation == sqrt(temp_segment_deviation));
	}
	//sum_deviation = sqrt(sum);

	/*=================================Evaluation Result=====================================================================*/
//#ifdef _DEBUG
//	typename TOOL::getDeviation(input_argument, original_time_series, reconstruct_time_series, output_argument);
//	assert(sum_deviation == output_argument.sum_deviation);
//#endif
	/*..............................................................................................................*/
	//TOOL::deleteArray(reconstruct_time_series);

	//return sum_deviation;
}

//************************************
// Method:getAPLAReconstructSeries
// Qualifier:Alrady has endpoint, widht, ab.
// date:181213
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
void APLA::getAPLAReconstructSeries(const vector<Y>& const area_vector, vector<T>& const reconstruct_time_series) {//190625 Has endpoint, width, a,b. get reconstruct series vector
#ifdef _DEBUG
	//assert(area_vector.size() == input_argument.point_dimension);
	assert(input_argument.time_series_length == area_vector.back().right_endpoint + 1);
#endif
	//reconstructed time series
	//DataType *reconstruct_time_series = new DataType[input_argument.time_series_length];
	reconstruct_time_series.resize(area_vector.back().right_endpoint + 1);
	//double difference = NULL;
	//double sum = 0;
	//double sum_deviation = NULL;

	//coefficient of equation
	//a
	//double a_minuend = NULL; //(l-1)/2
	//double a_divisor = NULL; //l(l-1)(l+1)
	////b
	//double b_minuend = NULL; //2l-1
	//double b_divisor = NULL; //l(l+1)
	//double a_sum = NULL;
	//double b_sum = NULL;
	double variable_id = NULL; //[0-segment_length)
	int segment_id = 0;//[0-point_dimension)
	int array_id = NULL;//time series id

	for (segment_id = 0; segment_id < area_vector.size(); segment_id++) {
		//assert
#ifdef _DEBUG
		assert(area_vector[segment_id].rectangle_width > 0 && area_vector[segment_id].apla.a != INF && area_vector[segment_id].apla.b != INF);
		if (segment_id == 0)
			//if(area_vector.at(segment_id).right_endpoint>1)
			assert(area_vector[segment_id].rectangle_width == area_vector[segment_id].right_endpoint + 1);
		else {
			//cout << area_vector[segment_id].rectangle_width << " " << area_vector[segment_id].right_endpoint << " " << area_vector[segment_id - 1].right_endpoint << endl;
			assert(area_vector[segment_id].rectangle_width == area_vector[segment_id].right_endpoint - area_vector[segment_id - 1].right_endpoint);
		}
#endif
		//		a_minuend = (area_vector.at(segment_id).rectangle_width - 1) / 2.0;//(l-1)/2
		//		a_divisor = (area_vector.at(segment_id).rectangle_width - 1)*(area_vector.at(segment_id).rectangle_width + 1)*area_vector.at(segment_id).rectangle_width;//l(l-1)(l+1)
		//		b_minuend = 2.0*area_vector.at(segment_id).rectangle_width - 1;//2l-1
		//		b_divisor = (area_vector.at(segment_id).rectangle_width + 1)*area_vector.at(segment_id).rectangle_width;//l(l+1)
		//#ifdef _DEBUG
		//		assert(a_divisor != 0);
		//		assert(b_divisor != 0);
		//#endif

				/*a_sum = 0;
				b_sum = 0;
				for (variable_id = 0, array_id = segment_id == 0 ? 0 : area_vector.at(segment_id - 1).right_endpoint + 1; array_id <= area_vector.at(segment_id).right_endpoint; array_id++, variable_id++) {
					a_sum += (variable_id - a_minuend) * original_time_series[array_id];
					b_sum += (b_minuend - variable_id * 3.0) * original_time_series[array_id];
				}

				area_vector[segment_id].apla.a = 12.0 * a_sum / a_divisor;
				area_vector[segment_id].apla.b = 2.0 * b_sum / b_divisor;*/

				//cout << "a_sum: " << a_sum << " a_divisor: " << a_divisor << endl;
				//cout << "a: " << area_vector.at(segment_id).apla.a << " b: " << area_vector.at(segment_id).apla.b << endl;

				//reconstruct APLA time series
				//variable_id = 0;
		for (variable_id = 0, array_id = segment_id == 0 ? 0 : area_vector.at(segment_id - 1).right_endpoint + 1; array_id <= area_vector.at(segment_id).right_endpoint; array_id++, variable_id++) {
			reconstruct_time_series[array_id] = area_vector[segment_id].apla.a * variable_id + area_vector[segment_id].apla.b;
			//difference = fabs(reconstruct_time_series[array_id] - original_time_series[array_id]);
			//sum += difference * difference;
		}

		//assert(area_vector[segment_id].rec_deviation == sqrt(temp_segment_deviation));
	}
	//sum_deviation = sqrt(sum);

	/*=================================Evaluation Result=====================================================================*/
//#ifdef _DEBUG
//	typename TOOL::getDeviation(input_argument, original_time_series, reconstruct_time_series, output_argument);
//	assert(sum_deviation == output_argument.sum_deviation);
//#endif
	/*..............................................................................................................*/
	//TOOL::deleteArray(reconstruct_time_series);

	//return sum_deviation;
}

//************************************
// Method:getAPLAReconstructSeries
// Qualifier:Alrady has endpoint, widht, ab.
// date:190907
// Input: 1 Right endpoint, 2 Width, 3 a&b
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
void APLA::getAPLAReconstructSeries(const DoublyLinkedList<Y>& const doubly_linked_list, vector<T>& const reconstruct_time_series) {//190917 Has endpoint, width, a,b. get reconstruct series vector
#ifdef _DEBUG
	assert(!doubly_linked_list.empty());
	//assert(area_vector.size() == input_argument.point_dimension);
	//assert(reconstruct_time_series.size() == doubly_linked_list.back().right_endpoint + 1);
#endif
	//reconstructed time series
	//DataType *reconstruct_time_series = new DataType[input_argument.time_series_length];
	reconstruct_time_series.resize(doubly_linked_list.back().right_endpoint + 1);

	double variable_id = NULL; //[0-segment_length)
	int segment_id = 0;//[0-point_dimension)
	int array_id = NULL;//time series id

	for (segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		//assert
#ifdef _DEBUG
		assert(doubly_linked_list[segment_id].rectangle_width > 0 && doubly_linked_list[segment_id].apla.a != INF && doubly_linked_list[segment_id].apla.b != INF);
		if (segment_id == 0)
			//if(area_vector.at(segment_id).right_endpoint>1)
			assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint + 1);
		else {
			//cout << area_vector[segment_id].rectangle_width << " " << area_vector[segment_id].right_endpoint << " " << area_vector[segment_id - 1].right_endpoint << endl;
			assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint);
		}
#endif

		for (variable_id = 0, array_id = segment_id == 0 ? 0 : doubly_linked_list[segment_id - 1].right_endpoint + 1; array_id <= doubly_linked_list[segment_id].right_endpoint; array_id++, variable_id++) {
#ifdef _DEBUG
			assert(doubly_linked_list[segment_id].apla.a != INF && doubly_linked_list[segment_id].apla.b != INF);
#endif
			reconstruct_time_series[array_id] = doubly_linked_list[segment_id].apla.a * variable_id + doubly_linked_list[segment_id].apla.b;
		}
	}
}

//************************************
// Method:get_PLA_reconstruct_series
// Qualifier:get reconstruct time series for one time series
// Input:
// Output:
// date:191230
// author:
//************************************
TEMPLATE
template<typename T>
void APLA::get_PLA_reconstruct_series(const vector<T>& const original_time_series_vector) {
#ifdef _DEBUG
	assert(!original_time_series_vector.empty());
#endif

	int segment_length = original_time_series_vector.size();
	vector<T> reconstruct_time_series_vector;
	int array_id = NULL;//time series id
	//a
	double a_minuend = NULL; //(l-1)/2
	double a_divisor = NULL; //l(l-1)(l+1)
	//b
	double b_minuend = NULL; //2l-1
	double b_divisor = NULL; //l(l+1)
	double a_sum = 0;
	double b_sum = 0;
	//
	double a = INF;
	double b = INF;
	//
	a_minuend = (segment_length - 1) / 2.0;//(l-1)/2
	a_divisor = (segment_length - 1) * (segment_length + 1) * segment_length;//l(l-1)(l+1)
	b_minuend = 2.0 * segment_length - 1;//2l-1
	b_divisor = (segment_length + 1) * segment_length;//l(l+1)
#ifdef _DEBUG
	assert(a_divisor != 0 && b_divisor != 0);
#endif


	for (array_id = 0; array_id < segment_length; array_id++) {
		a_sum += (array_id - a_minuend) * original_time_series_vector[array_id];
		b_sum += (b_minuend - array_id * 3.0) * original_time_series_vector[array_id];
	}

	a = 12.0 * a_sum / a_divisor;
	b = 2.0 * b_sum / b_divisor;

	//cout << "a_sum: " << a_sum << " a_divisor: " << a_divisor << endl;
	//cout << "a: " << area_vector.at(segment_id).apla.a << " b: " << area_vector.at(segment_id).apla.b << endl;

	//reconstruct APLA time series
	//variable_id = 0;
	for (array_id = 0; array_id < segment_length; array_id++) {
		reconstruct_time_series_vector.emplace_back(a * array_id + b);
		//difference = fabs(reconstruct_time_series[array_id] - original_time_series[array_id]);
		//sum += difference * difference;
	}

	assert(original_time_series_vector.size() == reconstruct_time_series_vector.size());

	/*=================================Evaluation Result=====================================================================*/
	for (auto&& au : reconstruct_time_series_vector) {
		cout << au << ",";
	}
	cout << endl;
	//#ifdef _DEBUG
	//	typename TOOL::getDeviation(input_argument, original_time_series, reconstruct_time_series, output_argument);
	//	assert(sum_deviation == output_argument.sum_deviation);
	//#endif
	/*========================================================================================================================*/

}

//200108 get reconstruct time series for one time series
//************************************
// Method:get_PLA_reconstruct_series
// Qualifier:
// date:200108
// author:
//************************************
TEMPLATE
template<typename T>
void APLA::get_PLA_reconstruct_series(const vector<T>& const original_time_series_vector, vector<T>& const reconstruct_time_series_vector) {
#ifdef _DEBUG
	assert(!original_time_series_vector.empty());
#endif

	int segment_length = original_time_series_vector.size();
	//vector<T> reconstruct_time_series_vector;
	int array_id = NULL;//time series id
	//a
	double a_minuend = NULL; //(l-1)/2
	double a_divisor = NULL; //l(l-1)(l+1)
	//b
	double b_minuend = NULL; //2l-1
	double b_divisor = NULL; //l(l+1)
	double a_sum = 0;
	double b_sum = 0;
	//
	double a = INF;
	double b = INF;
	//
	a_minuend = (segment_length - 1) / 2.0;//(l-1)/2
	a_divisor = (segment_length - 1) * (segment_length + 1) * segment_length;//l(l-1)(l+1)
	b_minuend = 2.0 * segment_length - 1;//2l-1
	b_divisor = (segment_length + 1) * segment_length;//l(l+1)
#ifdef _DEBUG
	assert(a_divisor != 0 && b_divisor != 0);
#endif


	for (array_id = 0; array_id < segment_length; array_id++) {
		a_sum += (array_id - a_minuend) * original_time_series_vector[array_id];
		b_sum += (b_minuend - array_id * 3.0) * original_time_series_vector[array_id];
	}

	a = 12.0 * a_sum / a_divisor;
	b = 2.0 * b_sum / b_divisor;

	//cout << "a_sum: " << a_sum << " a_divisor: " << a_divisor << endl;
	//cout << "a: " << area_vector.at(segment_id).apla.a << " b: " << area_vector.at(segment_id).apla.b << endl;

	//reconstruct APLA time series
	//variable_id = 0;
	for (array_id = 0; array_id < segment_length; array_id++) {
		reconstruct_time_series_vector.emplace_back(a * array_id + b);
		//difference = fabs(reconstruct_time_series[array_id] - original_time_series[array_id]);
		//sum += difference * difference;
	}

	assert(original_time_series_vector.size() == reconstruct_time_series_vector.size());

	/*=================================Evaluation Result=====================================================================*/
	/*for (auto&& au : reconstruct_time_series_vector) {
		cout << au << ",";
	}
	cout << endl;*/
	//#ifdef _DEBUG
	//	typename TOOL::getDeviation(input_argument, original_time_series, reconstruct_time_series, output_argument);
	//	assert(sum_deviation == output_argument.sum_deviation);
	//#endif
	/*========================================================================================================================*/
}


//************************************
// Method:get_PLA_coefficient
// Qualifier: //200206 get econstruct time series, a, b, segment_width for one time series
// Input:
// Output:
// date: 200206
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
void APLA::get_PLA_reconstruct_series(const vector<T>& const original_time_series_vector, Y& const temp_coefficient, vector<T>& const reconstruct_time_series_vector) {
#ifdef _DEBUG
	assert(!original_time_series_vector.empty() && original_time_series_vector.size() > 1);
#endif

	int segment_length = original_time_series_vector.size();
	//vector<T> reconstruct_time_series_vector;
	int array_id = NULL;//time series id
	//a
	double a_minuend = NULL; //(l-1)/2
	double a_divisor = NULL; //l(l-1)(l+1)
	//b
	double b_minuend = NULL; //2l-1
	double b_divisor = NULL; //l(l+1)
	double a_sum = 0;
	double b_sum = 0;
	//
	double a = INF;
	double b = INF;
	//
	a_minuend = (segment_length - 1) / 2.0;//(l-1)/2
	a_divisor = (segment_length - 1) * (segment_length + 1) * segment_length;//l(l-1)(l+1)
	b_minuend = 2.0 * segment_length - 1;//2l-1
	b_divisor = (segment_length + 1) * segment_length;//l(l+1)
#ifdef _DEBUG
	assert(a_divisor != 0 && b_divisor != 0);
#endif

	for (array_id = 0; array_id < segment_length; array_id++) {
		a_sum += (array_id - a_minuend) * original_time_series_vector[array_id];
		b_sum += (b_minuend - array_id * 3.0) * original_time_series_vector[array_id];
	}

	/*------------------------Segment Coefficient -------------------------------------*/
	temp_coefficient.apla.a = a = 12.0 * a_sum / a_divisor;
	temp_coefficient.apla.b = b = 2.0 * b_sum / b_divisor;
	temp_coefficient.rectangle_width = original_time_series_vector.size();
	/*--------------------------------------------------------------------------------*/

	//cout << "a_sum: " << a_sum << " a_divisor: " << a_divisor << endl;
	//cout << "a: " << area_vector.at(segment_id).apla.a << " b: " << area_vector.at(segment_id).apla.b << endl;

	//reconstruct APLA time series
	//variable_id = 0;
	for (array_id = 0; array_id < segment_length; array_id++) {
		reconstruct_time_series_vector.emplace_back(a * array_id + b);
		//difference = fabs(reconstruct_time_series[array_id] - original_time_series[array_id]);
		//sum += difference * difference;
	}

	assert(original_time_series_vector.size() == reconstruct_time_series_vector.size());
}


//************************************
// Method:get_PLA_part_reconstruct_series
// Qualifier: get part reconstruct time series for part of time series
// Input: part of original time series
// Output: part of reconstruction time series
// date:200205
// author:
//************************************
TEMPLATE
template<typename T>
void APLA::get_PLA_part_reconstruct_series(const vector<T>& const original_time_series, const int& const begin_id, const int& const end_id, vector<T>& const part_reconstruct_time_series) {
#ifdef _DEBUG
	assert(!original_time_series.empty() && part_reconstruct_time_series.empty() && begin_id != INF && end_id != INF && begin_id <= end_id);
#endif
	if (begin_id == end_id) {
		part_reconstruct_time_series.emplace_back(original_time_series[end_id]);
		return;
	}

	int part_time_series_length = end_id - begin_id + 1;
	vector<T> part_time_series(original_time_series.begin() + begin_id, original_time_series.begin() + end_id + 1);

#ifdef _DEBUG
	assert(part_time_series_length == part_time_series.size() && original_time_series[begin_id] == part_time_series.front() && original_time_series[end_id] == part_time_series.back());
#endif

	APLA::get_PLA_reconstruct_series(part_time_series, part_reconstruct_time_series);

#ifdef _DEBUG
	assert(part_reconstruct_time_series.size() == part_time_series.size() && part_time_series_length == part_reconstruct_time_series.size());
#endif
}

//************************************
// Method:get_PLA_part_reconstruct_series
// Qualifier: get part reconstruct time series, a&b width. for part of time series
// Input:
// Output:
// date:200206
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
void APLA::get_PLA_part_reconstruct_series(const vector<T>& const original_time_series, const int& const begin_id, const int& const end_id, Y& const temp_coefficient, vector<T>& const part_reconstruct_time_series) {
#ifdef _DEBUG
	assert(!original_time_series.empty() && part_reconstruct_time_series.empty() && begin_id != INF && end_id != INF && begin_id <= end_id);
#endif
	temp_coefficient.right_endpoint = end_id;
	if (begin_id == end_id) {
		temp_coefficient.rectangle_width = 1;
		part_reconstruct_time_series.emplace_back(original_time_series[end_id]);
		return;
	}

	int part_time_series_length = end_id - begin_id + 1;
	vector<T> part_time_series(original_time_series.begin() + begin_id, original_time_series.begin() + end_id + 1);

#ifdef _DEBUG
	assert(part_time_series_length == part_time_series.size() && original_time_series[begin_id] == part_time_series.front() && original_time_series[end_id] == part_time_series.back());
#endif


	temp_coefficient.rectangle_width = part_time_series.size();
	APLA::get_PLA_reconstruct_series(part_time_series, temp_coefficient, part_reconstruct_time_series);

#ifdef _DEBUG
	assert(part_reconstruct_time_series.size() == part_time_series.size() && part_time_series_length == part_reconstruct_time_series.size() && temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF);
#endif
}


//************************************
// Method:get_PLA_coefficient
// Qualifier: get reconstruct time series by endpoint
// Input:
// Output:
// date:200205
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
void APLA::get_PLA_reconstruct_series_by_endpoint(const vector<T>& const original_time_series, vector<Y>& const right_endpoint, vector<T>& const reconstruct_time_series) {
	assert(original_time_series.size() == right_endpoint.back() + 1 && right_endpoint.front() == 0 && reconstruct_time_series.empty());
	right_endpoint.front() = -1;
	vector<T> part_reconstruct_time_series;
	right_endpoint.pop_back();
	for (auto&& au : right_endpoint) {
		APLA::get_PLA_part_reconstruct_series(original_time_series, au + 1, *(&au + 1), part_reconstruct_time_series);
		reconstruct_time_series.insert(reconstruct_time_series.end(), part_reconstruct_time_series.begin(), part_reconstruct_time_series.end());
		part_reconstruct_time_series.clear();
		part_reconstruct_time_series.shrink_to_fit();
	}
	assert(original_time_series.size() == reconstruct_time_series.size());
}

//200220 get reconstruction time series for one segemnt, already know a&b and right endpoint
//************************************
// Method:get_PLA_reconstruct_series_by_segment
// Qualifier: get reconstruct time series for one segment
// Input: 1 a&b right endpoint, width of one segment
// Output: reconstruction time series
// date:200220
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
void APLA::get_PLA_reconstruct_series_by_segment(const vector<T>& const original_time_series_vector, const Y& const temp_coefficient, vector<T>& const reconstruct_time_series_vector) {
#ifdef _DEBUG
	assert(!original_time_series_vector.empty() && original_time_series_vector.size() > 1 && reconstruct_time_series_vector.empty());
	assert(temp_coefficient.rectangle_width > 0 && temp_coefficient.rectangle_width != INF && temp_coefficient.right_endpoint >= 0 && temp_coefficient.right_endpoint != INF);
	assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF && temp_coefficient.rectangle_width < original_time_series_vector.size());
#endif
	//reconstruct APLA time series
	//variable_id = 0;
	for (int array_id = 0; array_id < temp_coefficient.rectangle_width; array_id++) {
		reconstruct_time_series_vector.emplace_back(temp_coefficient.apla.a * array_id + temp_coefficient.apla.b);
		//difference = fabs(reconstruct_time_series[array_id] - original_time_series[array_id]);
		//sum += difference * difference;
	}
#ifdef _DEBUG
	assert(reconstruct_time_series_vector.size() == temp_coefficient.rectangle_width);
#endif
}

//************************************
// Method:get_PLA_coefficient
// Qualifier: get a & b of original time series
// Input:
// Output: a & b of time series
// date:200110
// author:
//************************************
TEMPLATE
template<typename T>
void APLA::get_PLA_coefficient(const vector<T>& const original_time_series_vector, typename TOOL::APLA_COEFFICIENT& const pla_coefficient) {
#ifdef _DEBUG
	assert(!original_time_series_vector.empty());
#endif

	if (original_time_series_vector.size() == 1) {
		pla_coefficient.a = 0;
		pla_coefficient.b = original_time_series_vector.front();
		return;
	}

	int segment_length = original_time_series_vector.size();
	//vector<T> reconstruct_time_series_vector;
	int array_id = NULL;//time series id
	//a
	double a_minuend = NULL; //(l-1)/2
	double a_divisor = NULL; //l(l-1)(l+1)
	//b
	double b_minuend = NULL; //2l-1
	double b_divisor = NULL; //l(l+1)
	double a_sum = 0;
	double b_sum = 0;
	//
	a_minuend = (segment_length - 1) / 2.0;//(l-1)/2
	a_divisor = (segment_length - 1) * (segment_length + 1) * segment_length;//l(l-1)(l+1)
	b_minuend = 2.0 * segment_length - 1;//2l-1
	b_divisor = (segment_length + 1) * segment_length;//l(l+1)

#ifdef _DEBUG
	assert(a_divisor != 0 && b_divisor != 0);
#endif

	for (array_id = 0; array_id < segment_length; array_id++) {
		a_sum += (array_id - a_minuend) * original_time_series_vector[array_id];
		b_sum += (b_minuend - array_id * 3.0) * original_time_series_vector[array_id];
	}

	pla_coefficient.a = 12.0 * a_sum / a_divisor;
	pla_coefficient.b = 2.0 * b_sum / b_divisor;
}

//200110 get a & b of original time series
//************************************
// Method:get_PLA_coefficient
// Qualifier:get a & b of time series
// Input:
// Output:
// date:200110
// author:
//************************************
TEMPLATE
template<typename T>
typename APLA::APLA_COEFFICIENT APLA::get_PLA_coefficient(const vector<T>& const original_time_series_vector) {
#ifdef _DEBUG
	assert(!original_time_series_vector.empty());
#endif

	typename APLA::APLA_COEFFICIENT pla_coefficient;

	if (original_time_series_vector.size() == 1) {
		pla_coefficient.a = 0;
		pla_coefficient.b = original_time_series_vector.front();
		return pla_coefficient;
	}

	int segment_length = original_time_series_vector.size();
	//vector<T> reconstruct_time_series_vector;
	int array_id = NULL;//time series id
	//a
	double a_minuend = NULL; //(l-1)/2
	double a_divisor = NULL; //l(l-1)(l+1)
	//b
	double b_minuend = NULL; //2l-1
	double b_divisor = NULL; //l(l+1)
	double a_sum = 0;
	double b_sum = 0;
	//
	//double a = INF;
	//double b = INF;
	//
	a_minuend = (segment_length - 1) / 2.0;//(l-1)/2
	a_divisor = (segment_length - 1) * (segment_length + 1) * segment_length;//l(l-1)(l+1)
	b_minuend = 2.0 * segment_length - 1;//2l-1
	b_divisor = (segment_length + 1) * segment_length;//l(l+1)

#ifdef _DEBUG
	assert(a_divisor != 0 && b_divisor != 0);
#endif

	for (array_id = 0; array_id < segment_length; array_id++) {
		a_sum += (array_id - a_minuend) * original_time_series_vector[array_id];
		b_sum += (b_minuend - array_id * 3.0) * original_time_series_vector[array_id];
	}

	pla_coefficient.a = 12.0 * a_sum / a_divisor;
	pla_coefficient.b = 2.0 * b_sum / b_divisor;

	return pla_coefficient;
}

//************************************
// Method:getAPLA
// Qualifier:
// date:181213
// author:
//************************************
TEMPLATE
void APLA::getAPLA(const typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector) {//181213
	assert(0);
	//printf("getPLA()\n");
	//assert(area_vector.size() == input_argument.point_dimension);

	//reconstructed time series
	DataType* reconstruct_time_series = new DataType[input_argument.time_series_length];
	vector<double> segment_deviaiton_vector;//190611

	vector<double> absolute_difference_vector;//190619
	vector<double> segment_series;//190619

	double difference = NULL;
	double sum = 0;
	double max_deviation = NULL;
	double sum_deviation = NULL;

	//coefficient of equation
	//a
	double a_minuend = NULL; //(l-1)/2
	double a_divisor = NULL; //l(l-1)(l+1)
	//b
	double b_minuend = NULL; //2l-1
	double b_divisor = NULL; //l(l+1)

	double a_sum = NULL;
	double b_sum = NULL;
	double variable_id = NULL; //[0-segment_length)
	int segment_id = 0;//[0-point_dimension)
	int array_id = NULL;//time series id

	/*=====================================================================================*/
	output_argument.sum_area = 0;
	output_argument.sum_density = 0;
	output_argument.sum_area0 = 0;
	output_argument.sum_density0 = 0;
	double segment_density = 0;
	double segment_area = 0;
	/*.....................................................................................*/

	for (segment_id = 0; segment_id < area_vector.size(); segment_id++) {
		//assert
		if (segment_id == 0)
			//if(area_vector.at(segment_id).right_endpoint>1)
			assert(area_vector[segment_id].rectangle_width == area_vector[segment_id].right_endpoint + 1);
		else {
			//cout << area_vector[segment_id].rectangle_width << " " << area_vector[segment_id].right_endpoint << " " << area_vector[segment_id - 1].right_endpoint << endl;
			assert(area_vector[segment_id].rectangle_width == area_vector[segment_id].right_endpoint - area_vector[segment_id - 1].right_endpoint);
		}

		segment_area = computeParallelogram(original_time_series, area_vector[segment_id]);//190619
		segment_density = 1.0 / area_vector[segment_id].parallelogram_height;//190619

		output_argument.sum_area += segment_area;
		output_argument.sum_density += segment_density;

		if (area_vector[segment_id].rectangle_width == 1) {
			getAandBSlopInterceptOnePoint(original_time_series, area_vector.at(segment_id));
		}
		else {
			a_minuend = (area_vector.at(segment_id).rectangle_width - 1) / 2.0;//(l-1)/2
			a_divisor = (area_vector.at(segment_id).rectangle_width - 1) * (area_vector.at(segment_id).rectangle_width + 1) * area_vector.at(segment_id).rectangle_width;//l(l-1)(l+1)
			assert(a_divisor != 0);

			b_minuend = 2.0 * area_vector.at(segment_id).rectangle_width - 1;//2l-1
			b_divisor = (area_vector.at(segment_id).rectangle_width + 1) * area_vector.at(segment_id).rectangle_width;//l(l+1)
			assert(b_divisor != 0);

			a_sum = 0;
			b_sum = 0;
			for (variable_id = 0, array_id = segment_id == 0 ? 0 : area_vector.at(segment_id - 1).right_endpoint + 1; array_id <= area_vector.at(segment_id).right_endpoint; array_id++, variable_id++) {
				a_sum += (variable_id - a_minuend) * original_time_series[array_id];
				b_sum += (b_minuend - variable_id * 3.0) * original_time_series[array_id];
			}

#ifdef _DEBUG
			assert(float(area_vector[segment_id].apla.a) == float(12.0 * a_sum / a_divisor));
			assert(float(area_vector[segment_id].apla.b) == float(2.0 * b_sum / b_divisor));
#endif

			area_vector[segment_id].apla.a = 12.0 * a_sum / a_divisor;
			area_vector[segment_id].apla.b = 2.0 * b_sum / b_divisor;
		}

		//cout << "a_sum: " << a_sum << " a_divisor: " << a_divisor << endl;
		//cout << "a: " << area_vector.at(segment_id).apla.a << " b: " << area_vector.at(segment_id).apla.b << endl;

		//reconstruct APLA time series
		//variable_id = 0;
		double temp_segment_deviation = 0;
		for (temp_segment_deviation = 0, variable_id = 0, array_id = segment_id == 0 ? 0 : area_vector.at(segment_id - 1).right_endpoint + 1; array_id <= area_vector.at(segment_id).right_endpoint; array_id++, variable_id++) {
			reconstruct_time_series[array_id] = area_vector[segment_id].apla.a * variable_id + area_vector[segment_id].apla.b;
			difference = fabs(reconstruct_time_series[array_id] - original_time_series[array_id]);
			absolute_difference_vector.push_back(reconstruct_time_series[array_id] - original_time_series[array_id]);
			segment_series.push_back(original_time_series[array_id]);
			max_deviation = max(max_deviation, difference);
			sum += difference * difference;
			temp_segment_deviation += difference * difference;
		}
		segment_deviaiton_vector.push_back(sqrt(temp_segment_deviation));
		auto min_max = minmax_element(absolute_difference_vector.begin(), absolute_difference_vector.end());
		auto min_max_series = minmax_element(segment_series.begin(), segment_series.end());
		double segment_height = *min_max.second - *min_max.first;

		if (area_vector[segment_id].rectangle_width == 2)
			segment_height = 0;
		double min_max_height = *min_max_series.second - *min_max_series.first;
		output_argument.sum_density0 += 1.0 / min_max_height;
		output_argument.sum_area0 += min_max_height * area_vector[segment_id].rectangle_width;
		double test_segemnt_area = segment_height * area_vector[segment_id].rectangle_width;

		assert(segment_height >= 0);
		assert(float(area_vector[segment_id].parallelogram_height) == float(segment_height) && float(segment_area) == float(test_segemnt_area));

		absolute_difference_vector.clear();
		segment_series.clear();
		//assert(area_vector[segment_id].rec_deviation == sqrt(temp_segment_deviation));
	}
	sum_deviation = sqrt(sum);

	/*=================================Evaluation Result=====================================================================*/
	typename TOOL::getDeviation(input_argument, original_time_series, reconstruct_time_series, output_argument);
	assert(sum_deviation == output_argument.sum_deviation && max_deviation == output_argument.max_deviation);
	/*..............................................................................................................*/

	/*=================================Print Result=====================================================================*/
	cout << "APLA devation: ";
	for (auto&& au : segment_deviaiton_vector) {
		cout << au << ", ";
	}
	cout << endl;
	//Print Array
	/*cout << "APLA Reconstructed Time Series: ";
	TOOL::printArray(reconstruct_time_series, input_argument.time_series_length);*/
	/*..............................................................................................................*/
	/*=================================Write Result=====================================================================*/
	TOOL::writeSingleResult("ReconstructAPLA181218", reconstruct_time_series, input_argument.time_series_length);
	/*................................................................................................................*/
	TOOL::deleteArray(reconstruct_time_series);
	//cout << endl;
	/*APCA_KNN_QUAL::printArray(pointer,1280);*/
}

//************************************
// Method:getAPLA
// Qualifier:Evaluation of sum& max deviaiton, a&b, reconstruction. Use linked list to instead vector
// Input: right endpoint. 
// Output: sum& max deviaiton, a&b, reconstruction
// date:190917
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
void APLA::getAPLA(const U& const input_argument, T*& const original_time_series, DoublyLinkedList<Y>& const doubly_linked_list) {//190917
	assert(0);
	//printf("getPLA()\n");
	//assert(area_vector.size() == input_argument.point_dimension);

	//reconstructed time series
	DataType* reconstruct_time_series = new DataType[input_argument.time_series_length];
	vector<double> segment_deviaiton_vector;//190611

	vector<double> absolute_difference_vector;//190619
	vector<double> segment_series;//190619

	double difference = NULL;
	double sum = 0;
	double absolut_difference_sum = 0;
	double max_deviation = NULL;
	double sum_deviation = NULL;

	//coefficient of equation
	//a
	double a_minuend = NULL; //(l-1)/2
	double a_divisor = NULL; //l(l-1)(l+1)
	//b
	double b_minuend = NULL; //2l-1
	double b_divisor = NULL; //l(l+1)

	double a_sum = NULL;
	double b_sum = NULL;
	double variable_id = NULL; //[0-segment_length)
	int segment_id = 0;//[0-point_dimension)
	int array_id = NULL;//time series id

	/*=====================================================================================*/
	output_argument.sum_area = 0;
	output_argument.sum_density = 0;
	output_argument.sum_area0 = 0;
	output_argument.sum_density0 = 0;
	double segment_density = 0;
	double segment_area = 0;
	/*.....................................................................................*/

	cout << "APLA a&b: ";
	for (segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		/*==================================get a&b===================================================*/
		//assert
		if (segment_id == 0)
			//if(area_vector.at(segment_id).right_endpoint>1)
			assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint + 1);
		else {
			//cout << area_vector[segment_id].rectangle_width << " " << area_vector[segment_id].right_endpoint << " " << area_vector[segment_id - 1].right_endpoint << endl;
			assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint);
		}

		cout << doubly_linked_list[segment_id].apla.a << " " << doubly_linked_list[segment_id].apla.b << ", " << doubly_linked_list[segment_id].right_endpoint << "; ";

		segment_area = computeParallelogram(original_time_series, doubly_linked_list[segment_id]);//190619
		segment_density = 1.0 / doubly_linked_list[segment_id].parallelogram_height;//190619

		output_argument.sum_area += segment_area;
		output_argument.sum_density += segment_density;

		if (doubly_linked_list[segment_id].rectangle_width == 1) {
			getAandBSlopInterceptOnePoint(original_time_series, doubly_linked_list[segment_id]);
		}
		else {
			a_minuend = (doubly_linked_list[segment_id].rectangle_width - 1) / 2.0;//(l-1)/2
			a_divisor = (doubly_linked_list[segment_id].rectangle_width - 1) * (doubly_linked_list[segment_id].rectangle_width + 1) * doubly_linked_list[segment_id].rectangle_width;//l(l-1)(l+1)
			assert(a_divisor != 0);

			b_minuend = 2.0 * doubly_linked_list[segment_id].rectangle_width - 1;//2l-1
			b_divisor = (doubly_linked_list[segment_id].rectangle_width + 1) * doubly_linked_list[segment_id].rectangle_width;//l(l+1)
			assert(b_divisor != 0);

			a_sum = 0;
			b_sum = 0;
			for (variable_id = 0, array_id = segment_id == 0 ? 0 : doubly_linked_list[segment_id - 1].right_endpoint + 1; array_id <= doubly_linked_list[segment_id].right_endpoint; array_id++, variable_id++) {
				a_sum += (variable_id - a_minuend) * original_time_series[array_id];
				b_sum += (b_minuend - variable_id * 3.0) * original_time_series[array_id];
			}

#ifdef _DEBUG
			assert(float(doubly_linked_list[segment_id].apla.a) == float(12.0 * a_sum / a_divisor));
			assert(float(doubly_linked_list[segment_id].apla.b) == float(2.0 * b_sum / b_divisor));
#endif

			doubly_linked_list[segment_id].apla.a = 12.0 * a_sum / a_divisor;
			doubly_linked_list[segment_id].apla.b = 2.0 * b_sum / b_divisor;
		}
		/*==================================================================================================*/
		//cout << "a_sum: " << a_sum << " a_divisor: " << a_divisor << endl;
		//cout << "a: " << area_vector.at(segment_id).apla.a << " b: " << area_vector.at(segment_id).apla.b << endl;

		//reconstruct APLA time series
		//variable_id = 0;
		/*========================================get Sum&Max devation, reconstruction time sieres ==========================================================*/
		double temp_segment_deviation = 0;
		for (temp_segment_deviation = 0, variable_id = 0, array_id = segment_id == 0 ? 0 : doubly_linked_list[segment_id - 1].right_endpoint + 1; array_id <= doubly_linked_list[segment_id].right_endpoint; array_id++, variable_id++) {
			reconstruct_time_series[array_id] = doubly_linked_list[segment_id].apla.a * variable_id + doubly_linked_list[segment_id].apla.b;
			difference = fabs(reconstruct_time_series[array_id] - original_time_series[array_id]);
			absolute_difference_vector.push_back(reconstruct_time_series[array_id] - original_time_series[array_id]);
			segment_series.push_back(original_time_series[array_id]);
			max_deviation = max(max_deviation, difference);
			sum += difference * difference;
			temp_segment_deviation += difference * difference;
			absolut_difference_sum += difference;
		}
		segment_deviaiton_vector.push_back(sqrt(temp_segment_deviation));
		auto min_max = minmax_element(absolute_difference_vector.begin(), absolute_difference_vector.end());
		auto min_max_series = minmax_element(segment_series.begin(), segment_series.end());
		double segment_height = *min_max.second - *min_max.first;

		if (doubly_linked_list[segment_id].rectangle_width == 2)
			segment_height = 0;
		double min_max_height = *min_max_series.second - *min_max_series.first;
		output_argument.sum_density0 += 1.0 / min_max_height;
		output_argument.sum_area0 += min_max_height * doubly_linked_list[segment_id].rectangle_width;
		double test_segemnt_area = segment_height * doubly_linked_list[segment_id].rectangle_width;

		assert(segment_height >= 0);
		assert(float(doubly_linked_list[segment_id].parallelogram_height) == float(segment_height) && float(segment_area) == float(test_segemnt_area));
		/*=============================================================================================================================*/
		absolute_difference_vector.clear();
		segment_series.clear();
		//assert(area_vector[segment_id].rec_deviation == sqrt(temp_segment_deviation));
	}
	cout << endl;
	sum_deviation = sqrt(sum);

	/*=================================Evaluation sum & max deviation=====================================================================*/
	typename TOOL::getDeviation(input_argument, original_time_series, reconstruct_time_series, output_argument);
	assert(sum_deviation == output_argument.sum_deviation && max_deviation == output_argument.max_deviation);
	//output_argument.sum_deviation = absolut_difference_sum;
	/*..............................................................................................................*/

	/*=================================Print Result=====================================================================*/
	cout << "APLA devation: ";
	for (auto&& au : segment_deviaiton_vector) {
		cout << au << ", ";
	}
	cout << endl;
	//Print Array
	/*cout << "APLA Reconstructed Time Series: ";
	TOOL::printArray(reconstruct_time_series, input_argument.time_series_length);*/
	/*..............................................................................................................*/
	/*=================================Write reconstruction time series=====================================================================*/
	TOOL::writeSingleResult("ReconstructAPLA181218", reconstruct_time_series, input_argument.time_series_length);
	/*................................................................................................................*/
	TOOL::deleteArray(reconstruct_time_series);
	//cout << endl;
	/*APCA_KNN_QUAL::printArray(pointer,1280);*/
}

//************************************
// Method:getAPLA
// Qualifier:
// date:190408
// author:
//************************************
TEMPLATE
void APLA::getAPLA(const typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, list<AREA_COEFFICIENT>& const area_vector) {//190408
	//printf("getPLA()\n");
	assert(0);
	assert(area_vector.size() == input_argument.point_dimension);

	//reconstructed time series
	DataType* reconstruct_time_series = new DataType[input_argument.time_series_length];
	double difference = NULL;
	double sum = 0;
	double max_deviation = NULL;
	double sum_deviation = NULL;

	//coefficient of equation
	//a
	double a_minuend = NULL; //(l-1)/2
	double a_divisor = NULL; //l(l-1)(l+1)
	//b
	double b_minuend = NULL; //2l-1
	double b_divisor = NULL; //l(l+1)

	double a_sum = NULL;
	double b_sum = NULL;
	double variable_id = NULL; //[0-segment_length)
	int segment_id = 0;//[0-point_dimension)
	int array_id = NULL;//time series id

	for (segment_id = 0; segment_id < input_argument.point_dimension; segment_id++) {
		//assert
		if (segment_id == 0)
			//if(area_vector.at(segment_id).right_endpoint>1)
			assert(area_vector[segment_id].rectangle_width == area_vector[segment_id].right_endpoint + 1);
		else {
			//cout << area_vector[segment_id].rectangle_width << " " << area_vector[segment_id].right_endpoint << " " << area_vector[segment_id - 1].right_endpoint << endl;
			assert(area_vector[segment_id].rectangle_width == area_vector[segment_id].right_endpoint - area_vector[segment_id - 1].right_endpoint);
		}

		if (area_vector[segment_id].rectangle_width == 1) {
			getAandBSlopInterceptOnePoint(original_time_series, area_vector.at(segment_id));
		}
		else {
			a_minuend = (area_vector.at(segment_id).rectangle_width - 1) / 2.0;//(l-1)/2
			a_divisor = (area_vector.at(segment_id).rectangle_width - 1) * (area_vector.at(segment_id).rectangle_width + 1) * area_vector.at(segment_id).rectangle_width;//l(l-1)(l+1)
			assert(a_divisor != 0);

			b_minuend = 2.0 * area_vector.at(segment_id).rectangle_width - 1;//2l-1
			b_divisor = (area_vector.at(segment_id).rectangle_width + 1) * area_vector.at(segment_id).rectangle_width;//l(l+1)
			assert(b_divisor != 0);

			a_sum = 0;
			b_sum = 0;
			for (variable_id = 0, array_id = segment_id == 0 ? 0 : area_vector.at(segment_id - 1).right_endpoint + 1; array_id <= area_vector.at(segment_id).right_endpoint; array_id++, variable_id++) {
				a_sum += (variable_id - a_minuend) * original_time_series[array_id];
				b_sum += (b_minuend - variable_id * 3.0) * original_time_series[array_id];
			}

			assert(area_vector[segment_id].apla.a == 12.0 * a_sum / a_divisor);
			assert(area_vector[segment_id].apla.b == 2.0 * b_sum / b_divisor);

			area_vector[segment_id].apla.a = 12.0 * a_sum / a_divisor;
			area_vector[segment_id].apla.b = 2.0 * b_sum / b_divisor;
		}

		//cout << "a_sum: " << a_sum << " a_divisor: " << a_divisor << endl;
		//cout << "a: " << area_vector.at(segment_id).apla.a << " b: " << area_vector.at(segment_id).apla.b << endl;

		//reconstruct APLA time series
		//variable_id = 0;
		double temp_segment_deviation = 0;
		for (temp_segment_deviation = 0, variable_id = 0, array_id = segment_id == 0 ? 0 : area_vector.at(segment_id - 1).right_endpoint + 1; array_id <= area_vector.at(segment_id).right_endpoint; array_id++, variable_id++) {
			reconstruct_time_series[array_id] = area_vector[segment_id].apla.a * variable_id + area_vector[segment_id].apla.b;
			difference = fabs(reconstruct_time_series[array_id] - original_time_series[array_id]);
			max_deviation = max(max_deviation, difference);
			sum += difference * difference;
			temp_segment_deviation += difference * difference;
		}
		//assert(area_vector[segment_id].rec_deviation == sqrt(temp_segment_deviation));
	}

	//Print Array
	/*cout << "APLA Reconstructed Time Series: ";
	TOOL::printArray(reconstruct_time_series, input_argument.time_series_length);*/

	TOOL::writeSingleResult("ReconstructAPLA181218", reconstruct_time_series, input_argument.time_series_length);

	sum_deviation = sqrt(sum);

	typename TOOL::getDeviation(input_argument, original_time_series, reconstruct_time_series, output_argument);

	assert(sum_deviation == output_argument.sum_deviation && max_deviation == output_argument.max_deviation);

	TOOL::deleteArray(reconstruct_time_series);
	//cout << endl;
	/*APCA_KNN_QUAL::printArray(pointer,1280);*/
}

//************************************
// Method:getAPLAArray
// Qualifier:Use array to instead vector, speed up
// date:190426
// author:
//************************************
TEMPLATE
void APLA::getAPLAArray(const typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, SEGMENT_COEFFICIENT*& const area_vector) {//190426
	//printf("getPLA()\n");
	//assert(area_vector.size() == input_argument.point_dimension);

	//reconstructed time series
	DataType* reconstruct_time_series = new DataType[input_argument.time_series_length];
	double difference = NULL;
	double sum = 0;
	double max_deviation = NULL;
	double sum_deviation = NULL;

	//coefficient of equation
	//a
	double a_minuend = NULL; //(l-1)/2
	double a_divisor = NULL; //l(l-1)(l+1)
	//b
	double b_minuend = NULL; //2l-1
	double b_divisor = NULL; //l(l+1)

	double a_sum = NULL;
	double b_sum = NULL;
	double variable_id = NULL; //[0-segment_length)
	int segment_id = 0;//[0-point_dimension)
	int array_id = NULL;//time series id

	for (segment_id = 0; segment_id < input_argument.point_dimension; segment_id++) {
		//assert
		if (segment_id == 0)
			//if(area_vector.at(segment_id).right_endpoint>1)
			assert(area_vector[segment_id].rectangle_width == area_vector[segment_id].right_endpoint + 1);
		else {
			//cout << area_vector[segment_id].rectangle_width << " " << area_vector[segment_id].right_endpoint << " " << area_vector[segment_id - 1].right_endpoint << endl;
			assert(area_vector[segment_id].rectangle_width == area_vector[segment_id].right_endpoint - area_vector[segment_id - 1].right_endpoint);
		}

		if (area_vector[segment_id].rectangle_width == 1) {
			//getAandB(original_time_series, area_vector[segment_id]);
#ifdef _DEBUG
			assert(0);
#endif
		}
		else {
			a_minuend = (area_vector[segment_id].rectangle_width - 1) / 2.0;//(l-1)/2
			a_divisor = (area_vector[segment_id].rectangle_width - 1) * (area_vector[segment_id].rectangle_width + 1) * area_vector[segment_id].rectangle_width;//l(l-1)(l+1)
			assert(a_divisor != 0);

			b_minuend = 2.0 * area_vector[segment_id].rectangle_width - 1;//2l-1
			b_divisor = (area_vector[segment_id].rectangle_width + 1) * area_vector[segment_id].rectangle_width;//l(l+1)
			assert(b_divisor != 0);

			a_sum = 0;
			b_sum = 0;
			for (variable_id = 0, array_id = segment_id == 0 ? 0 : area_vector[segment_id - 1].right_endpoint + 1; array_id <= area_vector[segment_id].right_endpoint; array_id++, variable_id++) {
				a_sum += (variable_id - a_minuend) * original_time_series[array_id];
				b_sum += (b_minuend - variable_id * 3.0) * original_time_series[array_id];
			}

#ifdef _DEBUG
			assert(float(area_vector[segment_id].apla.a) == float(12.0 * a_sum / a_divisor));
			assert(float(area_vector[segment_id].apla.b) == float(2.0 * b_sum / b_divisor));
#endif

			area_vector[segment_id].apla.a = 12.0 * a_sum / a_divisor;
			area_vector[segment_id].apla.b = 2.0 * b_sum / b_divisor;
		}

		//cout << "a_sum: " << a_sum << " a_divisor: " << a_divisor << endl;
		//cout << "a: " << area_vector.at(segment_id).apla.a << " b: " << area_vector.at(segment_id).apla.b << endl;

		//reconstruct APLA time series
		//variable_id = 0;
		double temp_segment_deviation = 0;
		for (temp_segment_deviation = 0, variable_id = 0, array_id = segment_id == 0 ? 0 : area_vector[segment_id - 1].right_endpoint + 1; array_id <= area_vector[segment_id].right_endpoint; array_id++, variable_id++) {
			reconstruct_time_series[array_id] = area_vector[segment_id].apla.a * variable_id + area_vector[segment_id].apla.b;
			difference = fabs(reconstruct_time_series[array_id] - original_time_series[array_id]);
			max_deviation = max(max_deviation, difference);
			sum += difference * difference;
			temp_segment_deviation += difference * difference;
		}
		//assert(area_vector[segment_id].rec_deviation == sqrt(temp_segment_deviation));
	}

	//Print Array
	/*cout << "APLA Reconstructed Time Series: ";
	TOOL::printArray(reconstruct_time_series, input_argument.time_series_length);*/

	TOOL::writeSingleResult("ReconstructAPLA181218", reconstruct_time_series, input_argument.time_series_length);

	sum_deviation = sqrt(sum);

	typename TOOL::getDeviation(input_argument, original_time_series, reconstruct_time_series, output_argument);

	assert(sum_deviation == output_argument.sum_deviation && max_deviation == output_argument.max_deviation);

	TOOL::deleteArray(reconstruct_time_series);
	//cout << endl;
	/*APCA_KNN_QUAL::printArray(pointer,1280);*/
}

//************************************
// Method:getPLAByAdaptiveSegment
// Qualifier:Get a b and sum_value of segment
// date:190617
// author:
//************************************
TEMPLATE
void APLA::getPLAByAdaptiveSegment(const typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector) {//190617
	//printf("getPLA()\n");
	assert(0);
#ifdef _DEBUG
	//assert(area_vector.size() == input_argument.point_dimension);
	//reconstructed time series
	DataType* reconstruct_time_series = new DataType[input_argument.time_series_length];
	vector<double> segment_deviaiton_vector;//190611
#endif

	double difference = NULL;
	double sum = 0;
	double max_deviation = NULL;
	double sum_deviation = NULL;

	//coefficient of equation
	//a
	double a_minuend = NULL; //(l-1)/2
	double a_divisor = NULL; //l(l-1)(l+1)
	//b
	double b_minuend = NULL; //2l-1
	double b_divisor = NULL; //l(l+1)
	///////////////////////////////////////
	double a_sum = NULL;
	double b_sum = NULL;
	double variable_id = NULL; //[0-segment_length)
	int segment_id = 0;//[0-point_dimension)
	int array_id = NULL;//time series id

	for (segment_id = 0; segment_id < area_vector.size(); segment_id++) {
#ifdef _DEBUG
		assert(area_vector[segment_id].right_endpoint > 0);
		if (segment_id == 0)
			//if(area_vector.at(segment_id).right_endpoint>1)
			assert(area_vector[segment_id].rectangle_width == area_vector[segment_id].right_endpoint + 1);
		else {
			//cout << area_vector[segment_id].rectangle_width << " " << area_vector[segment_id].right_endpoint << " " << area_vector[segment_id - 1].right_endpoint << endl;
			assert(area_vector[segment_id].rectangle_width == area_vector[segment_id].right_endpoint - area_vector[segment_id - 1].right_endpoint);
		}
#endif
		if (area_vector[segment_id].rectangle_width == 1) {
			//assert(0);
			/*-----------sum value-----------*/
			area_vector[segment_id].sum_value = original_time_series[int(area_vector[segment_id].right_endpoint)];
			/*--------a&b coefficient--------*/
			area_vector[segment_id].apla.a_minuend = 0;//(l-1)/2
			area_vector[segment_id].apla.a_divisor = 0;//l(l-1)(l+1)
			area_vector[segment_id].apla.b_minuend = b_minuend = 2.0 * area_vector.at(segment_id).rectangle_width - 1;//2l-1
			area_vector[segment_id].apla.b_divisor = b_divisor = (area_vector.at(segment_id).rectangle_width + 1) * area_vector.at(segment_id).rectangle_width;//l(l+1)
			/*................................*/
			/*------   One point a&b  --------*/
			getAandBSlopInterceptOnePoint(original_time_series, area_vector[segment_id]);
			/*................................*/
		}
		else {
			area_vector[segment_id].apla.a_minuend = a_minuend = (area_vector.at(segment_id).rectangle_width - 1) / 2.0;//(l-1)/2
			area_vector[segment_id].apla.a_divisor = a_divisor = (area_vector.at(segment_id).rectangle_width - 1) * (area_vector.at(segment_id).rectangle_width + 1) * area_vector.at(segment_id).rectangle_width;//l(l-1)(l+1)

			area_vector[segment_id].apla.b_minuend = b_minuend = 2.0 * area_vector.at(segment_id).rectangle_width - 1;//2l-1
			area_vector[segment_id].apla.b_divisor = b_divisor = (area_vector.at(segment_id).rectangle_width + 1) * area_vector.at(segment_id).rectangle_width;//l(l+1)
#ifdef _DEBUG
			assert(a_divisor != 0 && b_divisor != 0);
#endif
			a_sum = 0;
			b_sum = 0;
			area_vector[segment_id].sum_value = 0;
			for (variable_id = 0, array_id = segment_id == 0 ? 0 : area_vector.at(segment_id - 1).right_endpoint + 1; array_id <= area_vector.at(segment_id).right_endpoint; array_id++, variable_id++) {
				a_sum += (variable_id - a_minuend) * original_time_series[array_id];
				b_sum += (b_minuend - variable_id * 3.0) * original_time_series[array_id];
				area_vector[segment_id].sum_value += original_time_series[array_id];
			}

#ifdef _DEBUG
			//assert(float(area_vector[segment_id].apla.a) == float(12.0 * a_sum / a_divisor));
			//assert(float(area_vector[segment_id].apla.b) == float(2.0 * b_sum / b_divisor));
#endif

			area_vector[segment_id].apla.a = 12.0 * a_sum / a_divisor;
			area_vector[segment_id].apla.b = 2.0 * b_sum / b_divisor;
		}

		//cout << "a_sum: " << a_sum << " a_divisor: " << a_divisor << endl;
		//cout << "a: " << area_vector.at(segment_id).apla.a << " b: " << area_vector.at(segment_id).apla.b << endl;

		//reconstruct APLA time series
		//variable_id = 0;
		/*===================================================Sume deviaiton & Max deviation & reconstruction time series================================================================*/
#ifdef _DEBUG
		double temp_segment_deviation = 0;
		for (temp_segment_deviation = 0, variable_id = 0, array_id = segment_id == 0 ? 0 : area_vector.at(segment_id - 1).right_endpoint + 1; array_id <= area_vector.at(segment_id).right_endpoint; array_id++, variable_id++) {
			reconstruct_time_series[array_id] = area_vector[segment_id].apla.a * variable_id + area_vector[segment_id].apla.b;
			difference = fabs(reconstruct_time_series[array_id] - original_time_series[array_id]);

			max_deviation = max(max_deviation, difference);
			sum += difference * difference;
			temp_segment_deviation += difference * difference;
		}
		segment_deviaiton_vector.push_back(sqrt(temp_segment_deviation));
		//assert(area_vector[segment_id].rec_deviation == sqrt(temp_segment_deviation));
#endif
		/*................................................................................................................................................................................*/
	}

	/*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
		/*=====================================Evaluation==================================================================*/
#ifdef _DEBUG
	sum_deviation = sqrt(sum);
	typename TOOL::getDeviation(input_argument, original_time_series, reconstruct_time_series, output_argument);
	assert(sum_deviation == output_argument.sum_deviation && max_deviation == output_argument.max_deviation);

	for (auto&& au : area_vector) {
		assert(au.sum_value != INF);
	}

#endif
	/*...............................................................................................................*/

	/*======================================Print Write result===============================================================================*/
	//Print Array
/*cout << "APLA Reconstructed Time Series: ";
TOOL::printArray(reconstruct_time_series, input_argument.time_series_length);*/

//cout << "APLA devation: ";
//for (auto&& au : segment_deviaiton_vector) {
//	cout << au << ", ";
//}
//cout << endl;

	//TOOL::writeSingleResult("ReconstructAPLA181218", reconstruct_time_series, input_argument.time_series_length);
	/*.....................................................................................................................*/
#ifdef _DEBUG
	TOOL::deleteArray(reconstruct_time_series);
#endif
}

//************************************
// Method:getPLAByAdaptiveSegment
// Qualifier : Linked list to instead vector, get slope and intercept a&b and sum value
// date:190821
// author:
//************************************
TEMPLATE
void APLA::getPLAByAdaptiveSegment(const typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list) {//190821
	//printf("getPLA()\n");
	assert(0);
#ifdef _DEBUG
	//assert(doubly_linked_list.size() == input_argument.point_dimension);
	//reconstructed time series
	DataType* reconstruct_time_series = new DataType[input_argument.time_series_length];
	vector<double> segment_deviaiton_vector;//190611
#endif

	double difference = NULL;
	double sum = 0;
	double max_deviation = NULL;
	double sum_deviation = NULL;

	//coefficient of equation
	///////////////////////////////////////
	double a_sum = INF;
	double b_sum = INF;
	double variable_id = NULL; //[0-segment_length)
	int segment_id = 0;//[0-point_dimension)
	int array_id = NULL;//time series id

	for (segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
#ifdef _DEBUG
		if (segment_id == 0)
			//if(area_vector.at(segment_id).right_endpoint>1)
			assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint + 1);
		else {
			//cout << area_vector[segment_id].rectangle_width << " " << area_vector[segment_id].right_endpoint << " " << area_vector[segment_id - 1].right_endpoint << endl;
			assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint);
		}
#endif
		if (doubly_linked_list[segment_id].rectangle_width == 1) {
			//assert(0);
			///*-----------sum value-----------*/
			//doubly_linked_list[segment_id].sum_value = original_time_series[int(doubly_linked_list[segment_id].right_endpoint)];
			///*--------a&b coefficient--------*/
			//doubly_linked_list[segment_id].apla.a_minuend = 0;//(l-1)/2
			//doubly_linked_list[segment_id].apla.a_divisor = 0;//l(l-1)(l+1)
			//doubly_linked_list[segment_id].apla.b_minuend = b_minuend = 2.0 * doubly_linked_list[segment_id].rectangle_width - 1;//2l-1
			//doubly_linked_list[segment_id].apla.b_divisor = b_divisor = (doubly_linked_list[segment_id].rectangle_width + 1) * doubly_linked_list[segment_id].rectangle_width;//l(l+1)
			/*................................*/
			/*------   One point a&b  --------*/
			getAandBSlopInterceptOnePoint(original_time_series, doubly_linked_list[segment_id]);
			/*................................*/
		}
		else if (doubly_linked_list[segment_id].rectangle_width == 2) {
			getAandBSlopInterceptTwoPoint(original_time_series, doubly_linked_list[segment_id]);
		}
		else {
			doubly_linked_list[segment_id].apla.a_minuend = (doubly_linked_list[segment_id].rectangle_width - 1) / 2.0;//(l-1)/2
			doubly_linked_list[segment_id].apla.a_divisor = (doubly_linked_list[segment_id].rectangle_width - 1) * (doubly_linked_list[segment_id].rectangle_width + 1) * doubly_linked_list[segment_id].rectangle_width;//l(l-1)(l+1)

			doubly_linked_list[segment_id].apla.b_minuend = 2.0 * doubly_linked_list[segment_id].rectangle_width - 1;//2l-1
			doubly_linked_list[segment_id].apla.b_divisor = (doubly_linked_list[segment_id].rectangle_width + 1) * doubly_linked_list[segment_id].rectangle_width;//l(l+1)
#ifdef _DEBUG
			assert(doubly_linked_list[segment_id].apla.a_divisor != 0 && doubly_linked_list[segment_id].apla.b_divisor != 0);
#endif
			a_sum = 0;
			b_sum = 0;
			doubly_linked_list[segment_id].sum_value = 0;
			for (variable_id = 0, array_id = segment_id == 0 ? 0 : doubly_linked_list[segment_id - 1].right_endpoint + 1; array_id <= doubly_linked_list[segment_id].right_endpoint; array_id++, variable_id++) {
				a_sum += (variable_id - doubly_linked_list[segment_id].apla.a_minuend) * original_time_series[array_id];
				b_sum += (doubly_linked_list[segment_id].apla.b_minuend - variable_id * 3.0) * original_time_series[array_id];
				doubly_linked_list[segment_id].sum_value += original_time_series[array_id];
			}

#ifdef _DEBUG
			//assert(float(doubly_linked_list[segment_id].apla.a) == float(12.0 * a_sum / a_divisor));
			//assert(float(doubly_linked_list[segment_id].apla.b) == float(2.0 * b_sum / b_divisor));
#endif
			doubly_linked_list[segment_id].apla.a = 12.0 * a_sum / doubly_linked_list[segment_id].apla.a_divisor;
			doubly_linked_list[segment_id].apla.b = 2.0 * b_sum / doubly_linked_list[segment_id].apla.b_divisor;
		}

		//cout << "a_sum: " << a_sum << " a_divisor: " << a_divisor << endl;
		//cout << "a: " << area_vector.at(segment_id).apla.a << " b: " << area_vector.at(segment_id).apla.b << endl;

		//reconstruct APLA time series
		//variable_id = 0;
		/*===================================================Sume deviaiton & Max deviation & reconstruction time series================================================================*/
#ifdef _DEBUG
		double temp_segment_deviation = 0;
		for (temp_segment_deviation = 0, variable_id = 0, array_id = segment_id == 0 ? 0 : doubly_linked_list[segment_id - 1].right_endpoint + 1; array_id <= doubly_linked_list[segment_id].right_endpoint; array_id++, variable_id++) {
			reconstruct_time_series[array_id] = doubly_linked_list[segment_id].apla.a * variable_id + doubly_linked_list[segment_id].apla.b;
			difference = fabs(reconstruct_time_series[array_id] - original_time_series[array_id]);

			max_deviation = max(max_deviation, difference);
			sum += difference * difference;
			temp_segment_deviation += difference * difference;
		}
		segment_deviaiton_vector.push_back(sqrt(temp_segment_deviation));
		//assert(area_vector[segment_id].rec_deviation == sqrt(temp_segment_deviation));
#endif
		/*................................................................................................................................................................................*/
	}

	/*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
		/*=====================================Evaluation==================================================================*/
#ifdef _DEBUG
	sum_deviation = sqrt(sum);
	typename TOOL::getDeviation(input_argument, original_time_series, reconstruct_time_series, output_argument);
	assert(sum_deviation == output_argument.sum_deviation && max_deviation == output_argument.max_deviation);

	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		assert(doubly_linked_list[segment_id].sum_value != INF);
	}

#endif
	/*...............................................................................................................*/

	/*======================================Print Write result===============================================================================*/
	//Print Array
/*cout << "APLA Reconstructed Time Series: ";
TOOL::printArray(reconstruct_time_series, input_argument.time_series_length);*/

//cout << "APLA devation: ";
//for (auto&& au : segment_deviaiton_vector) {
//	cout << au << ", ";
//}
//cout << endl;

	//TOOL::writeSingleResult("ReconstructAPLA181218", reconstruct_time_series, input_argument.time_series_length);
	/*.....................................................................................................................*/
#ifdef _DEBUG
	TOOL::deleteArray(reconstruct_time_series);
#endif
}

//200212  Add template, time ssieres use vector to instead pointer
//200212 Linked list to instead vector, get slope and intercept a&b and sum value . No minmax point
//************************************
// Method:getPLAByAdaptiveSegment
// Qualifier : Linked list to instead vector, get slope and intercept a&b and sum value
// date:190821
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
void APLA::getPLAByAdaptiveSegment(const U& const input_argument, const vector<T>& const original_time_series_vector, DoublyLinkedList<Y>& const doubly_linked_list) {//200212
	//printf("getPLA()\n");
#ifdef _DEBUG
	assert(input_argument.time_series_length == original_time_series_vector.size());
	//assert(doubly_linked_list.size() == input_argument.point_dimension);
	//reconstructed time series
	//DataType* reconstruct_time_series = new DataType[input_argument.time_series_length];
	vector<T> reconstruct_time_series_vector(original_time_series_vector.size(), INF);
	vector<double> segment_deviaiton_vector;//190611
#endif

	double difference = NULL;
	double sum = 0;
	double max_deviation = NULL;
	double sum_deviation = NULL;

	//coefficient of equation
	///////////////////////////////////////
	double a_sum = INF;
	double b_sum = INF;
	double variable_id = NULL; //[0-segment_length)
	int segment_id = 0;//[0-point_dimension)
	int array_id = NULL;//time series id

	for (segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
#ifdef _DEBUG
		if (segment_id == 0)
			//if(area_vector.at(segment_id).right_endpoint>1)
			assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint + 1);
		else {
			//cout << area_vector[segment_id].rectangle_width << " " << area_vector[segment_id].right_endpoint << " " << area_vector[segment_id - 1].right_endpoint << endl;
			assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint);
		}
#endif
		if (doubly_linked_list[segment_id].rectangle_width == 1) {
			//assert(0);
			///*-----------sum value-----------*/
			//doubly_linked_list[segment_id].sum_value = original_time_series_vector[int(doubly_linked_list[segment_id].right_endpoint)];
			///*--------a&b coefficient--------*/
			//doubly_linked_list[segment_id].apla.a_minuend = 0;//(l-1)/2
			//doubly_linked_list[segment_id].apla.a_divisor = 0;//l(l-1)(l+1)
			//doubly_linked_list[segment_id].apla.b_minuend = b_minuend = 2.0 * doubly_linked_list[segment_id].rectangle_width - 1;//2l-1
			//doubly_linked_list[segment_id].apla.b_divisor = b_divisor = (doubly_linked_list[segment_id].rectangle_width + 1) * doubly_linked_list[segment_id].rectangle_width;//l(l+1)
			/*................................*/
			/*------   One point a&b  --------*/
			getAandBSlopInterceptOnePoint(original_time_series_vector, doubly_linked_list[segment_id]);
			/*--------------------------------*/
		}
		else if (doubly_linked_list[segment_id].rectangle_width == 2) {
			getAandBSlopInterceptTwoPoint(original_time_series_vector, doubly_linked_list[segment_id]);
		}
		else {
			doubly_linked_list[segment_id].apla.a_minuend = (doubly_linked_list[segment_id].rectangle_width - 1) / 2.0;//(l-1)/2
			doubly_linked_list[segment_id].apla.a_divisor = (doubly_linked_list[segment_id].rectangle_width - 1) * (doubly_linked_list[segment_id].rectangle_width + 1) * doubly_linked_list[segment_id].rectangle_width;//l(l-1)(l+1)

			doubly_linked_list[segment_id].apla.b_minuend = 2.0 * doubly_linked_list[segment_id].rectangle_width - 1;//2l-1
			doubly_linked_list[segment_id].apla.b_divisor = (doubly_linked_list[segment_id].rectangle_width + 1) * doubly_linked_list[segment_id].rectangle_width;//l(l+1)
#ifdef _DEBUG
			assert(doubly_linked_list[segment_id].apla.a_divisor != 0 && doubly_linked_list[segment_id].apla.b_divisor != 0);
			double sum_value_segment_test = 0;
#endif
			a_sum = 0;
			b_sum = 0;
			//doubly_linked_list[segment_id].sum_value = 0;
			for (variable_id = 0, array_id = segment_id == 0 ? 0 : doubly_linked_list[segment_id - 1].right_endpoint + 1; array_id <= doubly_linked_list[segment_id].right_endpoint; array_id++, variable_id++) {
				a_sum += (variable_id - doubly_linked_list[segment_id].apla.a_minuend) * original_time_series_vector[array_id];
				b_sum += (doubly_linked_list[segment_id].apla.b_minuend - variable_id * 3.0) * original_time_series_vector[array_id];
#ifdef _DEBUG
				sum_value_segment_test += original_time_series_vector[array_id];
#endif
			}

#ifdef _DEBUG
			//assert(float(doubly_linked_list[segment_id].apla.a) == float(12.0 * a_sum / a_divisor));
			//assert(float(doubly_linked_list[segment_id].apla.b) == float(2.0 * b_sum / b_divisor));
#endif
			doubly_linked_list[segment_id].apla.a = 12.0 * a_sum / doubly_linked_list[segment_id].apla.a_divisor;
			doubly_linked_list[segment_id].apla.b = 2.0 * b_sum / doubly_linked_list[segment_id].apla.b_divisor;

			//200303 assert(sum value formualtion)
			//200316 sum value
			//doubly_linked_list[segment_id].sum_value = get_sum_value(doubly_linked_list[segment_id].apla.a, doubly_linked_list[segment_id].apla.b, doubly_linked_list[segment_id].rectangle_width);
#ifdef _DEBUG
			//200316 sum value
			//assert(fabs(doubly_linked_list[segment_id].sum_value - sum_value_segment_test) <= MIN_D);
#endif
		}

		//cout << "a_sum: " << a_sum << " a_divisor: " << a_divisor << endl;
		//cout << "a: " << area_vector.at(segment_id).apla.a << " b: " << area_vector.at(segment_id).apla.b << endl;

		//reconstruct APLA time series
		//variable_id = 0;
		/*===================================================Sume deviaiton & Max deviation & reconstruction time series================================================================*/
#ifdef _DEBUG
		double temp_segment_deviation = 0;
		for (temp_segment_deviation = 0, variable_id = 0, array_id = segment_id == 0 ? 0 : doubly_linked_list[segment_id - 1].right_endpoint + 1; array_id <= doubly_linked_list[segment_id].right_endpoint; array_id++, variable_id++) {
			reconstruct_time_series_vector[array_id] = doubly_linked_list[segment_id].apla.a * variable_id + doubly_linked_list[segment_id].apla.b;
			difference = fabs(reconstruct_time_series_vector[array_id] - original_time_series_vector[array_id]);

			max_deviation = max(max_deviation, difference);
			sum += difference * difference;
			temp_segment_deviation += difference * difference;
		}
		segment_deviaiton_vector.push_back(sqrt(temp_segment_deviation));

		//assert(area_vector[segment_id].rec_deviation == sqrt(temp_segment_deviation));
#endif
		/*................................................................................................................................................................................*/
	}

	/*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
		/*=====================================Evaluation==================================================================*/
#ifdef _DEBUG
	sum_deviation = sqrt(sum);
	typename TOOL::getDeviation(input_argument, original_time_series_vector, reconstruct_time_series_vector, output_argument);
	assert(sum_deviation == output_argument.sum_deviation && max_deviation == output_argument.max_deviation);

	//200316 sum value
	/*for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		assert(doubly_linked_list[segment_id].sum_value != INF);
	}*/

	reconstruct_time_series_vector.clear();
	reconstruct_time_series_vector.shrink_to_fit();

#endif
	/*...............................................................................................................*/

	/*======================================Print Write result===============================================================================*/
	//Print Array
/*cout << "APLA Reconstructed Time Series: ";
TOOL::printArray(reconstruct_time_series, input_argument.time_series_length);*/

//cout << "APLA devation: ";
//for (auto&& au : segment_deviaiton_vector) {
//	cout << au << ", ";
//}
//cout << endl;

	//TOOL::writeSingleResult("ReconstructAPLA181218", reconstruct_time_series, input_argument.time_series_length);
	/*.....................................................................................................................*/
//#ifdef _DEBUG
//	TOOL::deleteArray(reconstruct_time_series);
//#endif
}

//************************************
// Method:getPLAByAdaptiveSegment
// Qualifier :  Linked list to instead vector, get slope and intercept a&b and sum value & minmax point of every segment
// Input:
// Output: a&b, sum, pla coefficient, min max point
// date:191031
// author:
//************************************
TEMPLATE
//template<typename T>
void APLA::getPLAByAdaptiveSegmentAndMinMax(const typename TOOL::INPUT_ARGUMENT& const input_argument, DataType*& const original_time_series, DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list) {//191031
	//printf("getPLA()\n");
#ifdef _DEBUG
	//assert(doubly_linked_list.size() == input_argument.point_dimension);
	//reconstructed time series
	DataType* reconstruct_time_series = new DataType[input_argument.time_series_length];
	vector<double> segment_deviaiton_vector;//190611

	//assert right enpoint & width of every segment
	assertRightEndpoint_Width(doubly_linked_list);
#endif

	double difference = NULL;
	double sum = 0;
	double max_deviation = NULL;
	double sum_deviation = NULL;

	//coefficient of equation
	///////////////////////////////////////
	double a_sum = NULL;
	double b_sum = NULL;
	double variable_id = NULL; //[0-segment_length)
	int segment_id = 0;//[0-point_dimension)
	int array_id = NULL;//time series id

	for (segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		auto& const segment = doubly_linked_list[segment_id];
#ifdef _DEBUG
		if (segment_id == 0)
			//if(area_vector.at(segment_id).right_endpoint>1)
			assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint + 1);
		else {
			//cout << area_vector[segment_id].rectangle_width << " " << area_vector[segment_id].right_endpoint << " " << area_vector[segment_id - 1].right_endpoint << endl;
			assert(doubly_linked_list[segment_id].rectangle_width == doubly_linked_list[segment_id].right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint);
		}
#endif
		if (doubly_linked_list[segment_id].rectangle_width == 1) {
			//assert(0);
			/*------   One point a&b min max --------*/
			getAandBSlopInterceptOnePoint(original_time_series, doubly_linked_list[segment_id]);
			/*.......................................*/

			segment.sum_value = original_time_series[int(segment.right_endpoint)];
			segment.min_point.id = segment.max_point.id = int(segment.right_endpoint);
			segment.min_point.value = segment.max_point.value = original_time_series[int(segment.right_endpoint)];
		}
		else if (doubly_linked_list[segment_id].rectangle_width == 2) {
			// a&b sum value & min max 
			getAandBSlopInterceptTwoPoint(original_time_series, doubly_linked_list[segment_id]);
			int segment_left_id = doubly_linked_list[segment_id].right_endpoint - 1;
			if (original_time_series[int(doubly_linked_list[segment_id].right_endpoint - 1)] < original_time_series[int(segment.right_endpoint)]) {
				doubly_linked_list[segment_id].min_point.id = segment_left_id;
				doubly_linked_list[segment_id].max_point.id = doubly_linked_list[segment_id].right_endpoint;
				doubly_linked_list[segment_id].min_point.value = original_time_series[segment_left_id];
				doubly_linked_list[segment_id].max_point.value = original_time_series[int(doubly_linked_list[segment_id].right_endpoint)];
			}
			else {
				doubly_linked_list[segment_id].min_point.id = doubly_linked_list[segment_id].right_endpoint;
				doubly_linked_list[segment_id].max_point.id = segment_left_id;
				doubly_linked_list[segment_id].min_point.value = original_time_series[int(doubly_linked_list[segment_id].right_endpoint)];
				doubly_linked_list[segment_id].max_point.value = original_time_series[segment_left_id];
			}
		}
		else {
			doubly_linked_list[segment_id].apla.a_minuend = (doubly_linked_list[segment_id].rectangle_width - 1) / 2.0;//(l-1)/2
			doubly_linked_list[segment_id].apla.a_divisor = (doubly_linked_list[segment_id].rectangle_width - 1) * (doubly_linked_list[segment_id].rectangle_width + 1) * doubly_linked_list[segment_id].rectangle_width;//l(l-1)(l+1)

			doubly_linked_list[segment_id].apla.b_minuend = 2.0 * doubly_linked_list[segment_id].rectangle_width - 1;//2l-1
			doubly_linked_list[segment_id].apla.b_divisor = (doubly_linked_list[segment_id].rectangle_width + 1) * doubly_linked_list[segment_id].rectangle_width;//l(l+1)
#ifdef _DEBUG
			assert(doubly_linked_list[segment_id].apla.a_divisor != 0 && doubly_linked_list[segment_id].apla.b_divisor != 0);
#endif
			/*---------------------------MinMax point-----------------------------------------*/
			doubly_linked_list[segment_id].min_point.value = INF;
			doubly_linked_list[segment_id].max_point.value = -INF;
			/*--------------------------------------------------------------------------------*/
			a_sum = b_sum = 0;
			doubly_linked_list[segment_id].sum_value = 0;
			for (variable_id = 0, array_id = segment_id == 0 ? 0 : doubly_linked_list[segment_id - 1].right_endpoint + 1; array_id <= doubly_linked_list[segment_id].right_endpoint; array_id++, variable_id++) {
				a_sum += (variable_id - doubly_linked_list[segment_id].apla.a_minuend) * original_time_series[array_id];
				b_sum += (doubly_linked_list[segment_id].apla.b_minuend - variable_id * 3.0) * original_time_series[array_id];
				doubly_linked_list[segment_id].sum_value += original_time_series[array_id];
				/*---------------------------MinMax point-----------------------------------------*/
				if (doubly_linked_list[segment_id].min_point.value > original_time_series[array_id]) {
					doubly_linked_list[segment_id].min_point.id = array_id;
					doubly_linked_list[segment_id].min_point.value = original_time_series[array_id];
				}
				if (doubly_linked_list[segment_id].max_point.value <= original_time_series[array_id]) {
					doubly_linked_list[segment_id].max_point.id = array_id;
					doubly_linked_list[segment_id].max_point.value = original_time_series[array_id];
				}
				/*--------------------------------------------------------------------------------*/
			}

#ifdef _DEBUG
			const auto& const segment = doubly_linked_list[segment_id];
			if (segment.min_point.value == segment.max_point.value) assert(segment.min_point.id < segment.max_point.id);
			int segment_left_id = segment.right_endpoint - segment.rectangle_width + 1;
			if (segment_id > 0) {
				assert(segment_left_id == doubly_linked_list[segment_id - 1].right_endpoint + 1);
			}

			assert(segment.min_point.id >= segment_left_id && segment.max_point.id >= segment_left_id && segment.min_point.id <= segment.right_endpoint && segment.max_point.id <= segment.right_endpoint);
			//assert(float(doubly_linked_list[segment_id].apla.a) == float(12.0 * a_sum / a_divisor));
			//assert(float(doubly_linked_list[segment_id].apla.b) == float(2.0 * b_sum / b_divisor));
#endif
			doubly_linked_list[segment_id].apla.a = 12.0 * a_sum / doubly_linked_list[segment_id].apla.a_divisor;
			doubly_linked_list[segment_id].apla.b = 2.0 * b_sum / doubly_linked_list[segment_id].apla.b_divisor;
		}

		//cout << "a_sum: " << a_sum << " a_divisor: " << a_divisor << endl;
		//cout << "a: " << area_vector.at(segment_id).apla.a << " b: " << area_vector.at(segment_id).apla.b << endl;

		//reconstruct APLA time series
		//variable_id = 0;
		/*===================================================Sume deviaiton & Max deviation & reconstruction time series================================================================*/
#ifdef _DEBUG
		double temp_segment_deviation = 0;
		for (temp_segment_deviation = 0, variable_id = 0, array_id = segment_id == 0 ? 0 : doubly_linked_list[segment_id - 1].right_endpoint + 1; array_id <= doubly_linked_list[segment_id].right_endpoint; array_id++, variable_id++) {
			reconstruct_time_series[array_id] = doubly_linked_list[segment_id].apla.a * variable_id + doubly_linked_list[segment_id].apla.b;
			difference = fabs(reconstruct_time_series[array_id] - original_time_series[array_id]);
			max_deviation = max(max_deviation, difference);
			sum += difference * difference;
			temp_segment_deviation += difference * difference;
		}
		segment_deviaiton_vector.emplace_back(sqrt(temp_segment_deviation));
		//assert(area_vector[segment_id].rec_deviation == sqrt(temp_segment_deviation));
#endif
		/*................................................................................................................................................................................*/
	}
	/*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/*=====================================Evaluation==================================================================*/
#ifdef _DEBUG
	sum_deviation = sqrt(sum);
	typename TOOL::getDeviation(input_argument, original_time_series, reconstruct_time_series, output_argument);
	assert(sum_deviation == output_argument.sum_deviation && max_deviation == output_argument.max_deviation);

	//assert right endpoint, widht, a&b, minmax point, sum_value
	assertLinkedList(doubly_linked_list);

	vector<DataType> original_time_series_vector;
	original_time_series_vector.resize(input_argument.time_series_length);
	std::copy_n(original_time_series, input_argument.time_series_length, original_time_series_vector.begin());

	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		const auto& const segment = doubly_linked_list[segment_id];
		auto test_segment = segment;
		int segment_left_id = segment.right_endpoint - segment.rectangle_width + 1;
		getSegmentMinMaxPoint(original_time_series, test_segment);
		auto segment_sum = std::accumulate(original_time_series_vector.begin() + segment_left_id, original_time_series_vector.begin() + int(segment.right_endpoint + 1), 0.0);
		assert(segment.sum_value == segment_sum);
		assert(segment.sum_value != INF && test_segment.min_point.value == segment.min_point.value && test_segment.max_point.value == segment.max_point.value);
	}

#endif
	/*================================================================================================================*/

	/*======================================Print Write result===============================================================================*/
	//Print Array
/*cout << "APLA Reconstructed Time Series: ";
TOOL::printArray(reconstruct_time_series, input_argument.time_series_length);*/

//cout << "APLA devation: ";
//for (auto&& au : segment_deviaiton_vector) {
//	cout << au << ", ";
//}
//cout << endl;

	//TOOL::writeSingleResult("ReconstructAPLA181218", reconstruct_time_series, input_argument.time_series_length);
	/*=========================================================================================================================================*/
#ifdef _DEBUG
	TOOL::deleteArray(reconstruct_time_series);
#endif
}

//200212 use vector to instead pointer for time series.Add template
//191031 Linked list to instead vector, get slope and intercept a&b and sum value & minmax point of every segment
//************************************
// Method:getPLAByAdaptiveSegment
// Qualifier :  Linked list to instead vector, get slope and intercept a&b and sum value & minmax point of every segment
// Input:
// Output: a&b, sum, pla coefficient, min max point
// date:200212
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
void APLA::getPLAByAdaptiveSegmentAndMinMax(const U& const input_argument, const vector<T>& const original_time_series_vector, DoublyLinkedList<Y>& const doubly_linked_list) {//191031
	//printf("getPLA()\n");
#ifdef _DEBUG
	assert(input_argument.time_series_length == original_time_series_vector.size());
	//assert(doubly_linked_list.size() == input_argument.point_dimension);
	//reconstructed time series
	//DataType* reconstruct_time_series = new DataType[input_argument.time_series_length];
	vector<T> reconstruct_time_series_vector(original_time_series_vector.size(), INF);
	//vector<double> segment_deviaiton_vector;//190611

	//assert right enpoint & width of every segment
	assertRightEndpoint_Width(doubly_linked_list);
#endif

	double difference = NULL;
	double sum = 0;
	double max_deviation = NULL;
	double sum_deviation = NULL;

	//coefficient of equation
	///////////////////////////////////////
	double a_sum = NULL;
	double b_sum = NULL;
	double variable_id = NULL; //[0-segment_length)
	int segment_id = 0;//[0-point_dimension)
	int array_id = NULL;//time series id

	for (segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		auto& const segment = doubly_linked_list[segment_id];
#ifdef _DEBUG
		if (segment_id == 0)
			//if(area_vector.at(segment_id).right_endpoint>1)
			assert(segment.rectangle_width == segment.right_endpoint + 1);
		else {
			//cout << area_vector[segment_id].rectangle_width << " " << area_vector[segment_id].right_endpoint << " " << area_vector[segment_id - 1].right_endpoint << endl;
			assert(segment.rectangle_width == segment.right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint);
		}
#endif
		if (segment.apla.a == INF) {
#ifdef _DEBUG
			//assert(segment.apla.b == INF && segment.right_subsegment->segment_density == INF);
#endif
			if (segment.rectangle_width == 1) {
				//assert(0);
				/*------      One point a&b       --------*/
				getAandBSlopInterceptOnePoint(original_time_series_vector, segment);
				/*-----------------------------------------*/
				//200314 minmax point
				/*..............................................min&max point.......................................................................*/
				segment.min_point.id = segment.max_point.id = int(segment.right_endpoint);
				segment.min_point.value = segment.max_point.value = original_time_series_vector[int(segment.right_endpoint)];
				/*...................................................................................................................................*/
			}
			else if (segment.rectangle_width == 2) {
				// a&b sum value & min max 
				getAandBSlopInterceptTwoPoint(original_time_series_vector, segment);
				/*..............................................min&max point.......................................................................*/
				//200314 minmax point
				int segment_left_id = segment.right_endpoint - 1;
				if (original_time_series_vector[int(segment.right_endpoint - 1)] < original_time_series_vector[int(segment.right_endpoint)]) {
					segment.min_point.id = segment_left_id;
					segment.max_point.id = segment.right_endpoint;
					segment.min_point.value = original_time_series_vector[segment_left_id];
					segment.max_point.value = original_time_series_vector[int(segment.right_endpoint)];
				}
				else {
					segment.min_point.id = segment.right_endpoint;
					segment.max_point.id = segment_left_id;
					segment.min_point.value = original_time_series_vector[int(segment.right_endpoint)];
					segment.max_point.value = original_time_series_vector[segment_left_id];
				}
				/*...................................................................................................................................*/
			}
			else {
				segment.apla.a_minuend = (segment.rectangle_width - 1) / 2.0;//(l-1)/2
				segment.apla.a_divisor = (segment.rectangle_width - 1) * (segment.rectangle_width + 1) * segment.rectangle_width;//l(l-1)(l+1)

				segment.apla.b_minuend = 2.0 * segment.rectangle_width - 1;//2l-1
				segment.apla.b_divisor = (segment.rectangle_width + 1) * segment.rectangle_width;//l(l+1)
#ifdef _DEBUG
				assert(segment.apla.a_divisor != 0 && segment.apla.b_divisor != 0);
#endif
				/*---------------------------MinMax point-----------------------------------------*/
				//200314 minmax point
				segment.min_point.value = INF;
				segment.max_point.value = -INF;
				/*--------------------------------------------------------------------------------*/
				a_sum = b_sum = 0;
				//segment.sum_value = 0;
				for (variable_id = 0, array_id = segment_id == 0 ? 0 : doubly_linked_list[segment_id - 1].right_endpoint + 1; array_id <= segment.right_endpoint; array_id++, variable_id++) {
					a_sum += (variable_id - segment.apla.a_minuend) * original_time_series_vector[array_id];
					b_sum += (segment.apla.b_minuend - variable_id * 3.0) * original_time_series_vector[array_id];
					//segment.sum_value += original_time_series_vector[array_id];
					/*---------------------------MinMax point-----------------------------------------*/
					//200314 minmax point
					if (segment.min_point.value > original_time_series_vector[array_id]) {
						segment.min_point.id = array_id;
						segment.min_point.value = original_time_series_vector[array_id];
					}
					if (segment.max_point.value <= original_time_series_vector[array_id]) {
						segment.max_point.id = array_id;
						segment.max_point.value = original_time_series_vector[array_id];
					}
					/*--------------------------------------------------------------------------------*/
				}

#ifdef _DEBUG
				//const auto& const segment = segment;
				//200314 minmax point
				//if (segment.min_point.value == segment.max_point.value) assert(segment.min_point.id < segment.max_point.id);
				int segment_left_id = segment.right_endpoint - segment.rectangle_width + 1;
				if (segment_id > 0) {
					assert(segment_left_id == doubly_linked_list[segment_id - 1].right_endpoint + 1);
				}
				/*......................................................          200314 minmax point                     .......................................*/
				//assert(segment.min_point.id >= segment_left_id && segment.max_point.id >= segment_left_id && segment.min_point.id <= segment.right_endpoint && segment.max_point.id <= segment.right_endpoint);
				/*............................................................................................................................................................*/
				//assert(float(segment.apla.a) == float(12.0 * a_sum / a_divisor));
				//assert(float(segment.apla.b) == float(2.0 * b_sum / b_divisor));
#endif
				segment.apla.a = 12.0 * a_sum / segment.apla.a_divisor;
				segment.apla.b = 2.0 * b_sum / segment.apla.b_divisor;

			}
		}
		//200316 sum value
		//segment.sum_value = get_sum_value(segment.apla.a, segment.apla.b, segment.rectangle_width);
		//cout << "a_sum: " << a_sum << " a_divisor: " << a_divisor << endl;
		//cout << "a: " << area_vector.at(segment_id).apla.a << " b: " << area_vector.at(segment_id).apla.b << endl;

		//reconstruct APLA time series
		//variable_id = 0;
		/*===================================================Sume deviaiton & Max deviation & reconstruction time series================================================================*/
#ifdef _DEBUG
		double temp_segment_deviation = 0;
		for (temp_segment_deviation = 0, variable_id = 0, array_id = segment_id == 0 ? 0 : doubly_linked_list[segment_id - 1].right_endpoint + 1; array_id <= segment.right_endpoint; array_id++, variable_id++) {
			reconstruct_time_series_vector[array_id] = segment.apla.a * variable_id + segment.apla.b;
			difference = fabs(reconstruct_time_series_vector[array_id] - original_time_series_vector[array_id]);
			max_deviation = max(max_deviation, difference);
			sum += difference * difference;
			temp_segment_deviation += difference * difference;
		}
		//segment_deviaiton_vector.emplace_back(sqrt(temp_segment_deviation));
		//assert(area_vector[segment_id].rec_deviation == sqrt(temp_segment_deviation));
#endif
		/*................................................................................................................................................................................*/
	}
	/*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/*=====================================Evaluation==================================================================*/
#ifdef _DEBUG
	sum_deviation = sqrt(sum);
	typename TOOL::getDeviation(input_argument, original_time_series_vector, reconstruct_time_series_vector, output_argument);
	assert(sum_deviation == output_argument.sum_deviation && max_deviation == output_argument.max_deviation);

	//assert right endpoint, widht, a&b, minmax point, sum_value
	//assertLinkedList(doubly_linked_list);

	/*vector<DataType> original_time_series_vector;
	original_time_series_vector.resize(input_argument.time_series_length);
	std::copy_n(original_time_series_vector, input_argument.time_series_length, original_time_series_vector.begin());*/

	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		const auto& const segment = doubly_linked_list[segment_id];
		auto test_segment = segment;
		int segment_left_id = segment.right_endpoint - segment.rectangle_width + 1;
		//200314 minmax point
		getSegmentMinMaxPoint(original_time_series_vector, test_segment);
		float segment_sum = std::accumulate(original_time_series_vector.begin() + segment_left_id, original_time_series_vector.begin() + int(segment.right_endpoint + 1), 0.0);
		//200316 sum value
		//assert(float(segment.sum_value) == segment_sum);
		//200314 minmax point
		assert(test_segment.min_point.value == segment.min_point.value && test_segment.max_point.value == segment.max_point.value);
	}
#endif
	/*================================================================================================================*/

	/*======================================Print Write result===============================================================================*/
	//Print Array
/*cout << "APLA Reconstructed Time Series: ";
TOOL::printArray(reconstruct_time_series, input_argument.time_series_length);*/

//cout << "APLA devation: ";
//for (auto&& au : segment_deviaiton_vector) {
//	cout << au << ", ";
//}
//cout << endl;

	//TOOL::writeSingleResult("ReconstructAPLA181218", reconstruct_time_series, input_argument.time_series_length);
	/*=========================================================================================================================================*/
#ifdef _DEBUG
	//TOOL::deleteArray(reconstruct_time_series);
	reconstruct_time_series_vector.clear();
	reconstruct_time_series_vector.shrink_to_fit();
#endif

}

//200212 use vector to instead pointer for time series. Add template
//200319 Linked list to instead vector, get slope and intercept a&b, triangle density, area difference
//************************************
// Method:get_each_segment_ab_density_difference
// Qualifier: Linked list to instead vector, get slope and intercept a&b, triangle density, area difference
// Input: original time series. doubly linked list segment
// Output: a&b, pla coefficient, triangle density, area difference
// date:200319
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
void APLA::get_each_segment_ab_density_difference(const vector<T>& const original_time_series_vector, DoublyLinkedList<Y>& const doubly_linked_list) {
#ifdef _DEBUG
	assert(!original_time_series_vector.empty());
	//assert right enpoint & width of every segment
	assertRightEndpoint_Width(doubly_linked_list);
#endif
	//coefficient of equation
	///////////////////////////////////////
	long double a_sum = NULL;
	long double b_sum = NULL;
	double variable_id = NULL; //[0-segment_length)
	int segment_id = 0;//[0-point_dimension)
	int array_id = NULL;//time series id

	for (segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		auto& const segment = doubly_linked_list[segment_id];
#ifdef _DEBUG
		if (segment_id == 0)
			//if(area_vector.at(segment_id).right_endpoint>1)
			assert(segment.rectangle_width == segment.right_endpoint + 1);
		else {
			//cout << area_vector[segment_id].rectangle_width << " " << area_vector[segment_id].right_endpoint << " " << area_vector[segment_id - 1].right_endpoint << endl;
			assert(segment.rectangle_width == segment.right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint);
		}
#endif
		/*=========================================================================Compute a&b===========================================================================================*/
		if (segment.apla.a == INF) {
#ifdef _DEBUG
			assert(segment.apla.b == INF && segment.right_subsegment->segment_density == INF);
#endif
			/*..................get a&b of one segment..............*/
			get_ab_segment(original_time_series_vector, segment);
			/*......................................................*/
//
//			//one point
//			if (segment.rectangle_width == 1) {
//				getAandBSlopInterceptOnePoint(original_time_series_vector, segment);
//			}//two points
//			else if (segment.rectangle_width == 2) {
//				getAandBSlopInterceptTwoPoint(original_time_series_vector, segment);
//			}//many points
//			else {
//				segment.apla.a_minuend = (segment.rectangle_width - 1) / 2.0;//(l-1)/2
//				segment.apla.a_divisor = (segment.rectangle_width - 1) * (segment.rectangle_width + 1) * segment.rectangle_width;//l(l-1)(l+1)
//				segment.apla.b_minuend = 2.0 * segment.rectangle_width - 1;//2l-1
//				segment.apla.b_divisor = (segment.rectangle_width + 1) * segment.rectangle_width;//l(l+1)
//#ifdef _DEBUG
//				assert(segment.apla.a_divisor != 0 && segment.apla.b_divisor != 0);
//#endif
//				a_sum = b_sum = 0;
//				for (variable_id = 0, array_id = segment_id == 0 ? 0 : doubly_linked_list[segment_id - 1].right_endpoint + 1; array_id <= segment.right_endpoint; array_id++, variable_id++) {
//					a_sum += (variable_id - segment.apla.a_minuend) * original_time_series_vector[array_id];
//					b_sum += (segment.apla.b_minuend - variable_id * 3.0) * original_time_series_vector[array_id];
//				}
//				segment.apla.a = 12.0 * a_sum / segment.apla.a_divisor;
//				segment.apla.b = 2.0 * b_sum / segment.apla.b_divisor;
//			}
		}
		/*===============================================================================================================================================================================*/
		/*=========================================================================Compute a&b===========================================================================================*/

		/*===============================================================================================================================================================================*/

	}
	/*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/*================================================Evaluation==================================================================*/
#ifdef _DEBUG
	//assert right endpoint, widht, a&b, minmax point, sum_value
	assertLinkedList(doubly_linked_list);
	//TOOL::deleteArray(reconstruct_time_series);
#endif
	/*=============================================================================================================================*/
}

//************************************
// Method:printSpecialPoint
// Qualifier:Print special point for segment
// date:190519
// author:
//************************************
TEMPLATE
void APLA::printSpecialPoint(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient) {//190517
	if (temp_coefficient.rectangle_width > 2) {
		/*=================================Print===============================*/
		cout << "diff: ";
		for (int order = 1, array_id = vector_id > 1 ? area_vector[vector_id - 2].right_endpoint + 1 : 0; array_id <= area_vector[vector_id].right_endpoint; array_id++, order++) {
			cout << order << ": " << array_id << ": " << original_time_series[array_id] << " ";
			if (array_id == area_vector[vector_id - 1].deviation_point.id || array_id == area_vector[vector_id].deviation_point.id)
				cout << "<- ";
			if (array_id == temp_coefficient.deviation_point.id)
				cout << "<= ";

			if (array_id == area_vector[vector_id - 1].min_point.id || array_id == area_vector[vector_id].min_point.id || array_id == area_vector[vector_id - 1].max_point.id || array_id == area_vector[vector_id].max_point.id)
				cout << "<*";
			if (array_id == temp_coefficient.min_point.id || array_id == temp_coefficient.max_point.id)
				cout << "<& ";
			if (array_id == area_vector[vector_id - 1].right_endpoint)
				cout << "|";
		}
		cout << endl;
		//Original time
		for (int array_id = vector_id > 1 ? area_vector[vector_id - 2].right_endpoint + 1 : 0; array_id <= area_vector[vector_id].right_endpoint; array_id++) {
			cout << original_time_series[array_id] << ",";
		}
		cout << endl;
		int original_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
		double temp_deviation = 0;
		//reconstruct
		for (int i = 0; i < temp_coefficient.rectangle_width; i++) {
			temp_deviation = fabs(temp_coefficient.apla.a * i + temp_coefficient.apla.b - original_time_series[original_id + i]);
			cout << temp_coefficient.apla.a * i + temp_coefficient.apla.b << ",";
		}
		cout << endl;
		//left sub segment
		int left_original_id = temp_coefficient.left_subsegment->right_endpoint - temp_coefficient.left_subsegment->rectangle_width + 1;
		for (int i = 0; i < temp_coefficient.left_subsegment->rectangle_width; i++) {
			cout << temp_coefficient.left_subsegment->apla.a * i + temp_coefficient.left_subsegment->apla.b << ",";
		}
		//right sub segment
		int right_original_id = temp_coefficient.right_subsegment->right_endpoint - temp_coefficient.right_subsegment->rectangle_width + 1;
		for (int i = 0; i < temp_coefficient.right_subsegment->rectangle_width; i++) {
			cout << temp_coefficient.right_subsegment->apla.a * i + temp_coefficient.right_subsegment->apla.b << ",";
		}
		cout << endl;

		return;
		/*.....................................................................*/
		//**total_merge_infor_count++;
		if (temp_coefficient.deviation_point.id == area_vector[vector_id - 1].deviation_point.id || temp_coefficient.deviation_point.id == area_vector[vector_id].deviation_point.id) {
			output_argument.same_deviation_id_count++;
		}
		else
			output_argument.diff_deviation_id_count++;
		//
		if (temp_coefficient.deviation_point.id == area_vector[vector_id - 1].min_point.id
			|| temp_coefficient.deviation_point.id == area_vector[vector_id].min_point.id
			|| temp_coefficient.deviation_point.id == area_vector[vector_id - 1].max_point.id
			|| temp_coefficient.deviation_point.id == area_vector[vector_id].max_point.id
			|| temp_coefficient.deviation_point.id == area_vector[vector_id - 1].deviation_point.id
			|| temp_coefficient.deviation_point.id == area_vector[vector_id].deviation_point.id
			|| temp_coefficient.deviation_point.id == area_vector[vector_id - 1].right_endpoint
			|| temp_coefficient.deviation_point.id == area_vector[vector_id].right_endpoint
			|| temp_coefficient.deviation_point.id == area_vector[vector_id - 1].right_endpoint + 1
			|| temp_coefficient.deviation_point.id == area_vector[vector_id - 1].right_endpoint - area_vector[vector_id - 1].rectangle_width + 1
			|| temp_coefficient.deviation_point.id == area_vector[vector_id - 1].min_point.id + 1
			|| temp_coefficient.deviation_point.id == area_vector[vector_id].min_point.id + 1
			|| temp_coefficient.deviation_point.id == area_vector[vector_id - 1].max_point.id + 1
			|| temp_coefficient.deviation_point.id == area_vector[vector_id].max_point.id + 1
			|| temp_coefficient.deviation_point.id == area_vector[vector_id - 1].right_endpoint - 1
			|| temp_coefficient.deviation_point.id == area_vector[vector_id].right_endpoint - 1
			|| temp_coefficient.deviation_point.id == area_vector[vector_id - 1].right_endpoint + 2
			|| temp_coefficient.deviation_point.id == area_vector[vector_id - 1].right_endpoint - area_vector[vector_id - 1].rectangle_width + 2
			) {
			return;
			//deviation_all_count++;
		}
		else {
			cout << "diff: ";
			for (int order = 1, array_id = vector_id > 1 ? area_vector[vector_id - 2].right_endpoint + 1 : 0; array_id <= area_vector[vector_id].right_endpoint; array_id++, order++) {
				cout << order << ": " << original_time_series[array_id] << " ";
				if (array_id == area_vector[vector_id - 1].deviation_point.id || array_id == area_vector[vector_id].deviation_point.id)
					cout << "<- ";
				if (array_id == temp_coefficient.deviation_point.id)
					cout << "<= ";

				if (array_id == area_vector[vector_id - 1].min_point.id || array_id == area_vector[vector_id].min_point.id || array_id == area_vector[vector_id - 1].max_point.id || array_id == area_vector[vector_id].max_point.id)
					cout << "<*";
				if (array_id == temp_coefficient.min_point.id || array_id == temp_coefficient.max_point.id)
					cout << "<& ";
				if (array_id == area_vector[vector_id - 1].right_endpoint)
					cout << "|";
			}
			//a & b
			cout << endl;
			cout << "m a: " << temp_coefficient.apla.a << " m b: " << temp_coefficient.apla.a << endl;
			cout << "l a: " << area_vector[vector_id - 1].apla.a << " l b: " << area_vector[vector_id - 1].apla.b << " r a: " << area_vector[vector_id].apla.a << " r b: " << area_vector[vector_id].apla.b << endl;
			cout << "l sub left a: " << temp_coefficient.left_subsegment->left_subsegment->apla.a << " l sub left b: " << temp_coefficient.left_subsegment->left_subsegment->apla.b;
			cout << " l sub right a: " << temp_coefficient.left_subsegment->right_subsegment->apla.a << "l sub right b: " << temp_coefficient.left_subsegment->right_subsegment->apla.b;
			cout << endl;
			cout << "r sub left a: " << temp_coefficient.right_subsegment->left_subsegment->apla.a << " r sub left b: " << temp_coefficient.right_subsegment->left_subsegment->apla.b;
			cout << " r sub right a: " << temp_coefficient.right_subsegment->right_subsegment->apla.a << "r sub right b: " << temp_coefficient.right_subsegment->right_subsegment->apla.b;
			cout << endl;
			cout << "rr sub left a: " << temp_coefficient.right_subsegment->left_subsegment->left_subsegment->apla.a << " rr sub left b: " << temp_coefficient.right_subsegment->left_subsegment->left_subsegment->apla.b;
			cout << " rr sub right a: " << temp_coefficient.right_subsegment->left_subsegment->right_subsegment->apla.a << "rr sub right b: " << temp_coefficient.right_subsegment->left_subsegment->right_subsegment->apla.b;
			cout << endl;

			//Original time
			for (int array_id = vector_id > 1 ? area_vector[vector_id - 2].right_endpoint + 1 : 0; array_id <= area_vector[vector_id].right_endpoint; array_id++) {
				cout << original_time_series[array_id] << ",";
			}
			cout << endl;
			int original_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
			double temp_deviation = 0;
			//reconstruct
			for (int i = 0; i < temp_coefficient.rectangle_width; i++) {
				temp_deviation = fabs(temp_coefficient.apla.a * i + temp_coefficient.apla.b - original_time_series[original_id + i]);
				cout << temp_coefficient.apla.a * i + temp_coefficient.apla.b << ",";
			}
			cout << endl;
			//left sub segment
			int left_original_id = temp_coefficient.left_subsegment->right_endpoint - temp_coefficient.left_subsegment->rectangle_width + 1;
			for (int i = 0; i < temp_coefficient.left_subsegment->rectangle_width; i++) {
				cout << temp_coefficient.left_subsegment->apla.a * i + temp_coefficient.left_subsegment->apla.b << ",";
			}
			//right sub segment
			int right_original_id = temp_coefficient.right_subsegment->right_endpoint - temp_coefficient.right_subsegment->rectangle_width + 1;
			for (int i = 0; i < temp_coefficient.right_subsegment->rectangle_width; i++) {
				cout << temp_coefficient.right_subsegment->apla.a * i + temp_coefficient.right_subsegment->apla.b << ",";
			}
			cout << endl;
			//left sub left segment
			for (int i = 0; i < temp_coefficient.left_subsegment->left_subsegment->rectangle_width; i++) {
				cout << temp_coefficient.left_subsegment->left_subsegment->apla.a * i + temp_coefficient.left_subsegment->left_subsegment->apla.b << ",";
			}
			//left sub right segment
			for (int i = 0; i < temp_coefficient.left_subsegment->right_subsegment->rectangle_width; i++) {
				cout << temp_coefficient.left_subsegment->right_subsegment->apla.a * i + temp_coefficient.left_subsegment->right_subsegment->apla.b << ",";
			}
			//right sub left segment
			for (int i = 0; i < temp_coefficient.right_subsegment->left_subsegment->rectangle_width; i++) {
				cout << temp_coefficient.right_subsegment->left_subsegment->apla.a * i + temp_coefficient.right_subsegment->left_subsegment->apla.b << ",";
			}
			//right sub right segment
			for (int i = 0; i < temp_coefficient.right_subsegment->right_subsegment->rectangle_width; i++) {
				cout << temp_coefficient.right_subsegment->right_subsegment->apla.a * i + temp_coefficient.right_subsegment->right_subsegment->apla.b << ",";
			}
			cout << endl;
			//cout << endl;
		}
	}
}
//************************************
// Method:printSpecialPoint0
// Qualifier:Print special point for segment
// date:190519
// author:
//************************************
TEMPLATE
void APLA::printSpecialPoint0(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient) {//190517
	draw3Line(original_time_series, area_vector, vector_id, temp_coefficient);
	//printMaxMagnitude(temp_coefficient);//190524
	int origintal_id = vector_id > 1 ? temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1 : 0;
	//cout << "left id: " << left_id- origintal_id << " right id:" << right_id - origintal_id << endl;
	cout << "diff: ";
	for (int order = 1, array_id = vector_id > 1 ? area_vector[vector_id - 2].right_endpoint + 1 : 0; array_id <= area_vector[vector_id].right_endpoint; array_id++, order++) {
		cout << order << ": " << array_id << ": " << original_time_series[array_id] << " ";
		if (array_id == area_vector[vector_id - 1].deviation_point.id || array_id == area_vector[vector_id].deviation_point.id)
			cout << "<- ";
		if (array_id == temp_coefficient.deviation_point.id)
			cout << "<= ";

		if (array_id == area_vector[vector_id - 1].min_point.id || array_id == area_vector[vector_id].min_point.id || array_id == area_vector[vector_id - 1].max_point.id || array_id == area_vector[vector_id].max_point.id)
			cout << "<*";
		if (array_id == temp_coefficient.min_point.id || array_id == temp_coefficient.max_point.id)
			cout << "<& ";
		if (array_id == area_vector[vector_id - 1].right_endpoint)
			cout << "|";
	}
	//a & b
	cout << endl;
	cout << "m a: " << temp_coefficient.apla.a << " m b: " << temp_coefficient.apla.a << endl;
	cout << "l a: " << area_vector[vector_id - 1].apla.a << " l b: " << area_vector[vector_id - 1].apla.b << " r a: " << area_vector[vector_id].apla.a << " r b: " << area_vector[vector_id].apla.b << endl;
	if (temp_coefficient.left_subsegment != nullptr && temp_coefficient.right_subsegment != nullptr) {
		if (temp_coefficient.left_subsegment->left_subsegment != nullptr && temp_coefficient.left_subsegment->right_subsegment != nullptr) {
			cout << "l sub left a: " << temp_coefficient.left_subsegment->left_subsegment->apla.a << " l sub left b: " << temp_coefficient.left_subsegment->left_subsegment->apla.b;
			cout << " l sub right a: " << temp_coefficient.left_subsegment->right_subsegment->apla.a << "l sub right b: " << temp_coefficient.left_subsegment->right_subsegment->apla.b;
			cout << endl;
		}
		if (temp_coefficient.right_subsegment->left_subsegment != nullptr && temp_coefficient.right_subsegment->right_subsegment != nullptr) {
			cout << "r sub left a: " << temp_coefficient.right_subsegment->left_subsegment->apla.a << " r sub left b: " << temp_coefficient.right_subsegment->left_subsegment->apla.b;
			cout << " r sub right a: " << temp_coefficient.right_subsegment->right_subsegment->apla.a << "r sub right b: " << temp_coefficient.right_subsegment->right_subsegment->apla.b;
			cout << endl;
		}
	}
	//Original time
	for (int array_id = vector_id > 1 ? area_vector[vector_id - 2].right_endpoint + 1 : 0; array_id <= area_vector[vector_id].right_endpoint; array_id++) {
		cout << original_time_series[array_id] << ",";
	}
	cout << endl;
	int original_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	double temp_deviation = 0;
	//reconstruct
	for (int i = 0; i < temp_coefficient.rectangle_width; i++) {
		temp_deviation = fabs(temp_coefficient.apla.a * i + temp_coefficient.apla.b - original_time_series[original_id + i]);
		cout << temp_coefficient.apla.a * i + temp_coefficient.apla.b << ",";
	}
	cout << endl;

	//left sub segment
	int left_original_id = temp_coefficient.left_subsegment->right_endpoint - temp_coefficient.left_subsegment->rectangle_width + 1;
	for (int i = 0; i < temp_coefficient.left_subsegment->rectangle_width; i++) {
		cout << temp_coefficient.left_subsegment->apla.a * i + temp_coefficient.left_subsegment->apla.b << ",";
	}
	//right sub segment
	int right_original_id = temp_coefficient.right_subsegment->right_endpoint - temp_coefficient.right_subsegment->rectangle_width + 1;
	for (int i = 0; i < temp_coefficient.right_subsegment->rectangle_width; i++) {
		cout << temp_coefficient.right_subsegment->apla.a * i + temp_coefficient.right_subsegment->apla.b << ",";
	}
	cout << endl;

	//left sub left segment
	if (temp_coefficient.left_subsegment->left_subsegment != nullptr)
		for (int i = 0; i < temp_coefficient.left_subsegment->left_subsegment->rectangle_width; i++) {
			cout << temp_coefficient.left_subsegment->left_subsegment->apla.a * i + temp_coefficient.left_subsegment->left_subsegment->apla.b << ",";
		}
	//left sub right segment
	if (temp_coefficient.left_subsegment->right_subsegment != nullptr)
		for (int i = 0; i < temp_coefficient.left_subsegment->right_subsegment->rectangle_width; i++) {
			cout << temp_coefficient.left_subsegment->right_subsegment->apla.a * i + temp_coefficient.left_subsegment->right_subsegment->apla.b << ",";
		}
	//right sub left segment
	if (temp_coefficient.right_subsegment->left_subsegment != nullptr)
		for (int i = 0; i < temp_coefficient.right_subsegment->left_subsegment->rectangle_width; i++) {
			cout << temp_coefficient.right_subsegment->left_subsegment->apla.a * i + temp_coefficient.right_subsegment->left_subsegment->apla.b << ",";
		}
	//right sub right segment
	if (temp_coefficient.right_subsegment->right_subsegment != nullptr)
		for (int i = 0; i < temp_coefficient.right_subsegment->right_subsegment->rectangle_width; i++) {
			cout << temp_coefficient.right_subsegment->right_subsegment->apla.a * i + temp_coefficient.right_subsegment->right_subsegment->apla.b << ",";
		}
	cout << endl;
	cout << "/************************/" << endl;
	//printSpecialPoint(original_time_series, area_vector, vector_id, temp_coefficient);
	printReconstructRecursive(temp_coefficient, 1);
	cout << endl;
	printReconstructRecursive(temp_coefficient, 2);
	cout << endl;
	printReconstructRecursive(temp_coefficient, 3);
	cout << endl;
	printReconstructRecursive(temp_coefficient, 4);
	cout << endl;
	printReconstructRecursive(temp_coefficient, 5);
	cout << endl;
	printReconstructRecursive(temp_coefficient, 6);
	cout << endl;
	printReconstructRecursive(temp_coefficient, 7);
	cout << endl;
	cout << endl;
}

//************************************
// Method:printSpecialPoint1
// Qualifier:Print special point for segment
// date:190602
// author:
//************************************
TEMPLATE
void APLA::printSpecialPoint1(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient) {//190602
	//draw3Line(original_time_series, area_vector, vector_id, temp_coefficient);
	//printMaxMagnitude(temp_coefficient);//190524
	int origintal_id = vector_id > 1 ? temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1 : 0;
	//cout << "left id: " << left_id- origintal_id << " right id:" << right_id - origintal_id << endl;
	cout << "diff: ";
	for (int order = 1, array_id = vector_id > 1 ? area_vector[vector_id - 2].right_endpoint + 1 : 0; array_id <= area_vector[vector_id].right_endpoint; array_id++, order++) {
		cout << order << ": " << array_id << ": " << original_time_series[array_id] << " ";
		if (array_id == area_vector[vector_id - 1].deviation_point.id || array_id == area_vector[vector_id].deviation_point.id)
			cout << "<- ";
		if (array_id == temp_coefficient.deviation_point.id)
			cout << "<= ";

		if (array_id == area_vector[vector_id - 1].min_point.id || array_id == area_vector[vector_id].min_point.id || array_id == area_vector[vector_id - 1].max_point.id || array_id == area_vector[vector_id].max_point.id)
			cout << "<*";
		if (array_id == temp_coefficient.min_point.id || array_id == temp_coefficient.max_point.id)
			cout << "<& ";
		if (array_id == area_vector[vector_id - 1].right_endpoint)
			cout << "|";
	}
	//a & b
	cout << endl;
	cout << "m a: " << temp_coefficient.apla.a << " m b: " << temp_coefficient.apla.b << endl;
	cout << "l a: " << area_vector[vector_id - 1].apla.a << " l b: " << area_vector[vector_id - 1].apla.b << " r a: " << area_vector[vector_id].apla.a << " r b: " << area_vector[vector_id].apla.b << endl;
	if (temp_coefficient.left_subsegment != nullptr && temp_coefficient.right_subsegment != nullptr) {
		if (temp_coefficient.left_subsegment->left_subsegment != nullptr && temp_coefficient.left_subsegment->right_subsegment != nullptr) {
			cout << "l sub left a: " << temp_coefficient.left_subsegment->left_subsegment->apla.a << " l sub left b: " << temp_coefficient.left_subsegment->left_subsegment->apla.b;
			cout << " l sub right a: " << temp_coefficient.left_subsegment->right_subsegment->apla.a << "l sub right b: " << temp_coefficient.left_subsegment->right_subsegment->apla.b;
			cout << endl;
		}
		if (temp_coefficient.right_subsegment->left_subsegment != nullptr && temp_coefficient.right_subsegment->right_subsegment != nullptr) {
			cout << "r sub left a: " << temp_coefficient.right_subsegment->left_subsegment->apla.a << " r sub left b: " << temp_coefficient.right_subsegment->left_subsegment->apla.b;
			cout << " r sub right a: " << temp_coefficient.right_subsegment->right_subsegment->apla.a << "r sub right b: " << temp_coefficient.right_subsegment->right_subsegment->apla.b;
			cout << endl;
		}
	}
	//Original time
	for (int array_id = vector_id > 1 ? area_vector[vector_id - 2].right_endpoint + 1 : 0; array_id <= area_vector[vector_id].right_endpoint; array_id++) {
		cout << original_time_series[array_id] << ",";
	}
	cout << endl;
	int original_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	//double temp_deviation = 0;
	//reconstruct
	for (int i = 0; i < temp_coefficient.rectangle_width; i++) {
		//temp_deviation = fabs(temp_coefficient.apla.a * i + temp_coefficient.apla.b - original_time_series[original_id + i]);
		cout << temp_coefficient.apla.a * i + temp_coefficient.apla.b << ",";
	}
	cout << endl;

	//left sub segment
	//int left_original_id = temp_coefficient.left_subsegment->right_endpoint - temp_coefficient.left_subsegment->rectangle_width + 1;
	for (int i = 0; i < area_vector[vector_id - 1].rectangle_width; i++) {
		cout << area_vector[vector_id - 1].apla.a * i + area_vector[vector_id - 1].apla.b << ",";
	}
	//right sub segment
	//int right_original_id = temp_coefficient.right_subsegment->right_endpoint - temp_coefficient.right_subsegment->rectangle_width + 1;
	for (int i = 0; i < area_vector[vector_id].rectangle_width; i++) {
		cout << area_vector[vector_id].apla.a * i + area_vector[vector_id].apla.b << ",";
	}

	cout << endl;
	cout << endl;
}

//************************************
// Method:computeMagnitude
// Qualifier:Print special point for segment
// date:190519
// author:
//************************************
TEMPLATE
double APLA::computeMagnitude(AREA_COEFFICIENT& const temp_coefficient, double difference) {//190521
	if (temp_coefficient.left_subsegment != nullptr && temp_coefficient.right_subsegment != nullptr) {
		//cout<<"recursive segment_magnitude: "<<temp_coefficient.left_subsegment->segment_magnitude << " " << temp_coefficient.right_subsegment->segment_magnitude<<endl;
		if (temp_coefficient.segment_magnitude == INF) {
			double difference_l = fabs(temp_coefficient.apla.a - temp_coefficient.left_subsegment->apla.a);
			double difference_r = fabs(temp_coefficient.apla.a - temp_coefficient.right_subsegment->apla.a);
			cout << "diff l " << difference_l << endl;
			cout << "diff r " << difference_r << endl;
			//temp_coefficient.segment_magnitude = 1;
			temp_coefficient.left_subsegment->segment_magnitude = 0;
			temp_coefficient.right_subsegment->segment_magnitude = 0;
			computeMagnitude(*(temp_coefficient.left_subsegment), difference_l);
			computeMagnitude(*(temp_coefficient.right_subsegment), difference_r);
		}
		else {
			//temp_coefficient.left_subsegment->segment_magnitude = difference;
			//temp_coefficient.right_subsegment->segment_magnitude = difference;
			cout << "diff s " << difference << endl;

			computeMagnitude(*(temp_coefficient.left_subsegment), difference);
			computeMagnitude(*(temp_coefficient.right_subsegment), difference);
		}

		//return getMaxMagnitude(*(temp_coefficient.left_subsegment)).segment_magnitude > getMaxMagnitude(*(temp_coefficient.right_subsegment)).segment_magnitude ? getMaxMagnitude(*(temp_coefficient.left_subsegment)) : getMaxMagnitude(*(temp_coefficient.right_subsegment));
	}
	else if (temp_coefficient.left_subsegment != nullptr && temp_coefficient.right_subsegment == nullptr) {
		assert(0);
		//return getMaxMagnitude(*(temp_coefficient.left_subsegment));
	}
	else if (temp_coefficient.left_subsegment == nullptr && temp_coefficient.right_subsegment != nullptr) {
		assert(0);
		//return getMaxMagnitude(*(temp_coefficient.right_subsegment));
	}
	else {
		cout << "*******" << temp_coefficient.segment_magnitude << endl;
		temp_coefficient.segment_magnitude += difference;
		cout << "****************" << temp_coefficient.segment_magnitude << endl;
		return temp_coefficient.segment_magnitude;
	}
}

//************************************
// Method:computeDifferenceA
// Qualifier:Print special point for segment
// date:190519
// author:
//************************************
TEMPLATE
double APLA::computeDifferenceA(AREA_COEFFICIENT& const temp_coefficient, int level) {
	if (level >= 0) {
		if (temp_coefficient.left_subsegment != nullptr && temp_coefficient.right_subsegment != nullptr) {
			temp_coefficient.left_subsegment->segment_magnitude = fabs(temp_coefficient.apla.a - temp_coefficient.left_subsegment->apla.a) * temp_coefficient.left_subsegment->rectangle_width;
			temp_coefficient.right_subsegment->segment_magnitude = fabs(temp_coefficient.apla.a - temp_coefficient.right_subsegment->apla.a) * temp_coefficient.right_subsegment->rectangle_width;
			temp_coefficient.segment_magnitude = temp_coefficient.left_subsegment->segment_magnitude + temp_coefficient.right_subsegment->segment_magnitude;
			level--;
			temp_coefficient.segment_magnitude += computeDifferenceA(*(temp_coefficient.left_subsegment), level) + computeDifferenceA(*(temp_coefficient.right_subsegment), level);
			return temp_coefficient.segment_magnitude;
		}
		else
			return 0;
	}
}

//************************************
// Method:getMaxMagnitude
// Qualifier:Print special point for segment
// date:190519
// author:
//************************************
TEMPLATE
typename APLA::AREA_COEFFICIENT& APLA::getMaxMagnitude0(AREA_COEFFICIENT& const temp_coefficient) {
	//if (temp_coefficient.left_subsegment->segment_magnitude != INF && temp_coefficient.right_subsegment->segment_magnitude != INF){
	if (temp_coefficient.left_subsegment != nullptr && temp_coefficient.right_subsegment != nullptr) {
		//cout<<"recursive segment_magnitude: "<<temp_coefficient.left_subsegment->segment_magnitude << " " << temp_coefficient.right_subsegment->segment_magnitude<<endl;
		return getMaxMagnitude(*(temp_coefficient.left_subsegment)).segment_magnitude > getMaxMagnitude(*(temp_coefficient.right_subsegment)).segment_magnitude ? getMaxMagnitude(*(temp_coefficient.left_subsegment)) : getMaxMagnitude(*(temp_coefficient.right_subsegment));
	}
	else if (temp_coefficient.left_subsegment != nullptr && temp_coefficient.right_subsegment == nullptr) {
		assert(0);
		return getMaxMagnitude(*(temp_coefficient.left_subsegment));
	}
	else if (temp_coefficient.left_subsegment == nullptr && temp_coefficient.right_subsegment != nullptr) {
		assert(0);
		return getMaxMagnitude(*(temp_coefficient.right_subsegment));
	}
	else {
		return temp_coefficient;
	}
}

//************************************
// Method:getMaxMagnitude
// Qualifier:Print special point for segment
// date:190519
// author:
//************************************
TEMPLATE
typename APLA::AREA_COEFFICIENT& APLA::getMaxMagnitude(AREA_COEFFICIENT& const temp_coefficient) {
	//if (temp_coefficient.left_subsegment->segment_magnitude != INF && temp_coefficient.right_subsegment->segment_magnitude != INF){
	if (temp_coefficient.left_subsegment != nullptr && temp_coefficient.right_subsegment != nullptr) {
		//cout<<"recursive segment_magnitude: "<<temp_coefficient.left_subsegment->segment_magnitude << " " << temp_coefficient.right_subsegment->segment_magnitude<<endl;
		//return getMaxMagnitude(*(temp_coefficient.left_subsegment)).segment_magnitude > getMaxMagnitude(*(temp_coefficient.right_subsegment)).segment_magnitude ? getMaxMagnitude(*(temp_coefficient.left_subsegment)) : getMaxMagnitude(*(temp_coefficient.right_subsegment));
		//temp_coefficient.left_subsegment->segment_magnitude = INF;
		//temp_coefficient.right_subsegment->segment_magnitude = INF;
		if (getMaxMagnitude(*(temp_coefficient.left_subsegment)).segment_magnitude > getMaxMagnitude(*(temp_coefficient.right_subsegment)).segment_magnitude) {
			temp_coefficient.segment_magnitude = getMaxMagnitude(*(temp_coefficient.left_subsegment)).segment_magnitude;
			return getMaxMagnitude(*(temp_coefficient.left_subsegment));
		}
		else {
			temp_coefficient.segment_magnitude = getMaxMagnitude(*(temp_coefficient.right_subsegment)).segment_magnitude;
			return getMaxMagnitude(*(temp_coefficient.right_subsegment));
		}
	}
	else if (temp_coefficient.left_subsegment != nullptr && temp_coefficient.right_subsegment == nullptr) {
		assert(0);
		return getMaxMagnitude(*(temp_coefficient.left_subsegment));
	}
	else if (temp_coefficient.left_subsegment == nullptr && temp_coefficient.right_subsegment != nullptr) {
		assert(0);
		return getMaxMagnitude(*(temp_coefficient.right_subsegment));
	}
	else {
		return temp_coefficient;
	}
}

//************************************
// Method:printgetMaxMagnitude
// Qualifier:Print max magnitude
// date:190521
// author:
//************************************
TEMPLATE
bool APLA::printMaxMagnitude(const AREA_COEFFICIENT& const temp_coefficient) {//190521
	if (temp_coefficient.left_subsegment != nullptr && temp_coefficient.right_subsegment != nullptr) {
		cout << "left magnitude: " << temp_coefficient.left_subsegment->segment_magnitude << " a:" << temp_coefficient.left_subsegment->apla.a << " b:" << temp_coefficient.left_subsegment->apla.b
			<< " width: " << temp_coefficient.left_subsegment->rectangle_width << " right endpoint: " << temp_coefficient.left_subsegment->right_endpoint
			<< " right magnitude: " << temp_coefficient.right_subsegment->segment_magnitude << " a:" << temp_coefficient.right_subsegment->apla.a << " b:" << temp_coefficient.right_subsegment->apla.b
			<< " width: " << temp_coefficient.right_subsegment->rectangle_width << " right endpoint: " << temp_coefficient.right_subsegment->right_endpoint << endl;
		printMaxMagnitude(*(temp_coefficient.left_subsegment));
		printMaxMagnitude(*(temp_coefficient.right_subsegment));
		return false;
	}
	else if (temp_coefficient.left_subsegment != nullptr && temp_coefficient.right_subsegment == nullptr) {
		cout << "left magnitude: " << temp_coefficient.left_subsegment->segment_magnitude << " a:" << temp_coefficient.left_subsegment->apla.a << " b:" << temp_coefficient.left_subsegment->apla.b
			<< " width: " << temp_coefficient.left_subsegment->rectangle_width << " right endpoint: " << temp_coefficient.left_subsegment->right_endpoint << endl;
		printMaxMagnitude(*(temp_coefficient.left_subsegment));
		return false;
	}
	else if (temp_coefficient.left_subsegment == nullptr && temp_coefficient.right_subsegment != nullptr) {
		cout << " right magnitude: " << temp_coefficient.right_subsegment->segment_magnitude << " a:" << temp_coefficient.right_subsegment->apla.a << " b:" << temp_coefficient.right_subsegment->apla.b
			<< " width: " << temp_coefficient.right_subsegment->rectangle_width << " right endpoint: " << temp_coefficient.right_subsegment->right_endpoint << endl;
		printMaxMagnitude(*(temp_coefficient.right_subsegment));
		return false;
	}
	else {
		cout << "final mag: " << temp_coefficient.segment_magnitude << " a:" << temp_coefficient.apla.a << endl;

		return false;
	}
}

//************************************
// Method:printReconstructRecursive
// Qualifier:Print max magnitude
// date:190521
// author:
//************************************
TEMPLATE
double APLA::printReconstructRecursive(const AREA_COEFFICIENT& const temp_coefficient, int  level) {//190522
	assert(level >= 0);
	if (level != 0 && temp_coefficient.left_subsegment != nullptr && temp_coefficient.right_subsegment != nullptr) {
		level--;
		printReconstructRecursive(*(temp_coefficient.left_subsegment), level);
		printReconstructRecursive(*(temp_coefficient.right_subsegment), level);
	}
	else if (temp_coefficient.rectangle_width > 2) {
		int original_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
		if (temp_coefficient.right_endpoint - temp_coefficient.rectangle_width < 0)
			original_id = 0;
		//double temp_deviation = 0;
		//reconstruct
		//cout << "segment width:" << temp_coefficient.rectangle_width<<" ";
		for (int array_id = 0; array_id < temp_coefficient.rectangle_width; array_id++, original_id++) {
			//temp_deviation = fabs(temp_coefficient.apla.a * i + temp_coefficient.apla.b - original_time_series[original_id + i]);
			cout << original_id << ": " << temp_coefficient.apla.a * array_id + temp_coefficient.apla.b << ",";
			//cout << temp_coefficient.apla.a * array_id + temp_coefficient.apla.b << ",";
			if (original_id == temp_coefficient.deviation_point.id)
				cout << "<- ";
			if (original_id == temp_coefficient.min_point.id || original_id == temp_coefficient.max_point.id)
				cout << "<* ";
			if (original_id == temp_coefficient.right_endpoint)
				cout << "|";
		}
		return 1;
	}
}

//************************************
// Method:print_segment_coefficients
// Qualifier: Print right endpoint, segment width, a&b, increment area, area difference, long segment triangle density
// date:200907
// author:
//************************************
TEMPLATE
template<typename T>
void APLA::print_segment_coefficients(const T& const temp_coefficient) {
	cout << "segment right endpoint: " << temp_coefficient.right_endpoint << ", width: " << temp_coefficient.rectangle_width << ", a&b: " << temp_coefficient.apla.a << "," << temp_coefficient.apla.b << ", increment area: " << 1 / temp_coefficient.segment_density << endl;
	if (temp_coefficient.right_subsegment) {
		cout << "long segment coefficients: right endpoint" << temp_coefficient.right_subsegment->right_endpoint << ", width: " << temp_coefficient.right_subsegment->rectangle_width << ", a&b: " << temp_coefficient.right_subsegment->apla.a << "," << temp_coefficient.right_subsegment->apla.b << ", increment area: " << 1 / temp_coefficient.right_subsegment->segment_density << endl;
	}
}

//************************************
// Method:printReconstructRecursive
// Qualifier:Print max magnitude
// date:190521
// author:
//************************************
TEMPLATE
void APLA::testAChange(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient) {
	temp_coefficient.segment_magnitude = INF;
	double difference = INF;
	computeMagnitude(temp_coefficient, difference);

	int origintal_id = vector_id > 1 ? temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1 : 0;

	int left = getMaxMagnitude(temp_coefficient).right_endpoint - getMaxMagnitude(temp_coefficient).rectangle_width;
	int right = getMaxMagnitude(temp_coefficient).right_endpoint;
	int middle = temp_coefficient.deviation_point.id;
	//
	//getMaxMagnitude(temp_coefficient).segment_magnitude = 0;
	int left0 = getMaxMagnitude(temp_coefficient).right_endpoint - getMaxMagnitude(temp_coefficient).rectangle_width;
	int right0 = getMaxMagnitude(temp_coefficient).right_endpoint;
	if ((middle >= left - 1 && middle <= right + 1) || (middle > left0 && middle <= right0) || middle == temp_coefficient.right_endpoint || middle == origintal_id
		|| middle == temp_coefficient.max_point.id
		|| middle == temp_coefficient.min_point.id
		|| middle == area_vector[vector_id - 1].max_point.id
		|| middle == area_vector[vector_id - 1].min_point.id
		|| middle == area_vector[vector_id - 1].max_point.id + 1
		|| middle == area_vector[vector_id - 1].min_point.id + 1
		|| middle == area_vector[vector_id - 1].deviation_point.id
		|| middle == area_vector[vector_id].max_point.id
		|| middle == area_vector[vector_id].min_point.id
		|| middle == area_vector[vector_id].max_point.id + 1
		|| middle == area_vector[vector_id].min_point.id + 1
		|| middle == area_vector[vector_id].deviation_point.id

		|| middle == area_vector[vector_id - 1].right_endpoint + 1
		|| middle == area_vector[vector_id - 1].right_endpoint
		) {
	}
	else {
		cout << "/************************/" << endl;
		printSpecialPoint(original_time_series, area_vector, vector_id, temp_coefficient);
		printReconstructRecursive(temp_coefficient, 2);
		cout << endl;
		printReconstructRecursive(temp_coefficient, 3);
		cout << endl;
		printReconstructRecursive(temp_coefficient, 4);
		cout << endl;
		cout << "Original T: ";
		for (int array_id = origintal_id; array_id <= temp_coefficient.right_endpoint; array_id++) {
			cout << original_time_series[array_id] << ",";
		}
		cout << endl;
		int max_mag_right_endpoint = getMaxMagnitude(temp_coefficient).right_endpoint;
		cout << "Max endpoint: " << max_mag_right_endpoint << endl;
		int max_width = getMaxMagnitude(temp_coefficient).rectangle_width;
		cout << "Max rec width: " << max_width << endl;
		cout << "m a: " << temp_coefficient.apla.a << " m b: " << temp_coefficient.apla.a << endl;
		cout << "l a: " << area_vector[vector_id - 1].apla.a << " l b: " << area_vector[vector_id - 1].apla.b << " r a: " << area_vector[vector_id].apla.a << " r b: " << area_vector[vector_id].apla.b << endl;
		cout << "l mag: " << area_vector[vector_id - 1].segment_magnitude << " r mag: " << area_vector[vector_id].segment_magnitude << endl;
		printMaxMagnitude(temp_coefficient);
		//assert(0);
	}
}

//************************************
// Method:printReconstructRecursive
// Qualifier:Print max magnitude
// date:190521
// author:
//************************************
TEMPLATE
void APLA::testAChange0(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient, int& const left_id, int& const right_id) {//190522
	AREA_COEFFICIENT max_deviation_segment;
	int origintal_id = vector_id > 1 ? temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1 : 0;
	//
	double left_diff = fabs(temp_coefficient.apla.a - temp_coefficient.left_subsegment->apla.a);
	double right_diff = fabs(temp_coefficient.apla.a - temp_coefficient.right_subsegment->apla.a);
	//int left_id = 0;
	//int right_id = 0;
	if (left_diff > right_diff) {
		left_id = temp_coefficient.left_subsegment->right_endpoint - temp_coefficient.left_subsegment->rectangle_width;
		right_id = temp_coefficient.left_subsegment->right_endpoint;
	}
	else {
		left_id = temp_coefficient.right_subsegment->right_endpoint - temp_coefficient.right_subsegment->rectangle_width;
		right_id = temp_coefficient.right_subsegment->right_endpoint;
	}
	int middle = temp_coefficient.deviation_point.id;

	if (left_id <= middle && middle <= right_id) {
	}
	else {
		/*cout << left_diff << " " << right_diff << endl;
		printSpecialPoint(original_time_series, area_vector, vector_id, temp_coefficient);
		assert(0);*/
	}
}

//************************************
// Method:testAChange1
// Qualifier:max_deviation point in minmax point, endpoint, sub_deviation point
// date:190522
// author:
//************************************
TEMPLATE
void APLA::testAChange1(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient) {//190522
	///////////////temp variable///////////////////////////
	int total_merge_infor_count = 0;
	int same_deviation_id_count = 0;
	int diff_deviation_id_count = 0;
	int deviation_all_count = 0;
	int deviaiton_min_max_count = 0;
	//////////////////////////////////////////////////////

	if (area_vector[vector_id - 1].rectangle_width > 2 && area_vector[vector_id].rectangle_width > 2 && area_vector[vector_id - 1].rectangle_width == area_vector[vector_id].rectangle_width) {
		total_merge_infor_count++;
		if (temp_coefficient.deviation_point.id == area_vector[vector_id - 1].deviation_point.id || temp_coefficient.deviation_point.id == area_vector[vector_id].deviation_point.id) {
			same_deviation_id_count = output_argument.same_deviation_id_count++;
		}
		else
			diff_deviation_id_count = output_argument.diff_deviation_id_count++;
		//
		int left_id = INF;
		int right_id = INF;
		//testAChange0(original_time_series, area_vector,vector_id, temp_coefficient, left_id, right_id);//190522

		computeDifferenceA(temp_coefficient, 2);//190524
		if (temp_coefficient.left_subsegment->segment_magnitude > temp_coefficient.right_subsegment->segment_magnitude) {
			left_id = temp_coefficient.left_subsegment->right_endpoint - temp_coefficient.left_subsegment->rectangle_width;
			right_id = temp_coefficient.left_subsegment->right_endpoint;
		}
		else {
			left_id = temp_coefficient.right_subsegment->right_endpoint - temp_coefficient.right_subsegment->rectangle_width;
			right_id = temp_coefficient.right_subsegment->right_endpoint;
		}

		if (temp_coefficient.deviation_point.id == area_vector[vector_id - 1].min_point.id
			|| temp_coefficient.deviation_point.id == area_vector[vector_id].min_point.id
			|| temp_coefficient.deviation_point.id == area_vector[vector_id - 1].max_point.id
			|| temp_coefficient.deviation_point.id == area_vector[vector_id].max_point.id
			|| temp_coefficient.deviation_point.id == area_vector[vector_id - 1].deviation_point.id
			|| temp_coefficient.deviation_point.id == area_vector[vector_id].deviation_point.id
			|| temp_coefficient.deviation_point.id == area_vector[vector_id - 1].right_endpoint
			|| temp_coefficient.deviation_point.id == area_vector[vector_id].right_endpoint
			|| temp_coefficient.deviation_point.id == area_vector[vector_id - 1].right_endpoint + 1
			|| temp_coefficient.deviation_point.id == area_vector[vector_id - 1].right_endpoint - area_vector[vector_id - 1].rectangle_width + 1
			|| temp_coefficient.deviation_point.id == area_vector[vector_id - 1].min_point.id + 1
			|| temp_coefficient.deviation_point.id == area_vector[vector_id].min_point.id + 1
			|| temp_coefficient.deviation_point.id == area_vector[vector_id - 1].max_point.id + 1
			|| temp_coefficient.deviation_point.id == area_vector[vector_id].max_point.id + 1
			|| temp_coefficient.deviation_point.id == area_vector[vector_id - 1].right_endpoint - 1
			|| temp_coefficient.deviation_point.id == area_vector[vector_id].right_endpoint - 1
			|| temp_coefficient.deviation_point.id == area_vector[vector_id - 1].right_endpoint + 2
			|| temp_coefficient.deviation_point.id == area_vector[vector_id - 1].right_endpoint - area_vector[vector_id - 1].rectangle_width + 2
			|| (left_id <= temp_coefficient.deviation_point.id && temp_coefficient.deviation_point.id <= right_id)
			) {
			deviation_all_count++;
		}
		else {
			draw3Line(original_time_series, area_vector, vector_id, temp_coefficient);
			printMaxMagnitude(temp_coefficient);//190524
			int origintal_id = vector_id > 1 ? temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1 : 0;
			//cout << "left id: " << left_id- origintal_id << " right id:" << right_id - origintal_id << endl;
			cout << "diff: ";
			for (int order = 1, array_id = vector_id > 1 ? area_vector[vector_id - 2].right_endpoint + 1 : 0; array_id <= area_vector[vector_id].right_endpoint; array_id++, order++) {
				cout << order << ": " << array_id << ": " << original_time_series[array_id] << " ";
				if (array_id == area_vector[vector_id - 1].deviation_point.id || array_id == area_vector[vector_id].deviation_point.id)
					cout << "<- ";
				if (array_id == temp_coefficient.deviation_point.id)
					cout << "<= ";

				if (array_id == area_vector[vector_id - 1].min_point.id || array_id == area_vector[vector_id].min_point.id || array_id == area_vector[vector_id - 1].max_point.id || array_id == area_vector[vector_id].max_point.id)
					cout << "<*";
				if (array_id == temp_coefficient.min_point.id || array_id == temp_coefficient.max_point.id)
					cout << "<& ";
				if (array_id == area_vector[vector_id - 1].right_endpoint)
					cout << "|";
			}
			//a & b
			cout << endl;
			cout << "m a: " << temp_coefficient.apla.a << " m b: " << temp_coefficient.apla.a << endl;
			cout << "l a: " << area_vector[vector_id - 1].apla.a << " l b: " << area_vector[vector_id - 1].apla.b << " r a: " << area_vector[vector_id].apla.a << " r b: " << area_vector[vector_id].apla.b << endl;
			cout << "l sub left a: " << temp_coefficient.left_subsegment->left_subsegment->apla.a << " l sub left b: " << temp_coefficient.left_subsegment->left_subsegment->apla.b;
			cout << " l sub right a: " << temp_coefficient.left_subsegment->right_subsegment->apla.a << "l sub right b: " << temp_coefficient.left_subsegment->right_subsegment->apla.b;
			cout << endl;
			cout << "r sub left a: " << temp_coefficient.right_subsegment->left_subsegment->apla.a << " r sub left b: " << temp_coefficient.right_subsegment->left_subsegment->apla.b;
			cout << " r sub right a: " << temp_coefficient.right_subsegment->right_subsegment->apla.a << "r sub right b: " << temp_coefficient.right_subsegment->right_subsegment->apla.b;
			cout << endl;
			cout << "rr sub left a: " << temp_coefficient.right_subsegment->left_subsegment->left_subsegment->apla.a << " rr sub left b: " << temp_coefficient.right_subsegment->left_subsegment->left_subsegment->apla.b;
			cout << " rr sub right a: " << temp_coefficient.right_subsegment->left_subsegment->right_subsegment->apla.a << "rr sub right b: " << temp_coefficient.right_subsegment->left_subsegment->right_subsegment->apla.b;
			cout << endl;

			//Original time
			for (int array_id = vector_id > 1 ? area_vector[vector_id - 2].right_endpoint + 1 : 0; array_id <= area_vector[vector_id].right_endpoint; array_id++) {
				cout << original_time_series[array_id] << ",";
			}
			cout << endl;
			int original_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
			double temp_deviation = 0;
			//reconstruct
			for (int i = 0; i < temp_coefficient.rectangle_width; i++) {
				temp_deviation = fabs(temp_coefficient.apla.a * i + temp_coefficient.apla.b - original_time_series[original_id + i]);
				cout << temp_coefficient.apla.a * i + temp_coefficient.apla.b << ",";
			}
			cout << endl;
			//left sub segment
			int left_original_id = temp_coefficient.left_subsegment->right_endpoint - temp_coefficient.left_subsegment->rectangle_width + 1;
			for (int i = 0; i < temp_coefficient.left_subsegment->rectangle_width; i++) {
				cout << temp_coefficient.left_subsegment->apla.a * i + temp_coefficient.left_subsegment->apla.b << ",";
			}
			//right sub segment
			int right_original_id = temp_coefficient.right_subsegment->right_endpoint - temp_coefficient.right_subsegment->rectangle_width + 1;
			for (int i = 0; i < temp_coefficient.right_subsegment->rectangle_width; i++) {
				cout << temp_coefficient.right_subsegment->apla.a * i + temp_coefficient.right_subsegment->apla.b << ",";
			}
			cout << endl;
			//left sub left segment
			for (int i = 0; i < temp_coefficient.left_subsegment->left_subsegment->rectangle_width; i++) {
				cout << temp_coefficient.left_subsegment->left_subsegment->apla.a * i + temp_coefficient.left_subsegment->left_subsegment->apla.b << ",";
			}
			//left sub right segment
			for (int i = 0; i < temp_coefficient.left_subsegment->right_subsegment->rectangle_width; i++) {
				cout << temp_coefficient.left_subsegment->right_subsegment->apla.a * i + temp_coefficient.left_subsegment->right_subsegment->apla.b << ",";
			}
			//right sub left segment
			for (int i = 0; i < temp_coefficient.right_subsegment->left_subsegment->rectangle_width; i++) {
				cout << temp_coefficient.right_subsegment->left_subsegment->apla.a * i + temp_coefficient.right_subsegment->left_subsegment->apla.b << ",";
			}
			//right sub right segment
			for (int i = 0; i < temp_coefficient.right_subsegment->right_subsegment->rectangle_width; i++) {
				cout << temp_coefficient.right_subsegment->right_subsegment->apla.a * i + temp_coefficient.right_subsegment->right_subsegment->apla.b << ",";
			}
			cout << endl;
			cout << "/************************/" << endl;
			//printSpecialPoint(original_time_series, area_vector, vector_id, temp_coefficient);
			printReconstructRecursive(temp_coefficient, 2);
			cout << endl;
			printReconstructRecursive(temp_coefficient, 3);
			cout << endl;
			printReconstructRecursive(temp_coefficient, 4);
			cout << endl;
			printReconstructRecursive(temp_coefficient, 5);
			cout << endl;
			printReconstructRecursive(temp_coefficient, 6);
			cout << endl;
			printReconstructRecursive(temp_coefficient, 7);
			cout << endl;
			cout << endl;
		}

		if (temp_coefficient.deviation_point.id == area_vector[vector_id - 1].min_point.id
			|| temp_coefficient.deviation_point.id == area_vector[vector_id].min_point.id
			|| temp_coefficient.deviation_point.id == area_vector[vector_id - 1].max_point.id
			|| temp_coefficient.deviation_point.id == area_vector[vector_id].max_point.id
			|| temp_coefficient.deviation_point.id == area_vector[vector_id - 1].min_point.id + 1
			|| temp_coefficient.deviation_point.id == area_vector[vector_id].min_point.id + 1
			|| temp_coefficient.deviation_point.id == area_vector[vector_id - 1].max_point.id + 1
			|| temp_coefficient.deviation_point.id == area_vector[vector_id].max_point.id + 1
			) {
			deviaiton_min_max_count++;
		}
		else {
			/*cout << "diff: ";
			for (int order=1, array_id = vector_id > 1 ? area_vector[vector_id - 2].right_endpoint + 1 : 0; array_id <= area_vector[vector_id].right_endpoint; array_id++, order++) {
				cout <<order<<": " <<original_time_series[array_id] << " ";
				if (array_id == area_vector[vector_id - 1].deviation_point.id || array_id == area_vector[vector_id].deviation_point.id)
					cout << "<- ";
				if (array_id == temp_coefficient.deviation_point.id)
					cout << "<= ";

				if (array_id == area_vector[vector_id - 1].min_point.id || array_id == area_vector[vector_id].min_point.id || array_id == area_vector[vector_id - 1].max_point.id || array_id == area_vector[vector_id].max_point.id)
					cout << "<*";
				if (array_id == temp_coefficient.min_point.id || array_id == temp_coefficient.max_point.id)
					cout << "<& ";
				if (array_id == area_vector[vector_id - 1].right_endpoint)
					cout << "|";*/
					//}
					/*cout << endl;
					for (int array_id = vector_id > 1 ? area_vector[vector_id - 2].right_endpoint + 1 : 0; array_id <= area_vector[vector_id].right_endpoint; array_id++) {
						cout << original_time_series[array_id] << ",";
					}

					cout << endl;
					int original_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
					double temp_deviation = 0;
					for (int i = 0; i < temp_coefficient.rectangle_width; i++) {
						temp_deviation = fabs(temp_coefficient.apla.a * i + temp_coefficient.apla.b - original_time_series[original_id + i]);
						cout << temp_coefficient.apla.a * i + temp_coefficient.apla.b << ",";
					}
					cout << endl;
					for (int i = 0; i < temp_coefficient.rectangle_width; i++) {
						temp_deviation = fabs(temp_coefficient.apla.a * i + temp_coefficient.apla.b - original_time_series[original_id + i]);
						cout << temp_deviation << ",";
					}
					cout << endl;
					cout << endl;*/
		}

		auto min_id = area_vector[vector_id - 1].min_point.value <= area_vector[vector_id].min_point.value ? area_vector[vector_id - 1].min_point.id : area_vector[vector_id].max_point.id;
		auto max_id = area_vector[vector_id - 1].max_point.value >= area_vector[vector_id].max_point.value ? area_vector[vector_id - 1].max_point.id : area_vector[vector_id].max_point.id;
	}
}

//************************************
// Method:draw3Line
// Qualifier:Print max magnitude
// date:190521
// author:
//************************************
TEMPLATE
void APLA::draw3Line(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient) {
	if (area_vector[vector_id - 1].rectangle_width == area_vector[vector_id].rectangle_width) {
		double coefficient1 = area_vector[vector_id - 1].rectangle_width + 1;//l_1+1
		double coefficient2 = (area_vector[vector_id - 1].rectangle_width * 2 + 1) * 2;//2*(l_1*2+1)
		double coefficient = coefficient1 / coefficient2;

		double coefficient_a1 = area_vector[vector_id - 1].rectangle_width - 1;//l_1-1
		double coefficient_a2 = area_vector[vector_id - 1].rectangle_width * 2 - 1;//2*l_1-1
		double coefficient_a = coefficient_a1 / coefficient_a2;

		double coefficient_s = 1 / (area_vector[vector_id - 1].rectangle_width * 2 + 1);//1/2l_1+1
		double coefficient_s1 = 3 / (area_vector[vector_id - 1].rectangle_width * 2 - 1); //3/(2l_1-1)

		//int origintal_id = vector_id > 1 ? temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1 : 0;
		cout << "3 Line: " << endl;
		for (int array_id = 0; array_id < area_vector[vector_id - 1].rectangle_width; array_id++) {
			cout << coefficient * (coefficient_a * area_vector[vector_id - 1].apla.a * array_id + area_vector[vector_id - 1].apla.b) << ",";
		}
		cout << endl;
		for (int array_id = 0; array_id < area_vector[vector_id - 1].rectangle_width; array_id++) {
			cout << coefficient * (coefficient_a * area_vector[vector_id].apla.a * array_id + area_vector[vector_id].apla.b) << ",";
		}
		cout << endl;
		for (int array_id = 0; array_id < area_vector[vector_id - 1].rectangle_width; array_id++) {
			cout << coefficient_s * (coefficient_s1 * (area_vector[vector_id].sum_value - area_vector[vector_id - 1].sum_value) * array_id + 2 * area_vector[vector_id - 1].sum_value - area_vector[vector_id].sum_value) << ",";
		}
		cout << endl;
	}
}

//************************************
// Method:testDeviationPointRecursive
// Qualifier:Test whether max deviation point in sub max deviation point
// date:190524
// author:
//************************************
TEMPLATE
void APLA::testDeviationPointRecursive(AREA_COEFFICIENT& const temp_coefficient, int level, set <int>& deviation_id) {//190524
	if (level != 0 && temp_coefficient.left_subsegment != nullptr && temp_coefficient.right_subsegment != nullptr) {
		level--;
		if (temp_coefficient.rectangle_width > 2) {
			deviation_id.emplace(temp_coefficient.left_subsegment->deviation_point.id);
			deviation_id.emplace(temp_coefficient.right_subsegment->deviation_point.id);
		}
		deviation_id.emplace(temp_coefficient.left_subsegment->min_point.id);
		deviation_id.emplace(temp_coefficient.right_subsegment->min_point.id);
		deviation_id.emplace(temp_coefficient.left_subsegment->max_point.id);
		deviation_id.emplace(temp_coefficient.right_subsegment->max_point.id);
		testDeviationPointRecursive(*(temp_coefficient.left_subsegment), level, deviation_id);
		testDeviationPointRecursive(*(temp_coefficient.right_subsegment), level, deviation_id);
	}
	else if (level != 0 && temp_coefficient.left_subsegment != nullptr && temp_coefficient.right_subsegment == nullptr) {
		level--;
		if (temp_coefficient.rectangle_width > 2) {
			deviation_id.emplace(temp_coefficient.left_subsegment->deviation_point.id);
		}
		deviation_id.emplace(temp_coefficient.left_subsegment->min_point.id);
		deviation_id.emplace(temp_coefficient.left_subsegment->max_point.id);
		testDeviationPointRecursive(*(temp_coefficient.left_subsegment), level, deviation_id);
	}
	else if (level != 0 && temp_coefficient.left_subsegment == nullptr && temp_coefficient.right_subsegment != nullptr) {
		level--;
		if (temp_coefficient.rectangle_width > 2) {
			deviation_id.emplace(temp_coefficient.right_subsegment->deviation_point.id);
		}
		deviation_id.emplace(temp_coefficient.right_subsegment->min_point.id);
		deviation_id.emplace(temp_coefficient.right_subsegment->max_point.id);
		testDeviationPointRecursive(*(temp_coefficient.right_subsegment), level, deviation_id);
	}
}

//************************************
// Method:testDeviationPointRecursive
// Qualifier:Test whether max deviation point in sub max deviation point
// date:190524
// author:
//************************************
TEMPLATE
bool APLA::testDeviationPoint(AREA_COEFFICIENT& const temp_coefficient, int level, set <int>& deviation_id) {
	testDeviationPointRecursive(temp_coefficient, level, deviation_id);
	if (deviation_id.size() == 0) return true;
	//cout <<endl<< "deviation id: " << temp_coefficient.deviation_point.id << endl;
	//cout <<"size: " <<deviation_id.size()<<" vector size: "<< temp_coefficient.rectangle_width << endl;
	for (auto it : deviation_id) {
		//cout << it << " ";
		if (temp_coefficient.deviation_point.id == it)
			return true;
	}
	//cout << endl;
	return false;
}

//************************************
// Method:compareLinkListAndVector
// Qualifier: compare vector & Linked list
// date:190822
// author:
//************************************
TEMPLATE
template<typename T>
bool APLA::compareLinkListAndVector(DoublyLinkedList<T>& const doubly_linked_list, vector<T>& const area_vector) {
	assert(area_vector.size() == doubly_linked_list.size());

	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		assert(doubly_linked_list[segment_id].right_subsegment != nullptr);

		assert(area_vector[segment_id].rectangle_width == doubly_linked_list[segment_id].rectangle_width);
		assert(area_vector[segment_id].right_endpoint == doubly_linked_list[segment_id].right_endpoint);
		assert(area_vector[segment_id].rectangle_height == doubly_linked_list[segment_id].rectangle_height);
		assert(area_vector[segment_id].minmax_distance == doubly_linked_list[segment_id].minmax_distance);
		assert(area_vector[segment_id].rectangle_area == doubly_linked_list[segment_id].rectangle_area);
		assert(area_vector[segment_id].real_area == doubly_linked_list[segment_id].real_area);
		assert(area_vector[segment_id].minmax_width_area == doubly_linked_list[segment_id].minmax_width_area);
		assert(area_vector[segment_id].minmax_distance_area == doubly_linked_list[segment_id].minmax_distance_area);
		assert(area_vector[segment_id].merged_percentage == doubly_linked_list[segment_id].merged_percentage);
		assert(area_vector[segment_id].merge_count == doubly_linked_list[segment_id].merge_count);
		assert(area_vector[segment_id].segment_density == doubly_linked_list[segment_id].segment_density);
		assert(area_vector[segment_id].rectangle_density == doubly_linked_list[segment_id].rectangle_density);
		assert(area_vector[segment_id].rec_deviation == doubly_linked_list[segment_id].rec_deviation);
		assert(area_vector[segment_id].sum_difference == doubly_linked_list[segment_id].sum_difference);
		assert(area_vector[segment_id].parallelogram_height == doubly_linked_list[segment_id].parallelogram_height);
		assert(area_vector[segment_id].sum_value == doubly_linked_list[segment_id].sum_value);
		assert(area_vector[segment_id].increment_area == doubly_linked_list[segment_id].increment_area);
		assert(area_vector[segment_id].area_difference == doubly_linked_list[segment_id].area_difference);
		assert(area_vector[segment_id].area_difference_density == doubly_linked_list[segment_id].area_difference_density);
		assert(area_vector[segment_id].max_point.id == doubly_linked_list[segment_id].max_point.id);
		assert(area_vector[segment_id].max_point.value == doubly_linked_list[segment_id].max_point.value);
		assert(area_vector[segment_id].min_point.id == doubly_linked_list[segment_id].min_point.id);
		assert(area_vector[segment_id].min_point.value == doubly_linked_list[segment_id].min_point.value);
		assert(area_vector[segment_id].deviation_point.id == doubly_linked_list[segment_id].deviation_point.id);
		assert(area_vector[segment_id].deviation_point.value == doubly_linked_list[segment_id].deviation_point.value);
		assert(area_vector[segment_id].apla.a == doubly_linked_list[segment_id].apla.a);
		assert(area_vector[segment_id].apla.b == doubly_linked_list[segment_id].apla.b);
		assert(area_vector[segment_id].already_compute == doubly_linked_list[segment_id].already_compute);
	}

	return true;
}

//210301
TEMPLATE
template<typename T>
inline bool APLA::assert_adjacent_nodes(const DoublyListNode<T>& const node) {
	assert(node._prev);
	T& left_seg = node._prev->_value;
	auto& seg = node._value;
	T& long_seg = *node._value.right_subsegment;
	assert(long_seg.right_endpoint == seg.right_endpoint && long_seg.rectangle_width == left_seg.rectangle_width + seg.rectangle_width);

	return true;
}

//210301
TEMPLATE
template<typename T>
inline bool APLA::assert_adjacent_nodes_endpoint(const DoublyListNode<T>& const node) {
	if (node._next) {
		assert(node._value.right_endpoint == node._next->_value.right_endpoint - node._next->_value.rectangle_width);
	}

	if (node._prev) {
		assert(node._prev->_value.right_endpoint == node._value.right_endpoint - node._value.rectangle_width);
	}

	return true;
}

//************************************
// Method:assertLinkedListAndSubLinkedList
// Qualifier: assert non INF, right endpoint, width,  sub segment, a&b
// Notice: comment minmax point,
// date:191101
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
bool APLA::assertLinkedListAndSubLinkedList(const vector<T>& const original_time_series_vector, const DoublyLinkedList<Y>& const doubly_linked_list) {
	assert(!doubly_linked_list.empty());
	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {

		const auto& const segment = doubly_linked_list[segment_id];
		int segment_left_id = segment.right_endpoint - segment.rectangle_width + 1;

		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++    assert minmax point    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		//210203 minmax point
		//assert(segment.min_point.id != INF && segment.min_point.value != INF && segment.max_point.id != INF && segment.max_point.value != INF);
		assert(segment.right_endpoint != INF && segment.rectangle_width != INF && segment.apla.a != INF && segment.apla.b != INF && segment.area_difference != INF);
		//assert(segment.min_point.id >= segment_left_id && segment.max_point.id >= segment_left_id && segment.min_point.id <= segment.right_endpoint && segment.max_point.id <= segment.right_endpoint);// 210203
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++ assert a&b, minmax point  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		Y test_segment = doubly_linked_list[segment_id];
		assert_two_segments_a_b(get_ab_segment(original_time_series_vector, test_segment), segment);
		//assert_segment_minmax(segment);// 210203
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		if (segment_id > 0) {
			const auto& const segment_left = doubly_linked_list[segment_id - 1];
			const auto& const sub_segment_pointer = segment.right_subsegment;
			//200316 sum value
			//assert(sub_segment_pointer->sum_value == segment.sum_value + doubly_linked_list[segment_id - 1].sum_value);
			assert(segment.rectangle_width == segment.right_endpoint - segment_left.right_endpoint);
			//assert(sub_segment_pointer->min_point.id != INF && sub_segment_pointer->min_point.value != INF && sub_segment_pointer->max_point.id != INF && sub_segment_pointer->max_point.value != INF);
			assert(sub_segment_pointer->area_difference != INF && sub_segment_pointer->right_endpoint != INF && sub_segment_pointer->rectangle_width != INF && sub_segment_pointer->apla.a != INF && sub_segment_pointer->apla.b != INF);
			assert(sub_segment_pointer->rectangle_width == segment.rectangle_width + segment_left.rectangle_width && sub_segment_pointer->right_endpoint == segment.right_endpoint);
			int sub_segment_left_id = sub_segment_pointer->right_endpoint - sub_segment_pointer->rectangle_width + 1;
			assert(segment.rectangle_width == segment.right_endpoint - segment_left.right_endpoint && segment.area_difference != INF);

			/*===================================================== 210203 assert minmax point ==================================================================*/
			/*assert(sub_segment_pointer->min_point.id >= sub_segment_left_id && sub_segment_pointer->max_point.id >= sub_segment_left_id && sub_segment_pointer->min_point.id <= sub_segment_pointer->right_endpoint && sub_segment_pointer->max_point.id <= sub_segment_pointer->right_endpoint);
			assert(sub_segment_pointer->min_point.value == segment.min_point.value || sub_segment_pointer->min_point.value == segment_left.min_point.value);
			assert(sub_segment_pointer->max_point.value == segment.max_point.value || sub_segment_pointer->max_point.value == segment_left.max_point.value);*/
			/*============================================================================================================================================*/
		}
	}
	return true;
}

//************************************
// Method:assertLinkedList
// Qualifier: 191101 assert segment: non INF, right endpoint, width, minmax point,, a&b
// date:191101
// NOtice 200214 Not sub linked list pointer
// author:
//************************************
TEMPLATE
template<typename T>
bool APLA::assertLinkedList(const DoublyLinkedList<T>& const doubly_linked_list) {
	assert(!doubly_linked_list.empty());
	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {

		const auto& const segment = doubly_linked_list[segment_id];
		int segment_left_id = segment.right_endpoint - segment.rectangle_width + 1;

		//assert(segment.min_point.id != INF && segment.min_point.value != INF && segment.max_point.id != INF && segment.max_point.value != INF); 210203
		assert(segment.right_endpoint != INF && segment.rectangle_width != INF && segment.apla.a != INF && segment.apla.b != INF);

		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++    assert minmax point    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		//200314 minmax point
		//assert(segment.min_point.id != INF && segment.min_point.value != INF && segment.max_point.id != INF && segment.max_point.value != INF); 210203
		assert(segment.right_endpoint != INF && segment.rectangle_width != INF && segment.apla.a != INF && segment.apla.b != INF && segment.area_difference != INF);
		//assert(segment.min_point.id >= segment_left_id && segment.max_point.id >= segment_left_id && segment.min_point.id <= segment.right_endpoint && segment.max_point.id <= segment.right_endpoint); 210203
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++ assert a&b, minmax point  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		auto test_segment = doubly_linked_list[segment_id];
		//assert_two_segments_a_b(get_ab_segment(original_time_series_vector, test_segment), segment);
		//assert_segment_minmax(segment);
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++     assert area difference    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		//assert(fabs(segment.area_difference - get_area_difference_segment(test_segment)) < MIN_D);
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		if (segment_id > 0) {
			//const auto& const sub_segment_pointer = segment.right_subsegment;
			const auto& const segment_left = doubly_linked_list[segment_id - 1];

			assert(segment.rectangle_width == segment.right_endpoint - segment_left.right_endpoint);

			assert(segment_left_id == segment_left.right_endpoint + 1 && segment.rectangle_width == segment.right_endpoint - segment_left.right_endpoint);
		}
	}

	return true;
}


// 201004 assert segment: non INF, right endpoint, width, minmax point, a&b, sub right endpoint
//************************************
// Method:assertLinkedList
// Qualifier: 191101 assert segment: non INF, right endpoint, width, minmax point,, a&b
// date:191101
// NOtice 200214 Not sub linked list pointer
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
bool APLA::assertLinkedList(const vector<T>& const original_time_series_vector, const DoublyLinkedList<Y>& const doubly_linked_list) {
	assert(!doubly_linked_list.empty());
	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {

		const auto& const segment = doubly_linked_list[segment_id];
		int segment_left_id = segment.right_endpoint - segment.rectangle_width + 1;

		assert(segment.min_point.id != INF && segment.min_point.value != INF && segment.max_point.id != INF && segment.max_point.value != INF);
		assert(segment.right_endpoint != INF && segment.rectangle_width != INF && segment.apla.a != INF && segment.apla.b != INF);

		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++    assert minmax point    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		//200314 minmax point
		assert(segment.min_point.id != INF && segment.min_point.value != INF && segment.max_point.id != INF && segment.max_point.value != INF);
		assert(segment.right_endpoint != INF && segment.rectangle_width != INF && segment.apla.a != INF && segment.apla.b != INF && segment.area_difference != INF);
		assert(segment.min_point.id >= segment_left_id && segment.max_point.id >= segment_left_id && segment.min_point.id <= segment.right_endpoint && segment.max_point.id <= segment.right_endpoint);
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++ assert a&b, minmax point  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		auto test_segment = doubly_linked_list[segment_id];
		assert_two_segments_a_b(get_ab_segment(original_time_series_vector, test_segment), segment);
		//assert_segment_minmax(segment);
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++     assert area difference    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		if (segment.rectangle_width > 3) {
			//assert(fabs(segment.area_difference - get_area_difference_segment(test_segment) * test_segment.rectangle_width) < MIN_D);
		}
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		if (segment_id > 0) {
			//const auto& const sub_segment_pointer = segment.right_subsegment;
			const auto& const segment_left = doubly_linked_list[segment_id - 1];

			assert(segment.rectangle_width == segment.right_endpoint - segment_left.right_endpoint);

			assert(segment_left_id == segment_left.right_endpoint + 1 && segment.rectangle_width == segment.right_endpoint - segment_left.right_endpoint);
		}
	}
	return true;
}

//************************************
// Method:assertRightEndpoint_Width
// Qualifier: assert segment right endpoint, width
// date:191101
// author:
//************************************
TEMPLATE
template<typename T>
bool APLA::assertRightEndpoint_Width(const DoublyLinkedList<T>& const doubly_linked_list) const {
	assert(!doubly_linked_list.empty() && doubly_linked_list[0].right_endpoint + 1 == doubly_linked_list[0].rectangle_width);
	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		const auto& const segment = doubly_linked_list[segment_id];
		int segment_left_id = segment.right_endpoint - segment.rectangle_width + 1;
		assert(segment.right_endpoint != INF && segment.rectangle_width != INF);
		if (segment_id > 0) {
			//const auto& const sub_segment_pointer = segment.right_subsegment;
			assert(segment_left_id == doubly_linked_list[segment_id - 1].right_endpoint + 1 && segment.rectangle_width == segment.right_endpoint - doubly_linked_list[segment_id - 1].right_endpoint);
		}
	}
	return true;
}


TEMPLATE
template<typename T, typename Y>//210831
bool APLA::assert_endpoint_a_b(const vector<T>& const original_time_series_vector, const DoublyLinkedList<Y>& const doubly_linked_list) {
	assertRightEndpoint_Width(doubly_linked_list);
	return assert_a_b(original_time_series_vector, doubly_linked_list);
}

TEMPLATE
template<typename T>
inline bool APLA::assert_segment_apla_coefficient(const T& const temp_coefficient) {
	assert(temp_coefficient.apla.a_minuend == (temp_coefficient.rectangle_width - 1) / 2.0);//(l-1)/2
	assert(temp_coefficient.apla.a_divisor == (temp_coefficient.rectangle_width - 1) * (temp_coefficient.rectangle_width + 1) * temp_coefficient.rectangle_width);//l(l-1)(l+1)
	// merged b coefficient
	assert(temp_coefficient.apla.b_minuend == 2.0 * temp_coefficient.rectangle_width - 1);//2l-1
	assert(temp_coefficient.apla.b_divisor == (temp_coefficient.rectangle_width + 1) * temp_coefficient.rectangle_width);//l(l+1)
	return true;
}

// 200214 assert a & b of  one  segment
TEMPLATE
template<typename T>
inline bool APLA::assert_segment_a_b(const T& const temp_coefficient) const {
	assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF);
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	if (temp_coefficient.apla.a > 0) {
		// merged a coefficient
		assert(temp_coefficient.apla.a_minuend == (temp_coefficient.rectangle_width - 1) / 2.0);//(l-1)/2
		assert(temp_coefficient.apla.a_divisor == (temp_coefficient.rectangle_width - 1) * (temp_coefficient.rectangle_width + 1) * temp_coefficient.rectangle_width);//l(l-1)(l+1)
		// merged b coefficient
		assert(temp_coefficient.apla.b_minuend == 2.0 * temp_coefficient.rectangle_width - 1);//2l-1
		assert(temp_coefficient.apla.b_divisor == (temp_coefficient.rectangle_width + 1) * temp_coefficient.rectangle_width);//l(l+1)
		/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	}
	return true;
}

//***************************************************************
// Method:assert_segment_a_b
// Qualifier: assert a&b of one segment with time series
// Input: time series. segment 
// Output: evaluate minmax of segment
// notice:
// date:200512
// author:
//***************************************************************
TEMPLATE
template<typename T, typename Y>
inline bool APLA::assert_segment_a_b(const vector<T>& const original_time_series_vector, const Y& const temp_coefficient) {
	Y test_temp_coefficient;
	test_temp_coefficient.right_endpoint = temp_coefficient.right_endpoint;
	test_temp_coefficient.rectangle_width = temp_coefficient.rectangle_width;

	assert(temp_coefficient.apla.a != INF && temp_coefficient.apla.b != INF);
	// merged a coefficient
	assert(temp_coefficient.apla.a_minuend == (temp_coefficient.rectangle_width - 1) / 2.0);//(l-1)/2
	assert(temp_coefficient.apla.a_divisor == (temp_coefficient.rectangle_width - 1) * (temp_coefficient.rectangle_width + 1) * temp_coefficient.rectangle_width);//l(l-1)(l+1)
	// merged b coefficient
	assert(temp_coefficient.apla.b_minuend == 2.0 * temp_coefficient.rectangle_width - 1);//2l-1
	assert(temp_coefficient.apla.b_divisor == (temp_coefficient.rectangle_width + 1) * temp_coefficient.rectangle_width);//l(l+1)

	get_ab_segment(original_time_series_vector, test_temp_coefficient);

	assert(fabs(test_temp_coefficient.apla.a - temp_coefficient.apla.a) <= 0.001 && fabs(test_temp_coefficient.apla.b - temp_coefficient.apla.b) <= 0.001);

	return true;
}

// 191108 assert a & b of every segment
TEMPLATE
template<typename T, typename Y>
bool APLA::assert_a_b(const vector<T>& const original_time_series_vector, const DoublyLinkedList<Y>& const doubly_linked_list){
	assert(!doubly_linked_list.empty() && doubly_linked_list[0].right_endpoint + 1 == doubly_linked_list[0].rectangle_width);
	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		Y segment = doubly_linked_list[segment_id];
		assert(segment.right_endpoint != INF && segment.rectangle_width != INF && segment.apla.a != INF && segment.apla.b != INF);
		assert_segment_a_b(original_time_series_vector, segment);
	}
	return true;
}

//210901 two segments have same left endpoint
TEMPLATE
template<typename T, typename Y>
inline bool APLA::assert_segment_same_left_endpoint(const T& const segment_1, const Y& const segment_2) {
	assert(segment_1.right_endpoint - segment_1.rectangle_width == segment_2.right_endpoint - segment_2.rectangle_width);
	return true;
}

// 210901 assert each rectangle width >= min width
TEMPLATE
template<typename T, typename Y>
bool APLA::assert_list_min_width(const T& const width_min, const DoublyLinkedList<Y>& const doubly_linked_list) {
	const int size_list = doubly_linked_list.size();

	for (int id_segment = 0; id_segment < size_list; id_segment++) {
		Y segment = doubly_linked_list[id_segment];
		assert(segment.rectangle_width >= width_min);
	}

	return true;
}

// 200320 assert compare a & b of two segments
TEMPLATE
template<typename T>
inline bool APLA::assert_two_segments_a_b(const T& const segment1, const T& const segment2) const {

	assert(segment1.apla.a != INF && segment1.apla.b != INF && segment1.right_endpoint != INF && segment1.rectangle_width != INF);
	assert(segment2.apla.a != INF && segment2.apla.b != INF && segment2.right_endpoint != INF && segment2.rectangle_width != INF);

	assert(fabs(segment1.apla.a - segment2.apla.a) <= 0.1 && fabs(segment1.apla.b - segment2.apla.b) <= 0.1);
	// merged a coefficient
	assert(segment1.apla.a_minuend == segment2.apla.a_minuend);//(l-1)/2
	assert(segment1.apla.a_divisor == segment2.apla.a_divisor);//l(l-1)(l+1)
	// merged b coefficient
	assert(segment1.apla.b_minuend == segment2.apla.b_minuend);//2l-1
	assert(segment1.apla.b_divisor == segment2.apla.b_divisor);//l(l+1)

	return true;
}

// 200320 assert compare a & b of two segments
TEMPLATE
template<typename T>
inline bool APLA::assert_equal_a_b(const T& const segment1, const T& const segment2) const {

	assert(segment1.apla.a == segment2.apla.a && segment1.apla.b == segment2.apla.b);

	return true;
}


// 200712 whether a&b of two segments are same
TEMPLATE
template<typename T>
inline bool APLA::if_equal_ab(const T& const segment1, const T& const segment2) const {
	if (segment1.apla.a == segment2.apla.a && segment1.apla.b == segment2.apla.b)
		return true;
	return false;
}

// 200721 a1-a2 < MIN_D && b1-b2 < MIN_D
TEMPLATE
template<typename T>
inline const bool APLA::if_similar_ab_two_segments(const T& const segment1, const T& const segment2) const {
	if (fabs(segment1.apla.a - segment2.apla.a) < MIN_D && fabs(segment1.apla.a * segment1.rectangle_width + segment1.apla.b - segment2.apla.b) < MIN_D)
		return true;
	return false;
}

//***************************************************************
// Method:evaluate_linkedlist_for_loop
// Qualifier: for(:) is the best,  for(int i;;), for_each_n(), for(auto;;), for_each(),
// Input:
// Output: 
// date:191114
// author:
//***************************************************************
TEMPLATE
template<typename T>
void APLA::evaluate_linkedlist_for_loop(const DoublyLinkedList<T>& const doubly_linked_list) {
	/*=============================================Evaluate iterator linked list speed===============================================================*/
	double time10 = INF, time11 = INF, time12 = INF, time13 = INF, time14 = INF;
	TOOL::recordStartTime(TOOL::time_record[10]);
	for (auto&& const au : doubly_linked_list) {
		//cout << au.right_endpoint + 1 << ",";
		au.right_endpoint + 1;
	}
	time14 = TOOL::recordFinishTime(TOOL::time_record[10]);
	cout << endl;
	TOOL::recordStartTime(TOOL::time_record[10]);
	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		//cout << doubly_linked_list[segment_id].right_endpoint + 1 << ",";
		doubly_linked_list[segment_id].right_endpoint + 1;
	}
	time10 = TOOL::recordFinishTime(TOOL::time_record[10]);
	cout << endl;
	TOOL::recordStartTime(TOOL::time_record[13]);
	for_each_n(doubly_linked_list.begin(), doubly_linked_list.size(), [](auto&& const au) {
		//cout << au.right_endpoint + 1 << ",";
		au.right_endpoint + 1;
		});
	time13 = TOOL::recordFinishTime(TOOL::time_record[13]);
	cout << endl;
	//doubly_linkedlist_iterator<AREA_COEFFICIENT> au(doubly_linked_list.get_head_node());
	//doubly_linkedlist_iterator<AREA_COEFFICIENT> au = doubly_linked_list.begin();
	TOOL::recordStartTime(TOOL::time_record[11]);
	for (auto&& const au = doubly_linked_list.begin(); au != doubly_linked_list.end(); ++au) {
		//cout << au.current_node_pointer->_value.right_endpoint<<endl;
		//cout << (*au).right_endpoint + 1 << ",";
		(*au).right_endpoint + 1;
		//cout<< au->right_endpoint + 1 << ",";
		//au->right_endpoint + 1;
	}
	time11 = TOOL::recordFinishTime(TOOL::time_record[11]);
	cout << endl;
	TOOL::recordStartTime(TOOL::time_record[12]);
	for_each(doubly_linked_list.begin(), doubly_linked_list.end(), [](auto&& const au) {
		//cout << au.right_endpoint + 1 << ",";
		au.right_endpoint + 1;
		});
	time12 = TOOL::recordFinishTime(TOOL::time_record[12]);
	cout << endl;

	//cout << "++++++++++++++++++++++++++++++++++++Iterator time++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n";
	//cout << time10 << "\n" << time11 << "\n" << time12 << "\n" << time13 << "\n" << time14 << "\n" << endl;
	vector<double> for_time_vector = { time14, time10, time13, time11, time12 };
	TOOL::writeResultNoCover("TIME", for_time_vector);
	//cout << "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n";
}

//***************************************************************
// Method:assert_linkedlist_rightEndpoint_Width_rightHeightDifference
// Qualifier: assert linked list right ednpoint , width, right height difference
// Input:
// Output: 
// date:191211
// author:
//***************************************************************
TEMPLATE
template<typename T>
void APLA::assert_linkedlist_rightEndpoint_Width_rightHeightDifference(const typename TOOL::INPUT_ARGUMENT& const input_argument, const DoublyLinkedList<T>& const doubly_linked_list) {
	assert(!doubly_linked_list.empty() && doubly_linked_list.back().right_endpoint + 1 == input_argument.time_series_length);
	for (auto&& au : doubly_linked_list) {
		assert(au.right_endpoint != INF && au.rectangle_width != INF && au.segment_right_height_difference != INF);
	}
}

//***************************************************************
// Method:assert_split_coefficients
// Qualifier: assert right endpoint, width, sum value, a&b.
// Input:one segment
// Output: 
// date:200306
// author:
//***************************************************************
TEMPLATE
template<typename T>
void APLA::assert_split_coefficients(const T& const temp_coefficient) {
	assert_segment_a_b(temp_coefficient);
	assert(temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF);
}

//***************************************************************
// Method:assert_structure_split_coefficients
// Qualifier: assert structure split coefficients: sub left & right segment endpoint, width, apla. a&b. segment density. magnitude
// Input: structure split coefficients
// Output: 
// date:200311
// author:
//***************************************************************
TEMPLATE
template<typename T>
void APLA::assert_structure_split_coefficients(const T& const split_coeffcients) {
	assert_split_coefficients(split_coeffcients.segment_left);
	assert_split_coefficients(split_coeffcients.segment_right);
	assert(split_coeffcients.split_magnitude != int(INF));
	assert(split_coeffcients.segment_right.segment_density > 0);
}

// 191108 assert min max point of one segment
TEMPLATE
template<typename T>
bool APLA::assert_segment_minmax(const T& const segment) const {
	assert(0);
	//200314 minmax point
	assert(segment.right_endpoint != INF && segment.min_point.id != INF && segment.min_point.value != INF && segment.max_point.id != INF && segment.max_point.value != INF && segment.min_point.value <= segment.max_point.value && segment.min_point.id <= segment.right_endpoint && segment.max_point.id <= segment.right_endpoint);
	return true;
}

// 200512 assert min max point of one segment
//***************************************************************
// Method:assert_segment_minmax
// Qualifier: assert structure split coefficients: sub left & right segment endpoint, width, apla. a&b. segment density. magnitude
// Input: structure split coefficients
// Output: 
// date:200311
// author:
//***************************************************************
TEMPLATE
template<typename T, typename Y>
inline bool APLA::assert_segment_minmax(const vector<T>& const original_time_series_vector, const Y& const temp_coefficient) const {
	//200314 minmax point
	assert(temp_coefficient.right_endpoint != INF && temp_coefficient.min_point.id != INF && temp_coefficient.min_point.value != INF && temp_coefficient.max_point.id != INF && temp_coefficient.max_point.value != INF && temp_coefficient.min_point.value <= temp_coefficient.max_point.value && temp_coefficient.min_point.id <= temp_coefficient.right_endpoint && temp_coefficient.max_point.id <= temp_coefficient.right_endpoint);

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&                    min&max point value                                &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	const auto& const minmax_value = minmax_element(original_time_series_vector.begin() + int(temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1), original_time_series_vector.begin() + temp_coefficient.right_endpoint + 1);
	assert(temp_coefficient.min_point.value == *minmax_value.first && temp_coefficient.max_point.value == *minmax_value.second && original_time_series_vector[temp_coefficient.min_point.id] == temp_coefficient.min_point.value && original_time_series_vector[temp_coefficient.max_point.id] == temp_coefficient.max_point.value);
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&                     min&max point id                                  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	const int id_segment_left = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
	assert(temp_coefficient.min_point.id <= temp_coefficient.right_endpoint && temp_coefficient.min_point.id >= id_segment_left && temp_coefficient.max_point.id <= temp_coefficient.right_endpoint && temp_coefficient.max_point.id >= id_segment_left);
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	return true;
}


//200313 assert min&max value
TEMPLATE
template<typename T, typename Y>
void APLA::assert_minmax_value(const vector<T>& const original_time_series_vector, const DoublyLinkedList<Y>& const doubly_linked_list) {
	//200314 minmax point
	//assert(0);

	assert(!original_time_series_vector.empty() && !doubly_linked_list.empty() && original_time_series_vector.size() == doubly_linked_list.back().right_endpoint + 1);

	for (auto&& au : doubly_linked_list) {
		assert(au.right_endpoint != INF && au.rectangle_width != INF && au.min_point.value != INF && au.max_point.value != INF);
		const auto& const minmax_value = minmax_element(original_time_series_vector.begin() + int(au.right_endpoint - au.rectangle_width + 1), original_time_series_vector.begin() + au.right_endpoint + 1);
		assert(au.min_point.value == *minmax_value.first && au.max_point.value == *minmax_value.second);
		/*-----  210113 upper bound  -----*/
		assert(au.bound.upper_bound_diff != -INF && au.bound.upper_bound_area != -INF);
		/*--------------------------------*/
	}
}

// 200527 assert min&max, a&b of one segment
TEMPLATE
template<typename T, typename Y>
inline void APLA::assert_segment_a_b_minmax(const vector<T>& const original_time_series_vector, const Y& const temp_coefficient) {
	assert_segment_a_b(original_time_series_vector, temp_coefficient);
	assert_segment_minmax(original_time_series_vector, temp_coefficient);
}


//***************************************************************
// Method:assert_loop_segment_density_area_difference
// Qualifier: assert loop about density & area difference in each segment
// Input: 1 linked list; 2 ; 3 ;
// Output:
// date:200825
// author:
//***************************************************************
TEMPLATE
template<typename T, typename Y, typename U>
bool APLA::assert_loop_segment_density_area_difference(const DoublyLinkedList<T>& const doubly_linked_list, const multimap<U, Y, std::greater<U>>& const multi_map_1, const multimap<U, Y, std::greater<U>>& const multi_map_2) {

	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
		//cout << doubly_linked_list[segment_id].area_difference << " ";
		const T& const segment = doubly_linked_list[segment_id];
		if (segment.area_difference > 0 && !multi_map_1.empty() && segment.rectangle_width > 3) {
			find_if_in_multimap(segment.area_difference, multi_map_1);
		}
		if (segment_id > 0) {
			find_if_in_multimap(segment.right_subsegment->segment_density, multi_map_2);
		}
	}

	return true;
}

// 201102 Assert Split MAP
//***************************************************************
// Method:assert_split_map_area_difference
// Qualifier: assert loop about density & area difference in each segment
// Input: 1 linked list; 2 ; 3 ;
// Output:
// date:200825
// author:
//***************************************************************
TEMPLATE
template<typename T>
bool APLA::assert_split_map_area_difference(const T& const split_map) {
	for (auto&& au : split_map) {
		assert(au.first > 0 && au.first == au.second._value.area_difference && au.second._value.rectangle_width > 3);
	}
	return true;
}

//***************************************************************
// Method:assert_split_map_optimization
// Qualifier: assert split map in optimization part
// Input: MAP
// Output:
// date:201227
// author:
//***************************************************************
TEMPLATE
template<typename T>
bool APLA::assert_split_map_optimization(const T& const split_map) {
	for (auto&& au : split_map) {
		assert(au.first == au.second._value.area_difference && au.second._value.rectangle_width > 1 && au.first >= 0);
	}
	return true;
}


// 210123 Assert Merge MAP
TEMPLATE
template<typename T>
bool APLA::assert_merge_map_triangle_density(const T& const merge_map) {
	for (auto&& au : merge_map) {
		assert(au.first == au.second._value.right_subsegment->segment_density);
	}
	return true;
}

TEMPLATE
template<typename T, typename Y>//210830 two segment has same value
inline bool APLA::assert_segment_equal(const T& const segment_1, const Y& const segment_2) {
	assert(segment_1.right_endpoint == segment_2.right_endpoint && segment_1.rectangle_width == segment_2.rectangle_width && segment_1.apla.a == segment_2.apla.a && segment_1.apla.b == segment_2.apla.b);
	return true;
}

//210622 2 SAPLA has same right endpoints
TEMPLATE
template<typename T>
bool APLA::assert_has_same_endpoints(const DoublyLinkedList<T>& const doubly_linked_list_1, const DoublyLinkedList<T>& const doubly_linked_list_2) {

	assert(doubly_linked_list_1.size() == doubly_linked_list_2.size());

	for (int id_segment = 0; id_segment < doubly_linked_list_1.size(); id_segment++) {
		const T& const  segment_1 = doubly_linked_list_1[id_segment];
		const T& const  segment_2 = doubly_linked_list_2[id_segment];
		assert(segment_1.right_endpoint == segment_2.right_endpoint && segment_1.rectangle_width == segment_2.rectangle_width);
	}

	return true;
}

//200219 Evaluate split point comparison: min density, binary, direct intersection and best split method
//***************************************************************
// Method:evaluate_accuracy_time_split_point
// Qualifier:
// Input: 1 time series, segment, min denstiy split id
//      
// Output: accuracy & time of 1 min density,2 binary,3 direct intersection and 4 best split method
// date:200219
// author:
//***************************************************************
TEMPLATE
template<typename T, typename Y>
void APLA::evaluate_accuracy_time_split_point(const vector<T>& const original_time_series_vector, const Y& const temp_coefficient, const double& const split_id_min_density, const double& const split_time_min_density) {
	assert(output_argument.coefficents_split_id.split_time_min_density != INF && output_argument.coefficents_split_id.split_time_binary != INF && output_argument.coefficents_split_id.split_time_direct_intersection != INF && output_argument.coefficents_split_id.split_time_best != INF);
	assert(output_argument.coefficents_split_id.split_sum_deviation_min_density != INF && output_argument.coefficents_split_id.split_sum_deviation_binary != INF && output_argument.coefficents_split_id.split_sum_deviation_direct_intersection != INF && output_argument.coefficents_split_id.split_sum_deviation_best != INF);
	assert(split_id_min_density != INF && split_time_min_density != NULL && temp_coefficient.rectangle_width > 3);

	/*-----------------------------------------Sum Deviation & Time of min density----------------------------------------------------------------------------*/
	output_argument.coefficents_split_id.split_time_min_density += split_time_min_density;
	output_argument.coefficents_split_id.split_sum_deviation_min_density += get_segment_sum_deviation_by_split_id(original_time_series_vector, temp_coefficient, split_id_min_density);
	/*---------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/*-----------------------------------------Sum Deviation & Time of Binary----------------------------------------------------------------------------------*/
#ifdef TIME_H
	typename TOOL::TIME time_find_split;
	TOOL::recordStartTime(time_find_split);//compare percentage time
#endif
	int split_id_binary = findSplitSegmentByEndpoint2length(original_time_series_vector, temp_coefficient);//200205 find binary split point
#ifdef TIME_H
	output_argument.coefficents_split_id.split_time_binary += TOOL::recordFinishTime(time_find_split);// 180923
#endif
	output_argument.coefficents_split_id.split_sum_deviation_binary += get_segment_sum_deviation_by_split_id(original_time_series_vector, temp_coefficient, split_id_binary);
	/*----------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/*------------------------------------------Sum Deviation & Time of Intersection Point----------------------------------------------------------------------*/
#ifdef TIME_H
	TOOL::recordStartTime(time_find_split);//compare percentage time
#endif
	int split_id_intersection = find_split_point_by_direct_intersection_point(original_time_series_vector, temp_coefficient);// directly find intersection point as split point

#ifdef TIME_H
	output_argument.coefficents_split_id.split_time_direct_intersection += TOOL::recordFinishTime(time_find_split);// 180923
#endif
	output_argument.coefficents_split_id.split_sum_deviation_direct_intersection += get_segment_sum_deviation_by_split_id(original_time_series_vector, temp_coefficient, split_id_intersection);
	/*-----------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/*-------------------------------------------Sum Deviation & Time of Middle Point-----------------------------------------------------------------------------*/
	// regard the middle point of segment split id
#ifdef TIME_H
	TOOL::recordStartTime(time_find_split);//compare percentage time
#endif
	int split_id_middle = find_split_point_by_middle_point(temp_coefficient);// directly find intersection point as split point
#ifdef TIME_H
	output_argument.coefficents_split_id.split_time_middle += TOOL::recordFinishTime(time_find_split);//
#endif
	output_argument.coefficents_split_id.split_sum_deviation_middle += get_segment_sum_deviation_by_split_id(original_time_series_vector, temp_coefficient, split_id_middle);
	/*-------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/*--------------------------------------------Sum Deviation & Time of Local bestst Point-----------------------------------------------------------------------*/
#ifdef TIME_H
	TOOL::recordStartTime(time_find_split);//compare percentage time
#endif																														 
	//split_id = APLA::findSplitSegmentBaseline(original_time_series_vector, doubly_linked_list[segment_id], 1);// min triangle density id
	int split_id_best = findSplitSegmentBaseline(original_time_series_vector, temp_coefficient, 0);//best split id
#ifdef TIME_H
	output_argument.coefficents_split_id.split_time_best += TOOL::recordFinishTime(time_find_split);// 180923
#endif
	output_argument.coefficents_split_id.split_sum_deviation_best += get_segment_sum_deviation_by_split_id(original_time_series_vector, temp_coefficient, split_id_best);
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/*--------------------------------------------Differece between best split id------------------------------------------------------------------------------------*/
	assert(split_id_min_density > 0 && split_id_binary > 0 && split_id_intersection != int(INF) && split_id_best > 0 && split_id_middle > 0);

	output_argument.coefficents_split_id.split_accuracy_min_density += fabs(split_id_min_density - split_id_best);
	output_argument.coefficents_split_id.split_accuracy_binary += fabs(split_id_binary - split_id_best);
	output_argument.coefficents_split_id.split_accuracy_direct_intersection += fabs(split_id_intersection - split_id_best);
	output_argument.coefficents_split_id.split_accuracy_middle += fabs(split_id_middle - split_id_best);
	output_argument.coefficents_split_id.split_id_best += split_id_best;
	/*---------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	assert(split_id_binary != int(INF) && split_id_intersection != int(INF) && split_id_middle != int(INF) && split_id_best != int(INF) && output_argument.coefficents_split_id.split_accuracy_min_density != INF && output_argument.coefficents_split_id.split_accuracy_binary != INF && output_argument.coefficents_split_id.split_accuracy_direct_intersection != INF && output_argument.coefficents_split_id.split_accuracy_middle != INF && output_argument.coefficents_split_id.split_id_best != INF);
	assert(output_argument.coefficents_split_id.split_time_min_density != INF && output_argument.coefficents_split_id.split_time_binary != INF && output_argument.coefficents_split_id.split_time_direct_intersection != INF && output_argument.coefficents_split_id.split_time_middle != INF && output_argument.coefficents_split_id.split_time_best != INF);
	assert(output_argument.coefficents_split_id.split_sum_deviation_min_density != INF && output_argument.coefficents_split_id.split_sum_deviation_binary != INF && output_argument.coefficents_split_id.split_sum_deviation_direct_intersection != INF && output_argument.coefficents_split_id.split_sum_deviation_middle != INF && output_argument.coefficents_split_id.split_sum_deviation_best != INF);
}

//***************************************************************
// Method:evaluate_segment_upper_lower_bound
// Qualifier: Evaluate upper & lower bound: max devation * l > sum deviation > lower bound deviation
// Input: 1 time series. 2 right endpoint, width of segment.
// Output: 
// date:200223
// author:
//***************************************************************
TEMPLATE
template<typename T, typename Y, typename U>
bool APLA::evaluate_segment_upper_lower_bound(U& const input_argument, const vector<T>& const original_time_series_vector, const Y& const temp_coefficient) {
	assert(0);
	assert(temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF && input_argument.number_point_max_deviation_true != INF && input_argument.number_point_max_deviation_false != INF && input_argument.number_not_smaller_than_sum_deviation != INF && input_argument.number_smaller_than_sum_deviation != INF && input_argument.number_not_smaller_than_sum_deviation_pow != INF && input_argument.number_smaller_than_sum_deviation_pow != INF);
	/*................................................................................................................*/
#ifdef _DEBUG
	assert_segment_a_b_minmax(original_time_series_vector, temp_coefficient);
#endif
	/*................................................................................................................*/

	long double min_point_difference = INF;
	long double max_point_difference = INF;
	long double left_end_point_difference = INF;
	long double right_end_point_difference = INF;

	long double min_point_difference_pow = INF;
	long double max_point_difference_pow = INF;
	long double left_end_point_difference_pow = INF;
	long double right_end_point_difference_pow = INF;

	priority_queue<long double> difference_abs_queue;
	priority_queue<long double> difference_abs_pow_queue;

	const size_t id_segment_left = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;

	/*-----------------------------------get a&b, minmax point-------------------------------------------------------*/
	//Y segment_evaluation = temp_coefficient;
	//get_ab_minmax_segment(original_time_series_vector, segment_evaluation);
	/*---------------------------------------------------------------------------------------------------------------*/

	long double sum_deviation = 0;
	long double max_deviation = -INF;
	long double point_difference = INF;
	long double point_difference_abs = INF;
	long double point_difference_pow = INF;

	long double difference_no_fabs = 0;

	for (int i = 0; i < temp_coefficient.rectangle_width; i++) {

		point_difference = temp_coefficient.apla.a * i + temp_coefficient.apla.b - original_time_series_vector[id_segment_left + i];
		difference_no_fabs += point_difference;
		point_difference_pow = pow(point_difference, 2.0);
		point_difference_abs = fabs(point_difference);

		if (i == 0) {
			left_end_point_difference = point_difference;
			left_end_point_difference_pow = point_difference_pow;
			difference_abs_queue.emplace(point_difference_abs);
			difference_abs_pow_queue.emplace(point_difference_pow);
		}
		if (i == temp_coefficient.rectangle_width - 1) {
			right_end_point_difference = point_difference;
			right_end_point_difference_pow = point_difference_pow;
			difference_abs_queue.emplace(point_difference_abs);
			difference_abs_pow_queue.emplace(point_difference_pow);
		}
		if (id_segment_left + i == temp_coefficient.min_point.id) {
			min_point_difference = point_difference;
			min_point_difference_pow = point_difference_pow;
			difference_abs_queue.emplace(point_difference_abs);
			difference_abs_pow_queue.emplace(point_difference_pow);
		}
		if (id_segment_left + i == temp_coefficient.max_point.id) {
			max_point_difference = point_difference;
			max_point_difference_pow = point_difference_pow;
			difference_abs_queue.emplace(point_difference_abs);
			difference_abs_pow_queue.emplace(point_difference_pow);
		}

		//cout << "(Point Diff: " << point_difference << " , diff pow: " << point_difference_pow << "); ";
		sum_deviation += point_difference_pow;
		max_deviation = max(max_deviation, point_difference_abs);
	}
	//cout << endl;
	assert(fabs(difference_no_fabs) < 0.00000001);

	sum_deviation = sqrt(sum_deviation);
	//assert max devation * l >=  sum deviation
	assert(max_deviation * sqrt(temp_coefficient.rectangle_width) >= sum_deviation);

	/*###############################################################################################################################*/
	if (difference_abs_queue.top() * temp_coefficient.rectangle_width >= sum_deviation) {
		input_argument.number_not_smaller_than_sum_deviation++;
	}
	else {
		input_argument.number_smaller_than_sum_deviation++;
	}

	if (difference_abs_pow_queue.top() * temp_coefficient.rectangle_width >= sum_deviation * sum_deviation) {
		input_argument.number_not_smaller_than_sum_deviation_pow++;
	}
	else {
		input_argument.number_smaller_than_sum_deviation_pow++;
	}
	/*###############################################################################################################################*/

	/*const size_t id_pla_min_point = segment_evaluation.min_point.id - id_segment_left;
	const size_t id_pla_max_point = segment_evaluation.max_point.id - id_segment_left;
	const long double value_pla_min_point = id_pla_min_point * segment_evaluation.apla.a + segment_evaluation.apla.b;
	const long double value_pla_max_point = id_pla_max_point * segment_evaluation.apla.a + segment_evaluation.apla.b;
	const long double value_pla_right_endpoint = (segment_evaluation.rectangle_width - 1) * segment_evaluation.apla.a + segment_evaluation.apla.b;
	min_point_difference = segment_evaluation.min_point.value - value_pla_min_point;
	max_point_difference = segment_evaluation.max_point.value - value_pla_max_point;
	left_end_point_difference = original_time_series_vector[id_segment_left] - segment_evaluation.apla.b;
	right_end_point_difference = original_time_series_vector[segment_evaluation.right_endpoint] - value_pla_right_endpoint;*/

	int already_know_id = 4;
	if (temp_coefficient.rectangle_width > 4) {

		if (id_segment_left == temp_coefficient.min_point.id) {
			left_end_point_difference = 0;
			left_end_point_difference_pow = 0;
			//right_end_point_difference = 0;
			already_know_id -= 1;
		}
		if (id_segment_left == temp_coefficient.max_point.id) {
			left_end_point_difference = 0;
			left_end_point_difference_pow = 0;
			//right_end_point_difference = 0;
			already_know_id -= 1;
		}
		if (temp_coefficient.right_endpoint == temp_coefficient.min_point.id) {
			//left_end_point_difference = 0;
			right_end_point_difference = 0;
			right_end_point_difference_pow = 0;
			already_know_id -= 1;
		}
		if (temp_coefficient.right_endpoint == temp_coefficient.max_point.id) {
			//left_end_point_difference = 0;
			right_end_point_difference = 0;
			right_end_point_difference_pow = 0;
			already_know_id -= 1;
		}

		const float difference_sum_four_points = min_point_difference + max_point_difference + left_end_point_difference + right_end_point_difference;
		assert(already_know_id > 0);
		const long double sum_point_difference_pow = min_point_difference_pow + max_point_difference_pow + left_end_point_difference_pow + right_end_point_difference_pow;

		const size_t rest_point_number = temp_coefficient.rectangle_width - already_know_id;
		const long double rest_difference_pow = pow(difference_sum_four_points / rest_point_number, 2.0);
		const float rest_difference_pow_sum = rest_difference_pow * rest_point_number;

		assert(rest_point_number > 0);

		const long double lower_bound = sqrt(min_point_difference_pow + max_point_difference_pow + left_end_point_difference_pow + right_end_point_difference_pow + rest_difference_pow_sum);
		//const long double lower_bound = sqrt(sum_point_difference_pow );

		assert(lower_bound <= sum_deviation || fabs(lower_bound - sum_deviation) < MIN_D);
	}
	else {
		input_argument.number_point_max_deviation_true++;
		return true;
	}

	if (max_deviation == fabs(min_point_difference) || max_deviation == fabs(max_point_difference) || max_deviation == fabs(left_end_point_difference) || max_deviation == fabs(right_end_point_difference)) {
		input_argument.number_point_max_deviation_true++;

		return true;
	}
	else {
		//cout << "Not match max deviation!!\n";
		//assert(0);
		input_argument.number_point_max_deviation_false++;
		return true;
	}

	return false;
}

//201023 evaluate upper & lower bound: max devation * l > sum deviation > lower bound deviation
//***************************************************************
// Method:evaluate_upper_lower_bound
// Qualifier: All Evaluate upper & lower bound: max devation * l > sum deviation > lower bound deviation
// Input: 1 time series. 2 right endpoint, width of segment.
// Output: 
// date:200223
// author:
//***************************************************************
TEMPLATE
template<typename T, typename Y, typename U>
bool APLA::evaluate_upper_lower_bound(U& const input_argument, const vector<T>& const original_time_series_vector, const DoublyLinkedList<Y>& const doubly_linked_list) {
	assert(0);
	for (auto au : doubly_linked_list) {
		evaluate_segment_upper_lower_bound(input_argument, original_time_series_vector, au);
	}
	return true;
}

/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&                   Compute intersection point of                         &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
//************************************
// Method:getIntersectionPoint
// Qualifier:intersection of two lines
// date:190527
// author:
//************************************
TEMPLATE
inline typename GEOMETRY::POINT& APLA::getIntersectionPoint(const AREA_COEFFICIENT& const temp_coefficient1, const AREA_COEFFICIENT& const temp_coefficient2, typename GEOMETRY::POINT& const intersection_point) {
	intersection_point.id = (temp_coefficient1.apla.b - temp_coefficient2.apla.b) / (temp_coefficient2.apla.a - temp_coefficient1.apla.a);
	intersection_point.value = temp_coefficient1.apla.a * intersection_point.id + temp_coefficient1.apla.b;
	return intersection_point;
}

//************************************
// Method:getIntersectionPoint
// Qualifier:intersection of two lines
// date:190528
// author:
//************************************
TEMPLATE
inline typename GEOMETRY::POINT& APLA::getIntersectionPoint(const APLA_COEFFICIENT& const apla1, const APLA_COEFFICIENT& const apla2, typename GEOMETRY::POINT& const intersection_point) {//190528
	intersection_point.id = (apla1.b - apla2.b) / (apla2.a - apla1.a);
	intersection_point.value = apla1.a * intersection_point.id + apla1.b;
	return intersection_point;
}

//************************************
// Method:getIntersectionPoint
// Qualifier:intersection of two lines
// date:190528
// author:
//************************************
TEMPLATE
inline typename GEOMETRY::POINT& APLA::getIntersectionPoint(const double& const a1, const double& const b1, const double& const a2, const double& const b2, typename GEOMETRY::POINT& const intersection_point) {//190528
	intersection_point.id = (b1 - b2) / (a2 - a1);
	intersection_point.value = a1 * intersection_point.id + b1;
	return intersection_point;
}

//************************************
// Method:segmentsIntr
// Qualifier:intersection of two lines
// date:190528
// author:
//************************************
TEMPLATE
inline typename GEOMETRY::POINT& APLA::segmentsIntr(typename  GEOMETRY::POINT& const point1, typename  GEOMETRY::POINT& const point2, typename  GEOMETRY::POINT& const point3, typename GEOMETRY::POINT& const point4, typename GEOMETRY::POINT& const intersection_point) {//190528
	/** 1 , . **/
// 0 , 
	double denominator = (point2.value - point1.value) * (point4.id - point3.id) - (point1.id - point2.id) * (point3.value - point4.value);
	if (denominator == 0) {
		//cout << "denominator: " << denominator << endl;
		intersection_point.id = INF;
		intersection_point.value = INF;
		return intersection_point;
	}

	//  (x , y)
	double x = ((point2.id - point1.id) * (point4.id - point3.id) * (point3.value - point1.value)
		+ (point2.value - point1.value) * (point4.id - point3.id) * point1.id
		- (point4.value - point3.value) * (point2.id - point1.id) * point3.id) / denominator;
	double y = -((point2.value - point1.value) * (point4.value - point3.value) * (point3.id - point1.id)
		+ (point2.id - point1.id) * (point4.value - point3.value) * point1.value
		- (point4.id - point3.id) * (point2.value - point1.value) * point3.value) / denominator;
	intersection_point.id = x;
	intersection_point.value = y;
	/** 2  **/
	if (
		// 1
		(x - point1.id) * (x - point2.id) <= 0 && (y - point1.value) * (y - point2.value) <= 0
		// 2
		&& (x - point3.id) * (x - point4.id) <= 0 && (y - point3.value) * (y - point4.value) <= 0
		) {
		// p
		return intersection_point;
	}
	intersection_point.id = INF;
	intersection_point.value = INF;
	//
	return intersection_point;
}

//************************************
// Method:segmentsIntrArea
// Qualifier:intersection of two lines
// Link:
// Notice: compute intersection point between line segment (point1, point2) and (point3, point4).
// date:190528
// author:
//************************************
TEMPLATE
inline typename GEOMETRY::POINT& APLA::segmentsIntrArea(typename  GEOMETRY::POINT& const point1, typename  GEOMETRY::POINT& const point2, typename  GEOMETRY::POINT& const point3, typename GEOMETRY::POINT& const point4, typename GEOMETRY::POINT& const intersection_point) {//190528
	// triangle abc 2
	long double area_abc = (point1.id - point3.id) * (point2.value - point3.value) - (point1.value - point3.value) * (point2.id - point3.id);

	// triangle abd 2
	long double area_abd = (point1.id - point4.id) * (point2.value - point4.value) - (point1.value - point4.value) * (point2.id - point4.id);

	// No intersection point
	if (area_abc * area_abd > 0) {//false
		intersection_point.id = INF;
		intersection_point.value = INF;
		return intersection_point;
	}

	// triangle cda 2
	long double area_cda = (point3.id - point1.id) * (point4.value - point1.value) - (point3.value - point1.value) * (point4.id - point1.id);
	// triangle cdb 2
	// : .,.
	long double area_cdb = area_cda + area_abc - area_abd;

	// No intersection point
	if (area_cda * area_cdb >= 0) {//false
		intersection_point.id = INF;
		intersection_point.value = INF;
		return intersection_point;
	}

	//Has intersection point
	long double t = area_cda / (area_abd - area_abc);
	long double dx = t * (point2.id - point1.id);
	long double dy = t * (point2.value - point1.value);

	intersection_point.id = point1.id + dx;
	intersection_point.value = point1.value + dy;

#ifdef _DEBUG
	assert(intersection_point.id > 0);
#endif

	return intersection_point;
}


//210509
//************************************
// Method:segmentsIntrArea
// Qualifier:intersection of two lines
// Link: 
// Notice: compute intersection point between line segment (point1, point2) and (point3, point4).
// date:210509
// author:
//************************************
TEMPLATE
template<typename T>
inline void APLA::segmentsIntrArea_pub(const T& const point1, const T& const point2, const T& const point3, const T& const point4, T& const intersection_point) {

	long double area_abc = (point1.id - point3.id) * (point2.value - point3.value) - (point1.value - point3.value) * (point2.id - point3.id);

	long double area_abd = (point1.id - point4.id) * (point2.value - point4.value) - (point1.value - point4.value) * (point2.id - point4.id);

	if (area_abc * area_abd > 0) {//false
		intersection_point.id = INF;
		intersection_point.value = INF;
		return intersection_point;
	}

	long double area_cda = (point3.id - point1.id) * (point4.value - point1.value) - (point3.value - point1.value) * (point4.id - point1.id);

	long double area_cdb = area_cda + area_abc - area_abd;
	if (area_cda * area_cdb >= 0) {
		intersection_point.id = INF;
		intersection_point.value = INF;
		return intersection_point;
	}

	long double t = area_cda / (area_abd - area_abc);
	long double dx = t * (point2.id - point1.id);
	long double dy = t * (point2.value - point1.value);

	intersection_point.id = point1.id + dx;
	intersection_point.value = point1.value + dy;

}

//************************************
// Method:getLineSegmentIntersectionPoint
// Qualifier:intersection of two lines
// date:190528
// author:
//************************************
TEMPLATE
inline typename GEOMETRY::POINT& APLA::getLineSegmentIntersectionPoint(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient, typename GEOMETRY::POINT& const intersection_point1, typename GEOMETRY::POINT& const intersection_point2) {//190528
	typename GEOMETRY::POINT intersection_pointA1;
	typename GEOMETRY::POINT intersection_pointB1;
	typename GEOMETRY::POINT intersection_pointA2;
	typename GEOMETRY::POINT intersection_pointB2;
	typename GEOMETRY::POINT intersection_pointA3;
	typename GEOMETRY::POINT intersection_pointB3;
	/*-------------------------------------------*/
	typename GEOMETRY::POINT point_A1;//Line A1A2
	typename GEOMETRY::POINT point_A2;
	typename GEOMETRY::POINT point_B1;//Line B1B2
	typename GEOMETRY::POINT point_B2;

	typename GEOMETRY::POINT point_A3;//Line A3A4
	typename GEOMETRY::POINT point_A4;
	typename GEOMETRY::POINT point_B3;//Line B3B4
	typename GEOMETRY::POINT point_B4;

	double b_temp = area_vector[vector_id - 1].rectangle_width * temp_coefficient.apla.a + temp_coefficient.apla.b;

	point_A1.id = 0;
	point_A1.value = area_vector[vector_id - 1].apla.b;
	point_A2.id = area_vector[vector_id - 1].rectangle_width - 1;
	point_A2.value = point_A2.id * area_vector[vector_id - 1].apla.a + area_vector[vector_id - 1].apla.b;

	point_B1.id = 0;
	point_B1.value = temp_coefficient.apla.b;
	point_B2.id = area_vector[vector_id - 1].rectangle_width - 1;
	point_B2.value = point_B2.id * temp_coefficient.apla.a + temp_coefficient.apla.b;

	point_A3.id = 0;
	point_A3.value = area_vector[vector_id].apla.b;
	point_A4.id = area_vector[vector_id].rectangle_width - 1;
	point_A4.value = point_A4.id * area_vector[vector_id].apla.a + area_vector[vector_id].apla.b;

	point_B3.id = 0;
	point_B3.value = b_temp;
	point_B4.id = area_vector[vector_id].rectangle_width - 1;
	point_B4.value = point_B4.id * temp_coefficient.apla.a + b_temp;
#ifdef _DEBUG
	/*=========================================================================================================================================*/
	/*===================================Intersection Point1===================================================*/
	getIntersectionPoint(area_vector[vector_id - 1], temp_coefficient, intersection_pointA1);
	//cout << "intersection point1: " << intersection_pointA1.id << " " << intersection_pointA1.value << endl;

	//cout << b_temp << endl;
	getIntersectionPoint(area_vector[vector_id].apla.a, area_vector[vector_id].apla.b, temp_coefficient.apla.a, b_temp, intersection_pointB1);
	//cout << "intersection point2: " << intersection_point.id+ area_vector[vector_id - 1].rectangle_width << " " << intersection_point.value << endl;
	//cout << "intersection point2: " << intersection_pointB1.id << " " << intersection_pointB1.value << endl;
	/*.........................................................................................................*/
	/*===================================Intersection Point2===================================================*/
	intersection_pointA2.id = INF;
	intersection_pointA2.value = INF;
	segmentsIntr(point_A1, point_A2, point_B1, point_B2, intersection_pointA2);
	//cout << "intersection point11: " << intersection_pointA2.id << " " << intersection_pointA2.value << endl;

	intersection_pointB2.id = INF;
	intersection_pointB2.value = INF;
	segmentsIntr(point_A3, point_A4, point_B3, point_B4, intersection_pointB2);
	//cout << "intersection point12: " << intersection_pointB2.id << " " << intersection_pointB2.value << endl;
	/*.........................................................................................................*/
	/*...........................................................................................................................................*/
#endif
	/*===================================Intersection Point3===================================================*/
	intersection_pointA3.id = INF;
	intersection_pointA3.value = INF;
	segmentsIntrArea(point_A1, point_A2, point_B1, point_B2, intersection_pointA3);
	//cout << "intersection point13: " << intersection_pointA3.id << " " << intersection_pointA3.value << endl;

	intersection_pointB3.id = INF;
	intersection_pointB3.value = INF;
	segmentsIntrArea(point_A3, point_A4, point_B3, point_B4, intersection_pointB3);
	//cout << "intersection point14: " << intersection_pointB3.id << " " << intersection_pointB3.value << endl;
	/*..........................................................................................................*/

	/*===========================================Evaluation=======================================================*/
	/*if(intersection_pointA1.id < area_vector[vector_id - 1].rectangle_width-1 && intersection_pointA1.id >= 0 ){
		assert(fabs(intersection_pointA1.id - intersection_pointA2.id) < 0.00001 && fabs(intersection_pointA2.id - intersection_pointA3.id)<0.00001);
	}
	else {
		assert(intersection_pointA2.id == INF && intersection_pointA3.id == INF);
	}

	if (intersection_pointB1.id < area_vector[vector_id].rectangle_width-1 && intersection_pointB1.id >= 0) {
		if(!(fabs(intersection_pointB1.id - intersection_pointB2.id) < 0.00001 && fabs(intersection_pointB2.id - intersection_pointB3.id)<0.00001)){
			printSpecialPoint1(original_time_series, area_vector, vector_id, temp_coefficient);
			assert(0);
		}
	}
	else {
		assert(intersection_pointB2.id == INF && intersection_pointB3.id == INF);
	}*/
	/*..................................................................................................................*/

	intersection_point1 = intersection_pointA3;
	intersection_point2 = intersection_pointB3;
#ifdef _DEBUG
	assert(intersection_pointB3.id > 0);
#endif

	return intersection_point1;
}

//210509
TEMPLATE
template<typename T>
inline long double APLA::get_abs_area_triangle(const T& const point1, const T& const point2, const T& const point3) {
#ifdef _DEBUG
	assert(point1.id != INF && point3.id != INF && point2.value != INF && point3.value != INF && point1.value != INF && point3.value != INF && point2.id != INF && point3.id != INF);
#endif
	return fabs(((point1.id - point3.id) * (point2.value - point3.value) - (point1.value - point3.value) * (point2.id - point3.id)) * 0.5);
}

//************************************
// Method:getLineSegmentIntersectionPoint
// Qualifier:intersection of two lines
// date:190528
// author:
//************************************
TEMPLATE
double APLA::getLineSegmentTriangleArea(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient) {//190528
	int left_id = vector_id - 1;
	/*===================================Segment Point=====================================================*/
	typename GEOMETRY::POINT point_A1;//Line A1A2
	typename GEOMETRY::POINT point_A2;
	typename GEOMETRY::POINT point_B1;//Line B1B2
	typename GEOMETRY::POINT point_B2;

	typename GEOMETRY::POINT point_A3;//Line A3A4
	typename GEOMETRY::POINT point_A4;
	typename GEOMETRY::POINT point_B3;//Line B3B4
	typename GEOMETRY::POINT point_B4;

	double b_temp = area_vector[left_id].rectangle_width * temp_coefficient.apla.a + temp_coefficient.apla.b;

	point_A1.id = 0;
	point_A1.value = area_vector[left_id].apla.b;
	point_A2.id = area_vector[left_id].rectangle_width - 1;
	point_A2.value = point_A2.id * area_vector[left_id].apla.a + area_vector[left_id].apla.b;

	point_B1.id = 0;
	point_B1.value = temp_coefficient.apla.b;
	point_B2.id = area_vector[left_id].rectangle_width - 1;
	point_B2.value = point_B2.id * temp_coefficient.apla.a + temp_coefficient.apla.b;

	point_A3.id = 0;
	point_A3.value = area_vector[vector_id].apla.b;
	point_A4.id = area_vector[vector_id].rectangle_width - 1;
	point_A4.value = point_A4.id * area_vector[vector_id].apla.a + area_vector[vector_id].apla.b;

	point_B3.id = 0;
	point_B3.value = b_temp;
	point_B4.id = area_vector[vector_id].rectangle_width - 1;
	point_B4.value = point_B4.id * temp_coefficient.apla.a + b_temp;
	double temp_right_endpoint_value = (temp_coefficient.rectangle_width - 1) * temp_coefficient.apla.a + temp_coefficient.apla.b;
#ifdef _DEBUG
	assert(fabs(point_B4.value - temp_right_endpoint_value) < 0.00001);
#endif
	/*...........................................................................................*/

	/*=============================Width or height of triangle & trapezoid==================================*/
	double ll_width = fabs(point_A1.value - point_B1.value);
	double lr_width = fabs(point_A2.value - point_B2.value);
	double rl_width = fabs(point_A3.value - point_B3.value);
	double rr_width = fabs(point_A4.value - point_B4.value);
	/*......................................................................................................*/

	/*=====================================intersection_point ===========================================================*/
	typename GEOMETRY::POINT intersection_point1;
	typename GEOMETRY::POINT intersection_point2;
	intersection_point1.id = INF;
	intersection_point1.value = INF;
	intersection_point2.id = INF;
	intersection_point2.value = INF;
	//getLineSegmentIntersectionPoint(original_time_series, area_vector, vector_id, temp_coefficient, intersection_point1, intersection_point2);
	segmentsIntrArea(point_A1, point_A2, point_B1, point_B2, intersection_point1);
	//cout << "intersection point13: " << intersection_pointA3.id << " " << intersection_pointA3.value << endl;
	segmentsIntrArea(point_A3, point_A4, point_B3, point_B4, intersection_point2);
	//cout << "intersection point14: " << intersection_pointB3.id << " " << intersection_pointB3.value << endl;
	/*--------------------------------------------------------------*/
	//getIntersectionPoint(area_vector[vector_id - 1], temp_coefficient, intersection_point1);
	//getIntersectionPoint(area_vector[vector_id].apla.a, area_vector[vector_id].apla.b, temp_coefficient.apla.a, b_temp, intersection_point2);
	//segmentsIntr(point_A1, point_A2, point_B1, point_B2, intersection_point1);
	//segmentsIntr(point_A3, point_A4, point_B3, point_B4, intersection_point2);

	/*....................................................................................................................*/

	double ll_height = intersection_point1.id;
	double lr_height = point_A2.id - intersection_point1.id;
	double rl_height = intersection_point2.id;
	double rr_height = point_A4.id - intersection_point2.id;

	temp_coefficient.increment_area = NULL;

	//cout << "Before: " << increment_area << endl;
	/*-----------------------------------------------------------------------------------------*/
	if (intersection_point1.id != INF && intersection_point1.value != INF) {
		temp_coefficient.increment_area = ll_width * ll_height + lr_width * lr_height;
	}
	else {
		temp_coefficient.increment_area = (ll_width + lr_width) * area_vector[left_id].rectangle_width;
	}

	if (intersection_point2.id != INF && intersection_point2.value != INF) {
		temp_coefficient.increment_area += rl_width * rl_height + rr_width * rr_height;
	}
	else {
		temp_coefficient.increment_area += (rl_width + rr_width) * area_vector[vector_id].rectangle_width;
	}

	/*............................................................................................*/
	/*if (area_vector[left_id].apla.b > temp_coefficient.apla.b) {
		if (intersection_point1.id != INF && intersection_point1.value != INF) {
			temp_coefficient.increment_area = ll_width * ll_height;
		}
		else {
			temp_coefficient.increment_area = (ll_width + lr_width) *area_vector[left_id].rectangle_width;
		}
	}*/
	//cout<<"After: "<<increment_area << endl;
	/*================================Evaluation increment_area>0======================================================*/
	/*if(!(increment_area > 0)){
		printSpecialPoint1(original_time_series, area_vector, vector_id, temp_coefficient);
		cout << double(increment_area) << endl;
		assert(0);
	}*/
	/*........................................................................................*/
	return temp_coefficient.increment_area;
}

//************************************
// Method:getLineSegmentTriangleAreaImprove
// Qualifier:intersection of two lines
// date:190604  FAIL
// author:
//************************************
TEMPLATE
double APLA::getLineSegmentTriangleAreaImprove(DataType*& const original_time_series, vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient) {//190604
	int left_id = vector_id - 1;
	/*===================================Segment Point=====================================================*/
	typename GEOMETRY::POINT point_A1;//Line A1A2
	typename GEOMETRY::POINT point_A2;
	typename GEOMETRY::POINT point_B1;//Line B1B2
	typename GEOMETRY::POINT point_B2;

	typename GEOMETRY::POINT point_A3;//Line A3A4
	typename GEOMETRY::POINT point_A4;
	typename GEOMETRY::POINT point_B3;//Line B3B4
	typename GEOMETRY::POINT point_B4;

	double b_temp = area_vector[left_id].rectangle_width * temp_coefficient.apla.a + temp_coefficient.apla.b;

	point_A1.id = 0;
	point_A1.value = area_vector[left_id].apla.b;
	point_A2.id = area_vector[left_id].rectangle_width - 1;
	point_A2.value = point_A2.id * area_vector[left_id].apla.a + area_vector[left_id].apla.b;

	point_B1.id = 0;
	point_B1.value = temp_coefficient.apla.b;
	point_B2.id = area_vector[left_id].rectangle_width - 1;
	point_B2.value = point_B2.id * temp_coefficient.apla.a + temp_coefficient.apla.b;

	point_A3.id = 0;
	point_A3.value = area_vector[vector_id].apla.b;
	point_A4.id = area_vector[vector_id].rectangle_width - 1;
	point_A4.value = point_A4.id * area_vector[vector_id].apla.a + area_vector[vector_id].apla.b;

	point_B3.id = 0;
	point_B3.value = b_temp;
	point_B4.id = area_vector[vector_id].rectangle_width - 1;
	point_B4.value = point_B4.id * temp_coefficient.apla.a + b_temp;
	double temp_right_endpoint_value = (temp_coefficient.rectangle_width - 1) * temp_coefficient.apla.a + temp_coefficient.apla.b;
#ifdef _DEBUG
	assert(fabs(point_B4.value - temp_right_endpoint_value) < 0.00001);
#endif
	/*...........................................................................................*/

	/*=============================Width or height of triangle & trapezoid==================================*/
	double ll_width = fabs(point_A1.value - point_B1.value);
	double lr_width = fabs(point_A2.value - point_B2.value);
	double rl_width = fabs(point_A3.value - point_B3.value);
	double rr_width = fabs(point_A4.value - point_B4.value);
	/*......................................................................................................*/

	/*=====================================intersection_point ===========================================================*/
	typename GEOMETRY::POINT intersection_point1;
	typename GEOMETRY::POINT intersection_point2;
	intersection_point1.id = INF;
	intersection_point1.value = INF;
	intersection_point2.id = INF;
	intersection_point2.value = INF;
	//getLineSegmentIntersectionPoint(original_time_series, area_vector, vector_id, temp_coefficient, intersection_point1, intersection_point2);
	segmentsIntrArea(point_A1, point_A2, point_B1, point_B2, intersection_point1);
	//cout << "intersection point13: " << intersection_pointA3.id << " " << intersection_pointA3.value << endl;
	segmentsIntrArea(point_A3, point_A4, point_B3, point_B4, intersection_point2);
	//cout << "intersection point14: " << intersection_pointB3.id << " " << intersection_pointB3.value << endl;
	/*....................................................................................................................*/

	double ll_height = intersection_point1.id;
	double lr_height = point_A2.id - intersection_point1.id;
	double rl_height = intersection_point2.id;
	double rr_height = point_A4.id - intersection_point2.id;

	temp_coefficient.increment_area = NULL;

	//cout << "Before: " << increment_area << endl;
	/*-----------------------------------------------------------------------------------------*/
	if (intersection_point1.id != INF && intersection_point1.value != INF) {
		temp_coefficient.increment_area = ll_width * ll_height + lr_width * lr_height;
	}
	else {
		temp_coefficient.increment_area = (ll_width + lr_width) * area_vector[left_id].rectangle_width;
	}

	if (intersection_point2.id != INF && intersection_point2.value != INF) {
		temp_coefficient.increment_area += rl_width * rl_height + rr_width * rr_height;
	}
	else {
		temp_coefficient.increment_area += (rl_width + rr_width) * area_vector[vector_id].rectangle_width;
	}
	/*............................................................................................*/
	if (area_vector[left_id].apla.b >= temp_coefficient.apla.b) {
		if (intersection_point1.id != INF && intersection_point1.value != INF) {
			temp_coefficient.increment_area = ll_width * ll_height;
			temp_coefficient.increment_area = (area_vector[left_id].apla.b - temp_coefficient.apla.b) * intersection_point1.id;
		}
		else {
			typename GEOMETRY::POINT point_A2;
			typename GEOMETRY::POINT point_B2;
			point_A2.id = area_vector[left_id].rectangle_width - 1;
			point_A2.value = point_A2.id * area_vector[left_id].apla.a + area_vector[left_id].apla.b;
			point_B2.id = area_vector[left_id].rectangle_width - 1;
			point_B2.value = point_B2.id * temp_coefficient.apla.a + temp_coefficient.apla.b;
			double lr_width = point_B2.value - point_A2.value;
			temp_coefficient.increment_area = (ll_width + lr_width) * area_vector[left_id].rectangle_width;
			temp_coefficient.increment_area = (area_vector[left_id].apla.b - temp_coefficient.apla.b + lr_width) * area_vector[left_id].rectangle_width;
		}

		if (area_vector[vector_id].apla.b >= b_temp) {
			if (intersection_point2.id != INF && intersection_point2.value != INF) {
				temp_coefficient.increment_area += rl_width * rl_height;
				temp_coefficient.increment_area += (b_temp - area_vector[vector_id].apla.b) * intersection_point2.id;
			}
			else {
				typename GEOMETRY::POINT point_A4;
				typename GEOMETRY::POINT point_B4;
				point_A4.id = area_vector[vector_id].rectangle_width - 1;
				point_A4.value = point_A4.id * area_vector[vector_id].apla.a + area_vector[vector_id].apla.b;
				point_B4.id = area_vector[vector_id].rectangle_width - 1;
				point_B4.value = point_B4.id * temp_coefficient.apla.a + b_temp;
				double rr_width = point_B4.value - point_A4.value;
				temp_coefficient.increment_area += (rl_width + rr_width) * area_vector[vector_id].rectangle_width;
				temp_coefficient.increment_area += (area_vector[vector_id].apla.b - b_temp + rr_width) * area_vector[vector_id].rectangle_width;
			}
		}
		else {
			if (intersection_point2.id != INF && intersection_point2.value != INF) {
				typename GEOMETRY::POINT point_A4;
				typename GEOMETRY::POINT point_B4;
				point_A4.id = area_vector[vector_id].rectangle_width - 1;
				point_A4.value = point_A4.id * area_vector[vector_id].apla.a + area_vector[vector_id].apla.b;
				point_B4.id = area_vector[vector_id].rectangle_width - 1;
				point_B4.value = point_B4.id * temp_coefficient.apla.a + b_temp;
				double rr_width = point_A4.value - point_B4.value;
				temp_coefficient.increment_area += rr_width * rr_height;
				temp_coefficient.increment_area += (b_temp - area_vector[vector_id].apla.b) * intersection_point2.id;
			}
			else {
				typename GEOMETRY::POINT point_A4;
				typename GEOMETRY::POINT point_B4;
				point_A4.id = area_vector[vector_id].rectangle_width - 1;
				point_A4.value = point_A4.id * area_vector[vector_id].apla.a + area_vector[vector_id].apla.b;
				point_B4.id = area_vector[vector_id].rectangle_width - 1;
				point_B4.value = point_B4.id * temp_coefficient.apla.a + b_temp;
				double rr_width = point_A4.value - point_B4.value;
				temp_coefficient.increment_area += (rl_width + rr_width) * area_vector[vector_id].rectangle_width;
				temp_coefficient.increment_area += (b_temp - area_vector[vector_id].apla.b + rr_width) * area_vector[vector_id].rectangle_width;
			}
		}
	}
	else {
		if (intersection_point1.id != INF && intersection_point1.value != INF) {
			temp_coefficient.increment_area = ll_width * ll_height;
			temp_coefficient.increment_area = (temp_coefficient.apla.b - area_vector[left_id].apla.b) * intersection_point1.id;
		}
		else {
			typename GEOMETRY::POINT point_A2;
			typename GEOMETRY::POINT point_B2;
			point_A2.id = area_vector[left_id].rectangle_width - 1;
			point_A2.value = point_A2.id * area_vector[left_id].apla.a + area_vector[left_id].apla.b;
			point_B2.id = area_vector[left_id].rectangle_width - 1;
			point_B2.value = point_B2.id * temp_coefficient.apla.a + temp_coefficient.apla.b;
			double lr_width = point_A2.value - point_B2.value;
			temp_coefficient.increment_area = (ll_width + lr_width) * area_vector[left_id].rectangle_width;
			temp_coefficient.increment_area = (temp_coefficient.apla.b - area_vector[left_id].apla.b + lr_width) * area_vector[left_id].rectangle_width;
		}

		if (area_vector[vector_id].apla.b >= b_temp) {
			if (intersection_point2.id != INF && intersection_point2.value != INF) {
				temp_coefficient.increment_area += rl_width * rl_height;
				temp_coefficient.increment_area += (area_vector[vector_id].apla.b - b_temp) * intersection_point2.id;
			}
			else {
				typename GEOMETRY::POINT point_A4;
				typename GEOMETRY::POINT point_B4;
				point_A4.id = area_vector[vector_id].rectangle_width - 1;
				point_A4.value = point_A4.id * area_vector[vector_id].apla.a + area_vector[vector_id].apla.b;
				point_B4.id = area_vector[vector_id].rectangle_width - 1;
				point_B4.value = point_B4.id * temp_coefficient.apla.a + b_temp;
				double rr_width = point_A4.value - point_B4.value;
				temp_coefficient.increment_area += (rl_width + rr_width) * area_vector[vector_id].rectangle_width;
				temp_coefficient.increment_area += (area_vector[vector_id].apla.b - b_temp + rr_width) * area_vector[vector_id].rectangle_width;
			}
		}
		else {
			if (intersection_point2.id != INF && intersection_point2.value != INF) {
				typename GEOMETRY::POINT point_A4;
				typename GEOMETRY::POINT point_B4;
				point_A4.id = area_vector[vector_id].rectangle_width - 1;
				point_A4.value = point_A4.id * area_vector[vector_id].apla.a + area_vector[vector_id].apla.b;
				point_B4.id = area_vector[vector_id].rectangle_width - 1;
				point_B4.value = point_B4.id * temp_coefficient.apla.a + b_temp;
				double rr_width = point_A4.value - point_B4.value;
				temp_coefficient.increment_area += rr_width * rr_height;
				temp_coefficient.increment_area += (b_temp - area_vector[vector_id].apla.b) * intersection_point2.id;
			}
			else {
				typename GEOMETRY::POINT point_A4;
				typename GEOMETRY::POINT point_B4;
				point_A4.id = area_vector[vector_id].rectangle_width - 1;
				point_A4.value = point_A4.id * area_vector[vector_id].apla.a + area_vector[vector_id].apla.b;
				point_B4.id = area_vector[vector_id].rectangle_width - 1;
				point_B4.value = point_B4.id * temp_coefficient.apla.a + b_temp;
				double rr_width = point_A4.value - point_B4.value;
				temp_coefficient.increment_area += (rl_width + rr_width) * area_vector[vector_id].rectangle_width;
				temp_coefficient.increment_area += (area_vector[vector_id].apla.b - b_temp + rr_width) * area_vector[vector_id].rectangle_width;
			}
		}
	}
	//cout<<"After: "<<increment_area << endl;
	/*================================Evaluation increment_area>0======================================================*/
	/*if(!(increment_area > 0)){
		printSpecialPoint1(original_time_series, area_vector, vector_id, temp_coefficient);
		cout << double(increment_area) << endl;
		assert(0);
	}*/
	/*........................................................................................*/
	return temp_coefficient.increment_area;
}
//************************************
// Method:getLineSegmentTriangleDensity
// Qualifier:intersection of two lines
// date:190528
// author:
//************************************
TEMPLATE
inline double APLA::getLineSegmentTriangleDensity(AREA_COEFFICIENT& const temp_coefficient) {//190602
#if _DEBUG
	assert(temp_coefficient.increment_area != INF && temp_coefficient.rectangle_width != INF);
#endif

	if (temp_coefficient.increment_area == 0) {
		return temp_coefficient.segment_density = INF;
	}
	return temp_coefficient.segment_density = temp_coefficient.rectangle_width / temp_coefficient.increment_area;
}

//************************************
// Method:getLineSegmentTriangleAreaDensity
// Qualifier:get area and density of triangle.
// Input: left & right & temp segment apla coefficient, a&b, width,
// Output: Segment Triangle Area Density
// date:190611
// author:
//************************************
TEMPLATE
double APLA::getLineSegmentTriangleAreaDensity(vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient) {//190611
	int left_id = vector_id - 1;
	assert(0);
#ifdef _DEBUG
	assert(left_id > -1);
	assert(area_vector[left_id].rectangle_width != INF && area_vector[vector_id].rectangle_width != INF && temp_coefficient.rectangle_width != INF && area_vector[left_id].right_endpoint != INF && area_vector[vector_id].right_endpoint != INF && temp_coefficient.right_endpoint != INF);
	assert(area_vector[left_id].apla.a != INF && area_vector[vector_id].apla.a != INF && temp_coefficient.apla.a != INF && area_vector[left_id].apla.b != INF && area_vector[vector_id].apla.b != INF && temp_coefficient.apla.b != INF);
	assert(area_vector[left_id].apla.a_minuend != INF && area_vector[vector_id].apla.a_minuend != INF && temp_coefficient.apla.a_minuend != INF && area_vector[left_id].apla.b_minuend != INF && area_vector[vector_id].apla.b_minuend != INF && temp_coefficient.apla.b_minuend != INF);
#endif

	/*===================================Segment Point=====================================================*/
	typename GEOMETRY::POINT point_A1;//Line A1A2
	typename GEOMETRY::POINT point_A2;
	typename GEOMETRY::POINT point_B1;//Line B1B2
	typename GEOMETRY::POINT point_B2;

	typename GEOMETRY::POINT point_A3;//Line A3A4
	typename GEOMETRY::POINT point_A4;
	typename GEOMETRY::POINT point_B3;//Line B3B4
	typename GEOMETRY::POINT point_B4;

	double b_temp = area_vector[left_id].rectangle_width * temp_coefficient.apla.a + temp_coefficient.apla.b;

	point_A1.id = 0;
	point_A1.value = area_vector[left_id].apla.b;
	point_A2.id = area_vector[left_id].rectangle_width - 1;
	point_A2.value = point_A2.id * area_vector[left_id].apla.a + area_vector[left_id].apla.b;

	point_B1.id = 0;
	point_B1.value = temp_coefficient.apla.b;
	point_B2.id = area_vector[left_id].rectangle_width - 1;
	point_B2.value = point_B2.id * temp_coefficient.apla.a + temp_coefficient.apla.b;

	point_A3.id = 0;
	point_A3.value = area_vector[vector_id].apla.b;
	point_A4.id = area_vector[vector_id].rectangle_width - 1;
	point_A4.value = point_A4.id * area_vector[vector_id].apla.a + area_vector[vector_id].apla.b;

	point_B3.id = 0;
	point_B3.value = b_temp;
	point_B4.id = area_vector[vector_id].rectangle_width - 1;
	point_B4.value = point_B4.id * temp_coefficient.apla.a + b_temp;
	double temp_right_endpoint_value = (temp_coefficient.rectangle_width - 1) * temp_coefficient.apla.a + temp_coefficient.apla.b;
#ifdef _DEBUG
	assert(fabs(point_B4.value - temp_right_endpoint_value) < 0.00001);
#endif
	/*...........................................................................................*/

	/*=============================Width or height of triangle & trapezoid==================================*/
	double ll_width = fabs(point_A1.value - point_B1.value);
	double lr_width = fabs(point_A2.value - point_B2.value);
	double rl_width = fabs(point_A3.value - point_B3.value);
	double rr_width = fabs(point_A4.value - point_B4.value);
	/*......................................................................................................*/

	/*=====================================intersection_point ===========================================================*/
	typename GEOMETRY::POINT intersection_point1;
	typename GEOMETRY::POINT intersection_point2;
	intersection_point1.id = INF;
	intersection_point1.value = INF;
	intersection_point2.id = INF;
	intersection_point2.value = INF;
	//getLineSegmentIntersectionPoint(original_time_series, area_vector, vector_id, temp_coefficient, intersection_point1, intersection_point2);
	segmentsIntrArea(point_A1, point_A2, point_B1, point_B2, intersection_point1);
	//cout << "intersection point13: " << intersection_pointA3.id << " " << intersection_pointA3.value << endl;
	segmentsIntrArea(point_A3, point_A4, point_B3, point_B4, intersection_point2);
	//cout << "intersection point14: " << intersection_pointB3.id << " " << intersection_pointB3.value << endl;

	/*....................................................................................................................*/

	double ll_height = intersection_point1.id;
	double lr_height = point_A2.id - intersection_point1.id;
	double rl_height = intersection_point2.id;
	double rr_height = point_A4.id - intersection_point2.id;

	temp_coefficient.increment_area = NULL;

	//cout << "Before: " << increment_area << endl;
	/*-----------------------------------------------------------------------------------------*/
	if (intersection_point1.id != INF && intersection_point1.value != INF) {
		temp_coefficient.increment_area = ll_width * ll_height + lr_width * lr_height;
	}
	else {
		//temp_coefficient.increment_area = (ll_width + lr_width) * area_vector[left_id].rectangle_width;
		//200305
		temp_coefficient.increment_area = GEOMETRY::get_abs_area_triangle(point_A1, point_A2, point_B1) + GEOMETRY::get_abs_area_triangle(point_B1, point_B2, point_A2);
	}

	if (intersection_point2.id != INF && intersection_point2.value != INF) {
		temp_coefficient.increment_area += rl_width * rl_height + rr_width * rr_height;
	}
	else {
		//temp_coefficient.increment_area += (rl_width + rr_width) * area_vector[vector_id].rectangle_width;
		//200305
		temp_coefficient.increment_area += GEOMETRY::get_abs_area_triangle(point_A3, point_A4, point_B3) + GEOMETRY::get_abs_area_triangle(point_B3, point_B4, point_A4);
	}

	/*........................................................................................*/

#ifdef _DEBUG
	assert(temp_coefficient.increment_area != INF);
#endif

	if (temp_coefficient.increment_area == 0) {
		return temp_coefficient.segment_density = INF;
	}

	return temp_coefficient.segment_density = temp_coefficient.rectangle_width / temp_coefficient.increment_area;
}

//190826 Use linkned list to instead vector
//************************************
// Method:getLineSegmentTriangleAreaDensity
// Qualifier:get area and density of triangle.
// Input: left & right & temp segment apla coefficient, a&b, width,
// Output: Segment Triangle Area Density
// date:190826
// author:
//************************************
TEMPLATE
double APLA::getLineSegmentTriangleAreaDensity(DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient) {//190826
	int left_id = vector_id - 1;
	assert(0);
#ifdef _DEBUG
	assert(left_id > -1);
	assert(doubly_linked_list[left_id].rectangle_width != INF && doubly_linked_list[vector_id].rectangle_width != INF && temp_coefficient.rectangle_width != INF && doubly_linked_list[left_id].right_endpoint != INF && doubly_linked_list[vector_id].right_endpoint != INF && temp_coefficient.right_endpoint != INF);
	assert(doubly_linked_list[left_id].apla.a != INF && doubly_linked_list[vector_id].apla.a != INF && temp_coefficient.apla.a != INF && doubly_linked_list[left_id].apla.b != INF && doubly_linked_list[vector_id].apla.b != INF && temp_coefficient.apla.b != INF);
	assert(doubly_linked_list[left_id].apla.a_minuend != INF && doubly_linked_list[vector_id].apla.a_minuend != INF && temp_coefficient.apla.a_minuend != INF && doubly_linked_list[left_id].apla.b_minuend != INF && doubly_linked_list[vector_id].apla.b_minuend != INF && temp_coefficient.apla.b_minuend != INF);
#endif

	/*===================================Segment Point=====================================================*/
	typename GEOMETRY::POINT point_A1;//Line A1A2
	typename GEOMETRY::POINT point_A2;
	typename GEOMETRY::POINT point_B1;//Line B1B2
	typename GEOMETRY::POINT point_B2;

	typename GEOMETRY::POINT point_A3;//Line A3A4
	typename GEOMETRY::POINT point_A4;
	typename GEOMETRY::POINT point_B3;//Line B3B4
	typename GEOMETRY::POINT point_B4;

	double b_temp = doubly_linked_list[left_id].rectangle_width * temp_coefficient.apla.a + temp_coefficient.apla.b;

	point_A1.id = 0;
	point_A1.value = doubly_linked_list[left_id].apla.b;
	point_A2.id = doubly_linked_list[left_id].rectangle_width - 1;
	point_A2.value = point_A2.id * doubly_linked_list[left_id].apla.a + doubly_linked_list[left_id].apla.b;

	point_B1.id = 0;
	point_B1.value = temp_coefficient.apla.b;
	point_B2.id = doubly_linked_list[left_id].rectangle_width - 1;
	point_B2.value = point_B2.id * temp_coefficient.apla.a + temp_coefficient.apla.b;

	point_A3.id = 0;
	point_A3.value = doubly_linked_list[vector_id].apla.b;
	point_A4.id = doubly_linked_list[vector_id].rectangle_width - 1;
	point_A4.value = point_A4.id * doubly_linked_list[vector_id].apla.a + doubly_linked_list[vector_id].apla.b;

	point_B3.id = 0;
	point_B3.value = b_temp;
	point_B4.id = doubly_linked_list[vector_id].rectangle_width - 1;
	point_B4.value = point_B4.id * temp_coefficient.apla.a + b_temp;
	double temp_right_endpoint_value = (temp_coefficient.rectangle_width - 1) * temp_coefficient.apla.a + temp_coefficient.apla.b;
#ifdef _DEBUG
	assert(fabs(point_B4.value - temp_right_endpoint_value) < 0.00001);
#endif
	/*...........................................................................................*/

	/*=============================Width or height of triangle & trapezoid==================================*/
	double ll_width = fabs(point_A1.value - point_B1.value);
	double lr_width = fabs(point_A2.value - point_B2.value);
	double rl_width = fabs(point_A3.value - point_B3.value);
	double rr_width = fabs(point_A4.value - point_B4.value);
	/*......................................................................................................*/

	/*=====================================intersection_point ===========================================================*/
	typename GEOMETRY::POINT intersection_point1;
	typename GEOMETRY::POINT intersection_point2;
	intersection_point1.id = INF;
	intersection_point1.value = INF;
	intersection_point2.id = INF;
	intersection_point2.value = INF;
	//getLineSegmentIntersectionPoint(original_time_series, area_vector, vector_id, temp_coefficient, intersection_point1, intersection_point2);
	segmentsIntrArea(point_A1, point_A2, point_B1, point_B2, intersection_point1);
	//cout << "intersection point13: " << intersection_pointA3.id << " " << intersection_pointA3.value << endl;
	segmentsIntrArea(point_A3, point_A4, point_B3, point_B4, intersection_point2);
	//cout << "intersection point14: " << intersection_pointB3.id << " " << intersection_pointB3.value << endl;

	/*....................................................................................................................*/

	double ll_height = intersection_point1.id;
	double lr_height = point_A2.id - intersection_point1.id;
	double rl_height = intersection_point2.id;
	double rr_height = point_A4.id - intersection_point2.id;

	temp_coefficient.increment_area = NULL;

	//cout << "Before: " << increment_area << endl;
	/*-----------------------------------------------------------------------------------------*/
	if (intersection_point1.id != INF && intersection_point1.value != INF) {
		temp_coefficient.increment_area = ll_width * ll_height + lr_width * lr_height;
	}
	else {
		//temp_coefficient.increment_area = (ll_width + lr_width) * doubly_linked_list[left_id].rectangle_width;
		//200305
		temp_coefficient.increment_area = GEOMETRY::get_abs_area_triangle(point_A1, point_A2, point_B1) + GEOMETRY::get_abs_area_triangle(point_B1, point_B2, point_A2);
	}

	if (intersection_point2.id != INF && intersection_point2.value != INF) {
		temp_coefficient.increment_area += rl_width * rl_height + rr_width * rr_height;
	}
	else {
		//temp_coefficient.increment_area += (rl_width + rr_width) * doubly_linked_list[vector_id].rectangle_width;
		//200305
		temp_coefficient.increment_area += GEOMETRY::get_abs_area_triangle(point_A3, point_A4, point_B3) + GEOMETRY::get_abs_area_triangle(point_B3, point_B4, point_A4);
	}

	/*........................................................................................*/

#ifdef _DEBUG
	assert(temp_coefficient.increment_area != INF);
#endif

	if (temp_coefficient.increment_area == 0) {
		return temp_coefficient.segment_density = INF;
	}

	return temp_coefficient.segment_density = temp_coefficient.rectangle_width / temp_coefficient.increment_area;
}

//190905 Use linkned list to instead vector
//************************************
// Method:getLineSegmentTriangleAreaDensity
// Qualifier:get area and density of triangle.
// Input: left & right & temp segment apla coefficient, a&b, width,
// Output: Segment Triangle Area Density
// date:190906
// author:
//************************************
TEMPLATE
inline double& APLA::getLineSegmentTriangleAreaDensity(int nothing, const AREA_COEFFICIENT& const left_segment, const AREA_COEFFICIENT& const right_segment, AREA_COEFFICIENT& const merged_segment) {//190905
#ifdef _DEBUG
	assert(left_segment.rectangle_width != INF && right_segment.rectangle_width != INF && merged_segment.rectangle_width != INF && left_segment.right_endpoint != INF && right_segment.right_endpoint != INF && merged_segment.right_endpoint != INF);
	assert(left_segment.apla.a != INF && right_segment.apla.a != INF && merged_segment.apla.a != INF && left_segment.apla.b != INF && right_segment.apla.b != INF && merged_segment.apla.b != INF);
	assert(left_segment.apla.a_minuend != INF && right_segment.apla.a_minuend != INF && merged_segment.apla.a_minuend != INF && left_segment.apla.b_minuend != INF && right_segment.apla.b_minuend != INF && merged_segment.apla.b_minuend != INF);
#endif
	assert(0);
	/*===================================Segment Point=====================================================*/
	typename GEOMETRY::POINT point_A1;//Line A1A2 left short segment
	typename GEOMETRY::POINT point_A2;
	typename GEOMETRY::POINT point_B1;//Line B1B2 long segment
	typename GEOMETRY::POINT point_B2;

	typename GEOMETRY::POINT point_A3;//Line A3A4 right short segment
	typename GEOMETRY::POINT point_A4;
	typename GEOMETRY::POINT point_B3;//Line B3B4 long segment
	typename GEOMETRY::POINT point_B4;


	point_A1.id = point_B1.id = point_A3.id = point_B3.id = 0;
	point_A1.value = left_segment.apla.b;
	point_A2.id = point_B2.id = left_segment.rectangle_width - 1;
	point_A2.value = point_A2.id * left_segment.apla.a + left_segment.apla.b;

	point_B1.value = merged_segment.apla.b;
	point_B2.value = point_B2.id * merged_segment.apla.a + merged_segment.apla.b;

	point_A3.value = right_segment.apla.b;
	point_A4.id = point_B4.id = right_segment.rectangle_width - 1;
	point_A4.value = point_A4.id * right_segment.apla.a + right_segment.apla.b;

	point_B3.value = left_segment.rectangle_width * merged_segment.apla.a + merged_segment.apla.b;
	point_B4.value = point_B4.id * merged_segment.apla.a + point_B3.value;

#ifdef _DEBUG
	double temp_right_endpoint_value = (merged_segment.rectangle_width - 1) * merged_segment.apla.a + merged_segment.apla.b;
	assert(fabs(point_B4.value - temp_right_endpoint_value) < 0.00001);
#endif
	/*===========================================================================================================*/

	/*=============================Width or height of triangle & trapezoid=======================================*/
	double ll_width = fabs(point_A1.value - point_B1.value);
	double lr_width = fabs(point_A2.value - point_B2.value);
	double rl_width = fabs(point_A3.value - point_B3.value);
	double rr_width = fabs(point_A4.value - point_B4.value);
	/*============================================================================================================*/

	/*=====================================intersection_point ===========================================================*/
	typename GEOMETRY::POINT intersection_point1;
	typename GEOMETRY::POINT intersection_point2;
	intersection_point1.id = intersection_point1.value = INF;
	intersection_point2.id = intersection_point2.value = INF;
	//getLineSegmentIntersectionPoint(original_time_series, area_vector, vector_id, merged_segment, intersection_point1, intersection_point2);
	segmentsIntrArea(point_A1, point_A2, point_B1, point_B2, intersection_point1);
	//cout << "intersection point13: " << intersection_pointA3.id << " " << intersection_pointA3.value << endl;
	segmentsIntrArea(point_A3, point_A4, point_B3, point_B4, intersection_point2);
	//cout << "intersection point14: " << intersection_pointB3.id << " " << intersection_pointB3.value << endl;
	/*====================================================================================================================*/

	merged_segment.increment_area = 0;
	//cout << "Before: " << increment_area << endl;
	/*-----------------------------  Area of Triganle  -----------------------------------------*/
	if (intersection_point1.id != INF && intersection_point1.value != INF) {
		double ll_height = intersection_point1.id;
		double lr_height = point_A2.id - intersection_point1.id;
		merged_segment.increment_area = ll_width * ll_height + lr_width * lr_height;

	}
	else {
		//merged_segment.increment_area = (ll_width + lr_width) * left_segment.rectangle_width;
		//200305
		merged_segment.increment_area = GEOMETRY::get_abs_area_triangle(point_A1, point_A2, point_B1) + GEOMETRY::get_abs_area_triangle(point_B1, point_B2, point_A2);
	}

	if (intersection_point2.id != INF && intersection_point2.value != INF) {
		double rl_height = intersection_point2.id;
		double rr_height = point_A4.id - intersection_point2.id;
		merged_segment.increment_area += rl_width * rl_height + rr_width * rr_height;
	}
	else {
		//merged_segment.increment_area += (rl_width + rr_width) * right_segment.rectangle_width;
		//200305
		merged_segment.increment_area += GEOMETRY::get_abs_area_triangle(point_A3, point_A4, point_B3) + GEOMETRY::get_abs_area_triangle(point_B3, point_B4, point_A4);
	}
	/*------------------------------------------------------------------------------------------*/

#ifdef _DEBUG
	assert(merged_segment.increment_area != INF);
#endif

	if (merged_segment.increment_area == 0) {
		return merged_segment.segment_density = INF;
	}

	return merged_segment.segment_density = merged_segment.rectangle_width / merged_segment.increment_area;
}

//200206 get density of triangle area
//190905 Use linkned list to instead vector
//************************************
// Method:getLineSegmentTriangleAreaDensity
// Qualifier:get area and density of triangle.
// Input: left & right & temp segment apla coefficient, a&b, width,
// Output: Segment Triangle Area Density
// Notice: 
// date:200305
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline double APLA::getLineSegmentTriangleAreaDensity(const T& const left_segment, const T& const right_segment, Y& const merged_segment) {
	/*.....................................................................................................................................*/
#ifdef _DEBUG
	assert(left_segment.rectangle_width != INF && right_segment.rectangle_width != INF && merged_segment.rectangle_width != INF && left_segment.right_endpoint != INF && right_segment.right_endpoint != INF && merged_segment.right_endpoint != INF);
	assert(left_segment.apla.a != INF && right_segment.apla.a != INF && merged_segment.apla.a != INF && left_segment.apla.b != INF && right_segment.apla.b != INF && merged_segment.apla.b != INF);
	assert(left_segment.apla.a_minuend != INF && right_segment.apla.a_minuend != INF && merged_segment.apla.a_minuend != INF && left_segment.apla.b_minuend != INF && right_segment.apla.b_minuend != INF && merged_segment.apla.b_minuend != INF);
#endif
	/*.....................................................................................................................................*/

	/*===================================Segment Point=====================================================*/
	typename GEOMETRY::POINT point_A1;//Line A1A2 left short segment
	typename GEOMETRY::POINT point_A2;
	typename GEOMETRY::POINT point_B1;//Line B1B2 long segment
	typename GEOMETRY::POINT point_B2;

	typename GEOMETRY::POINT point_A3;//Line A3A4 right short segment
	typename GEOMETRY::POINT point_A4;
	typename GEOMETRY::POINT point_B3;//Line B3B4 long segment
	typename GEOMETRY::POINT point_B4;

	point_A1.id = point_B1.id = point_A3.id = point_B3.id = 0;
	point_A1.value = left_segment.apla.b;
	point_A2.id = point_B2.id = left_segment.rectangle_width - 1;
	point_A2.value = point_A2.id * left_segment.apla.a + left_segment.apla.b;

	point_B1.value = merged_segment.apla.b;
	point_B2.value = point_B2.id * merged_segment.apla.a + merged_segment.apla.b;

	point_A3.value = right_segment.apla.b;
	point_A4.id = point_B4.id = right_segment.rectangle_width - 1;
	point_A4.value = point_A4.id * right_segment.apla.a + right_segment.apla.b;

	point_B3.value = left_segment.rectangle_width * merged_segment.apla.a + merged_segment.apla.b;
	point_B4.value = point_B4.id * merged_segment.apla.a + point_B3.value;

	/*......................................................................................................*/
#ifdef _DEBUG
	const double temp_right_endpoint_value = (merged_segment.rectangle_width - 1) * merged_segment.apla.a + merged_segment.apla.b;
	assert(fabs(point_B4.value - temp_right_endpoint_value) < 0.1);
#endif
	/*......................................................................................................*/
	/*===========================================================================================================*/

	/*=============================Width or height of triangle & trapezoid=======================================*/
	const double ll_width = fabs(point_A1.value - point_B1.value);
	const double lr_width = fabs(point_A2.value - point_B2.value);
	const double rl_width = fabs(point_A3.value - point_B3.value);
	const double rr_width = fabs(point_A4.value - point_B4.value);
	/*============================================================================================================*/

	/*======================200206 Height of rectangle when two line segments has no intersection ================*/
	/*vector<double> left_point_value_vector = { point_A1.value, point_A2.value, point_B1.value, point_B2.value };
	vector<double> right_point_value_vector = { point_A3.value, point_A4.value, point_B3.value, point_B4.value };
	const auto [left_min, left_max] = std::minmax_element(left_point_value_vector.begin(), left_point_value_vector.end());
	const auto [right_min, right_max] = std::minmax_element(right_point_value_vector.begin(), right_point_value_vector.end());
	assert(left_max >= left_min && right_max - right_min);
	double left_rectangle_height = fabs(left_max - left_min);
	double right_rectangle_height = fabs(right_max - right_min);*/
	/*============================================================================================================*/

	/*=====================================intersection_point ===========================================================*/
	typename GEOMETRY::POINT intersection_point1;
	typename GEOMETRY::POINT intersection_point2;
	intersection_point1.id = intersection_point1.value = INF;
	intersection_point2.id = intersection_point2.value = INF;
	//getLineSegmentIntersectionPoint(original_time_series, area_vector, vector_id, merged_segment, intersection_point1, intersection_point2);
	// compute intersection point between A1A2 and B1B2.
	segmentsIntrArea(point_A1, point_A2, point_B1, point_B2, intersection_point1);
	//cout << "intersection pointL: " << intersection_point1.id << " " << intersection_point1.value << endl;
	// compute intersection point between A3A4 and B3B4.
	segmentsIntrArea(point_A3, point_A4, point_B3, point_B4, intersection_point2);
	//cout << "intersection pointR: " << intersection_point2.id << " " << intersection_point2.value << endl;
	/*====================================================================================================================*/

	double increment_area = 0;
	//cout << "Before: " << increment_area << endl;
	/*-----------------------------  Area of Triganle  -----------------------------------------*/
	if (intersection_point1.id != INF && intersection_point1.value != INF) {// has left intersection point 
		const double ll_height = intersection_point1.id;
		const double lr_height = point_A2.id - intersection_point1.id;
		increment_area = ll_width * ll_height + lr_width * lr_height;
	}
	else {//No left intersection point // Area is Rectangle Area - 2 Triangle Area
		//increment_area = (ll_width + lr_width) * left_segment.rectangle_width;
		increment_area = GEOMETRY::get_abs_area_triangle(point_A1, point_A2, point_B1) + GEOMETRY::get_abs_area_triangle(point_B1, point_B2, point_A2);
		//increment_area = 0;
		//increment_area *= 2;
	}

	if (intersection_point2.id != INF && intersection_point2.value != INF) {// has right intersection point 
		const double rl_height = intersection_point2.id;
		const double rr_height = point_A4.id - intersection_point2.id;
		increment_area += rl_width * rl_height + rr_width * rr_height;
	}
	else {//No right intersection point // Area is Rectangle Area - 2 Triangle Area
		//increment_area += (rl_width + rr_width) * right_segment.rectangle_width;
		increment_area += (GEOMETRY::get_abs_area_triangle(point_A3, point_A4, point_B3) + GEOMETRY::get_abs_area_triangle(point_B3, point_B4, point_A4));
		//increment_area = 0;
	}
	/*------------------------------------------------------------------------------------------*/

	/*..................................*/
#ifdef _DEBUG
	assert(increment_area != INF);
#endif
	/*..................................*/

	if (increment_area == 0) {
		return merged_segment.segment_density = INF;
	}

	// Density  Triangle Area
	//return merged_segment.segment_density = merged_segment.rectangle_width / increment_area;

	//210119
	//increment_area /= 2;
	return merged_segment.segment_density = 1.0 / increment_area;
	//210119
	//assert(merged_segment.area_difference == merged_segment.bound.upper_bound_area);
	//return merged_segment.segment_density = merged_segment.area_difference;
}

//211007 get density of triangle area. If area > 0, segment 0 is top, segment 1 is down, else converse
TEMPLATE
template<typename T, typename Y>
inline long double APLA::get_segment_top_down_area_difference(const T& const segment_0, const Y& const segment_1) {
	/*......................................................................................................................*/
#ifdef _DEBUG
	assert(segment_0.right_endpoint == segment_1.right_endpoint && segment_0.rectangle_width == segment_1.rectangle_width);
#endif
	/*.......................................................................................................................*/

	const long double order_end = segment_0.rectangle_width - 1;
	//const long double ry0 = order_end * segment_0.apla.a + segment_0.apla.b;//b.y
	//const long double ry1 = order_end * segment_1.apla.a + segment_1.apla.b;//c.y
	//const long double& const ly0 = segment_0.apla.b;//a.y
	//const long double& const ly1 = segment_1.apla.b;//d.y
	const long double width_left = segment_0.apla.b - segment_1.apla.b;// triangle width
	const long double width_right = order_end * (segment_0.apla.a - segment_1.apla.a) + width_left;// triangle width
	
	if (width_left * width_right >= 0) {// no intersectio point, is trapezoid
		return (width_left + width_right) * order_end / 2.0;
	}
	else {// has intersectio point, is triangle

		const long double area_0 = order_end * width_right;//abc
		const long double area_1 = order_end * width_left;//abd

		/*...................................................*/
#ifdef _DEBUG
		assert(area_0 * area_1 < 0);// has intersect point
#endif
		/*...................................................*/

		const long double t = area_1 / (area_1 - area_0);
		const long double intercept_x = t * order_end;// intercept point (x,)
		//const long double intercept_y = intercept_x * segment_0.apla.a + segment_0.apla.b;// intercept point (,y)

		/*...................................................*/
#ifdef _DEBUG
		assert(intercept_x > 0 && intercept_x < order_end);//  intersect point
#endif
		/*...................................................*/

		return (width_left * intercept_x + width_right * (segment_0.rectangle_width - intercept_x)) / 2;
	}
}

//211007 get list triangle area.
TEMPLATE
template<typename T, typename Y>
long double APLA::get_top_down_area_difference(const DoublyLinkedList<T>& const doubly_linked_list_0, const DoublyLinkedList<Y>& const doubly_linked_list_1) {
	/*...............................................................*/
#ifdef _DEBUG
	assert(doubly_linked_list_0.size() == doubly_linked_list_1.size());
#endif
	/*...............................................................*/
	
	const int size_list = doubly_linked_list_0.size();

	long double area_list = 0;

	for (int id_segment = 0; id_segment < size_list; id_segment++) {
		area_list += get_segment_top_down_area_difference(doubly_linked_list_0[id_segment], doubly_linked_list_1[id_segment]);
	}

	return area_list;
}

//211012 get list triangle area. If area > 0, list 0 is top, list 1 is down, else converse
TEMPLATE
template<typename T, typename Y>
void APLA::get_convex_top(const T& const segment_candidate, DoublyLinkedList<Y>& const doubly_linked_list) {
	/*...................................................................................*/
#ifdef _DEBUG
	assert(segment_candidate.right_endpoint == doubly_linked_list.back().right_endpoint);
#endif
	/*....................................................................................*/

	//const size_t size_list = doubly_linked_list.size();
	const size_t endpoint = segment_candidate.right_endpoint;
	T segment_temp = segment_candidate;
	int position_in_segment = -1;
	int id_seg = 0;
	while (doubly_linked_list[id_seg].right_endpoint <= endpoint) {
		segment_temp.right_endpoint = doubly_linked_list[id_seg].right_endpoint;
		segment_temp.rectangle_width = doubly_linked_list[id_seg].rectangle_width;
		position_in_segment += segment_temp.rectangle_width;
	}
}

//************************************
// Method:get_triangle_density_by_accumulate_segment
// Qualifier:Increment Area, get density of triangle area from current segment & accumulates segment
// Input: left & right & temp segment apla coefficient, a&b, width,
// Output: current segment Segment Triangle Area Density
// Notice: 
// date:200728 
// author:
//************************************
TEMPLATE
template<typename T>
inline long double APLA::get_triangle_density_by_accumulate_segment(T& const current_segment, const T& const accumulate_segment) {

	/*.....................................................................................................................................*/
#ifdef _DEBUG
	assert(current_segment.rectangle_width + 1 == accumulate_segment.rectangle_width && current_segment.right_endpoint + 1 == accumulate_segment.right_endpoint);
	assert(current_segment.rectangle_width != INF && accumulate_segment.rectangle_width != INF && current_segment.right_endpoint != INF && accumulate_segment.right_endpoint != INF);
	assert_segment_a_b(current_segment);
	assert_segment_a_b(accumulate_segment);
#endif
	/*......................................................................................................................................*/

	/*===================================Segment Point======================================================*/

	typename GEOMETRY::POINT point_A1;//Line A1A2 current segment
	typename GEOMETRY::POINT point_A2;
	typename GEOMETRY::POINT point_B1;//Line B1B2 accumulate segment
	typename GEOMETRY::POINT point_B2;

	point_A1.id = point_B1.id = 0;
	point_A1.value = current_segment.apla.b;
	point_A2.id = point_B2.id = current_segment.rectangle_width;
	point_A2.value = current_segment.rectangle_width * current_segment.apla.a + current_segment.apla.b;

	point_B1.value = accumulate_segment.apla.b;
	point_B2.value = current_segment.rectangle_width * accumulate_segment.apla.a + accumulate_segment.apla.b;

	/*========================================================================================================*/

	/*===================================== Intersection Point ===========================================================*/
	typename GEOMETRY::POINT intersection_point;
	intersection_point.id = intersection_point.value = INF;

	// getLineSegmentIntersectionPoint(original_time_series, area_vector, vector_id, accumulate_segment, intersection_point, intersection_point2);
	// compute intersection point between A1A2 and B1B2.
	segmentsIntrArea(point_A1, point_A2, point_B1, point_B2, intersection_point);
	/*====================================================================================================================*/

	long double increment_area = 0;
	//cout << "Before: " << increment_area << endl;
	/*--------------------------------------------  Area of Triganle  --------------------------------------------*/
	if (intersection_point.id != INF && intersection_point.value != INF) {// has left intersection point 
		const long double ll_height = intersection_point.id;
		const long double lr_height = point_A2.id - intersection_point.id;
		increment_area = fabs(point_A1.value - point_B1.value) * ll_height + fabs(point_A2.value - point_B2.value) * lr_height;
	}
	else {//No left intersection point // Area is Rectangle Area - 2 Triangle Area
		//increment_area = (ll_width + lr_width) * left_segment.rectangle_width;
		increment_area = GEOMETRY::get_abs_area_triangle(point_A1, point_A2, point_B1) + GEOMETRY::get_abs_area_triangle(point_B1, point_B2, point_A2);
		//increment_area *= 2;
	}
	/*-------------------------------------------------------------------------------------------------------------*/

	/*..................................*/
#ifdef _DEBUG
	assert(increment_area != INF);
#endif
	/*..................................*/

	if (increment_area == 0) {
		return current_segment.segment_density = INF;
	}

	/*-------------------------------------------------------------------------------------------------------------*/
	//cout << "Right endpoint: " << current_segment.right_endpoint << "  Density: " << accumulate_segment.rectangle_width / increment_area  << endl;
	//cout << "Right endpoint: " << current_segment.right_endpoint << "  Density: " << 1.0 / increment_area << endl;
	/*-------------------------------------------------------------------------------------------------------------*/

	// Density  Triangle Area
	//return accumulate_segment.segment_density = accumulate_segment.rectangle_width / increment_area;
	return current_segment.segment_density = 1.0 / increment_area;
}

//210509 get triangle area by line A1A2 and B1B2, they have same length
TEMPLATE
template<typename T>
inline long double APLA::get_triangle_area(const T& const segment_1, const T& const segment_2) {

	/*.......................................*/
#ifdef _DEBUG
	assert_segment_a_b(segment_1);
	assert_segment_a_b(segment_2);
	assert(segment_1.rectangle_width == segment_2.rectangle_width && segment_1.right_endpoint == segment_2.right_endpoint);
#endif
	/*.......................................*/

	/*===================================Segment Point======================================================*/
	typename GEOMETRY::POINT point_A1;//Line A1A2 current segment
	typename GEOMETRY::POINT point_A2;
	typename GEOMETRY::POINT point_B1;//Line B1B2 accumulate segment
	typename GEOMETRY::POINT point_B2;

	point_A1.id = point_B1.id = 0;
	point_A1.value = segment_1.apla.b;
	point_B1.value = segment_2.apla.b;

	point_A2.id = point_B2.id = segment_1.rectangle_width - 1;
	point_A2.value = point_A2.id * segment_1.apla.a + segment_1.apla.b;
	point_B2.value = point_A2.id * segment_2.apla.a + segment_2.apla.b;

	/*========================================================================================================*/

	/*===================================== Intersection Point ===========================================================*/
	typename GEOMETRY::POINT intersection_point;
	intersection_point.id = intersection_point.value = INF;

	// getLineSegmentIntersectionPoint(original_time_series, area_vector, vector_id, accumulate_segment, intersection_point, intersection_point2);
	// compute intersection point between A1A2 and B1B2.
	segmentsIntrArea(point_A1, point_A2, point_B1, point_B2, intersection_point);
	/*====================================================================================================================*/

	long double increment_area = 0;
	//cout << "Before: " << increment_area << endl;
	/*--------------------------------------------  Area of Triganle  --------------------------------------------*/
	if (intersection_point.id != INF && intersection_point.value != INF) {// has left intersection point 
		const long double ll_height = intersection_point.id;
		const long double lr_height = point_A2.id - intersection_point.id;
		/*------------------*/
		//return increment_area = (fabs(point_A1.value - point_B1.value) * ll_height + fabs(point_A2.value - point_B2.value) * lr_height) * 0.5;
		increment_area = (fabs(point_A1.value - point_B1.value) * ll_height + fabs(point_A2.value - point_B2.value) * lr_height) * 0.5;
		/*-----------------*/
	}
	else {//No left intersection point // Area is 2 Triangle Area sum
		/*..................................*/
#ifdef _DEBUG
		assert(increment_area != INF);
#endif
		/*..................................*/
		//increment_area = (ll_width + lr_width) * left_segment.rectangle_width;
		/*-------------*/
		//return increment_area = GEOMETRY::get_abs_area_triangle(point_A1, point_A2, point_B1) + GEOMETRY::get_abs_area_triangle(point_B1, point_B2, point_A2);
		increment_area = GEOMETRY::get_abs_area_triangle(point_A1, point_A2, point_B1) + GEOMETRY::get_abs_area_triangle(point_B1, point_B2, point_A2);
		/*-------------*/
		//increment_area *= 2;
	}
	/*-------------------------------------------------------------------------------------------------------------*/
	//cout << "triangle area: " << increment_area << endl;
	return increment_area;
	//if (increment_area == 0) {
		//return segment_1.area_difference = 0.0;
	//}

	/*-------------------------------------------------------------------------------------------------------------*/
	//cout << "Right endpoint: " << segment_1.right_endpoint << "  Density: " << accumulate_segment.rectangle_width / increment_area  << endl;
	//cout << "Right endpoint: " << segment_1.right_endpoint << "  Density: " << 1.0 / increment_area << endl;
	/*-------------------------------------------------------------------------------------------------------------*/

	// Density  Triangle Area
	//return accumulate_segment.segment_density = accumulate_segment.rectangle_width / increment_area;
	//return increment_area;
}

//210509 get triangle area by line A1A2 and B1B2, they have same length
TEMPLATE
template<typename T>
inline long double APLA::get_triangle_area_pub(const T& const segment_1, const T& const segment_2) {
	POINT point_A1;
	POINT point_A2;
	POINT point_B1;
	POINT point_B2;

	point_A1.id = point_B1.id = 0;
	point_A1.value = segment_1.apla.b;
	point_A2.id = point_B2.id = segment_1.rectangle_width - 1;
	point_A2.value = point_A2.id * segment_1.apla.a + segment_1.apla.b;

	point_B1.value = segment_2.apla.b;
	point_B2.value = point_A2.id * segment_2.apla.a + segment_2.apla.b;

	POINT intersection_point;
	intersection_point.id = intersection_point.value = INF;

	segmentsIntrArea_pub(point_A1, point_A2, point_B1, point_B2, intersection_point);

	long double increment_area = 0;

	if (intersection_point.id != INF && intersection_point.value != INF) {// has left intersection point 
		increment_area = fabs(point_A1.value - point_B1.value) * intersection_point.id + fabs(point_A2.value - point_B2.value) * (point_A2.id - intersection_point.id);
	}
	else {
		increment_area = get_abs_area_triangle(point_A1, point_A2, point_B1) + get_abs_area_triangle(point_B1, point_B2, point_A2);
	}

	if (increment_area == 0) {
		return segment_1.area_difference = 0.0;
	}

	return segment_1.area_difference = increment_area;
}

//************************************
// Method:get_triangle_area_by_points
// Qualifier:get triangle area by line A1A2 and B1B2
// Input: A1A2 := current segment<a&b, width>. A1A2.width == B1B2.width
// Output: Segment Triangle Area
// Notice: Area, Not Density!!!!!!!!!!!!!!!!!!!!
// date:201007 
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline long double APLA::get_triangle_area_by_points(T& const current_segment, const Y& const B1_y, const Y& const B2_y) {
	/*.......................................*/
#ifdef _DEBUG
	assert_segment_a_b(current_segment);
#endif
	/*.......................................*/

	/*===================================Segment Point======================================================*/

	typename GEOMETRY::POINT point_A1;//Line A1A2 current segment
	typename GEOMETRY::POINT point_A2;
	typename GEOMETRY::POINT point_B1;//Line B1B2 accumulate segment
	typename GEOMETRY::POINT point_B2;

	point_A1.id = point_B1.id = 0;
	point_A1.value = current_segment.apla.b;
	point_A2.id = point_B2.id = current_segment.rectangle_width - 1;
	point_A2.value = (current_segment.rectangle_width - 1) * current_segment.apla.a + current_segment.apla.b;

	point_B1.value = B1_y;
	point_B2.value = B2_y;

	/*========================================================================================================*/

	/*===================================== Intersection Point ===========================================================*/
	typename GEOMETRY::POINT intersection_point;
	intersection_point.id = intersection_point.value = INF;

	// getLineSegmentIntersectionPoint(original_time_series, area_vector, vector_id, accumulate_segment, intersection_point, intersection_point2);
	// compute intersection point between A1A2 and B1B2.
	segmentsIntrArea(point_A1, point_A2, point_B1, point_B2, intersection_point);
	/*====================================================================================================================*/

	long double increment_area = 0;
	//cout << "Before: " << increment_area << endl;
	/*--------------------------------------------  Area of Triganle  --------------------------------------------*/
	if (intersection_point.id != INF && intersection_point.value != INF) {// has left intersection point 
		const long double ll_height = intersection_point.id;
		const long double lr_height = point_A2.id - intersection_point.id;
		increment_area = fabs(point_A1.value - point_B1.value) * ll_height + fabs(point_A2.value - point_B2.value) * lr_height;
	}
	else {//No left intersection point // Area is Rectangle Area - 2 Triangle Area
		//increment_area = (ll_width + lr_width) * left_segment.rectangle_width;
		increment_area = GEOMETRY::get_abs_area_triangle(point_A1, point_A2, point_B1) + GEOMETRY::get_abs_area_triangle(point_B1, point_B2, point_A2);
		//increment_area *= 2;
	}
	/*-------------------------------------------------------------------------------------------------------------*/

	/*..................................*/
#ifdef _DEBUG
	assert(increment_area != INF);
#endif
	/*..................................*/

	if (increment_area == 0) {
		return current_segment.area_difference = 0.0;
	}

	/*-------------------------------------------------------------------------------------------------------------*/
	//cout << "Right endpoint: " << current_segment.right_endpoint << "  Density: " << accumulate_segment.rectangle_width / increment_area  << endl;
	//cout << "Right endpoint: " << current_segment.right_endpoint << "  Density: " << 1.0 / increment_area << endl;
	/*-------------------------------------------------------------------------------------------------------------*/

	// Density  Triangle Area
	//return accumulate_segment.segment_density = accumulate_segment.rectangle_width / increment_area;
	return current_segment.area_difference = increment_area;
}

//210509 get triangle area by line A1A2 and B1B2
TEMPLATE
template<typename T, typename Y>
inline long double APLA::get_triangle_area_by_points_pub(T& const current_segment, const Y& const B1_y, const Y& const B2_y) {

	POINT point_A1;
	POINT point_A2;
	POINT point_B1;
	POINT point_B2;

	point_A1.id = point_B1.id = 0;
	point_A1.value = current_segment.apla.b;
	point_A2.id = point_B2.id = current_segment.rectangle_width - 1;
	point_A2.value = (current_segment.rectangle_width - 1) * current_segment.apla.a + current_segment.apla.b;

	point_B1.value = B1_y;
	point_B2.value = B2_y;

	POINT intersection_point;
	intersection_point.id = intersection_point.value = INF;
	segmentsIntrArea_pub(point_A1, point_A2, point_B1, point_B2, intersection_point);


	long double increment_area = 0;

	if (intersection_point.id != INF && intersection_point.value != INF) {// has left intersection point 
		increment_area = fabs(point_A1.value - point_B1.value) * intersection_point.id + fabs(point_A2.value - point_B2.value) * (point_A2.id - intersection_point.id);
	}
	else {
		increment_area = get_abs_area_triangle(point_A1, point_A2, point_B1) + get_abs_area_triangle(point_B1, point_B2, point_A2);
	}


	if (increment_area == 0) {
		return current_segment.area_difference = 0.0;
	}

	return current_segment.area_difference = increment_area;
}

//***************************************************************
// Method: get_line_segment_height_diference
// Qualifier:get endpoint of long segment and two short segments
// Input:  
// Output: 
// date: 200206 
// author:
//**************************************************************
TEMPLATE
template<typename T>
inline long double APLA::get_line_segment_height_diference(const T& const left_segment, const  T& const right_segment, const T& const merged_segment) {
#ifdef _DEBUG
	assert(left_segment.rectangle_width != INF && right_segment.rectangle_width != INF && merged_segment.rectangle_width != INF && left_segment.right_endpoint != INF && right_segment.right_endpoint != INF && merged_segment.right_endpoint != INF);
	assert(left_segment.apla.a != INF && right_segment.apla.a != INF && merged_segment.apla.a != INF && left_segment.apla.b != INF && right_segment.apla.b != INF && merged_segment.apla.b != INF);
	assert(left_segment.apla.a_minuend != INF && right_segment.apla.a_minuend != INF && merged_segment.apla.a_minuend != INF && left_segment.apla.b_minuend != INF && right_segment.apla.b_minuend != INF && merged_segment.apla.b_minuend != INF);
#endif

	/*===================================Segment Point=====================================================*/
	typename GEOMETRY::POINT point_A1;//Line A1A2 left short segment
	typename GEOMETRY::POINT point_A2;
	typename GEOMETRY::POINT point_B1;//Line B1B2 long segment
	typename GEOMETRY::POINT point_B2;

	typename GEOMETRY::POINT point_A3;//Line A3A4 right short segment
	typename GEOMETRY::POINT point_A4;
	typename GEOMETRY::POINT point_B3;//Line B3B4 long segment
	typename GEOMETRY::POINT point_B4;


	point_A1.id = point_B1.id = point_A3.id = point_B3.id = 0;
	point_A1.value = left_segment.apla.b;
	point_A2.id = point_B2.id = left_segment.rectangle_width - 1;
	point_A2.value = point_A2.id * left_segment.apla.a + left_segment.apla.b;

	point_B1.value = merged_segment.apla.b;
	point_B2.value = point_B2.id * merged_segment.apla.a + merged_segment.apla.b;

	point_A3.value = right_segment.apla.b;
	point_A4.id = point_B4.id = right_segment.rectangle_width - 1;
	point_A4.value = point_A4.id * right_segment.apla.a + right_segment.apla.b;

	point_B3.value = left_segment.rectangle_width * merged_segment.apla.a + merged_segment.apla.b;
	point_B4.value = point_B4.id * merged_segment.apla.a + point_B3.value;

#ifdef _DEBUG
	double temp_right_endpoint_value = (merged_segment.rectangle_width - 1) * merged_segment.apla.a + merged_segment.apla.b;
	assert(fabs(point_B4.value - temp_right_endpoint_value) < 0.00001);
#endif
	/*===========================================================================================================*/

	/*=============================Height Differnce of Point in line Segment=======================================*/
	double ll_width = fabs(point_A1.value - point_B1.value);
	double lr_width = fabs(point_A2.value - point_B2.value);
	double rl_width = fabs(point_A3.value - point_B3.value);
	double rr_width = fabs(point_A4.value - point_B4.value);
	/*============================================================================================================*/

	//return ll_width + lr_width + rl_width + rr_width;// ll + lr + rl + rr
	return fabs(ll_width + lr_width - rl_width - rr_width); // | Ll + lr - rl - rr|
}

//***************************************************************
// Method: get_line_segment_height_diference_from_accumulate
// Qualifier:get endpoint of accumulate segment and current segment, and comput height difference between them.(whether bigger than max deviation, search upper bound)
// Input:  
// Output: 
// date: 210111
// author:
//**************************************************************
TEMPLATE
template<typename T, typename Y, typename U>
inline long double APLA::get_line_segment_height_diference_from_accumulate(const vector<Y>& const original_time_series_vector, T& const current_segment, T& const accumulate_segment, U& const output_argument) {

	/*.....................................................................................................................................*/
#ifdef _DEBUG
	assert(current_segment.rectangle_width + 1 == accumulate_segment.rectangle_width && current_segment.right_endpoint + 1 == accumulate_segment.right_endpoint);
	assert(current_segment.rectangle_width != INF && accumulate_segment.rectangle_width != INF && current_segment.right_endpoint != INF && accumulate_segment.right_endpoint != INF);
	assert_segment_a_b(current_segment);
	assert_segment_a_b(accumulate_segment);
#endif
	/*......................................................................................................................................*/

	/*|||||||||||||||||||||||||||||||||||||   210111 compare triangle width with max deviation   ||||||||||||||||||||||||||||||||||||||||||||||||||||||||*/
	/*===================================  Segment Point  ======================================================*/
	const size_t& const endpoint_segment_left = current_segment.right_endpoint - current_segment.rectangle_width + 1;
	//const long double value_point_A2_left = (current_segment.rectangle_width - 1) * current_segment.apla.a + current_segment.apla.b;
	//const long double value_point_B2_left = (current_segment.rectangle_width - 1) * accumulate_segment.apla.a + accumulate_segment.apla.b;
	const long double& const value_predic_right = current_segment.rectangle_width * current_segment.apla.a + current_segment.apla.b;
	const long double& const value_increment_right = current_segment.rectangle_width * accumulate_segment.apla.a + accumulate_segment.apla.b;
	/*==========================================================================================================*/

	/*====================================================================================*/
	long double max_point_difference = 0;
	//max_point_difference = max(max_point_difference, fabs(value_predic_right - original_time_series_vector[accumulate_segment.right_endpoint]));d_rtp
	max_point_difference = max(max_point_difference, fabs(value_increment_right - original_time_series_vector[accumulate_segment.right_endpoint]));
	//max_point_difference = max(max_point_difference, fabs(value_increment_right - value_predic_right));//drti
	max_point_difference = max(max_point_difference, fabs((current_segment.rectangle_width - 1) * current_segment.apla.a + current_segment.apla.b - original_time_series_vector[current_segment.right_endpoint]));
	max_point_difference = max(max_point_difference, fabs((current_segment.rectangle_width - 1) * accumulate_segment.apla.a + accumulate_segment.apla.b - original_time_series_vector[current_segment.right_endpoint]));
	max_point_difference = max(max_point_difference, fabs(current_segment.apla.b - original_time_series_vector[endpoint_segment_left]));
	max_point_difference = max(max_point_difference, fabs(accumulate_segment.apla.b - original_time_series_vector[endpoint_segment_left]));
	/*====================================================================================*/

	//accumulate_segment.bound.upper_bound_diff = difference_map.begin()->first;
	//accumulate_segment.bound.upper_bound_diff = max(current_segment.bound.upper_bound_diff, difference_map.begin()->first);
	accumulate_segment.bound.upper_bound_diff = max(current_segment.bound.upper_bound_diff, max_point_difference);
	accumulate_segment.area_difference = accumulate_segment.bound.upper_bound_area = accumulate_segment.bound.upper_bound_diff * current_segment.rectangle_width;
	//accumulate_segment.bound.upper_bound_area = accumulate_segment.bound.upper_bound_diff * accumulate_segment.rectangle_width;
	//accumulate_segment.bound.upper_bound_area = accumulate_segment.bound.upper_bound_diff;

	/*.......................................................................................................................................................................................................*/
#ifdef _DEBUG

	/*==========================================================================================================*/
	map<const long double, const size_t, greater<long double>> difference_map;// area difference, node*
	difference_map.try_emplace(fabs(value_predic_right - original_time_series_vector[accumulate_segment.right_endpoint]), 6);//difference_accumulate_right_current_real
	difference_map.try_emplace(fabs(value_increment_right - original_time_series_vector[accumulate_segment.right_endpoint]), 7);//difference_accumulate_right_accumulate_real
	difference_map.try_emplace(fabs(value_increment_right - value_predic_right), 8);//difference_accumulate_right_accumulate_current

	difference_map.try_emplace(fabs((current_segment.rectangle_width - 1) * current_segment.apla.a + current_segment.apla.b - original_time_series_vector[current_segment.right_endpoint]), 3);//difference_current_right_current_real
	difference_map.try_emplace(fabs((current_segment.rectangle_width - 1) * accumulate_segment.apla.a + accumulate_segment.apla.b - original_time_series_vector[current_segment.right_endpoint]), 4);//difference_current_right_accumulate_real
	//difference_map.emplace(fabs(value_point_B2_left - value_point_A2_left), 5);//difference_current_right_accumulate_current

	difference_map.try_emplace(fabs(current_segment.apla.b - original_time_series_vector[endpoint_segment_left]), 0);//difference_left_current_real
	difference_map.try_emplace(fabs(accumulate_segment.apla.b - original_time_series_vector[endpoint_segment_left]), 1);//difference_left_accumulate_real
	//difference_map.emplace(fabs(accumulate_segment.apla.b - current_segment.apla.b), 2);// difference_left_accumulate_current
	/*==========================================================================================================*/
	/*=============          210112 Add minmax point difference                ===========*/
	//const long double difference_min_point_current = current_segment.apla.a * (current_segment.min_point.id - endpoint_segment_left) + current_segment.apla.b - current_segment.min_point.value;
	//const long double difference_max_point_current = current_segment.apla.a * (current_segment.max_point.id - endpoint_segment_left) + current_segment.apla.b - current_segment.max_point.value;
	//difference_map.emplace(difference_min_point_current, 9);
	//difference_map.emplace(difference_max_point_current, 10);

	//const long double difference_min_point_accumulate = accumulate_segment.apla.a * (accumulate_segment.min_point.id - endpoint_segment_left) + accumulate_segment.apla.b - accumulate_segment.min_point.value;
	//const long double difference_max_point_accumulate = accumulate_segment.apla.a * (accumulate_segment.max_point.id - endpoint_segment_left) + accumulate_segment.apla.b - accumulate_segment.max_point.value;
	//difference_map.emplace(difference_min_point_accumulate, 11);
	//difference_map.emplace(difference_max_point_accumulate, 12);
	/*====================================================================================*/

	/*-----------------    210123 if previous upper bound    -------------------*/
	if (current_segment.bound.upper_bound_diff > difference_map.begin()->first) {
		count_upper_bound_type(9, output_argument.evaluation_bound.map_bound_increment);
	}
	else {
		count_upper_bound_type(difference_map.begin()->second, output_argument.evaluation_bound.map_bound_increment);
	}
	/*--------------------------------------------------------------------------*/

	long double sum_deviation = 0;
	long double max_deviation = -INF;
	long double point_difference = INF;
	long double point_difference_abs = INF;
	long double point_difference_pow = INF;

	long double difference_no_fabs = 0;

	//typename GEOMETRY::POINT point_max_deviation;

	for (int i = 0; i < accumulate_segment.rectangle_width; i++) {

		point_difference = accumulate_segment.apla.a * i + accumulate_segment.apla.b - original_time_series_vector[endpoint_segment_left + i];
		difference_no_fabs += point_difference;
		point_difference_pow = pow(point_difference, 2.0);
		point_difference_abs = fabs(point_difference);
		sum_deviation += point_difference_pow;
		//max_deviation = max(max_deviation, point_difference_abs);
		if (max_deviation < point_difference_abs) {
			//accumulate_segment.bound.value_point_max_deviation = max_deviation = point_difference_abs;
			//accumulate_segment.bound.id_point_max_deviation = i + endpoint_segment_left;
		}

	}
	assert(fabs(difference_no_fabs) < 0.00000001);
	//accumulate_segment.bound.sum_deviation_real = sum_deviation = sqrt(sum_deviation);

	/*********************************************    compare id of max deviation and upper bound   **********************************************/
	//if (current_segment.bound.upper_bound_diff > difference_map.begin()->first) {
	//	//cout<<"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@!!!!!&&&&      Max Deviation: " << current_segment.bound.id_upper_bound_diff <<" , " << accumulate_segment.bound.id_point_max_deviation * current_segment.rectangle_width << endl;
	//	output_argument.evaluation_bound.difference_id_max_deviation_vs_height_diff += fabs(current_segment.bound.id_upper_bound_diff - accumulate_segment.bound.id_point_max_deviation);
	//	accumulate_segment.bound.id_upper_bound_diff = current_segment.bound.id_upper_bound_diff;
	//}
	//else {
	//	get_current_max_id(difference_map, accumulate_segment);
	//}
	/********************************************************************************************************************************************/
	long double sum_differece = 0;
	/*for (auto&& au : difference_map) {
		sum_differece += au.first;
	}*/
	sum_differece = difference_map.begin()->first;

	//accumulate_segment.segment_right_height_difference = max(current_segment.segment_right_height_difference, sum_differece);
	//cout << "Max deviation point: id: " << point_max_deviation.id << ". ( " << point_max_deviation.value << " , " << accumulate_segment.segment_right_height_difference * current_segment.rectangle_width << " ) accumulate\n";
	//assert(max_deviation <= accumulate_segment.bound.upper_bound_area);
	if (difference_map.begin()->second == 5) {
		vector<long double> difference_array(difference_map.size() + 1, INF);
		for (auto&& au : difference_map) {
			difference_array[au.second] = au.first;
		}

		assert(difference_array[5] <= difference_array[8]);
	}
	//cout << "Max Deviation: " << max_deviation << ", upper bound: " << accumulate_segment.bound.upper_bound_area << ", upper bound diff: " << accumulate_segment.bound.upper_bound_diff << endl;
	//cout << "Max Deviation: " << accumulate_segment.bound.upper_bound_area - max_deviation << endl;// << ", upper bound: " << accumulate_segment.bound.upper_bound_area << ", upper bound diff: " << accumulate_segment.bound.upper_bound_diff << endl;
	//if (max_deviation > 0 && accumulate_segment.bound.upper_bound_area > 0 && max_deviation > accumulate_segment.bound.upper_bound_area) {
		//if (accumulate_segment.bound.sum_deviation_real > 0 && accumulate_segment.bound.upper_bound_area > 0 && accumulate_segment.bound.sum_deviation_real > accumulate_segment.bound.upper_bound_area) {
		//cout << "Max Deviation: " << max_deviation << ", upper bound: " << accumulate_segment.bound.upper_bound_area << ", upper bound diff: " << accumulate_segment.bound.upper_bound_diff << endl;
		//cout << "Max Deviation: " << accumulate_segment.bound.sum_deviation_real << ", upper bound: " << accumulate_segment.bound.upper_bound_area << ", upper bound diff: " << accumulate_segment.bound.upper_bound_diff << endl;
		//assert(0);
	//}
#endif
	/*......................................................................................................................................*/

	return accumulate_segment.bound.upper_bound_area;
	/*||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||*/
}


//***********************************************************************
// Method: get_upper_bound_sub_segment_left_right
// Qualifier: get upper bound of sub left & right segment after splitting
// Input:  
// Output: 
// date: 210113 
// author:
//************************************************************************
TEMPLATE
template<typename T, typename Y, typename U>
inline void APLA::get_upper_bound_sub_segment_left_right(const vector<Y>& const original_time_series_vector, T& const left_segment, T& const right_segment, const T& const merged_segment, U& const output_argument) {
	/*........................................................................................................*/
#ifdef _DEBUG
	assert(!original_time_series_vector.empty());
	assert(left_segment.rectangle_width != INF && right_segment.rectangle_width != INF && merged_segment.rectangle_width != INF && left_segment.right_endpoint != INF && right_segment.right_endpoint != INF && merged_segment.right_endpoint != INF);
	assert(left_segment.apla.a != INF && right_segment.apla.a != INF && merged_segment.apla.a != INF && left_segment.apla.b != INF && right_segment.apla.b != INF && merged_segment.apla.b != INF);
	assert(left_segment.apla.a_minuend != INF && right_segment.apla.a_minuend != INF && merged_segment.apla.a_minuend != INF && left_segment.apla.b_minuend != INF && right_segment.apla.b_minuend != INF && merged_segment.apla.b_minuend != INF);
	assert(merged_segment.bound.upper_bound_area != -INF && merged_segment.bound.upper_bound_diff != -INF);
#endif
	/*........................................................................................................*/

	/***************  Merged Segment ****************/
	if (merged_segment.rectangle_width == 4) {
		left_segment.area_difference = 0;
		left_segment.bound.upper_bound_diff = 0;
		left_segment.bound.upper_bound_area = 0;

		right_segment.bound.upper_bound_diff = 0;
		right_segment.bound.upper_bound_area = 0;
		right_segment.area_difference = 0;

		return;
	}
	/************************************************/

	/*|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||          Segment Point       |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||*/

	/*=================================         PLA id of point in PLA reconstruction series       ====================================*/
	const long double& const value_right_segment_left_pla = (left_segment.rectangle_width - 1) * left_segment.apla.a + left_segment.apla.b;
	const long double& const value_right_segment_merge_pla_left = (left_segment.rectangle_width - 1) * merged_segment.apla.a + merged_segment.apla.b;
	const long double& const value_right_segment_right_pla = (right_segment.rectangle_width - 1) * right_segment.apla.a + right_segment.apla.b;
	const long double& const value_left_segment_merge_pla_right = left_segment.rectangle_width * merged_segment.apla.a + merged_segment.apla.b;
	const long double& const value_right_segment_merge_pla_right = (merged_segment.rectangle_width - 1) * merged_segment.apla.a + merged_segment.apla.b;
	/*==================================================================================================================================*/

	/*=============================Real id of point in original time series==========================*/
	const size_t id_left_end_left_seg = left_segment.right_endpoint - left_segment.rectangle_width + 1;
	const size_t id_left_end_right_seg = right_segment.right_endpoint - right_segment.rectangle_width + 1;
	/*===============================================================================================*/

	/*=============================          Compute triangle width        =======================================*/
	/*********************************   Left Segment    *********************************/
	long double max_point_difference_left = 0;
	max_point_difference_left = max(max_point_difference_left, fabs(left_segment.apla.b - original_time_series_vector[id_left_end_left_seg]));
	max_point_difference_left = max(max_point_difference_left, fabs(merged_segment.apla.b - original_time_series_vector[id_left_end_left_seg]));
	max_point_difference_left = max(max_point_difference_left, fabs(left_segment.apla.b - merged_segment.apla.b));
	max_point_difference_left = max(max_point_difference_left, fabs(value_right_segment_left_pla - original_time_series_vector[left_segment.right_endpoint]));
	max_point_difference_left = max(max_point_difference_left, fabs(value_right_segment_merge_pla_left - original_time_series_vector[left_segment.right_endpoint]));
	max_point_difference_left = max(max_point_difference_left, fabs(value_right_segment_left_pla - value_right_segment_merge_pla_left));
	/*************************************************************************************/

	/*********************************  Right Segment    *********************************/
	long double max_point_difference_right = 0;
	max_point_difference_right = max(max_point_difference_right, fabs(right_segment.apla.b - original_time_series_vector[id_left_end_right_seg]));
	max_point_difference_right = max(max_point_difference_right, fabs(value_left_segment_merge_pla_right - original_time_series_vector[id_left_end_right_seg]));
	max_point_difference_right = max(max_point_difference_right, fabs(right_segment.apla.b - value_left_segment_merge_pla_right));
	max_point_difference_right = max(max_point_difference_right, fabs(value_right_segment_right_pla - original_time_series_vector[right_segment.right_endpoint]));
	max_point_difference_right = max(max_point_difference_right, fabs(value_right_segment_merge_pla_right - original_time_series_vector[right_segment.right_endpoint]));
	max_point_difference_right = max(max_point_difference_right, fabs(value_right_segment_right_pla - value_right_segment_merge_pla_right));
	/************************************************************************************/
	/*============================================================================================================*/
	/*||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||*/

	left_segment.bound.upper_bound_diff = max_point_difference_left;// difference_map_left.begin()->first;
	left_segment.area_difference = left_segment.bound.upper_bound_area = left_segment.bound.upper_bound_diff * (left_segment.rectangle_width - 1);
	//left_segment.bound.upper_bound_area = left_segment.bound.upper_bound_diff * left_segment.rectangle_width;
	if (left_segment.rectangle_width == 2) left_segment.area_difference = left_segment.bound.upper_bound_area = left_segment.bound.upper_bound_diff = 0;

	right_segment.bound.upper_bound_diff = max_point_difference_right;// difference_map_right.begin()->first;
	right_segment.area_difference = right_segment.bound.upper_bound_area = right_segment.bound.upper_bound_diff * (right_segment.rectangle_width - 1);
	//right_segment.bound.upper_bound_area = right_segment.bound.upper_bound_diff * right_segment.rectangle_width;
	if (right_segment.rectangle_width == 2) right_segment.area_difference = right_segment.bound.upper_bound_area = right_segment.bound.upper_bound_diff = 0;

	/*..............................................................................................................................................*/
#ifdef _DEBUG
	/*=============================          Compute triangle width        =======================================*/
	map<const long double, const size_t, greater<long double>> difference_map_left, difference_map_right;
	/*********************************   Left Segment    *********************************/
	difference_map_left.try_emplace(fabs(left_segment.apla.b - original_time_series_vector[id_left_end_left_seg]), 0);//difference_ll_short_real
	difference_map_left.try_emplace(fabs(merged_segment.apla.b - original_time_series_vector[id_left_end_left_seg]), 1);//difference_ll_long_real
	difference_map_left.try_emplace(fabs(left_segment.apla.b - merged_segment.apla.b), 2);//difference_ll_short_long

	difference_map_left.try_emplace(fabs(value_right_segment_left_pla - original_time_series_vector[left_segment.right_endpoint]), 3);// difference_lr_short_real
	difference_map_left.try_emplace(fabs(value_right_segment_merge_pla_left - original_time_series_vector[left_segment.right_endpoint]), 4);//difference_lr_long_real
	difference_map_left.try_emplace(fabs(value_right_segment_left_pla - value_right_segment_merge_pla_left), 5);// difference_lr_short_long
	/*************************************************************************************/
	/*********************************  Right Segment    *********************************/
	difference_map_right.try_emplace(fabs(right_segment.apla.b - original_time_series_vector[id_left_end_right_seg]), 6);//difference_rl_short_real
	difference_map_right.try_emplace(fabs(value_left_segment_merge_pla_right - original_time_series_vector[id_left_end_right_seg]), 7);//difference_rl_long_real
	difference_map_right.try_emplace(fabs(right_segment.apla.b - value_left_segment_merge_pla_right), 8);//difference_rl_short_long

	difference_map_right.try_emplace(fabs(value_right_segment_right_pla - original_time_series_vector[right_segment.right_endpoint]), 9);//difference_rr_short_real
	difference_map_right.try_emplace(fabs(value_right_segment_merge_pla_right - original_time_series_vector[right_segment.right_endpoint]), 10);//difference_rr_long_real
	difference_map_right.try_emplace(fabs(value_right_segment_right_pla - value_right_segment_merge_pla_right), 11);//difference_rr_short_long
	/************************************************************************************/
	/*============================================================================================================*/
	/*=============          210112 Add minmax point difference                ===========*/
	/*const long double difference_min_point_left = left_segment.apla.a * (left_segment.min_point.id - real_point_C1.id) + left_segment.apla.b - left_segment.min_point.value;
	const long double difference_max_point_left = left_segment.apla.a * (left_segment.max_point.id - real_point_C1.id) + left_segment.apla.b - left_segment.max_point.value;
	difference_map.emplace(difference_min_point_left, 12);
	difference_map.emplace(difference_max_point_left, 13);

	const long double difference_min_point_right = right_segment.apla.a * (right_segment.min_point.id - real_point_C3.id) + right_segment.apla.b - right_segment.min_point.value;
	const long double difference_max_point_right = right_segment.apla.a * (right_segment.max_point.id - real_point_C3.id) + right_segment.apla.b - right_segment.max_point.value;
	difference_map.emplace(difference_min_point_right, 14);
	difference_map.emplace(difference_max_point_right, 15);

	const long double difference_min_point_merge = merged_segment.apla.a * (merged_segment.min_point.id - real_point_C1.id) + merged_segment.apla.b - merged_segment.min_point.value;
	const long double difference_max_point_merge = merged_segment.apla.a * (merged_segment.max_point.id - real_point_C1.id) + merged_segment.apla.b - merged_segment.max_point.value;
	difference_map.emplace(difference_min_point_merge, 16);
	difference_map.emplace(difference_max_point_merge, 17);*/
	/*====================================================================================*/

	///*-----------------    210123 if previous upper bound    -------------------*/
	//if (merged_segment.bound.upper_bound_diff > difference_map_left.begin()->first) {
	//	count_upper_bound_type(12, output_argument.evaluation_bound.map_bound_split);
	//}
	//else {
	//	count_upper_bound_type(difference_map_left.begin()->second, output_argument.evaluation_bound.map_bound_split);
	//}
	///*--------------------------------------------------------------------------*/

	///*-----------------    210123 if previous upper bound    -------------------*/
	//if (merged_segment.bound.upper_bound_diff > difference_map_right.begin()->first) {
	//	count_upper_bound_type(13, output_argument.evaluation_bound.map_bound_split);
	//}
	//else {
	//	count_upper_bound_type(difference_map_right.begin()->second, output_argument.evaluation_bound.map_bound_split);
	//}
	///*--------------------------------------------------------------------------*/
	//assert(left_segment.right_endpoint + right_segment.right_endpoint - right_segment.rectangle_width + 1);
	//double temp_right_endpoint_value = (merged_segment.rectangle_width - 1) * merged_segment.apla.a + merged_segment.apla.b;

	///*======================          Left          ======================*/
	//long double sum_deviation_left = 0;
	//long double max_deviation_left = -INF;
	//long double point_difference_left = INF;
	//long double point_difference_abs_left = INF;
	//long double point_difference_pow_left = INF;
	////typename GEOMETRY::POINT point_max_deviation;
	//for (int i = 0; i < left_segment.rectangle_width; i++) {
	//	point_difference_left = left_segment.apla.a * i + left_segment.apla.b - original_time_series_vector[left_segment.right_endpoint - left_segment.rectangle_width + 1 + i];
	//	point_difference_pow_left = pow(point_difference_left, 2.0);
	//	point_difference_abs_left = fabs(point_difference_left);
	//	sum_deviation_left += point_difference_pow_left;
	//	//max_deviation_left = max(max_deviation_left, point_difference_abs_left);
	//	if (max_deviation_left < point_difference_abs_left) {
	//		left_segment.bound.value_point_max_deviation = max_deviation_left = point_difference_abs_left;
	//		left_segment.bound.id_point_max_deviation = left_segment.right_endpoint - left_segment.rectangle_width + 1 + i;
	//	}
	//}
	//left_segment.bound.sum_deviation_real = sum_deviation_left = sqrt(sum_deviation_left);
	//long double sum_difference_left = 0;
	///*for (auto&& au: difference_map_left) {
	//	sum_difference_left += au.first;
	//}*/
	//sum_difference_left = difference_map_left.begin()->first;
	////left_segment.bound.upper_bound_diff = max(merged_segment.bound.upper_bound_diff, sum_difference_left);
	////assert(max_deviation_left <= left_segment.segment_right_height_difference * (left_segment.rectangle_width - 1));
	//if (max_deviation_left > 0 && left_segment.bound.upper_bound_area > 0 && max_deviation_left > left_segment.bound.upper_bound_area) {
	//	//if (left_segment.bound.sum_deviation_real > 0 && left_segment.bound.upper_bound_area > 0 && left_segment.bound.sum_deviation_real > left_segment.bound.upper_bound_area) {
	//	cout << "Left Max Deviation: " << max_deviation_left << ", upper bound: " << left_segment.bound.upper_bound_area << ", upper bound diff: " << left_segment.bound.upper_bound_diff << endl;
	//	cout << "Left Sum Deviation: " << left_segment.bound.sum_deviation_real << ", upper bound: " << left_segment.bound.upper_bound_area << ", upper bound diff: " << left_segment.bound.upper_bound_diff << endl;
	//	assert(0);
	//}
	///*=====================================================================*/
	////return merged_segment.bound.upper_bound_area;
	///*======================           Right         ======================*/
	//long double sum_deviation_right = 0;
	//long double max_deviation_right = -INF;
	//long double point_difference_right = INF;
	//long double point_difference_abs_right = INF;
	//long double point_difference_pow_right = INF;
	////typename GEOMETRY::POINT point_max_deviation;
	//for (int i = 0; i < right_segment.rectangle_width; i++) {
	//	point_difference_right = right_segment.apla.a * i + right_segment.apla.b - original_time_series_vector[right_segment.right_endpoint - right_segment.rectangle_width + 1 + i];
	//	point_difference_pow_right = pow(point_difference_right, 2.0);
	//	point_difference_abs_right = fabs(point_difference_right);
	//	sum_deviation_right += point_difference_pow_right;
	//	//max_deviation_right = max(max_deviation_right, point_difference_abs_right);
	//	if (max_deviation_right < point_difference_abs_right) {
	//		right_segment.bound.value_point_max_deviation = max_deviation_right = point_difference_abs_right;
	//		right_segment.bound.id_point_max_deviation = i + right_segment.right_endpoint - right_segment.rectangle_width + 1;
	//	}
	//}
	//right_segment.bound.sum_deviation_real = sum_deviation_right = sqrt(sum_deviation_right);
	//long double sum_difference_right = 0;
	///*for (auto&& au: difference_map_right) {
	//	sum_difference_right += au.first;
	//}*/
	//sum_difference_right = difference_map_right.begin()->first;

	////right_segment.bound.upper_bound_diff = max(merged_segment.bound.upper_bound_diff, sum_difference_right);

	////assert(max_deviation_right <= right_segment.segment_right_height_difference * (right_segment.rectangle_width - 1));
	//if (max_deviation_right > 0 && right_segment.bound.upper_bound_area > 0 && max_deviation_right > right_segment.bound.upper_bound_area) {
	////if (right_segment.bound.sum_deviation_real > 0 && right_segment.bound.upper_bound_area > 0 && right_segment.bound.sum_deviation_real > right_segment.bound.upper_bound_area) {
	//	cout << "Right Max Deviation: " << max_deviation_right << ", upper bound: " << right_segment.bound.upper_bound_area << ", upper bound diff: " << right_segment.bound.upper_bound_diff << endl;
	//	cout << "Right Sum Deviation: " << right_segment.bound.sum_deviation_real << ", upper bound: " << right_segment.bound.upper_bound_area << ", upper bound diff: " << right_segment.bound.upper_bound_diff << endl;
	//	assert(0);
	//}
	/*==================================================================*/
#endif
/*.................................................................................................................................................*/

}

//***************************************************************
// Method: get_line_segment_height_diference_with_original
// Qualifier:get endpoint of long segment and two short segments, compute height difference with original time series
// Input:  
// Output: 
// date: 200206 
// author:
//**************************************************************
TEMPLATE
template<typename T, typename Y, typename U>
inline long double APLA::get_line_segment_height_diference_with_original(const vector<Y>& const original_time_series_vector, const T& const left_segment, const  T& const right_segment, T& const merged_segment, U& const output_argument) {
	/*........................................................................................................*/
#ifdef _DEBUG
	assert(!original_time_series_vector.empty());
	assert(left_segment.rectangle_width != INF && right_segment.rectangle_width != INF && merged_segment.rectangle_width != INF && left_segment.right_endpoint != INF && right_segment.right_endpoint != INF && merged_segment.right_endpoint != INF);
	assert(left_segment.apla.a != INF && right_segment.apla.a != INF && merged_segment.apla.a != INF && left_segment.apla.b != INF && right_segment.apla.b != INF && merged_segment.apla.b != INF);
	assert(left_segment.apla.a_minuend != INF && right_segment.apla.a_minuend != INF && merged_segment.apla.a_minuend != INF && left_segment.apla.b_minuend != INF && right_segment.apla.b_minuend != INF && merged_segment.apla.b_minuend != INF);
	assert(left_segment.bound.upper_bound_diff != -INF && left_segment.bound.upper_bound_area != -INF && right_segment.bound.upper_bound_diff != -INF && right_segment.bound.upper_bound_area != -INF);
#endif
	/*........................................................................................................*/

	/*||||||||||||||||||||||||||||||||||||||||||||          Segment Point       |||||||||||||||||||||||||||||||||||||||||||||||||*/

	/*========================= PLA id of point in PLA reconstruction series ====================================*/
	const long double& const value_right_segment_left_pla = (left_segment.rectangle_width - 1) * left_segment.apla.a + left_segment.apla.b;
	const long double& const value_right_segment_merge_pla_left = (left_segment.rectangle_width - 1) * merged_segment.apla.a + merged_segment.apla.b;

	const long double& const value_right_segment_right_pla = (right_segment.rectangle_width - 1) * right_segment.apla.a + right_segment.apla.b;

	const long double& const value_left_segment_merge_pla_right = left_segment.rectangle_width * merged_segment.apla.a + merged_segment.apla.b;
	const long double& const value_right_segment_merge_pla_right = (merged_segment.rectangle_width - 1) * merged_segment.apla.a + merged_segment.apla.b;
	/*============================================================================================================*/

	/*=============================Real id of point in original time series=======================================*/
	const long double& const value_real_left_segment_left = original_time_series_vector[left_segment.right_endpoint - left_segment.rectangle_width + 1];
	const long double& const value_real_right_segment_left = original_time_series_vector[right_segment.right_endpoint - right_segment.rectangle_width + 1];
	/*============================================================================================================*/

	/*============================================================================================================*/
	long double max_point_difference = 0;
	max_point_difference = max(max_point_difference, fabs(left_segment.apla.b - value_real_left_segment_left));
	max_point_difference = max(max_point_difference, fabs(merged_segment.apla.b - value_real_left_segment_left));
	max_point_difference = max(max_point_difference, fabs(left_segment.apla.b - merged_segment.apla.b));
	max_point_difference = max(max_point_difference, fabs(value_right_segment_left_pla - original_time_series_vector[left_segment.right_endpoint]));
	max_point_difference = max(max_point_difference, fabs(value_right_segment_merge_pla_left - original_time_series_vector[left_segment.right_endpoint]));
	max_point_difference = max(max_point_difference, fabs(value_right_segment_left_pla - value_right_segment_merge_pla_left));
	max_point_difference = max(max_point_difference, fabs(right_segment.apla.b - value_real_right_segment_left));
	max_point_difference = max(max_point_difference, fabs(value_left_segment_merge_pla_right - value_real_right_segment_left));
	max_point_difference = max(max_point_difference, fabs(right_segment.apla.b - value_left_segment_merge_pla_right));
	max_point_difference = max(max_point_difference, fabs(value_right_segment_right_pla - original_time_series_vector[right_segment.right_endpoint]));
	max_point_difference = max(max_point_difference, fabs(value_right_segment_merge_pla_right - original_time_series_vector[right_segment.right_endpoint]));
	max_point_difference = max(max_point_difference, fabs(value_right_segment_right_pla - value_right_segment_merge_pla_right));
	/*============================================================================================================*/

	/*=============          210112 Add minmax point difference                ===========*/
	/*const long double difference_min_point_left = left_segment.apla.a * (left_segment.min_point.id - real_point_C1.id) + left_segment.apla.b - left_segment.min_point.value;
	const long double difference_max_point_left = left_segment.apla.a * (left_segment.max_point.id - real_point_C1.id) + left_segment.apla.b - left_segment.max_point.value;
	difference_map.emplace(difference_min_point_left, 12);
	difference_map.emplace(difference_max_point_left, 13);

	const long double difference_min_point_right = right_segment.apla.a * (right_segment.min_point.id - real_point_C3.id) + right_segment.apla.b - right_segment.min_point.value;
	const long double difference_max_point_right = right_segment.apla.a * (right_segment.max_point.id - real_point_C3.id) + right_segment.apla.b - right_segment.max_point.value;
	difference_map.emplace(difference_min_point_right, 14);
	difference_map.emplace(difference_max_point_right, 15);

	const long double difference_min_point_merge = merged_segment.apla.a * (merged_segment.min_point.id - real_point_C1.id) + merged_segment.apla.b - merged_segment.min_point.value;
	const long double difference_max_point_merge = merged_segment.apla.a * (merged_segment.max_point.id - real_point_C1.id) + merged_segment.apla.b - merged_segment.max_point.value;
	difference_map.emplace(difference_min_point_merge, 16);
	difference_map.emplace(difference_max_point_merge, 17);*/
	/*====================================================================================*/
	/*||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||*/

	//merged_segment.bound.upper_bound_diff = max(max(left_segment.bound.upper_bound_diff, right_segment.bound.upper_bound_diff), sum_differece);
	merged_segment.bound.upper_bound_diff = max_point_difference;// difference_map.begin()->first;
	merged_segment.area_difference = merged_segment.bound.upper_bound_area = merged_segment.bound.upper_bound_diff * (merged_segment.rectangle_width - 1);
	//merged_segment.bound.upper_bound_area = merged_segment.bound.upper_bound_diff * merged_segment.rectangle_width;

	/*............................................................................................................................................................................................*/
#ifdef _DEBUG

	/*=============================          Compute triangle width        =======================================*/
	map<const long double, const size_t, greater<long double>> difference_map;

	difference_map.try_emplace(fabs(left_segment.apla.b - value_real_left_segment_left), 0);//difference_ll_short_real
	difference_map.try_emplace(fabs(merged_segment.apla.b - value_real_left_segment_left), 1);//difference_ll_long_real
	difference_map.try_emplace(fabs(left_segment.apla.b - merged_segment.apla.b), 2);//difference_ll_short_long

	difference_map.try_emplace(fabs(value_right_segment_left_pla - original_time_series_vector[left_segment.right_endpoint]), 3);//difference_lr_short_real
	difference_map.try_emplace(fabs(value_right_segment_merge_pla_left - original_time_series_vector[left_segment.right_endpoint]), 4);//difference_lr_long_real
	difference_map.try_emplace(fabs(value_right_segment_left_pla - value_right_segment_merge_pla_left), 5);//difference_lr_short_long

	difference_map.try_emplace(fabs(right_segment.apla.b - value_real_right_segment_left), 6);//difference_rl_short_real
	difference_map.try_emplace(fabs(value_left_segment_merge_pla_right - value_real_right_segment_left), 7);//difference_rl_long_real
	difference_map.try_emplace(fabs(right_segment.apla.b - value_left_segment_merge_pla_right), 8);//difference_rl_short_long

	difference_map.try_emplace(fabs(value_right_segment_right_pla - original_time_series_vector[right_segment.right_endpoint]), 9);//difference_rr_short_real
	difference_map.try_emplace(fabs(value_right_segment_merge_pla_right - original_time_series_vector[right_segment.right_endpoint]), 10);//difference_rr_long_real
	difference_map.try_emplace(fabs(value_right_segment_right_pla - value_right_segment_merge_pla_right), 11);//difference_rr_short_long
	/*============================================================================================================*/

	/*-----------------    210123 if previous upper bound    -------------------*/
	//if (left_segment.bound.upper_bound_diff > difference_map.begin()->first) {
	//	count_upper_bound_type(12, output_argument.evaluation_bound.map_bound_merge);
	//}
	//else if(right_segment.bound.upper_bound_diff > difference_map.begin()->first) {
	//	count_upper_bound_type(13, output_argument.evaluation_bound.map_bound_merge);
	//}
	//else {
	//	count_upper_bound_type(difference_map.begin()->second, output_argument.evaluation_bound.map_bound_merge);
	//}
	///*--------------------------------------------------------------------------*/

	//assert(left_segment.right_endpoint + right_segment.right_endpoint - right_segment.rectangle_width + 1);
	//double temp_right_endpoint_value = (merged_segment.rectangle_width - 1) * merged_segment.apla.a + merged_segment.apla.b;

	//long double sum_differece = 0;
	///*for (auto&& au: difference_map) {
	//	sum_differece += au.first;
	//}*/
	//sum_differece = difference_map.begin()->first;

	//long double sum_deviation = 0;
	//long double max_deviation = -INF;
	//long double point_difference = INF;
	//long double point_difference_abs = INF;
	//long double point_difference_pow = INF;
	//long double difference_no_fabs = 0;
	////typename GEOMETRY::POINT point_max_deviation;

	//for (int i = 0; i < merged_segment.rectangle_width; i++) {

	//	point_difference = merged_segment.apla.a * i + merged_segment.apla.b - original_time_series_vector[left_segment.right_endpoint - left_segment.rectangle_width + 1 + i];
	//	difference_no_fabs += point_difference;
	//	point_difference_pow = pow(point_difference, 2.0);
	//	point_difference_abs = fabs(point_difference);
	//	sum_deviation += point_difference_pow;
	//	//max_deviation = max(max_deviation, point_difference_abs);
	//	if (max_deviation < point_difference_abs) {
	//		merged_segment.bound.value_point_max_deviation = max_deviation = point_difference_abs;
	//		merged_segment.bound.id_point_max_deviation = i + left_segment.right_endpoint - left_segment.rectangle_width + 1;
	//	}

	//}
	//assert(fabs(difference_no_fabs) < 0.00000001);
	//merged_segment.bound.sum_deviation_real = sum_deviation = sqrt(sum_deviation);
	////assert(max_deviation <= merged_segment.segment_right_height_difference * (merged_segment.rectangle_width - 1));
	//if (max_deviation > 0 && merged_segment.bound.upper_bound_area > 0 && max_deviation > merged_segment.bound.upper_bound_area) {
	////if (merged_segment.bound.sum_deviation_real > 0 && merged_segment.bound.upper_bound_area > 0 && merged_segment.bound.sum_deviation_real > merged_segment.bound.upper_bound_area) {
	//	cout << "Merge Max Deviation: " << max_deviation << ", upper bound: " << merged_segment.bound.upper_bound_area << ", upper bound diff: " << merged_segment.bound.upper_bound_diff << endl;
	//	cout << "Merge Sum Deviation: " << merged_segment.bound.sum_deviation_real << ", upper bound: " << merged_segment.bound.upper_bound_area << ", upper bound diff: " << merged_segment.bound.upper_bound_diff << endl;
	//	assert(0);
	//}
#endif
	/*............................................................................................................................................................................................*/

	return merged_segment.bound.upper_bound_area;
}


//***************************************************************
// Method: get_upper_bound_move_endpoint
// Qualifier: After optimization. get upper bound when increase/decrease, left/right endpoint
// Input:  
// Output: 
// date: 210114
// author:
//**************************************************************
TEMPLATE
template<typename T, typename Y, typename U>
inline long double APLA::get_upper_bound_move_endpoint(const vector<Y>& const original_time_series_vector, const T& const segment_original, T& const segment_move, U& const output_argument) {
	/*.........................................................................................................................................................................*/
#ifdef _DEBUG
	//assert(current_segment.rectangle_width + 1 == accumulate_segment.rectangle_width); //&& current_segment.right_endpoint + 1 == accumulate_segment.right_endpoint);
	assert(segment_original.rectangle_width != INF && segment_move.rectangle_width != INF && segment_original.right_endpoint != INF && segment_move.right_endpoint != INF);
	assert_segment_a_b(segment_original);
	assert_segment_a_b(segment_move);
	assert(segment_original.bound.upper_bound_area != -INF && segment_original.bound.upper_bound_diff != -INF);
#endif
	/*..........................................................................................................................................................................*/

	if (segment_move.rectangle_width < 3) {//==2
		segment_move.area_difference = segment_move.bound.upper_bound_area = segment_move.bound.upper_bound_diff = 0;

		return segment_move.bound.upper_bound_area;
	}

	//map<const long double, const size_t, greater<long double>> difference_map;
	long double max_point_difference = 0;

	if (segment_move.right_endpoint != segment_original.right_endpoint) {// move right endpoint
		/*.....................................................................................................................................*/
#ifdef _DEBUG
		assert(segment_move.right_endpoint - segment_move.rectangle_width == segment_original.right_endpoint - segment_original.rectangle_width);
#endif
		/*......................................................................................................................................*/

		if (segment_move.rectangle_width < segment_original.rectangle_width) {// decrease right
			/*.....................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_move.rectangle_width + 1 == segment_original.rectangle_width && segment_move.right_endpoint + 1 == segment_original.right_endpoint);
#endif
			/*......................................................................................................................................*/

			max_point_difference = max(max_point_difference, fabs(segment_move.rectangle_width * segment_original.apla.a + segment_original.apla.b - original_time_series_vector[segment_original.right_endpoint]));
			max_point_difference = max(max_point_difference, fabs(segment_move.rectangle_width * segment_move.apla.a + segment_move.apla.b - original_time_series_vector[segment_original.right_endpoint]));
			max_point_difference = max(max_point_difference, fabs((segment_move.rectangle_width - 1) * segment_original.apla.a + segment_original.apla.b - original_time_series_vector[segment_move.right_endpoint]));
			max_point_difference = max(max_point_difference, fabs((segment_move.rectangle_width - 1) * segment_move.apla.a + segment_move.apla.b - original_time_series_vector[segment_move.right_endpoint]));

			/*------------------------------------------------*/
			//difference_map.try_emplace(fabs(segment_move.rectangle_width * segment_original.apla.a + segment_original.apla.b - original_time_series_vector[segment_original.right_endpoint]), 6);//difference_accumulate_right_current_real
			//difference_map.try_emplace(fabs(segment_move.rectangle_width * segment_move.apla.a + segment_move.apla.b - original_time_series_vector[segment_original.right_endpoint]), 7);//difference_accumulate_right_accumulate_real
			////difference_map.emplace(fabs(value_point_original_right - value_point_move_right_next), 8);//difference_accumulate_right_accumulate_current

			//difference_map.try_emplace(fabs((segment_move.rectangle_width - 1) * segment_original.apla.a + segment_original.apla.b - original_time_series_vector[segment_move.right_endpoint]), 3);//difference_current_right_current_real
			//difference_map.try_emplace(fabs((segment_move.rectangle_width - 1) * segment_move.apla.a + segment_move.apla.b - original_time_series_vector[segment_move.right_endpoint]), 4);//difference_current_right_accumulate_real
			//difference_map.emplace(fabs(value_point_original_right_prev - value_point_move_right), 5);//difference_current_right_accumulate_current
			/*------------------------------------------------*/
		}
		else {// increase right
			/*.....................................................................................................................................*/
#ifdef _DEBUG
			assert(segment_move.rectangle_width == segment_original.rectangle_width + 1 && segment_move.right_endpoint == segment_original.right_endpoint + 1);
#endif
			/*......................................................................................................................................*/

			const long double& const value_point_original_right_next = segment_original.rectangle_width * segment_original.apla.a + segment_original.apla.b;
			const long double& const value_point_move_right = segment_original.rectangle_width * segment_move.apla.a + segment_move.apla.b;
			const long double& const value_point_original_right = (segment_original.rectangle_width - 1) * segment_original.apla.a + segment_original.apla.b;
			const long double& const value_point_move_right_prev = (segment_original.rectangle_width - 1) * segment_move.apla.a + segment_move.apla.b;

			max_point_difference = max(max_point_difference, fabs(value_point_original_right_next - original_time_series_vector[segment_move.right_endpoint]));
			max_point_difference = max(max_point_difference, fabs(value_point_move_right - original_time_series_vector[segment_move.right_endpoint]));
			max_point_difference = max(max_point_difference, fabs(value_point_original_right_next - value_point_move_right));
			max_point_difference = max(max_point_difference, fabs(value_point_original_right - original_time_series_vector[segment_original.right_endpoint]));
			max_point_difference = max(max_point_difference, fabs(value_point_move_right_prev - original_time_series_vector[segment_original.right_endpoint]));
			max_point_difference = max(max_point_difference, fabs(value_point_original_right - value_point_move_right_prev));

			/*------------------------------------------------*/
			//difference_map.try_emplace(fabs(value_point_original_right_next - original_time_series_vector[segment_move.right_endpoint]), 6);//difference_accumulate_right_current_real
			//difference_map.try_emplace(fabs(value_point_move_right - original_time_series_vector[segment_move.right_endpoint]), 7);//difference_accumulate_right_accumulate_real
			//difference_map.try_emplace(fabs(value_point_original_right_next - value_point_move_right), 8);//difference_accumulate_right_accumulate_current

			//difference_map.try_emplace(fabs(value_point_original_right - original_time_series_vector[segment_original.right_endpoint]), 3);//difference_current_right_current_real
			//difference_map.try_emplace(fabs(value_point_move_right_prev - original_time_series_vector[segment_original.right_endpoint]), 4);//difference_current_right_accumulate_real
			//difference_map.try_emplace(fabs(value_point_original_right - value_point_move_right_prev), 5);//difference_current_right_accumulate_current
			/*------------------------------------------------*/
		}

		const size_t& const id_segment_left = segment_original.right_endpoint - segment_original.rectangle_width + 1;

		max_point_difference = max(max_point_difference, fabs(segment_original.apla.b - original_time_series_vector[id_segment_left]));
		max_point_difference = max(max_point_difference, fabs(segment_move.apla.b - original_time_series_vector[id_segment_left]));

		/*------------------------------------------------*/
		//difference_map.try_emplace(fabs(segment_original.apla.b - original_time_series_vector[id_segment_left]), 0);//difference_left_current_real
		//difference_map.try_emplace(fabs(segment_move.apla.b - original_time_series_vector[id_segment_left]), 1);//difference_left_accumulate_real
		//difference_map.emplace(fabs(segment_move.apla.b - segment_original.apla.b), 2);//difference_left_accumulate_current
		/*------------------------------------------------*/
	}
	else {// move left endpoint
		/*....................................................................*/
#ifdef _DEBUG
		assert(segment_move.right_endpoint == segment_original.right_endpoint);
#endif
		/*....................................................................*/

		const long double& const value_point_original_right = (segment_original.rectangle_width - 1) * segment_original.apla.a + segment_original.apla.b;
		const long double& const value_point_move_right = (segment_move.rectangle_width - 1) * segment_move.apla.a + segment_move.apla.b;

		max_point_difference = max(max_point_difference, fabs(value_point_original_right - original_time_series_vector[segment_original.right_endpoint]));
		max_point_difference = max(max_point_difference, fabs(value_point_move_right - original_time_series_vector[segment_original.right_endpoint]));
		max_point_difference = max(max_point_difference, fabs(value_point_original_right - value_point_move_right));

		/*------------------------------------------------*/
		//difference_map.try_emplace(fabs(value_point_original_right - original_time_series_vector[segment_original.right_endpoint]), 6);//difference_accumulate_right_current_real
		//difference_map.try_emplace(fabs(value_point_move_right - original_time_series_vector[segment_original.right_endpoint]), 7);//difference_accumulate_right_accumulate_real
		//difference_map.try_emplace(fabs(value_point_original_right - value_point_move_right), 8);//difference_accumulate_right_accumulate_current
		/*------------------------------------------------*/

		if (segment_move.rectangle_width < segment_original.rectangle_width) {// decrease left
			/*.............................................................................*/
#ifdef _DEBUG
			assert(segment_move.rectangle_width + 1 == segment_original.rectangle_width);
#endif
			/*.............................................................................*/

			const size_t& const id_original_left = segment_move.right_endpoint - segment_move.rectangle_width;

			max_point_difference = max(max_point_difference, fabs(segment_original.apla.b - original_time_series_vector[id_original_left]));
			max_point_difference = max(max_point_difference, fabs(segment_move.apla.b - segment_move.apla.a - original_time_series_vector[id_original_left]));
			max_point_difference = max(max_point_difference, fabs(segment_move.apla.b - segment_move.apla.a - segment_original.apla.b));
			max_point_difference = max(max_point_difference, fabs(segment_original.apla.a + segment_original.apla.b - original_time_series_vector[id_original_left + 1]));
			max_point_difference = max(max_point_difference, fabs(segment_move.apla.b - original_time_series_vector[id_original_left + 1]));
			max_point_difference = max(max_point_difference, fabs(segment_original.apla.a + segment_original.apla.b - segment_move.apla.b));

			/*------------------------------------------------*/
			//difference_map.try_emplace(fabs(segment_original.apla.b - original_time_series_vector[id_original_left]), 0);//difference_left_current_real
			//difference_map.try_emplace(fabs(segment_move.apla.b - segment_move.apla.a - original_time_series_vector[id_original_left]), 1);//difference_left_accumulate_real a * -1 + b = b - a
			//difference_map.try_emplace(fabs(segment_move.apla.b - segment_move.apla.a - segment_original.apla.b), 2);//difference_left_accumulate_current

			//difference_map.try_emplace(fabs(segment_original.apla.a + segment_original.apla.b - original_time_series_vector[id_original_left + 1]), 3);//difference_current_right_current_real
			//difference_map.try_emplace(fabs(segment_move.apla.b - original_time_series_vector[id_original_left + 1]), 4);//difference_current_right_accumulate_real
			//difference_map.try_emplace(fabs(segment_original.apla.a + segment_original.apla.b - segment_move.apla.b), 5);//difference_current_right_accumulate_current
			/*------------------------------------------------*/
		}
		else {// increase left
			/*.............................................................................*/
#ifdef _DEBUG
			assert(segment_move.rectangle_width == segment_original.rectangle_width + 1);
#endif
			/*.............................................................................*/

			const size_t& const id_move_left = segment_original.right_endpoint - segment_original.rectangle_width;

			max_point_difference = max(max_point_difference, fabs(segment_original.apla.b - segment_original.apla.a - original_time_series_vector[id_move_left]));
			max_point_difference = max(max_point_difference, fabs(segment_move.apla.b - original_time_series_vector[id_move_left]));
			max_point_difference = max(max_point_difference, fabs(segment_original.apla.b - segment_original.apla.a - segment_move.apla.b));
			max_point_difference = max(max_point_difference, fabs(segment_original.apla.b - original_time_series_vector[id_move_left + 1]));
			max_point_difference = max(max_point_difference, fabs(segment_move.apla.a + segment_move.apla.b - original_time_series_vector[id_move_left + 1]));
			max_point_difference = max(max_point_difference, fabs(segment_move.apla.a + segment_move.apla.b - segment_original.apla.b));

			/*------------------------------------------------*/
			//difference_map.try_emplace(fabs(segment_original.apla.b - segment_original.apla.a - original_time_series_vector[id_move_left]), 0);//difference_left_current_real
			//difference_map.try_emplace(fabs(segment_move.apla.b  - original_time_series_vector[id_move_left]), 1);//difference_left_accumulate_real a * -1 + b = b - a
			//difference_map.try_emplace(fabs(segment_original.apla.b - segment_original.apla.a - segment_move.apla.b), 2);//difference_left_accumulate_current
			//difference_map.try_emplace(fabs(segment_original.apla.b - original_time_series_vector[id_move_left + 1]), 3);//difference_current_right_current_real
			//difference_map.try_emplace(fabs(segment_move.apla.a + segment_move.apla.b - original_time_series_vector[id_move_left + 1]), 4);//difference_current_right_accumulate_real
			//difference_map.try_emplace(fabs(segment_move.apla.a + segment_move.apla.b - segment_original.apla.b), 5);//difference_current_right_accumulate_current
			/*------------------------------------------------*/
		}
	}

	//segment_move.bound.upper_bound_diff = difference_map.begin()->first;
	//segment_move.bound.upper_bound_diff = max(segment_original.bound.upper_bound_diff, difference_map.begin()->first);
	segment_move.bound.upper_bound_diff = max(segment_original.bound.upper_bound_diff, max_point_difference);
	segment_move.area_difference = segment_move.bound.upper_bound_area = segment_move.bound.upper_bound_diff * (segment_move.rectangle_width - 1);
	//segment_move.bound.upper_bound_area = segment_move.bound.upper_bound_diff * segment_move.rectangle_width;

	/*=============          210112 Add minmax point difference                ===========*/
	//const long double difference_min_point_current = current_segment.apla.a * (current_segment.min_point.id - endpoint_segment_left) + current_segment.apla.b - current_segment.min_point.value;
	//const long double difference_max_point_current = current_segment.apla.a * (current_segment.max_point.id - endpoint_segment_left) + current_segment.apla.b - current_segment.max_point.value;
	//difference_map.emplace(difference_min_point_current, 9);
	//difference_map.emplace(difference_max_point_current, 10);

	//const long double difference_min_point_accumulate = accumulate_segment.apla.a * (accumulate_segment.min_point.id - endpoint_segment_left) + accumulate_segment.apla.b - accumulate_segment.min_point.value;
	//const long double difference_max_point_accumulate = accumulate_segment.apla.a * (accumulate_segment.max_point.id - endpoint_segment_left) + accumulate_segment.apla.b - accumulate_segment.max_point.value;
	//difference_map.emplace(difference_min_point_accumulate, 11);
	//difference_map.emplace(difference_max_point_accumulate, 12);
	/*====================================================================================*/

	/*..........................................................................................................................................................................................................*/
#ifdef _DEBUG

	assert_segment_bound(original_time_series_vector, segment_original);
	assert_segment_bound(original_time_series_vector, segment_move);

	/*-----------------    210123 if previous upper bound    -------------------*/
	//if (segment_original.bound.upper_bound_diff > difference_map.begin()->first) {
	//	count_upper_bound_type(9, output_argument.evaluation_bound.map_bound_move);
	//}
	//else {
	//	count_upper_bound_type(difference_map.begin()->second, output_argument.evaluation_bound.map_bound_move);
	//}
	///*--------------------------------------------------------------------------*/
	//long double sum_deviation = 0;
	//long double max_deviation = -INF;
	//long double point_difference = INF;
	//long double point_difference_abs = INF;
	//long double point_difference_pow = INF;
	////typename GEOMETRY::POINT point_max_deviation;
	//for (int i = 0; i < segment_move.rectangle_width; i++) {
	//	point_difference = segment_move.apla.a * i + segment_move.apla.b - original_time_series_vector[segment_move.right_endpoint - segment_move.rectangle_width + 1 + i];
	//	point_difference_pow = pow(point_difference, 2.0);
	//	point_difference_abs = fabs(point_difference);
	//	sum_deviation += point_difference_pow;
	//	//max_deviation = max(max_deviation, point_difference_abs);
	//	if (max_deviation < point_difference_abs) {
	//		segment_move.bound.value_point_max_deviation = max_deviation = point_difference_abs;
	//		segment_move.bound.id_point_max_deviation = segment_move.right_endpoint - segment_move.rectangle_width + 1 + i;
	//	}
	//}
	//segment_move.bound.sum_deviation_real = sum_deviation = sqrt(sum_deviation);

	//long double sum_differece = 0;
	///*for (auto&& au : difference_map) {
	//	sum_differece += au.first;
	//}*/

	//sum_differece = difference_map.begin()->first;

	////accumulate_segment.segment_right_height_difference = max(current_segment.segment_right_height_difference, sum_differece);
	////cout << "Max deviation point: id: " << point_max_deviation.id << ". ( " << point_max_deviation.value << " , " << accumulate_segment.segment_right_height_difference * current_segment.rectangle_width << " ) accumulate\n";
	////assert(max_deviation <= accumulate_segment.bound.upper_bound_area);

	//if (max_deviation > 0 && segment_move.bound.upper_bound_area > 0 && max_deviation > segment_move.bound.upper_bound_area) {
	////if (segment_move.bound.sum_deviation_real > 0 && segment_move.bound.upper_bound_area > 0 && segment_move.bound.sum_deviation_real > segment_move.bound.upper_bound_area) {
	//	cout << "Optimization Max Deviation: " << max_deviation << ", upper bound: " << segment_move.bound.upper_bound_area << ", upper bound diff: " << segment_move.bound.upper_bound_diff << endl;
	//	cout << "Optimization Sum Deviation: " << segment_move.bound.sum_deviation_real << ", upper bound: " << segment_move.bound.upper_bound_area << ", upper bound diff: " << segment_move.bound.upper_bound_diff << endl;
	//	assert(0);
	//}
#endif
	/*................................................................................................................................................................................*/

	return segment_move.bound.upper_bound_area;
}

//210121
//***************************************************************
// Method: count_upper_bound_type
// Qualifier: count the number of upper bound
// Input:  
// Output: 
// date: 210115
// author:
//**************************************************************
TEMPLATE
template<typename T, typename Y>
inline void APLA::count_upper_bound_type(const T upper_bound_type, Y& const map_upper_bound) {

	auto find_type = map_upper_bound.find(upper_bound_type);

	if (find_type != map_upper_bound.end()) {
		find_type->second++;
	}
	else {
		map_upper_bound.emplace(upper_bound_type, 1);
	}
}

//210122
TEMPLATE
template<typename T, typename Y>
void APLA::merge_map_with_same_key(const T& const map_target, Y& const map_result) {
	for (auto it = map_target.begin(); it != map_target.end(); ++it) {
		if (map_result[it->first])
			map_result[it->first] += it->second;
		else
			map_result[it->first] = it->second;
	}
}

//***************************************************************
// Method: count_upper_bound_whole
// Qualifier: count whole result of bound evaluation
// Input:  
// Output: 
// date: 210115
// author:
//**************************************************************
TEMPLATE
template<typename T, typename Y>
inline void APLA::count_upper_bound_whole(const T& const output_argument, Y& const evaluation_bound_whole) {

	merge_map_with_same_key(output_argument.evaluation_bound.map_bound_increment, evaluation_bound_whole.map_bound_increment);

	merge_map_with_same_key(output_argument.evaluation_bound.map_bound_merge, evaluation_bound_whole.map_bound_merge);

	merge_map_with_same_key(output_argument.evaluation_bound.map_bound_split, evaluation_bound_whole.map_bound_split);

	merge_map_with_same_key(output_argument.evaluation_bound.map_bound_move, evaluation_bound_whole.map_bound_move);

}

//210122
TEMPLATE
template<typename T>
void APLA::print_count_of_upper_bound(const T& const evaluation_bound) {

	cout << "Upper Bound Increment: ";
	TOOL::print_map(evaluation_bound.map_bound_increment);
	cout << "Upper Bound Merge: ";
	TOOL::print_map(evaluation_bound.map_bound_merge);
	cout << "Upper Bound Split: ";
	TOOL::print_map(evaluation_bound.map_bound_split);
	cout << "Upper Bound Move: ";
	TOOL::print_map(evaluation_bound.map_bound_move);
	cout << "Max Deviaiton id difference: " << evaluation_bound.difference_id_max_deviation_vs_height_diff << endl;

}

//210126
TEMPLATE
template<typename T, typename Y>
inline void APLA::get_current_max_id(const T& const map_result, Y& const temp_coefficient) {
	const size_t endpoint_segment_left = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;

	switch (map_result.begin()->second) {
	case 0:
	case 1:
	case 2:
		temp_coefficient.bound.id_upper_bound_diff = endpoint_segment_left;
		break;
	case 3:
	case 4:
	case 5:
		temp_coefficient.bound.id_upper_bound_diff = temp_coefficient.right_endpoint - 1;
		break;
	case 6:
	case 7:
	case 8:
		temp_coefficient.bound.id_upper_bound_diff = temp_coefficient.right_endpoint;
		break;
	default:
		assert(0);
	}
}

//210115 Not INF
//***************************************************************
// Method: assert_segment_bound
// Qualifier:
// Input:  
// Output: 
// date: 210115
// author:
//**************************************************************
TEMPLATE
template<typename T>
inline bool APLA::assert_segment_bound(const T& const temp_coefficient) {
	assert(temp_coefficient.bound.upper_bound_area != -INF && temp_coefficient.bound.upper_bound_diff != -INF && temp_coefficient.bound.upper_bound_area == temp_coefficient.area_difference);
	return true;
}

//***************************************************************
// Method: assert_segment_bound
// Qualifier:
// Input:  
// Output: 
// date: 210115
// author:
//**************************************************************
TEMPLATE
template<typename T, typename Y>
inline bool APLA::assert_segment_bound(const vector<Y>& const original_time_series_vector, const T& const temp_coefficient) {
	assert_segment_a_b(temp_coefficient);
	assert_segment_bound(temp_coefficient);

	if (temp_coefficient.rectangle_width == 2) {
		assert(temp_coefficient.bound.upper_bound_area == 0 && temp_coefficient.bound.upper_bound_diff == 0 && temp_coefficient.bound.upper_bound_area == temp_coefficient.area_difference);
		return true;
	}

	long double sum_deviation = 0;
	size_t id_max_deviation = NULL;
	long double max_deviation = -INF;
	long double point_difference = INF;
	long double point_difference_abs = INF;
	long double point_difference_pow = INF;
	//typename GEOMETRY::POINT point_max_deviation;
	for (int i = 0; i < temp_coefficient.rectangle_width; i++) {
		point_difference = temp_coefficient.apla.a * i + temp_coefficient.apla.b - original_time_series_vector[temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1 + i];
		point_difference_pow = pow(point_difference, 2.0);
		point_difference_abs = fabs(point_difference);
		sum_deviation += point_difference_pow;
		//max_deviation = max(max_deviation, point_difference_abs);
		if (max_deviation < point_difference_abs) {
			max_deviation = point_difference_abs;
			id_max_deviation = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1 + i;
		}
	}
	sum_deviation = sqrt(sum_deviation);

	//accumulate_segment.segment_right_height_difference = max(current_segment.segment_right_height_difference, sum_differece);
	//cout << "Max deviation point: id: " << point_max_deviation.id << ". ( " << point_max_deviation.value << " , " << accumulate_segment.segment_right_height_difference * current_segment.rectangle_width << " ) accumulate\n";
	//assert(max_deviation <= accumulate_segment.bound.upper_bound_area);
	if (temp_coefficient.rectangle_width > 3 && max_deviation > 0 && temp_coefficient.bound.upper_bound_area > 0 && max_deviation > temp_coefficient.bound.upper_bound_area) {
		cout << "!!!! Upper Bound Wrong \n";
		cout << "Max Deviation: " << max_deviation << ", upper bound: " << temp_coefficient.bound.upper_bound_area << ", upper bound diff: " << temp_coefficient.bound.upper_bound_diff;

		max_deviation = -INF;
		vector<long double> original_time_series_part_vector;
		vector<long double> reconstructet_time_series_vector;

		for (int i = 0; i < temp_coefficient.rectangle_width; i++) {
			original_time_series_part_vector.emplace_back(original_time_series_vector[temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1 + i]);
			reconstructet_time_series_vector.emplace_back(temp_coefficient.apla.a * i + temp_coefficient.apla.b);

			point_difference = temp_coefficient.apla.a * i + temp_coefficient.apla.b - original_time_series_vector[temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1 + i];
			point_difference_pow = pow(point_difference, 2.0);
			point_difference_abs = fabs(point_difference);
			sum_deviation += point_difference_pow;
			//max_deviation = max(max_deviation, point_difference_abs);
			if (max_deviation < point_difference_abs) {
				max_deviation = point_difference_abs;
				id_max_deviation = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1 + i;
			}
		}

		cout << "origintal ";
		TOOL::print_vector(original_time_series_part_vector);
		cout << "reconstructed ";
		TOOL::print_vector(reconstructet_time_series_vector);
		assert(0);
		return false;
	}

	return true;
}

//210115
TEMPLATE
template<typename T, typename Y>
inline bool APLA::assert_bound(const vector<Y>& const original_time_series_vector, const DoublyLinkedList<T>& const doubly_linked_list) {
	for (auto&& au : doubly_linked_list) {
		assert_segment_bound(original_time_series_vector, au);
	}
	return true;
}

//***************************************************************
// Method: getPLAMinMaxAreaDifference
// Qualifier:count Already know a&b right_endpoint and width
// Get area density of every segment by PLA line
// Input:  left & right & temp segment, a&b, (left & right)min max point, width, right endpoint,
// Output: PLA, minmax width area difference, temp segment min&max point
// date: 190724
// author:
//**************************************************************
TEMPLATE
inline double& APLA::getPLAMinMaxAreaDifference(vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient) {//190724
	int left_id = vector_id - 1;

#ifdef _DEBUG
	assert(left_id > -1);
	assert(area_vector[left_id].min_point.id != INF && area_vector[vector_id].min_point.id != INF && area_vector[left_id].max_point.id != INF && area_vector[vector_id].max_point.id != INF);
	assert(area_vector[left_id].min_point.value != INF && area_vector[vector_id].min_point.value != INF && area_vector[left_id].max_point.value != INF && area_vector[vector_id].max_point.value != INF);
	assert(area_vector[left_id].rectangle_width != INF && area_vector[vector_id].rectangle_width != INF && temp_coefficient.rectangle_width != INF && area_vector[left_id].right_endpoint != INF && area_vector[vector_id].right_endpoint != INF && temp_coefficient.right_endpoint != INF);
	assert(area_vector[left_id].apla.a != INF && area_vector[vector_id].apla.a != INF && temp_coefficient.apla.a != INF && area_vector[left_id].apla.b != INF && area_vector[vector_id].apla.b != INF && temp_coefficient.apla.b != INF);
	assert(area_vector[left_id].apla.a_minuend != INF && area_vector[vector_id].apla.a_minuend != INF && temp_coefficient.apla.a_minuend != INF && area_vector[left_id].apla.b_minuend != INF && area_vector[vector_id].apla.b_minuend != INF && temp_coefficient.apla.b_minuend != INF);
	assert(temp_coefficient.right_endpoint == area_vector[vector_id].right_endpoint && temp_coefficient.rectangle_width == area_vector[left_id].rectangle_width + area_vector[vector_id].rectangle_width);
#endif

	set<pair<double, int>> area_difference_id_set;
	priority_queue<int> decrease_id_queue;

	/*================PLA Area=====================*/
	auto pla_rectangle_height = fabs(temp_coefficient.apla.a * (temp_coefficient.rectangle_width - 1));
	temp_coefficient.rectangle_area = pla_rectangle_height * temp_coefficient.rectangle_width;
	//temp_coefficient.rectangle_density = 1.0 / pla_rectangle_height;
	/*...............................................*/

	/*=======MinMax width area & MinMax dist area======*/
	//getSegmentMinMaxPoint(original_time_series, temp_coefficient);
	temp_coefficient.min_point = area_vector[left_id].min_point.value < area_vector[vector_id].min_point.value ? area_vector[left_id].min_point : area_vector[vector_id].min_point;
	temp_coefficient.max_point = area_vector[left_id].max_point.value > area_vector[vector_id].max_point.value ? area_vector[left_id].max_point : area_vector[vector_id].max_point;

#ifdef _DEBUG
	//assert(temp_coefficient.min_point.id == min(area_vector[left_id].min_point.id, area_vector[vector_id].min_point.id) && temp_coefficient.max_point.id == max(area_vector[left_id].max_point.id, area_vector[vector_id].max_point.id));
	//assert(temp_coefficient.min_point.value == min(area_vector[left_id].min_point.value, area_vector[vector_id].min_point.value) && temp_coefficient.max_point.value == max(area_vector[left_id].max_point.value, area_vector[vector_id].max_point.value));
	assert(temp_coefficient.minmax_width_area >= 0 && temp_coefficient.minmax_distance_area >= 0);//n is even
#endif

	auto min_max_height = temp_coefficient.max_point.value - temp_coefficient.min_point.value;
	temp_coefficient.minmax_width_area = min_max_height * temp_coefficient.rectangle_width;
	temp_coefficient.minmax_distance_area = min_max_height * fabs(temp_coefficient.max_point.id - temp_coefficient.min_point.id);

#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width >= fabs(temp_coefficient.max_point.id - temp_coefficient.min_point.id));//n is even
	assert(temp_coefficient.minmax_width_area >= 0 && temp_coefficient.minmax_distance_area >= 0);//n is even
#endif
	/*.................................................*/

	/*=======Compute Area difference==============*/
	if (temp_coefficient.rectangle_area <= temp_coefficient.minmax_distance_area && temp_coefficient.minmax_distance_area <= temp_coefficient.minmax_width_area) {
		temp_coefficient.area_difference = temp_coefficient.minmax_width_area - temp_coefficient.rectangle_area;
	}
	else if (temp_coefficient.minmax_distance_area <= temp_coefficient.rectangle_area && temp_coefficient.rectangle_area <= temp_coefficient.minmax_width_area) {
		temp_coefficient.area_difference = temp_coefficient.minmax_width_area - temp_coefficient.minmax_distance_area;
	}
	else if (temp_coefficient.minmax_distance_area <= temp_coefficient.minmax_width_area && temp_coefficient.minmax_width_area <= temp_coefficient.rectangle_area) {
		temp_coefficient.area_difference = temp_coefficient.rectangle_area - temp_coefficient.minmax_distance_area;
	}
	else {
		assert(0);
	}
	temp_coefficient.area_difference = fabs(temp_coefficient.minmax_width_area - temp_coefficient.rectangle_area) / temp_coefficient.rectangle_width;
#ifdef _DEBUG
	assert(temp_coefficient.area_difference >= 0 && temp_coefficient.area_difference != INF);
	assert(temp_coefficient.max_point.id != INF && temp_coefficient.min_point.id != INF && temp_coefficient.max_point.value != INF && temp_coefficient.min_point.value != INF);
#endif
	/*..............................................*/
	//area_difference_id_set.emplace(make_pair(temp_coefficient.area_difference, segment_id));
	//segment_id++;

	return temp_coefficient.area_difference;
}

// 190826
// Input a&b, min max point, widht, right endpoint
// Output PLA, minmax width area difference
//***************************************************************
// Method: getPLAMinMaxAreaDifference
// Qualifier:count Already know a&b right_endpoint and width
// Get area density of every segment by PLA line
// Input:  left & right & temp segment, a&b, (left & right)min max point, width, right endpoint,
// Output: 1 PLA, minmax width area difference, 2 temp segment min&max point
// date: 190826
// author:
//**************************************************************
TEMPLATE
double& APLA::getPLAMinMaxAreaDifference(DoublyLinkedList<AREA_COEFFICIENT>& const doubly_linked_list, const int& const vector_id, AREA_COEFFICIENT& const temp_coefficient) {//190826
	int left_id = vector_id - 1;
#ifdef _DEBUG
	assert(left_id > -1);
	assert(doubly_linked_list[left_id].min_point.id != INF && doubly_linked_list[vector_id].min_point.id != INF && doubly_linked_list[left_id].max_point.id != INF && doubly_linked_list[vector_id].max_point.id != INF);
	assert(doubly_linked_list[left_id].min_point.value != INF && doubly_linked_list[vector_id].min_point.value != INF && doubly_linked_list[left_id].max_point.value != INF && doubly_linked_list[vector_id].max_point.value != INF);
	assert(doubly_linked_list[left_id].rectangle_width != INF && doubly_linked_list[vector_id].rectangle_width != INF && temp_coefficient.rectangle_width != INF && doubly_linked_list[left_id].right_endpoint != INF && doubly_linked_list[vector_id].right_endpoint != INF && temp_coefficient.right_endpoint != INF);
	assert(doubly_linked_list[left_id].apla.a != INF && doubly_linked_list[vector_id].apla.a != INF && temp_coefficient.apla.a != INF && doubly_linked_list[left_id].apla.b != INF && doubly_linked_list[vector_id].apla.b != INF && temp_coefficient.apla.b != INF);
	assert(doubly_linked_list[left_id].apla.a_minuend != INF && doubly_linked_list[vector_id].apla.a_minuend != INF && temp_coefficient.apla.a_minuend != INF && doubly_linked_list[left_id].apla.b_minuend != INF && doubly_linked_list[vector_id].apla.b_minuend != INF && temp_coefficient.apla.b_minuend != INF);
	assert(temp_coefficient.right_endpoint == doubly_linked_list[vector_id].right_endpoint && temp_coefficient.rectangle_width == doubly_linked_list[left_id].rectangle_width + doubly_linked_list[vector_id].rectangle_width);
#endif

	set<pair<double, int>> area_difference_id_set;
	priority_queue<int> decrease_id_queue;

	/*================PLA Area=====================*/
	auto pla_rectangle_height = fabs(temp_coefficient.apla.a * (temp_coefficient.rectangle_width - 1));
	temp_coefficient.rectangle_area = pla_rectangle_height * temp_coefficient.rectangle_width;
	//temp_coefficient.rectangle_density = 1.0 / pla_rectangle_height;
	/*...............................................*/

	/*=======MinMax width area & MinMax dist area======*/
	//getSegmentMinMaxPoint(original_time_series, temp_coefficient);
	temp_coefficient.min_point = doubly_linked_list[left_id].min_point.value < doubly_linked_list[vector_id].min_point.value ? doubly_linked_list[left_id].min_point : doubly_linked_list[vector_id].min_point;
	temp_coefficient.max_point = doubly_linked_list[left_id].max_point.value > doubly_linked_list[vector_id].max_point.value ? doubly_linked_list[left_id].max_point : doubly_linked_list[vector_id].max_point;

#ifdef _DEBUG
	//assert(temp_coefficient.min_point.id == min(area_vector[left_id].min_point.id, area_vector[vector_id].min_point.id) && temp_coefficient.max_point.id == max(area_vector[left_id].max_point.id, area_vector[vector_id].max_point.id));
	//assert(temp_coefficient.min_point.value == min(area_vector[left_id].min_point.value, area_vector[vector_id].min_point.value) && temp_coefficient.max_point.value == max(area_vector[left_id].max_point.value, area_vector[vector_id].max_point.value));
	assert(temp_coefficient.minmax_width_area >= 0 && temp_coefficient.minmax_distance_area >= 0);//n is even
#endif

	auto min_max_height = temp_coefficient.max_point.value - temp_coefficient.min_point.value;
	temp_coefficient.minmax_width_area = min_max_height * temp_coefficient.rectangle_width;
	temp_coefficient.minmax_distance_area = min_max_height * fabs(temp_coefficient.max_point.id - temp_coefficient.min_point.id);

#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width >= fabs(temp_coefficient.max_point.id - temp_coefficient.min_point.id));//n is even
	assert(temp_coefficient.minmax_width_area >= 0 && temp_coefficient.minmax_distance_area >= 0);//n is even
#endif
	/*.................................................*/

	/*===========================================                Compute Area difference                           ===============================*/
	if (temp_coefficient.rectangle_area <= temp_coefficient.minmax_distance_area && temp_coefficient.minmax_distance_area <= temp_coefficient.minmax_width_area) {
		temp_coefficient.area_difference = temp_coefficient.minmax_width_area - temp_coefficient.rectangle_area;
	}
	else if (temp_coefficient.minmax_distance_area <= temp_coefficient.rectangle_area && temp_coefficient.rectangle_area <= temp_coefficient.minmax_width_area) {
		temp_coefficient.area_difference = temp_coefficient.minmax_width_area - temp_coefficient.minmax_distance_area;
	}
	else if (temp_coefficient.minmax_distance_area <= temp_coefficient.minmax_width_area && temp_coefficient.minmax_width_area <= temp_coefficient.rectangle_area) {
		temp_coefficient.area_difference = temp_coefficient.rectangle_area - temp_coefficient.minmax_distance_area;
	}
	else {
		assert(0);
	}
	temp_coefficient.area_difference = fabs(temp_coefficient.minmax_width_area - temp_coefficient.rectangle_area) / temp_coefficient.rectangle_width;
#ifdef _DEBUG
	assert(temp_coefficient.area_difference >= 0 && temp_coefficient.area_difference != INF);
	assert(temp_coefficient.max_point.id != INF && temp_coefficient.min_point.id != INF && temp_coefficient.max_point.value != INF && temp_coefficient.min_point.value != INF);
#endif
	/*=============================================================================================================================================*/
	//area_difference_id_set.emplace(make_pair(temp_coefficient.area_difference, segment_id));
	//segment_id++;
	return temp_coefficient.area_difference;
}

// 190905
//***************************************************************
// Method: getPLAMinMaxAreaDifference
// Qualifier:count Already know a&b right_endpoint and width
// Get area density of every segment by PLA line
// Input:  left & right & temp segment, a&b, (left & right)min&max point, width, right endpoint,
// Output: 1 PLA, minmax width area difference, 2 temp segment min&max point
// date: 190905
// author:
//**************************************************************
TEMPLATE
double& APLA::getPLAMinMaxAreaDifference(const AREA_COEFFICIENT& const left_segment, const AREA_COEFFICIENT& const right_segment, AREA_COEFFICIENT& const merged_segment) {//190905
	assert(0);
#ifdef _DEBUG
	assert(left_segment.min_point.id != INF && right_segment.min_point.id != INF && left_segment.max_point.id != INF && right_segment.max_point.id != INF);
	assert(left_segment.min_point.value != INF && right_segment.min_point.value != INF && left_segment.max_point.value != INF && right_segment.max_point.value != INF);
	assert(left_segment.rectangle_width != INF && right_segment.rectangle_width != INF && merged_segment.rectangle_width != INF && left_segment.right_endpoint != INF && right_segment.right_endpoint != INF && merged_segment.right_endpoint != INF);
	assert(left_segment.apla.a != INF && right_segment.apla.a != INF && merged_segment.apla.a != INF && left_segment.apla.b != INF && right_segment.apla.b != INF && merged_segment.apla.b != INF);
	assert(left_segment.apla.a_minuend != INF && right_segment.apla.a_minuend != INF && merged_segment.apla.a_minuend != INF && left_segment.apla.b_minuend != INF && right_segment.apla.b_minuend != INF && merged_segment.apla.b_minuend != INF);
	assert(merged_segment.right_endpoint == right_segment.right_endpoint && merged_segment.rectangle_width == left_segment.rectangle_width + right_segment.rectangle_width);
	int left_segment_left_id = left_segment.right_endpoint - left_segment.rectangle_width + 1;
	assert(left_segment.min_point.value <= left_segment.max_point.value && left_segment.min_point.id <= left_segment.right_endpoint && left_segment.max_point.id <= left_segment.right_endpoint && left_segment.min_point.id >= left_segment_left_id && left_segment.max_point.id >= left_segment_left_id);
	int right_segment_left_id = right_segment.right_endpoint - right_segment.rectangle_width + 1;
	assert(right_segment.min_point.value <= right_segment.max_point.value && right_segment.min_point.id <= right_segment.right_endpoint && right_segment.max_point.id <= right_segment.right_endpoint && right_segment.min_point.id >= right_segment_left_id && right_segment.max_point.id >= right_segment_left_id);
	//if(left_segment.min_point.value == left_segment.max_point.value) assert(left_segment.min_point.id < left_segment.max_point.id);
	//if(right_segment.min_point.value == right_segment.max_point.value) assert(right_segment.min_point.id < right_segment.max_point.id);
#endif
	//set<pair<double, int>> area_difference_id_set;

	/*=======MinMax width area & MinMax dist area======*/
	//getSegmentMinMaxPoint(original_time_series, merged_segment);
	merged_segment.min_point = left_segment.min_point.value < right_segment.min_point.value ? left_segment.min_point : right_segment.min_point;
	merged_segment.max_point = left_segment.max_point.value > right_segment.max_point.value ? left_segment.max_point : right_segment.max_point;

#ifdef _DEBUG
	int merged_segment_left_id = merged_segment.right_endpoint - merged_segment.rectangle_width + 1;
	assert(merged_segment.min_point.value <= merged_segment.max_point.value && merged_segment.min_point.id <= merged_segment.right_endpoint && merged_segment.max_point.id <= merged_segment.right_endpoint && merged_segment.min_point.id >= merged_segment_left_id && merged_segment.max_point.id >= merged_segment_left_id);
	//if(merged_segment.min_point.value == merged_segment.max_point.value)assert(merged_segment.min_point.id < merged_segment.max_point.id);
#endif
	/*==================================================*/
	/*===========Area Difference====================*/
	return getAreaDifference(merged_segment);

	//	/*================PLA Area=====================*/
	//	merged_segment.rectangle_area = fabs(merged_segment.apla.a * (merged_segment.rectangle_width - 1)) * merged_segment.rectangle_width;
	//	//merged_segment.rectangle_density = 1.0 / pla_rectangle_height;
	//	/*...............................................*/
	//
	//
	//
	//	auto min_max_height = merged_segment.max_point.value - merged_segment.min_point.value;
	//	merged_segment.minmax_width_area = min_max_height * merged_segment.rectangle_width;
	//	merged_segment.minmax_distance_area = min_max_height * fabs(merged_segment.max_point.id - merged_segment.min_point.id);
	//
	//#ifdef _DEBUG
	//	assert(merged_segment.rectangle_width >= fabs(merged_segment.max_point.id - merged_segment.min_point.id));//n is even
	//	assert(merged_segment.minmax_width_area >= 0 && merged_segment.minmax_distance_area >= 0);//n is even
	//#endif
	//	/*.................................................*/
	//
	//	/*=======Compute Area difference==============*/
	//	if (merged_segment.rectangle_area <= merged_segment.minmax_distance_area && merged_segment.minmax_distance_area <= merged_segment.minmax_width_area) {
	//		merged_segment.area_difference = merged_segment.minmax_width_area - merged_segment.rectangle_area;
	//	}
	//	else if (merged_segment.minmax_distance_area <= merged_segment.rectangle_area && merged_segment.rectangle_area <= merged_segment.minmax_width_area) {
	//		merged_segment.area_difference = merged_segment.minmax_width_area - merged_segment.minmax_distance_area;
	//	}
	//	else if (merged_segment.minmax_distance_area <= merged_segment.minmax_width_area && merged_segment.minmax_width_area <= merged_segment.rectangle_area) {
	//		merged_segment.area_difference = merged_segment.rectangle_area - merged_segment.minmax_distance_area;
	//	}
	//	else {
	//		assert(0);
	//	}
	//	//merged_segment.area_difference = fabs(merged_segment.minmax_width_area - merged_segment.rectangle_area) / merged_segment.rectangle_width;
	//#ifdef _DEBUG
	//	assert(merged_segment.area_difference >= 0 && merged_segment.area_difference != INF);
	//	assert(merged_segment.max_point.id != INF && merged_segment.min_point.id != INF && merged_segment.max_point.value != INF && merged_segment.min_point.value != INF);
	//#endif
	//	/*..............................................*/
	//	//area_difference_id_set.emplace(make_pair(merged_segment.area_difference, segment_id));
	//	//segment_id++;
	//	return merged_segment.area_difference;
}

//************************************
// Method:getPLALineRectangleAreaDensity
// Qualifier:count Already know a&b right_endpoint and width
// Get area density of every segment by PLA line
// date:190627
// author:
//************************************
TEMPLATE
template<typename T>
void APLA::getPLALineRectangleAreaDensity(vector<T>& const area_vector) {//190627 Already know a&b right_endpoint and width
	assert(0);
	for (auto&& au : area_vector) {
#ifdef _DEBUG
		assert(au.apla.a != INF && au.apla.b != INF && au.right_endpoint != INF && au.rectangle_width != INF);
#endif
		auto pla_rectangle_height = fabs(au.apla.a * (au.rectangle_width - 1));
		au.rectangle_area = pla_rectangle_height * au.rectangle_width;
		au.rectangle_density = 1.0 / pla_rectangle_height;
	}
}

//************************************
// Method:getPLALineRectangleAreaDensity
// Qualifier:count Already know a&b right_endpoint and width
// Get area density of every segment by PLA line
// date:190627
// author:
//************************************
TEMPLATE
template<typename T>
void APLA::getPLALineRectangleAreaDensity(DoublyLinkedList<T>& const doubly_linked_list) {//190826 Already know a&b right_endpoint and width
	assert(0);
	for (int segment_id = 0; segment_id < doubly_linked_list.size(); segment_id++) {
#ifdef _DEBUG
		assert(doubly_linked_list[segment_id].apla.a != INF && doubly_linked_list[segment_id].apla.b != INF && doubly_linked_list[segment_id].right_endpoint != INF && doubly_linked_list[segment_id].rectangle_width != INF);
#endif
		auto pla_rectangle_height = fabs(doubly_linked_list[segment_id].apla.a * (doubly_linked_list[segment_id].rectangle_width - 1));
		doubly_linked_list[segment_id].rectangle_area = pla_rectangle_height * doubly_linked_list[segment_id].rectangle_width;
		doubly_linked_list[segment_id].rectangle_density = 1.0 / pla_rectangle_height;
	}
}

//200419 scan segment to get min & max value height
//************************************
// Method:get_segment_minmax_height
// Qualifier:scan segment to get min & max value height
// Input: Width & right end point, Original time series
// Output: Min&Max Point value height
// date:200419
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
long double APLA::get_segment_minmax_height(const vector<T>& const original_time_series_vector, Y& const temp_coefficient) {

	/*...........................................................................................................................*/
#ifdef _DEBUG
	assert(temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF && temp_coefficient.rectangle_width > 0);
#endif
	/*...........................................................................................................................*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	if (temp_coefficient.rectangle_width == 1) {
		//temp_coefficient.min_point.id = temp_coefficient.max_point.id = temp_coefficient.right_endpoint;
		//temp_coefficient.min_point.value = temp_coefficient.max_point.value = original_time_series_vector[int(temp_coefficient.right_endpoint)];
		return 0;
	}
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	int initial_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;

	/*...........................................................................................................................*/
#ifdef _DEBUG
	assert(initial_id > -1);
#endif
	/*...........................................................................................................................*/

	const auto [min_point, max_point] = minmax_element(original_time_series_vector.begin() + initial_id, original_time_series_vector.begin() + int(temp_coefficient.right_endpoint + 1));

	return *max_point - *min_point;
}


//************************************
// Method:initialize_segment_minmax
// Qualifier:initialize min&max point of segmnet = INF
// Input: segment min max point
// Output: Min&Max Point = INF
// date:200519
// author:
//************************************
TEMPLATE
template<typename T>
inline void APLA::initialize_segment_minmax(T& const temp_coefficient) {
	temp_coefficient.min_point.id = temp_coefficient.min_point.value = temp_coefficient.max_point.id = temp_coefficient.max_point.value = INF;
}

//200422 get min&max point of one point segment
//************************************
// Method:get_segment_one_point_minmax
// Qualifier:get min max point of segment
// Input: Width & right end point
// Output: Min&Max Point
// date:200422
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline void APLA::get_segment_one_point_minmax(const T& const point_value, Y& const temp_coefficient) {
#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width == 1);
#endif
	/*######################################     get min&max point     #####################################*/
	temp_coefficient.min_point.id = temp_coefficient.max_point.id = int(temp_coefficient.right_endpoint);
	temp_coefficient.min_point.value = temp_coefficient.max_point.value = point_value;
	/*######################################################################################################*/
}

//200422 get min&max point of two points segment
//************************************
// Method:get_segment_two_point_minmax
// Qualifier:get min max point of segment
// Input: Width & right end point
// Output: Min&Max Point
// date:200422
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline void APLA::get_segment_two_point_minmax(const vector<T>& const original_time_series_vector, Y& const temp_coefficient) {
#ifdef _DEBUG
	assert(!original_time_series_vector.empty() && temp_coefficient.rectangle_width == 2);
#endif

	const int segment_left_id = temp_coefficient.right_endpoint - 1;

#ifdef _DEBUG
	assert(temp_coefficient.right_endpoint - segment_left_id == 1);
#endif

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!        200421 get min&max point of segment    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	if (original_time_series_vector[segment_left_id] <= original_time_series_vector[int(temp_coefficient.right_endpoint)]) {
		temp_coefficient.min_point.id = segment_left_id;
		temp_coefficient.max_point.id = temp_coefficient.right_endpoint;
		temp_coefficient.min_point.value = original_time_series_vector[segment_left_id];
		temp_coefficient.max_point.value = original_time_series_vector[int(temp_coefficient.right_endpoint)];
	}
	else {
		temp_coefficient.min_point.id = temp_coefficient.right_endpoint;
		temp_coefficient.max_point.id = segment_left_id;
		temp_coefficient.min_point.value = original_time_series_vector[int(temp_coefficient.right_endpoint)];
		temp_coefficient.max_point.value = original_time_series_vector[segment_left_id];
	}
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
}

// get min&max point of two points segment
//************************************
// Method:get_segment_two_point_minmax
// Qualifier:get min max point of segment
// Input: Width & right end point
// Output: Min&Max Point
// date:200714
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline void APLA::get_segment_two_point_minmax(const T& const left_value, const T& const right_value, Y& const temp_coefficient) {
#ifdef _DEBUG
	assert(temp_coefficient.rectangle_width == 2);
#endif

	const int segment_left_id = temp_coefficient.right_endpoint - 1;

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!        200421 get min&max point of segment    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	if (left_value < right_value) {
		temp_coefficient.min_point.id = segment_left_id;
		temp_coefficient.max_point.id = temp_coefficient.right_endpoint;
		temp_coefficient.min_point.value = left_value;
		temp_coefficient.max_point.value = right_value;
	}
	else {
		temp_coefficient.min_point.id = temp_coefficient.right_endpoint;
		temp_coefficient.max_point.id = segment_left_id;
		temp_coefficient.min_point.value = right_value;
		temp_coefficient.max_point.value = left_value;
	}
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
}

//200422 get and verify min&max point of long segment
//************************************
// Method:get_segment_minmax_point
// Qualifier:get min max point of segment
// Input: Width & right end point
// Output: Min&Max Point
// date:200422
// author:
//************************************
TEMPLATE
template<typename T, typename Y, typename U>
inline void APLA::get_segment_minmax_point(const T& const point_id, const Y& const point_value, U& const temp_coefficient) {
#ifdef _DEBUG
	assert(temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF && temp_coefficient.rectangle_width > 2 && point_id <= temp_coefficient.right_endpoint);
	assert_segment_minmax(temp_coefficient);
#endif
	/*+++++++++++++++++++++++++++++     200420 get min&max point         +++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/*---------------------------MinMax point-----------------------------------------*/
	if (temp_coefficient.min_point.value > point_value) {
		temp_coefficient.min_point.id = point_id;
		temp_coefficient.min_point.value = point_value;
	}
	if (temp_coefficient.max_point.value <= point_value) {
		temp_coefficient.max_point.id = point_id;
		temp_coefficient.max_point.value = point_value;
	}
	/*--------------------------------------------------------------------------------*/
	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
}

//************************************
// Method:getSegmentMinMaxPoint
// Qualifier:get min max point of segment
// Input: Width & right end point
// Output: Min&Max Point
// date:190701
// author:
//************************************
TEMPLATE
void APLA::getSegmentMinMaxPoint(DataType*& const original_time_series, AREA_COEFFICIENT& const temp_coefficient) {//190701
#ifdef _DEBUG
	assert(temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF && temp_coefficient.rectangle_width > 0);
#endif
	/*=============================================*/
	if (temp_coefficient.rectangle_width == 1) {
		temp_coefficient.min_point.id = temp_coefficient.max_point.id = temp_coefficient.right_endpoint;
		temp_coefficient.min_point.value = temp_coefficient.max_point.value = original_time_series[int(temp_coefficient.right_endpoint)];
		return;
	}
	/*............................................*/
	int initial_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;

#ifdef _DEBUG
	assert(initial_id > -1);
#endif

	auto [min_p, max_p] = minmax_element(original_time_series + initial_id, original_time_series + int(temp_coefficient.right_endpoint + 1));
	temp_coefficient.min_point.id = min_p - original_time_series;
	temp_coefficient.min_point.value = *min_p;

	temp_coefficient.max_point.id = max_p - original_time_series;
	temp_coefficient.max_point.value = *max_p;

#ifdef _DEBUG
	assert(temp_coefficient.min_point.id >= initial_id && temp_coefficient.max_point.id >= initial_id && temp_coefficient.min_point.id <= temp_coefficient.right_endpoint && temp_coefficient.min_point.id <= temp_coefficient.right_endpoint);
	double min_value = INF, max_value = -INF;
	for (int array_id = initial_id; array_id <= temp_coefficient.right_endpoint; array_id++) {
		min_value = min(min_value, original_time_series[array_id]);
		max_value = max(max_value, original_time_series[array_id]);
	}
	assert(min_value == temp_coefficient.min_point.value && max_value == temp_coefficient.max_point.value && temp_coefficient.min_point.id != INF && temp_coefficient.max_point.id != INF && temp_coefficient.min_point.value != INF && temp_coefficient.max_point.value != INF);
#endif
}


//200506 
//************************************
// Method:get_long_segment_minmax_by_sub_segments
// Qualifier: Get min&max point of long segment from left & right short segments
// Input: min&max points of sub left and right segments
// Output: Min&Max Point of long segment
// date:200506
// author:
//************************************
TEMPLATE
template<typename T>
inline void APLA::get_long_segment_minmax_by_sub_segments(const T& const sub_left_segment, const T& const sub_right_segment, T& const long_segment) {

#ifdef _DEBUG
	//assert_segment_minmax(sub_left_segment); //210203
	//assert_segment_minmax(sub_right_segment);
	assert(sub_right_segment.right_endpoint == long_segment.right_endpoint && sub_left_segment.rectangle_width + sub_right_segment.rectangle_width == long_segment.rectangle_width);
#endif

	/*===================== 200109 Deflete in the future Min & Max Point====================*/
	//200314 minmax point
	//getSegmentMinMaxPoint(original_time_series, long_segment);
	long_segment.min_point = sub_left_segment.min_point.value < sub_right_segment.min_point.value ? sub_left_segment.min_point : sub_right_segment.min_point;
	long_segment.max_point = sub_left_segment.max_point.value > sub_right_segment.max_point.value ? sub_left_segment.max_point : sub_right_segment.max_point;
	/*=====================================================================================*/

#ifdef _DEBUG
	const int merged_segment_left_id = long_segment.right_endpoint - long_segment.rectangle_width + 1;
	assert(long_segment.min_point.value <= long_segment.max_point.value && long_segment.min_point.id <= long_segment.right_endpoint && long_segment.max_point.id <= long_segment.right_endpoint && long_segment.min_point.id >= merged_segment_left_id && long_segment.max_point.id >= merged_segment_left_id);
	//if(long_segment.min_point.value == long_segment.max_point.value) assert(long_segment.min_point.id < long_segment.max_point.id);
#endif
}

//200212 time series from pointer to vector, Addd template
//************************************
// Method:getSegmentMinMaxPoint
// Qualifier:get min max point of segment
// Input: Width & right end point
// Output: Min&Max Point
// date:190701
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
void APLA::getSegmentMinMaxPoint(const vector<T>& const original_time_series_vector, Y& const temp_coefficient) {
	assert(0);
#ifdef _DEBUG
	assert(temp_coefficient.right_endpoint != INF && temp_coefficient.rectangle_width != INF && temp_coefficient.rectangle_width > 0);
#endif
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!           when segment width == 1         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	if (temp_coefficient.rectangle_width == 1) {
		temp_coefficient.min_point.id = temp_coefficient.max_point.id = temp_coefficient.right_endpoint;
		temp_coefficient.min_point.value = temp_coefficient.max_point.value = original_time_series_vector[int(temp_coefficient.right_endpoint)];
		return;
	}
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!          scan to get min&max point         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	int initial_id = temp_coefficient.right_endpoint - temp_coefficient.rectangle_width + 1;
#ifdef _DEBUG
	assert(initial_id > -1);
#endif
	/*++++++++++++++++++++++++++++++++++++++++++            200314 minmax element         +++++++++++++++++++++++++++++++++*/
	auto [min_p, max_p] = minmax_element(original_time_series_vector.begin() + initial_id, original_time_series_vector.begin() + int(temp_coefficient.right_endpoint + 1));
	/*++++++++++++++++++++++++++++++++++++++++++             200314 minmax point         +++++++++++++++++++++++++++++++++*/
	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	temp_coefficient.min_point.id = min_p - original_time_series_vector.begin();
	temp_coefficient.min_point.value = *min_p;

	temp_coefficient.max_point.id = max_p - original_time_series_vector.begin();
	temp_coefficient.max_point.value = *max_p;
	/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	/*........................................................................................................................................*/
#ifdef _DEBUG
	assert_segment_minmax(original_time_series_vector, temp_coefficient);
	assert(temp_coefficient.min_point.id >= initial_id && temp_coefficient.max_point.id >= initial_id && temp_coefficient.min_point.id <= temp_coefficient.right_endpoint && temp_coefficient.min_point.id <= temp_coefficient.right_endpoint);
	double min_value = INF, max_value = -INF;
	for (int array_id = initial_id; array_id <= temp_coefficient.right_endpoint; array_id++) {
		min_value = min(min_value, original_time_series_vector[array_id]);
		max_value = max(max_value, original_time_series_vector[array_id]);
	}
	assert(min_value == temp_coefficient.min_point.value && max_value == temp_coefficient.max_point.value);
	assert(temp_coefficient.min_point.id != INF && temp_coefficient.max_point.id != INF && temp_coefficient.min_point.value != INF && temp_coefficient.max_point.value != INF);
#endif
	/*........................................................................................................................................*/
}

//************************************
// Method:get_minmax_segment_by_accumulation
// Qualifier:get accumulated segment minmaxpoint by last short segment minmax point
// Input: 1 right endpoint, Width, minmax point of short segent. 2 Right end point, Width of long segment
// Output: Min&Max Point of long segment
// date:200714
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline void APLA::get_minmax_segment_by_accumulation(const T& const end_point_value, const Y& const short_segment, Y& const temp_coefficient) {
	/*........................................................................................................................................*/
#ifdef _DEBUG
	assert(short_segment.right_endpoint + 1 == temp_coefficient.right_endpoint && short_segment.rectangle_width + 1 == temp_coefficient.rectangle_width);
	assert_segment_minmax(short_segment);
#endif
	/*........................................................................................................................................*/

	if (short_segment.max_point.value < end_point_value) {
		temp_coefficient.max_point.id = temp_coefficient.right_endpoint;
		temp_coefficient.max_point.value = end_point_value;
		temp_coefficient.min_point = short_segment.min_point;
	}
	else if (short_segment.min_point.value > end_point_value) {
		temp_coefficient.min_point.id = temp_coefficient.right_endpoint;
		temp_coefficient.min_point.value = end_point_value;
		temp_coefficient.max_point = short_segment.max_point;
	}
	else {
		temp_coefficient.min_point = short_segment.min_point;
		temp_coefficient.max_point = short_segment.max_point;
	}

	/*........................................................................................................................................*/
#ifdef _DEBUG
	assert_segment_minmax(temp_coefficient);
#endif
	/*........................................................................................................................................*/
}

//************************************
// Method:get_minmax_segment_by_accumulation
// Qualifier: get accumulated segment minmaxpoint by accumulate endpoint value
// Input: 1 long segment endpoint value. 2 Right endpoint of long segment. 3 minmax point of short segent. 
// Output: Min&Max Point of long segment
// date:200731 
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
inline void APLA::get_minmax_segment_by_accumulation(const T& const end_point_value, Y& const accumulate_segment) {
	/*........................................................................................................................................*/
#ifdef _DEBUG
	assert(accumulate_segment.min_point.id < accumulate_segment.right_endpoint&& accumulate_segment.max_point.id < accumulate_segment.right_endpoint);
	assert_segment_minmax(accumulate_segment);
#endif
	/*........................................................................................................................................*/

	if (accumulate_segment.max_point.value < end_point_value) {
		accumulate_segment.max_point.id = accumulate_segment.right_endpoint;
		accumulate_segment.max_point.value = end_point_value;
	}
	else if (accumulate_segment.min_point.value > end_point_value) {
		accumulate_segment.min_point.id = accumulate_segment.right_endpoint;
		accumulate_segment.min_point.value = end_point_value;
	}

	/*........................................................................................................................................*/
#ifdef _DEBUG
	assert_segment_minmax(accumulate_segment);
#endif
	/*........................................................................................................................................*/
}

//************************************
// Method:getSubMinMaxPoint
// Qualifier:get min max point of segment
// Input: oritinal time series. Sub left & right: 1 right enpoint, 2 width. 
//                             Long segment: 1 right endpoint, 2 width, 3 min&max point
// Output: sub left & right: min&max point 
// date:191104 13:32
// author:
//************************************
TEMPLATE
void APLA::getSubMinMaxPoint(DataType*& const original_time_series, AREA_COEFFICIENT& const left_segment, AREA_COEFFICIENT& const right_segment, const AREA_COEFFICIENT& const merged_segment) {
	assert(0);
#ifdef _DEBUG
	assert(left_segment.right_endpoint != INF && left_segment.rectangle_width != INF && right_segment.right_endpoint != INF && right_segment.rectangle_width != INF && merged_segment.right_endpoint != INF && merged_segment.rectangle_width != INF && right_segment.right_endpoint == merged_segment.right_endpoint && merged_segment.rectangle_width == left_segment.rectangle_width + right_segment.rectangle_width && merged_segment.min_point.id != INF && merged_segment.min_point.value != INF && merged_segment.max_point.id != INF && merged_segment.max_point.value != INF);
	assert(merged_segment.min_point.id != merged_segment.max_point.id);
	assert(right_segment.right_endpoint == merged_segment.right_endpoint && left_segment.right_endpoint == right_segment.right_endpoint - right_segment.rectangle_width && left_segment.right_endpoint - left_segment.rectangle_width == merged_segment.right_endpoint - merged_segment.rectangle_width);
#endif

	/*---------------------    Flat segment  ------------------------------*/
	if (merged_segment.min_point.value == merged_segment.max_point.value) {
#ifdef _DEBUG
		assert(original_time_series[int(merged_segment.min_point.id)] == original_time_series[int(merged_segment.max_point.id)] && merged_segment.max_point.id == merged_segment.right_endpoint && merged_segment.rectangle_width == left_segment.rectangle_width + right_segment.rectangle_width && left_segment.right_endpoint - left_segment.rectangle_width + 1 == merged_segment.right_endpoint - merged_segment.rectangle_width + 1);
#endif
		left_segment.min_point.value = left_segment.max_point.value = right_segment.min_point.value = right_segment.max_point.value;
		left_segment.min_point.id = left_segment.right_endpoint - left_segment.rectangle_width + 1;
		left_segment.max_point.id = left_segment.right_endpoint;

		right_segment.min_point.id = left_segment.right_endpoint + 1;
		right_segment.max_point.id = merged_segment.right_endpoint;
		return;
	}
	/*---------------------------------------------------------------------*/

	const typename GEOMETRY::POINT* left_point = nullptr;
	const typename GEOMETRY::POINT* right_point = nullptr;

	/*--------------------------------------------------------------*/
	if (merged_segment.min_point.id < merged_segment.max_point.id) {
		left_point = &merged_segment.min_point;
		right_point = &merged_segment.max_point;
	}
	else {
		left_point = &merged_segment.max_point;
		right_point = &merged_segment.min_point;
	}
	/*---------------------------------------------------------------*/
	if (right_point->id <= left_segment.right_endpoint) {// min & max point of long segment in left segment. 
		left_segment.min_point = merged_segment.min_point;
		left_segment.max_point = merged_segment.max_point;

		getSegmentMinMaxPoint(original_time_series, right_segment);
		//return;
	}
	else if (left_point->id > left_segment.right_endpoint) {// min & max point of long segment in right segment.
		right_segment.min_point = merged_segment.min_point;
		right_segment.max_point = merged_segment.max_point;

		getSegmentMinMaxPoint(original_time_series, left_segment);
		//return;
	}
	else if (left_point->id <= left_segment.right_endpoint && right_point->id > left_segment.right_endpoint) { // min & max point of long segment located in left & right segment separately

		int left_initial_id = left_segment.right_endpoint - left_segment.rectangle_width + 1;
		int right_initial_id = left_segment.right_endpoint + 1;
		int right_end_id = right_segment.right_endpoint + 1;
		//left point is min point
		if (left_point->value < right_point->value) {// min point in left segment, max opint in right segment.
			left_segment.min_point = merged_segment.min_point;
			auto max_p = max_element(original_time_series + left_initial_id, original_time_series + right_initial_id);//[start, finish)
			left_segment.max_point.id = max_p - original_time_series;
			left_segment.max_point.value = *max_p;

			right_segment.max_point = merged_segment.max_point;
			auto min_p = min_element(original_time_series + right_initial_id, original_time_series + right_end_id);//[start, finish)
			right_segment.min_point.id = min_p - original_time_series;
			right_segment.min_point.value = *min_p;

		}
		else if (left_point->value > right_point->value) {// max point in left segment, min opint in right segment.
			left_segment.max_point = merged_segment.max_point;
			auto min_p = min_element(original_time_series + left_initial_id, original_time_series + right_initial_id);//[start, finish)
			left_segment.min_point.id = min_p - original_time_series;
			left_segment.min_point.value = *min_p;

			right_segment.min_point = merged_segment.min_point;
			auto max_p = max_element(original_time_series + right_initial_id, original_time_series + right_end_id);//[start, finish)
			right_segment.max_point.id = max_p - original_time_series;
			right_segment.max_point.value = *max_p;
		}
		else {
			assert(0);
		}
		//return;
	}
	else {
		assert(0);
	}

#ifdef _DEBUG
	AREA_COEFFICIENT test_left_segment = left_segment;
	AREA_COEFFICIENT test_right_segment = right_segment;
	getSegmentMinMaxPoint(original_time_series, test_left_segment);
	getSegmentMinMaxPoint(original_time_series, test_right_segment);
	assert(test_left_segment.min_point.value == left_segment.min_point.value && test_left_segment.max_point.value == left_segment.max_point.value);
	assert(test_right_segment.min_point.value == right_segment.min_point.value && test_right_segment.max_point.value == right_segment.max_point.value);
#endif
}

//200213 use vector to instead pointer for time series
//************************************
// Method:getSubMinMaxPoint
// Qualifier:get min max point of segment
// Input: oritinal time series. Sub left & right: 1 right enpoint, 2 width. 
//                             Long segment: 1 right endpoint, 2 width, 3 min&max point
// Output: sub left & right: min&max point 
//Input: oritinal time series vector. sub left right: 1 right enpoint, 2 width. Long segment: 1 right endpoint, 2 width, 3 min&max point
//Output: sub left right: min&max point 
// date:200213 13:32
// author:
//************************************
TEMPLATE
template<typename T, typename Y>
void APLA::getSubMinMaxPoint(const vector<T>& const original_time_series_vector, Y& const left_segment, Y& const right_segment, const Y& const merged_segment) {
	assert(0);
#ifdef _DEBUG
	assert(left_segment.right_endpoint != INF && left_segment.rectangle_width != INF && right_segment.right_endpoint != INF && right_segment.rectangle_width != INF && merged_segment.right_endpoint != INF && merged_segment.rectangle_width != INF && right_segment.right_endpoint == merged_segment.right_endpoint && merged_segment.rectangle_width == left_segment.rectangle_width + right_segment.rectangle_width && merged_segment.min_point.id != INF && merged_segment.min_point.value != INF && merged_segment.max_point.id != INF && merged_segment.max_point.value != INF);
	//assert(merged_segment.min_point.id != merged_segment.max_point.id);
	assert(right_segment.right_endpoint == merged_segment.right_endpoint && left_segment.right_endpoint == right_segment.right_endpoint - right_segment.rectangle_width && left_segment.right_endpoint - left_segment.rectangle_width == merged_segment.right_endpoint - merged_segment.rectangle_width);
	assert_segment_minmax(merged_segment);
	assert_segment_minmax(original_time_series_vector, merged_segment);
#endif

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&       Flat segment     &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	// 200314 minmax point
	if (merged_segment.min_point.value == merged_segment.max_point.value) {
#ifdef _DEBUG
		assert(original_time_series_vector[int(merged_segment.min_point.id)] == original_time_series_vector[int(merged_segment.max_point.id)] && merged_segment.max_point.id == merged_segment.right_endpoint && merged_segment.rectangle_width == left_segment.rectangle_width + right_segment.rectangle_width && left_segment.right_endpoint - left_segment.rectangle_width + 1 == merged_segment.right_endpoint - merged_segment.rectangle_width + 1);
#endif
		left_segment.min_point.value = left_segment.max_point.value = right_segment.min_point.value = right_segment.max_point.value;
		left_segment.min_point.id = left_segment.right_endpoint - left_segment.rectangle_width + 1;
		left_segment.max_point.id = left_segment.right_endpoint;

		right_segment.min_point.id = left_segment.right_endpoint + 1;
		right_segment.max_point.id = merged_segment.right_endpoint;
		return;
	}
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	const typename GEOMETRY::POINT* left_point = nullptr;
	const typename GEOMETRY::POINT* right_point = nullptr;

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	if (merged_segment.min_point.id < merged_segment.max_point.id) {
		left_point = &merged_segment.min_point;
		right_point = &merged_segment.max_point;
	}
	else {
		left_point = &merged_segment.max_point;
		right_point = &merged_segment.min_point;
	}
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/

	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
	if (right_point->id <= left_segment.right_endpoint) {// min & max point of long segment in left segment. 
		left_segment.min_point = merged_segment.min_point;
		left_segment.max_point = merged_segment.max_point;

		getSegmentMinMaxPoint(original_time_series_vector, right_segment);
		//return;
	}
	else if (left_point->id > left_segment.right_endpoint) {// min & max point of long segment in right segment.
		right_segment.min_point = merged_segment.min_point;
		right_segment.max_point = merged_segment.max_point;

		getSegmentMinMaxPoint(original_time_series_vector, left_segment);
		//return;
	}
	else if (left_point->id <= left_segment.right_endpoint && right_point->id > left_segment.right_endpoint) { // min & max point of long segment located in left & right segment separately

		int left_initial_id = left_segment.right_endpoint - left_segment.rectangle_width + 1;
		int right_initial_id = left_segment.right_endpoint + 1;
		int right_end_id = right_segment.right_endpoint + 1;
		//left point is min point
		if (left_point->value < right_point->value) {// min point in left segment, max opint in right segment.
			left_segment.min_point = merged_segment.min_point;
			auto max_p = max_element(original_time_series_vector.begin() + left_initial_id, original_time_series_vector.begin() + right_initial_id);//[start, finish)
			left_segment.max_point.id = max_p - original_time_series_vector.begin();
			left_segment.max_point.value = *max_p;

			right_segment.max_point = merged_segment.max_point;
			auto min_p = min_element(original_time_series_vector.begin() + right_initial_id, original_time_series_vector.begin() + right_end_id);//[start, finish)
			right_segment.min_point.id = min_p - original_time_series_vector.begin();
			right_segment.min_point.value = *min_p;

		}
		else if (left_point->value > right_point->value) {// max point in left segment, min opint in right segment.
			left_segment.max_point = merged_segment.max_point;
			auto min_p = min_element(original_time_series_vector.begin() + left_initial_id, original_time_series_vector.begin() + right_initial_id);//[start, finish)
			left_segment.min_point.id = min_p - original_time_series_vector.begin();
			left_segment.min_point.value = *min_p;

			right_segment.min_point = merged_segment.min_point;
			auto max_p = max_element(original_time_series_vector.begin() + right_initial_id, original_time_series_vector.begin() + right_end_id);//[start, finish)
			right_segment.max_point.id = max_p - original_time_series_vector.begin();
			right_segment.max_point.value = *max_p;
		}
		else {
			assert(0);
		}
		//return;
	}
	else {
		assert(0);
	}
	/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
#ifdef _DEBUG
	Y test_left_segment = left_segment;
	Y test_right_segment = right_segment;
	getSegmentMinMaxPoint(original_time_series_vector, test_left_segment);
	getSegmentMinMaxPoint(original_time_series_vector, test_right_segment);
	assert(test_left_segment.min_point.value == left_segment.min_point.value && test_left_segment.max_point.value == left_segment.max_point.value);
	assert(test_right_segment.min_point.value == right_segment.min_point.value && test_right_segment.max_point.value == right_segment.max_point.value);

	assert_segment_minmax(original_time_series_vector, left_segment);
	assert_segment_minmax(original_time_series_vector, right_segment);

#endif
}

//************************************
// Method:countBreakPoint
// Qualifier:count which point is break point.
// date:190613
// author:
//************************************
TEMPLATE
void APLA::countBreakPoint(vector<AREA_COEFFICIENT>& const area_vector, const int& const vector_id, vector<int>& const count_break_point_vector) {//190613
	int begin_id = INF;
	int end_id = INF;
	int front_id = vector_id - 1;
	assert(front_id >= 0);
	if (front_id == 0)
		assert(area_vector[front_id].right_endpoint == area_vector[front_id].rectangle_width - 1);
	else
		assert(area_vector[vector_id].right_endpoint - area_vector[vector_id].rectangle_width == area_vector[front_id].right_endpoint);
	if (front_id > 0) {
		begin_id = area_vector[front_id - 1].right_endpoint + 1;
	}
	else {
		begin_id = 0;
	}
	end_id = area_vector[vector_id].right_endpoint;
	for (int i = begin_id; i <= end_id; i++) {
		count_break_point_vector[i]++;
	}
}

//***************************************************************
// Method:write_reconstruct_time_series
// Qualifier:  
// Input: File name, segment coefficenst
// Output: write reconstruct time series to file
// date:200128
// author:
//***************************************************************
TEMPLATE
template<typename T>
void APLA::write_reconstruct_time_series(const string& const file_name, const DoublyLinkedList<T>& const doubly_linked_list) {
	assert(!doubly_linked_list.empty());
	vector<double> initial_reconstruct_time_series_vector;
	getAPLAReconstructSeries(doubly_linked_list, initial_reconstruct_time_series_vector);
	//cout << "" << endl;
	TOOL::writeResultNoCover(file_name, initial_reconstruct_time_series_vector);
	initial_reconstruct_time_series_vector.clear();
	initial_reconstruct_time_series_vector.shrink_to_fit();
}

//***************************************************************
// Method:write_segment_point
// Qualifier:  
// Input:File name, segment coefficenst
// Output: write segment points to file
// date:200128
// author:
//***************************************************************
TEMPLATE
template<typename T>
void APLA::write_segment_point(const string& const file_name, const DoublyLinkedList<T>& const doubly_linked_list) {

}

#endif